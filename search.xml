<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>MATLAB 函数 —— gaussdesign</title>
    <url>/posts/a2967b00.html</url>
    <content><![CDATA[<p><code>gaussdesign</code>：高斯 FIR 脉冲成形滤波器设计</p>
<h1 id="语法">语法</h1>
<p><code>h = gaussdesign(bt,span,sps)</code></p>
<span id="more"></span>
<h1 id="说明">说明</h1>
<p><code>h = gaussdesign(bt,span,sps)</code> 设计一个低通 FIR
高斯脉冲成形滤波器，并返回滤波器系数向量 <code>h</code>。滤波器有
<code>span</code> 个符号，每个符号包含 <code>sps</code>
个样本。滤波器的阶次，也即 <code>sps * span</code> 必须是偶数。<a href="#Examples-01">举例</a></p>
<h1 id="示例">示例</h1>
<h2 id="gsm-gmsk-数字蜂窝通信系统的高斯滤波器">GSM GMSK
数字蜂窝通信系统的高斯滤波器<a name="Examples-01"></a></h2>
<p>指定用于传输比特位的调制是高斯最小频移键控（GMSK）脉冲。此脉冲的 3-dB
带宽等于比特率的 <code>0.3</code> 倍，滤波器的符号数为
<code>4</code>，每个符号 <code>8</code> 个采样点。</p>
<figure class="highlight matlab"><table><tbody><tr><td class="code"><pre><span class="line">bt = <span class="number">0.3</span>;</span><br><span class="line">span = <span class="number">4</span>;</span><br><span class="line">sps = <span class="number">8</span>;</span><br><span class="line">h = gaussdesign(bt,span,sps);</span><br><span class="line">fvtool(h,<span class="string">'impulse'</span>)</span><br></pre></td></tr></tbody></table></figure>
<p><img data-src="../images/post/2020-11-26-matlab-gaussdesign/2020-11-26-matlab-gaussdesign-010-GaussianFilterForAGSMGMSKDigitalCellularCommunicationSysExample-01.png?imageMogr2/thumbnail/!100p%7Cwatermark/2/text/QEpvc2ggR2Fv/font/YWhyb25iZC50dGY=/fontsize/14/dissolve/20/gravity/southeast/dx/5/dy/5"></p>
<h1 id="输入参数">输入参数</h1>
<h2 id="bt---3-db带宽符号时间积"><code>bt</code> -
3-dB带宽符号时间积</h2>
<p>3-dB 单边带带宽（以 Hz
为单位）和符号时间（以秒为单位）的乘积，指定为<strong>正实标量</strong>。较小的
<code>bt</code> 值会产生较大的脉冲宽度。</p>
<p><strong>数据类型</strong>：<code>double</code> |
<code>single</code></p>
<h2 id="span---符号数"><code>span</code> - 符号数</h2>
<p>符号数，指定为<strong>正整数标量</strong>（默认为 3）。</p>
<p><strong>数据类型</strong>：<code>double</code> |
<code>single</code></p>
<h2 id="sps---每个符号的样本数"><code>sps</code> - 每个符号的样本数</h2>
<p>每个符号周期的样本数（上采样因子），指定为<strong>正整数标量</strong>（默认为
2）。</p>
<p><strong>数据类型</strong>：<code>double</code> |
<code>single</code></p>
<h1 id="输出参数">输出参数</h1>
<h2 id="h---fir-滤波器系数"><code>h</code> - FIR 滤波器系数</h2>
<p>高斯脉冲成形滤波器的 FIR
系数，以<strong>行向量</strong>的形式返回。系数已被归一化，因此标称通带增益始终为
1。</p>
<p><strong>数据类型</strong>：<code>double</code> |
<code>single</code></p>
<h1 id="参考">参考</h1>
<p>[1] Krishnapura, N., S. Pavan, C. Mathiazhagan, and B. Ramamurthi. “A
baseband pulse shaping filter for Gaussian minimum shift keying.”
<em>Proceedings of the 1998 IEEE International Symposium on Circuits and
Systems</em>. Vol. 1, 1998, pp.&nbsp;249–252.</p>
<p>[2] Rappaport, Theodore S. <em>Wireless Communications: Principles
and Practice.</em> 2nd Ed. Upper Saddle River, NJ: Prentice Hall,
2002.</p>
<h1 id="版本历史">版本历史</h1>
<p>在 R2013b 中推出</p>
<h1 id="另请参阅">另请参阅</h1>
<p><a href="https://ww2.mathworks.cn/help/signal/ref/rcosdesign.html"><code>rcosdesign</code></a></p>
<p>原文参考：<a href="https://ww2.mathworks.cn/help/signal/ref/gaussdesign.html">https://ww2.mathworks.cn/help/signal/ref/gaussdesign.html</a></p>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/css/markmap.css">

<script src="/js/markmap.js"></script>
]]></content>
      <categories>
        <category>MATLAB</category>
        <category>函数用法</category>
      </categories>
      <tags>
        <tag>MATLAB</tag>
        <tag>翻译</tag>
        <tag>成形滤波器</tag>
        <tag>滤波器</tag>
      </tags>
  </entry>
  <entry>
    <title>MATLAB 函数 —— rcosdesign</title>
    <url>/posts/5c45edfe.html</url>
    <content><![CDATA[<p><code>rcosdesign</code>：升余弦 FIR 脉冲成形滤波器设计</p>
<h1 id="语法">语法</h1>
<p><code>b = rcosdesign(beta,span,sps)</code></p>
<p><code>b = rcosdesign(beta,span,sps,shape)</code></p>
<span id="more"></span>
<h1 id="说明">说明</h1>
<p><code>b = rcosdesign(beta,span,sps)</code> 返回根升余弦（square-root
raised cosine）FIR 滤波器的系数 <code>b</code>。根升余弦 FIR
滤波器的滚降系数（rolloff factor）为
<code>beta</code>。滤波器被截断（truncated）为 <code>span</code>
个符号，并且每个符号周期包含 <code>sps</code> 个采样点。滤波器的阶数
<code>sps * span</code> 必须是偶数。滤波器的能量为 1。<a href="#Examples-01">示例</a></p>
<p><code>b = rcosdesign(beta,span,sps,shape)</code> 根据
<code>shape</code> 返回不同的滤波器。当 <code>shape</code> 为
<code>sqrt</code> 时，返回根升余弦滤波器；当 <code>shape</code> 为
<code>normal</code> 时，返回升余弦（raised cosine） FIR 滤波器。<a href="#Examples-02">示例</a></p>
<h1 id="示例">示例</h1>
<h2 id="设计根升余弦滤波器">设计根升余弦滤波器<a name="Examples-01"></a></h2>
<p>令滚降系数为 <code>0.25</code>，滤波器符号数为 <code>6</code>
个，每个符号 <code>4</code> 个采样点。验证 <code>sqrt</code> 是参数
<code>shape</code> 的默认值。</p>
<figure class="highlight matlab"><table><tbody><tr><td class="code"><pre><span class="line">h = rcosdesign(<span class="number">0.25</span>,<span class="number">6</span>,<span class="number">4</span>);</span><br><span class="line">mx = <span class="built_in">max</span>(<span class="built_in">abs</span>(h-rcosdesign(<span class="number">0.25</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="string">'sqrt'</span>)))</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p><code>mx = 0</code></p>
</blockquote>
<figure class="highlight matlab"><table><tbody><tr><td class="code"><pre><span class="line">fvtool(h,<span class="string">'Analysis'</span>,<span class="string">'impulse'</span>)</span><br></pre></td></tr></tbody></table></figure>
<p><img data-src="../images/post/2020-11-25-matlab-rcosdesign/2020-11-25-matlab-rcosdesign-010-DesignASquareRootRaisedCosineFilterExample.svg"></p>
<h2 id="升余弦和根升余弦滤波器的脉冲响应">升余弦和根升余弦滤波器的脉冲响应<a name="Examples-02"></a></h2>
<p>将升余弦滤波器与根升余弦滤波器进行比较。一个理想的（无限长）升余弦脉冲成形滤波器等效于两个级联的理想的根升余弦滤波器。因此，FIR
升余弦滤波器的脉冲响应应类似于与其自身卷积的根升余弦滤波器的脉冲响应。</p>
<p>设计一个滚降系数为 <code>0.25</code>、符号数为 <code>4</code>
个、每个符号 <code>3</code> 个采样点的升余弦滤波器。</p>
<figure class="highlight matlab"><table><tbody><tr><td class="code"><pre><span class="line">rf = <span class="number">0.25</span>;</span><br><span class="line">span = <span class="number">4</span>;</span><br><span class="line">sps = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">h1 = rcosdesign(rf,span,sps,<span class="string">'normal'</span>);</span><br><span class="line">impz(h1)</span><br></pre></td></tr></tbody></table></figure>
<p><img data-src="../images/post/2020-11-25-matlab-rcosdesign/2020-11-25-matlab-rcosdesign-020-ImpulseResponsesOfNormalAndSquareRootRaisedCosineFiltersExample-01.svg"></p>
<p><strong>升余弦滤波器在 <code>sps</code>
的整数倍处具有零值点</strong>。因此，它满足无码间串扰（ISI）的 Nyquist
准则。但是，根升余弦滤波器没有这样的特性：</p>
<figure class="highlight matlab"><table><tbody><tr><td class="code"><pre><span class="line">h2 = rcosdesign(rf,span,sps,<span class="string">"sqrt"</span>);</span><br><span class="line">impz(h2)</span><br></pre></td></tr></tbody></table></figure>
<p><img data-src="../images/post/2020-11-25-matlab-rcosdesign/2020-11-25-matlab-rcosdesign-030-ImpulseResponsesOfNormalAndSquareRootRaisedCosineFiltersExample-02.svg"></p>
<p>将根升余弦滤波器与自身进行卷积。在最大值处截断脉冲响应，使其长度与
<code>h1</code>
相同。使用最大值将响应归一化。然后，将卷积后的根升余弦滤波器与升余弦滤波器进行比较。</p>
<figure class="highlight matlab"><table><tbody><tr><td class="code"><pre><span class="line">h3 = conv(h2,h2,<span class="string">"same"</span>);</span><br><span class="line"></span><br><span class="line">stem(<span class="number">0</span>:span*sps,[h1/<span class="built_in">max</span>(<span class="built_in">abs</span>(h1));h3/<span class="built_in">max</span>(<span class="built_in">abs</span>(h3))]',<span class="string">"filled"</span>)</span><br><span class="line">xlabel(<span class="string">"Samples"</span>)</span><br><span class="line">ylabel(<span class="string">"Normalized Amplitude"</span>)</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">"h1"</span>,<span class="string">"h2 * h2"</span>)</span><br></pre></td></tr></tbody></table></figure>
<p><img data-src="../images/post/2020-11-25-matlab-rcosdesign/2020-11-25-matlab-rcosdesign-040-ImpulseResponsesOfNormalAndSquareRootRaisedCosineFiltersExample-03.svg"></p>
<p>由于卷积响应的长度是有限的，因此根升余弦滤波器与自身进行卷积得到的结果会与升余弦滤波器不一致。增加
<code>span</code> 可以在响应之间获得更紧密的一致性，并更好地符合 Nyquist
准则。</p>
<h2 id="将信号通过升余弦滤波器">将信号通过升余弦滤波器<a name="Examples-03"></a></h2>
<p>本例说明如何将信号通过根升余弦滤波器。</p>
<p>指定滤波器参数。</p>
<figure class="highlight matlab"><table><tbody><tr><td class="code"><pre><span class="line">rolloff = <span class="number">0.25</span>;     <span class="comment">% 滚降系数</span></span><br><span class="line">span = <span class="number">6</span>;           <span class="comment">% 滤波器宽度（符号数）</span></span><br><span class="line">sps = <span class="number">4</span>;            <span class="comment">% 每个符号的采样点数</span></span><br></pre></td></tr></tbody></table></figure>
<p>生成根升余弦滤波器的系数。</p>
<figure class="highlight matlab"><table><tbody><tr><td class="code"><pre><span class="line">b = rcosdesign(rolloff, span, sps);</span><br></pre></td></tr></tbody></table></figure>
<p>生成双极性数据向量。</p>
<figure class="highlight matlab"><table><tbody><tr><td class="code"><pre><span class="line">d = <span class="number">2</span>*randi([<span class="number">0</span> <span class="number">1</span>], <span class="number">100</span>, <span class="number">1</span>) - <span class="number">1</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>上采样并对数据进行滤波以实现脉冲成形。</p>
<figure class="highlight matlab"><table><tbody><tr><td class="code"><pre><span class="line">x = upfirdn(d, b, sps);</span><br></pre></td></tr></tbody></table></figure>
<p>添加噪声。</p>
<figure class="highlight matlab"><table><tbody><tr><td class="code"><pre><span class="line">r = x + <span class="built_in">randn</span>(<span class="built_in">size</span>(x))*<span class="number">0.01</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>对接收到的信号进行滤波和下采样以进行匹配滤波。</p>
<figure class="highlight matlab"><table><tbody><tr><td class="code"><pre><span class="line">y = upfirdn(r, b, <span class="number">1</span>, sps);</span><br></pre></td></tr></tbody></table></figure>
<p>有关如何使用根升余弦滤波器对信号进行插值和抽取的信息，请参见使<a href="https://ww2.mathworks.cn/help/releases/R2024a/comm/ug/filtering.html#mw_fa589f54-fcad-495e-b4f8-4a4ad52c1f1a">用
RRC 滤波器进行插值和抽取</a>（Communications Toolbox）。</p>
<h1 id="输入参数">输入参数</h1>
<h2 id="beta---滚降系数"><code>beta</code> - 滚降系数</h2>
<p>滚降系数，应为不大于 <code>1</code>
的<strong>实非负标量</strong>。滚降系数决定滤波器的多余带宽。滚降系数为
<code>0</code> 时为矩形滤波器（brick-wall filter），滚降系数为
<code>1</code> 时为纯升余弦滤波器。</p>
<p><strong>数据类型</strong>：<code>double</code> |
<code>single</code></p>
<h2 id="span---符号数"><code>span</code> - 符号数</h2>
<p>符号数，应为<strong>正整数标量</strong>。</p>
<p><strong>数据类型</strong>：<code>double</code> |
<code>single</code></p>
<h2 id="sps---每个符号的采样点数"><code>sps</code> -
每个符号的采样点数</h2>
<blockquote>
<p>正整数标量</p>
</blockquote>
<p>每个符号的采样点数（上采样因子），应为<strong>正整数标量</strong>。</p>
<p><strong>数据类型</strong>：<code>double</code> |
<code>single</code></p>
<h2 id="shape---升余弦滤波器的形状"><code>shape</code> -
升余弦滤波器的形状</h2>
<p>升余弦滤波器的形状，应为 <code>"normal"</code> 或
<code>"sqrt"</code>。</p>
<h1 id="输出参数">输出参数</h1>
<h2 id="b---fir-滤波器系数"><code>b</code> - FIR 滤波器系数</h2>
<p>升余弦滤波器的系数，以<strong>列向量</strong>的形式返回。</p>
<p><strong>数据类型</strong>：<code>double</code> |
<code>single</code></p>
<h1 id="提示">提示</h1>
<ul>
<li>如果您有 Communications Toolbox™
软件的许可证，则可以执行具有流式传输行为的多速率升余弦滤波。为此，请使用
System object™ 滤波器——<code>comm.RaisedCosineTransmitFilter</code> 和
<code>comm.RaisedCosineReceiveFilter</code>。</li>
</ul>
<h1 id="参考">参考</h1>
<p>[1] Tranter, William H., K. Sam Shanmugan, Theodore S. Rappaport, and
Kurt L. Kosbar. <em>Principles of Communication Systems Simulation with
Wireless Applications.</em> Upper Saddle River, NJ: Prentice Hall,
2004.</p>
<h1 id="扩展功能">扩展功能</h1>
<h2 id="cc-代码生成">C/C++ 代码生成</h2>
<blockquote>
<p>使用 MATLAB® Coder™ 生成 C 代码和 C++ 代码。</p>
</blockquote>
<h1 id="版本历史">版本历史</h1>
<p>在 R2013b 中推出</p>
<h1 id="另请参阅">另请参阅</h1>
<p><a href="https://ww2.mathworks.cn/help/releases/R2024a/signal/ref/gaussdesign.html"><code>gaussdesign</code></a></p>
<h2 id="主题">主题</h2>
<p><a href="https://ww2.mathworks.cn/help/releases/R2024a/comm/ug/filtering.html#mw_fa589f54-fcad-495e-b4f8-4a4ad52c1f1a">用
RRC 滤波器进行插值和抽取</a>（Communications Toolbox）</p>
<blockquote>
<p>原文参考：<a href="https://ww2.mathworks.cn/help/releases/R2024a/signal/ref/rcosdesign.html">https://ww2.mathworks.cn/help/releases/R2024a/signal/ref/rcosdesign.html</a></p>
</blockquote>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/css/markmap.css">

<script src="/js/markmap.js"></script>
]]></content>
      <categories>
        <category>MATLAB</category>
        <category>函数用法</category>
      </categories>
      <tags>
        <tag>MATLAB</tag>
        <tag>翻译</tag>
        <tag>成形滤波器</tag>
        <tag>滤波器</tag>
      </tags>
  </entry>
  <entry>
    <title>MATLAB 函数 —— upsample（Signal Processing Toolbox）</title>
    <url>/posts/3a606c9c.html</url>
    <content><![CDATA[<p><code>upsample</code>：将采样率提高整数倍</p>
<h1 id="语法">语法</h1>
<p><code>y = upsample(x,n)</code></p>
<p><code>y = upsample(x,n,phase)</code></p>
<span id="more"></span>
<h1 id="说明">说明</h1>
<p><code>y = upsample(x,n)</code> 通过在样本之间插入
<code>n - 1</code>个零来增加 <code>x</code> 的采样率。如果
<code>x</code> 是矩阵，则该函数将每一列视为单独的序列。<a href="#Examples-01">举例</a></p>
<p><code>y = upsample(x,n,phase)</code>
指定未采样序列所偏移的样本数。</p>
<h1 id="示例">示例</h1>
<h2 id="提高采样率">提高采样率<a name="Examples-01"></a></h2>
<p>将序列的采样率提高 <code>3</code> 倍。</p>
<figure class="highlight matlab"><figcaption><span>输入</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">x = [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>];</span><br><span class="line">y = upsample(x,<span class="number">3</span>)</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plaintext"><figcaption><span>输出</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">y = 1×12</span><br><span class="line"></span><br><span class="line">    1     0     0     2     0     0     3     0     0     4     0     0</span><br></pre></td></tr></tbody></table></figure>
<p>将序列的采样率增加 <code>3</code> 倍，并将相位偏移增加
<code>2</code>。</p>
<figure class="highlight matlab"><figcaption><span>输入</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">x = [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>];</span><br><span class="line">y = upsample(x,<span class="number">3</span>,<span class="number">2</span>)</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plaintext"><figcaption><span>输出</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">y = 1×12</span><br><span class="line"></span><br><span class="line">    0     0     1     0     0     2     0     0     3     0     0     4     0</span><br></pre></td></tr></tbody></table></figure>
<p>将矩阵的采样率提高3倍。</p>
<figure class="highlight matlab"><figcaption><span>输入</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">x = [<span class="number">1</span> <span class="number">2</span>;</span><br><span class="line">     <span class="number">3</span> <span class="number">4</span>;</span><br><span class="line">     <span class="number">5</span> <span class="number">6</span>];</span><br><span class="line">y = upsample(x,<span class="number">3</span>)</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plaintext"><figcaption><span>输出</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">y = 9×2</span><br><span class="line"></span><br><span class="line">    1     2</span><br><span class="line">    0     0</span><br><span class="line">    0     0</span><br><span class="line">    3     4</span><br><span class="line">    0     0</span><br><span class="line">    0     0</span><br><span class="line">    5     6</span><br><span class="line">    0     0</span><br><span class="line">    0     0</span><br></pre></td></tr></tbody></table></figure>
<h1 id="输入参数">输入参数</h1>
<h2 id="x---输入数组"><code>x</code> - 输入数组</h2>
<p>输入数组，指定为<strong>向量</strong>或<strong>矩阵</strong>。如果
<code>x</code> 是矩阵，该函数会将不同列向量视为独立的通道。</p>
<p><strong>举例</strong>：<code>cos(pi/4*(0:159)) + randn(1,160)</code>
指定加有高斯白噪声的正弦曲线。</p>
<p><strong>举例</strong>：<code>cos(pi./[4;2]*(0:159))' + randn(160,2)</code>
指定一个两通道的正弦波。</p>
<h2 id="n---上采样因子"><code>n</code> - 上采样因子</h2>
<p>上采样因子，指定为<strong>正整数</strong>。</p>
<p><strong>数据类型</strong>：<code>single</code> |
<code>double</code></p>
<h2 id="phase---偏移量"><code>phase</code> - 偏移量</h2>
<p>偏移量，指定为从 <code>0</code> 到 <code>n - 1</code>
的<strong>正整数</strong>。默认为 <code>0</code>。</p>
<p><strong>数据类型</strong>：<code>single</code> |
<code>double</code></p>
<h1 id="输出参数">输出参数</h1>
<h2 id="y---上采样数组"><code>y</code> - 上采样数组</h2>
<p>上采样数组，以<strong>向量</strong>或<strong>矩阵</strong>的形式返回。<code>y</code>
有 <code>x × n</code> 个样本。</p>
<h1 id="扩展功能">扩展功能</h1>
<h2 id="cc-代码生成">C/C++ 代码生成</h2>
<blockquote>
<p>使用 MATLAB® Coder™ 生成 C 代码和 C++ 代码。</p>
</blockquote>
<h1 id="版本历史">版本历史</h1>
<p>在 R2006a 之前推出</p>
<h1 id="另请参阅">另请参阅</h1>
<p><a href="https://ww2.mathworks.cn/help/signal/ref/decimate.html"><code>decimate</code></a>
| <a href="https://ww2.mathworks.cn/help/signal/ref/downsample.html"><code>downsample</code></a>
| <a href="https://ww2.mathworks.cn/help/signal/ref/interp.html"><code>interp</code></a>
| <a href="https://ww2.mathworks.cn/help/matlab/ref/interp1.html"><code>interp1</code></a>
| <a href="https://ww2.mathworks.cn/help/signal/ref/resample.html"><code>resample</code></a>
| <a href="https://ww2.mathworks.cn/help/matlab/ref/spline.html"><code>spline</code></a>
| <a href="https://ww2.mathworks.cn/help/signal/ref/upfirdn.html"><code>upfirdn</code></a></p>
<blockquote>
<p>原文参考：<a href="https://ww2.mathworks.cn/help/signal/ref/upsample.html">https://ww2.mathworks.cn/help/signal/ref/upsample.html</a></p>
</blockquote>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/css/markmap.css">

<script src="/js/markmap.js"></script>
]]></content>
      <categories>
        <category>MATLAB</category>
        <category>函数用法</category>
      </categories>
      <tags>
        <tag>MATLAB</tag>
        <tag>翻译</tag>
        <tag>上采样</tag>
      </tags>
  </entry>
  <entry>
    <title>Josh&#39;s Note — Verilog&lt;br&gt;Part 1 初识 HDL 设计方法</title>
    <url>/posts/460433dd.html</url>
    <content><![CDATA[<h1 id="设计方法的变迁">1. 设计方法的变迁<a id="toc.1"></a></h1>
<p>随着微电子设计技术与工艺的发展，数字集成电路从电子管、晶体管、中小规模集成电路、超大规模集成电路（Very
Large Scale Integrated Circuit,
VLSIC）逐步发展到今天的专用集成电路（Application Specific Integrated
Circuit,
ASIC），愈发数字化的产品如计算机、手机、数字电视等都运用了复杂的专用数字集成电路。数字逻辑器件从简单的逻辑门到复杂的
SoC，种类繁多，提供了对复杂系统的灵活支撑。</p>
<span id="more"></span>
<p>随着数字电路系统的不断发展，系统的逻辑复杂度与规模日益增加，数字系统的设计方法也随之不断演进。在早期简单的门逻辑设计阶段，EDA（Electronic
Design
Automation，电子设计自动化）工具应用范围十分有限，工程师们习惯于使用<strong><mark class="label prime">卡诺图</mark></strong>简化设计，然后通过面包板等实验系统验证设计；系统相对复杂后，工程师们借助
EDA 工具通过原理图描述数字系统。</p>
<div class="note default"><p>原理图由元件库中的元件构成，使用 EDA
工具可以对原理图进行仿真并分析其性能。</p>
</div>
<p>当数字系统发展到 ASIC 与 PLD（Programmable Logic
Device，可编程逻辑器件）设计阶段后，原理图不利于移植、维护费时费力等缺点逐步显现，这时需要抽象度更高、更灵活的设计方式
—— HDL（Hardware Description Language，硬件描述语言）。</p>
<p>使用 HDL 语言，可以从算法、系统级（System
Level）、功能模块级（Functional Model Level）、行为级（Behavioral
Level）、寄存器传输级（RTL, Register Transfer Level）、门级（Gate
Level）到开关级（Switch Level）等不同层次描述数字电路系统，然后通过 EDA
工具综合、仿真并实现该系统。可以说 HDL
语言的出现是数字系统设计方法的一个重大飞跃。</p>
<p>数字电路系统设计方法的另一个重大飞跃是随着 EDA
工具的不断推陈出新发生的。早期 ASIC 和 PLD 设计时，需要直接描述 CMOS
的开关电路或门级电路，其设计量庞大，仿真速度也非常慢，用开关级或门级方法描述如当今门数量为千万门级的
FPGA 在当时是不可想象的。这时人们就希望能够使用 HDL
直接从更高的层次描述电路，然后使用 EDA 工具自动将高层次的 HDL
电路描述解析到门级，这些将大大节约设计与仿真时间，这个<strong><mark class="label prime">从高层次的电路描述通过 EDA 工具解析到门级等低层次的电路描述的过程就叫“综合”（Synthesize），或者逻辑综合</mark></strong>。</p>
<div class="note default"><p>综合工具能将高层次的 HDL
语言、原理图等设计描述翻译成由与、或、非门等基本逻辑单元组成的门级连接（<strong>网表</strong>）并根据设计目标与要求（约束条件）优化所生成的逻辑连接，输出门级网表文件。</p>
</div>
<p>目前最成熟的综合工具是 RTL 级综合工具，它能将 RTL
级描述翻译并优化为门级网表。综合工具的产生支撑了直接从 RTL
级描述硬件电路，这种从门级描述抽象到 RTL
级描述数字电路是设计方法的又一次伟大飞跃。</p>
<p>从上面描述可以看到 HDL 语言是分层次的，关于上述 HDL
语言设计层次的含义在本文的 <a href="#toc.3">3. HDL
的设计与验证流程</a>小节和 <a href="https://josh-gao.top/posts/fd117896.html#toc.5">Part
3——描述方式和设计层次的 5. 设计层次</a>小节有详细论述。</p>
<h1 id="verilog-语言的特点">2. Verilog 语言的特点<a id="toc.2"></a></h1>
<h2 id="verilog-的由来">2.1. Verilog 的由来</h2>
<p>Verilog 是 Verilog HDL 的简称。</p>
<div class="note info"><p>Verilog 语言最初于1983年由 Gateway Design Automation
公司开发，于1995年接受为 IEEE 标准。</p>
</div>
<p>Verilog
语言不仅定义了语法，而且对每个语法结构都清晰定义了仿真语义，从而便于仿真调试。而且
Verilog 从 C 语言继承了很多操作符和语法结构，对初学者而言易学易用。另外
Verilog 语言具有很强的扩展能力，最新的 Verilog 2001 标准<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>大大扩展了 Verilog 的应用灵活性。</p>
<p>另外一个流行的 HDL 语言是 VHDL，其发展初期受到美国国防部支持，并于
1987 年成为 IEEE 标准。VHDL 语言的特点是描述严谨。</p>
<h2 id="verilog-和-vhdl">2.2. Verilog 和 VHDL</h2>
<p>Verilog 和 VHDL 作为最为流行的 HDL
语言，从设计能力上而言都能胜任数字电路系统的设计任务。</p>
<p>VHDL
最初用作文档来描述数字硬件的行为，因此其<strong>描述性和抽象层次更高</strong>。也就是说，VHDL
更适合描述更高层次（如行为级、系统级等）的硬件电路。</p>
<p>Verilog
最初是为了更简洁有效地描述数字硬件电路和仿真而设计的，它的许多关键字与语法集成了
C 语言的体系，因此易学易懂，接受度很广。</p>
<p>前面已经提到最流行的 HDL 语言是 Verilog 和
VHDL。在其基础上发展出了许多抽象程度更高的硬件描述语言，如
SystemVerilog、Superlog、SystemC、CoWare C，这些高级 HDL
语言的语法结枃更加丰富，更适合做系统级、功能级等高层次的设计描述和仿真。</p>
<h2 id="verilog-和-c">2.3. Verilog 和 C</h2>
<p>Verilog 语言是根据 C 语言发明而来的，因此 Verilog 具备了 C
语言的简洁易用的特点。Verilog 从 C
语言中借鉴了许多语法，例如预编译指令和一些高级编程语言结构。</p>
<ol type="1">
<li><p>C 语言与 Verilog 的最大区别</p>
<p>C 语言与 Verilog 的最大区别在于 C 缺乏硬件描述的 3 个基本概念：</p>
<ul>
<li><p><strong><mark class="label primary">互连（connectivity）</mark></strong>：硬件系统中，互连是非常重要的组成部分，而在
C 语言中并没有直接可以用来表示模块间互连的变量；而 Verilog 的
<code>wire</code>
型变量配合一些驱动结构能有效地描述网线的互连。</p></li>
<li><p><strong><mark class="label primary">并发（concurrency）</mark></strong>：C
语言天生是<strong>串行</strong>的，不能描述硬件之间并发的特性，C
语言编译后，其机器指令在 CPU 的高速缓冲队列中基本是顺序执行；而 Verilog
可以有效地描述并行的硬件系统，硬件系统比软件系统速度快、实时性高的一个重要原因就是硬件系统中<strong>各个单元的运算是独立的，信号流是并行的</strong>。</p></li>
<li><p><strong><mark class="label primary">时间（time）</mark></strong>：C
程序运行的时候，没有一个严格的时间概念，程序运行的时间长短取决于处理器本身的性能；而
Verilog
语言本身定义了绝对和相对的时间度量，在仿真时可以通过时间度量与周期关系描述信号直接的时间关系。</p></li>
</ul></li>
<li><p>HDL 语言的本质</p>
<p>硬件描述语言（HDL）同软件语言（如 C、C++ 等）是有本质区别的。Verilog
作为硬件描述语言，<strong>它的本质作用在于描述硬件</strong>。Verilog
虽然采用了 C
语言形式，但是它的最终描述结果是芯片内部的实际电路。所以评判一段 HDL
代码优劣的最终标准是其描述并实现的硬件电路的性能（包括<strong>面积</strong>和<strong>速度</strong>两个方面）。评价一个设计的代码水平较高，仅仅是说这个设计由硬件向
HDL
代码这种表现形式转换得更流畅、合理。而一个设计的最终性能更大程度上取决于设计工程师所构想的硬件实现方案的效率以及合理性。</p>
<div class="note warning"><p>初学者，特别是由软件转行的初学者，片面追求代码的整洁、简短，这是错误的，是与评价
HDL
的标准背道而驰的。正确的编写代码的方法是，首先要做到对所需实现的硬件电路“胸有成竹”，对该部分硬件的结构与连接十分清晰，然后再用适当的
HDL 语句表达出来即可。</p>
</div></li>
<li><p>Verilog 与 C 的结合</p>
<p>Verilog 毕竟是硬件描述语言，在抽象层次上比 C 语言要差一些，语法不如 C
灵活，例如文件输入和输出方面，Verilog 的功能显然不如 C。为了克服 Verilog
高级抽象的缺陷，Verilog 的设计者们发明了 PLI（Programming Language
Interface）。PLI 可以在仿真器中将 C 语言的程序和 Verilog
的程序互相通信，或者在 Verilog 中调用 C 语言的函数库，这样就大大扩展了
Verilog 语言的灵活性和高层次抽象的能力。开发时，一方面，硬件设计者使用
Verilog 进行硬件建模；另一方面，验证工程师却常常使用 C
来编写测试向量，然后通过 Verilog 的 PLI 将 Verilog 和 C
联系起来。这样，C 语言就很好地弥补了 Verilog 高层次建模的缺陷。</p></li>
</ol>
<h1 id="hdl-的设计与验证流程">3. HDL
的设计与验证流程<a id="toc.3"></a></h1>
<p>HDL 的基本功能就是有效地描述并仿真硬件系统。在此部分，抛开具体的 PLD
或 ASIC 设计流程，从 HDL 语言层次入手，分析典型的 HDL
设计与验证流程。基于 HDL 的设计、仿真流程如<a href="#fig.1-1">图 1-1</a>
所示。图中，虚线框表示的步骤可以根据项目的复杂度省略，而实线框表示的步骤为必须执行的步骤。</p>
<p><a id="fig.1-1"></a></p>
<figure>
<img data-src="../images/post/2020-11-27-josh-verilog-part-1/2020-11-27-josh-verilog-part-1-010-DesignSimulationFlowChartBasedonHDL.png?imageMogr2/thumbnail/!100p%7Cwatermark/2/text/QEpvc2ggR2Fv/font/YWhyb25iZC50dGY=/fontsize/14/dissolve/20/gravity/southeast/dx/5/dy/5" width="800" alt="图 1-1 基于 HDL 的设计、仿真流程">
<figcaption aria-hidden="true">图 1-1 基于 HDL
的设计、仿真流程</figcaption>
</figure>
<p>下面对一些关键设计步骤与概念进行展开。</p>
<h2 id="系统与功能模块定义系统与功能模块级">3.1.
系统与功能模块定义（系统与功能模块级）</h2>
<p>在大型系统的设计与实现中，首先要进行详细的系统规划和描述，此时 HDL
描述
<strong><mark class="label prime">侧重于整体系统的划分和实现</mark></strong>。对系统级的仿真侧重于对整个系统的功能和性能指标的考量。功能模块级设计时将系统整体功能划分为可实现的具体功能模块，大致确定模块间的接口，如时钟、读写信号、数据流、控制信号等。在有些情况下，还要根据系统要求，描述每个模块或进程的时序约束。另外在此层次，必须权衡整个系统多种的实现方式的优劣，选出系统性能指标优并且可以高效实现的设计方案。功能模块级仿真主要是考察每个功能的功能和基本时序情况。系统与功能模块级设计与仿真常常要借助于
C 语言和抽象程度较高的 HDL 语言描述，如 SystemC、Coware
C、SystemVerilog、Superlog 等。</p>
<h2 id="行为级描述测试激励behavioral-level">3.2.
行为级描述测试激励（Behavioral Level）</h2>
<p>行为级模块描述的最大特点是
<strong><mark class="label prime">必须明确每个模块间的所有接口和边界</mark></strong>。此时模块内部的功能已经明确，模块间的所有接口，顶层的输入、输出信号等在行为级已经被清晰地描述出来。在
PLD 和 ASIC
设计流程中，常用行为级描述方式编写测试激励。延时描述、监视描述等命令都是在编写测试激励过程中常用的行为级语法。行为级描述常用
HDL 语言如 Verilog 和 VHDL 等。</p>
<h2 id="寄存器传输级rtl">3.3. 寄存器传输级（RTL）</h2>
<p>寄存器传输级指不关注寄存器和组合逻辑的细节（如使用了多少逻辑门，逻辑门之间的连接拓扑结构等），<strong><mark class="label prime">通过描述寄存器到寄存器之间的逻辑功能描述电路</mark></strong>的
HDL 层次。RTL 级是比门级更高的抽象层次，一般使用 RTL
级语言描述硬件电路比门级描述电路简单、高效得多。寄存器传输级描述的最大特点是可以直接用综合工具综合门级网表。RTL
设计直接决定着设计的功能和效率。好的 RTL
设计能在满足逻辑功能的前提下，使设计的速度和面积达到一种平衡的优化。RTL
级描述最常用的 HDL 语言是 Verilog 和 VHDL 语言。</p>
<h2 id="对-rtl-级描述进行功能仿真">3.4 对 RTL 级描述进行功能仿真</h2>
<p>一般来说需要对 RTL 级设计进行功能仿真，仿真的目的为
<strong><mark class="label prime">验证 RTL 级描述是否与设计意图一致</mark></strong>。为了提高效率，一般功能仿真的测试激励使用行为级的
HDL 语言描述。</p>
<h2 id="逻辑综合使用-rtl-级-eda-工具">3.5. 逻辑综合（使用 RTL 级 EDA
工具）</h2>
<p>RTL 级综合指
<strong><mark class="label prime">将 RTL 级 HDL 语言翻译成由与、或、非门等基本逻辑单元组成的门级连接（网表），并根据设计目标与要求（约束条件）优化所生成的逻辑连接，输出门级网表文件</mark></strong>。随着综合工具的不断智能化，使用 RTL
级语言描述硬件电路越来越方便，特别是在 PLD（主要指 FPGA 和
CPLD）设计领域，最重要的代码设计层次就是 RTL 级。</p>
<h2 id="门级gate-level">3.6. 门级（Gate Level）</h2>
<p>由于目前 FPGA 设计大多数依靠专业综合工具完成从 RTL
级代码向门级代码的转换，所有设计者直接用 HDL
语言描述门级模型的情况越来越少，高效的综合工具将设计者从复杂繁琐的门级描述中彻底解脱出来。目前直接使用门级描述的场合一般是
ASIC 和 FPGA 设计中
<strong><mark class="label prime">某些面积或时序要求较高的模块</mark></strong>。门级描述的特点是整个设计用逻辑门实现，通过逻辑门的组合显化描述了设计的引脚、功能、时钟周期等所有信息。</p>
<h2 id="综合后门级仿真">3.7. 综合后门级仿真</h2>
<p>综合完成后，如果需要检查综合结果是否与原设计一致，就需要做综合后仿真。在仿真时，把综合生成的标准延时文件反标注到综合仿真模型中去，可估计门延时带来的影响。综合后仿真虽然比功能仿真精确一些，但是<strong>只能估计门延时，不能估计线延时</strong>，仿真结果<strong>与布线后的实际情况还有一定的差距</strong>，并不十分准确。这种仿真的主要目的在于
<strong><mark class="label prime">检查综合器的综合结果是否与设计输入一致</mark></strong>。目前主流综合工具日益成熟，对于一般性设计，如果设计者确信自己表述明确，没有综合歧义发生，则可以省略综合后仿真步骤。<strong>一般情况下，综合后仿真与功能仿真的仿真激励相同</strong>。</p>
<h2 id="布局规划与布局布线">3.8. 布局规划与布局布线</h2>
<p>综合的门级结果最终要映射到目标库（如 ASIC 设计）或目标器件（如 PLD
设计）。ASIC 与 PLD 设计的相关流程在此不深究 。</p>
<h2 id="布局布线后时序仿真与验证">3.9. 布局布线后时序仿真与验证</h2>
<p>将最终布局规划或布局布线的时延信息反标注到设计网表中，所进行的仿真就叫时序仿真或布局规划与布局布线后仿真，简称后仿真。布局规划与布局布线之后生成的仿真时延文件包含的时延信息最全，不仅包含门延时，还包含实际布线延时，所以时序仿真最准确，能较好地反映芯片的实际工作情况。一般来说，建议进行时序仿真步骤，通过时序仿真能检查设计时序与芯片实际运行情况是否一致，确保设计的可靠性和稳定性。时序仿真的主要目的在于发现时序违规（Timing
Violation），即不满足时序约束条件或者器件固有时序规则（建立时间、保持时间等）的情况。</p>
<h1 id="参考文献">参考文献</h1>
<p>EDA 先锋工作室. <em>轻松成为设计高手——Verilog HDL 实用精解.</em>
北京航空航天大学出版社, 2012.</p>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr>
<ol>
<li id="fn1"><p>最新的 Verilog HDL标准为 <a href="https://ieeexplore.ieee.org/document/1620780">IEEE
1364-2005</a>。<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/css/markmap.css">

<script src="/js/markmap.js"></script>
]]></content>
      <categories>
        <category>Josh 的学习笔记</category>
        <category>Verilog</category>
      </categories>
      <tags>
        <tag>Verilog</tag>
        <tag>HDL</tag>
        <tag>硬件描述语言</tag>
        <tag>行为级</tag>
        <tag>RTL</tag>
        <tag>寄存器传输级</tag>
      </tags>
  </entry>
  <entry>
    <title>MATLAB 函数 —— awgn</title>
    <url>/posts/2f6db45b.html</url>
    <content><![CDATA[<p><code>awgn</code>：在信号中添加高斯白斯噪声</p>
<h1 id="语法">语法</h1>
<p><code>out = awgn(in,snr)</code></p>
<p><code>out = awgn(in,snr,signalpower)</code></p>
<hr>
<p><code>out = awgn(in,snr,signalpower,randobject)</code></p>
<p><code>out = awgn(in,snr,signalpower,seed)</code></p>
<hr>
<p><code>out = awgn(___,powertype)</code></p>
<span id="more"></span>
<h1 id="说明">说明</h1>
<p><code>out = awgn(in,snr)</code> 将高斯白噪声添加到矢量信号
<code>in</code> 中。此条语句假定 <code>in</code> 的功率为 0 dBW。</p>
<p><code>out = awgn(in,snr,signalpower)</code> 接受以 dBW
为单位的输入信号功率值。要使该函数在添加噪声之前测量 <code>in</code>
的功率，请将 <code>signalpower</code> 指定为 <code>measured</code>。<a href="#Examples-01">举例</a></p>
<p><code>out = awgn(in,snr,signalpower,randobject)</code>
接受满足前述两条语法，外加随机数流对象的输入组合以生成满足正态分布的随机噪声样本。有关产生可重复噪声样本的信息，请参见<a href="#tips">提示</a>。<a href="#Examples-03">举例</a></p>
<p><code>out = awgn(in,snr,signalpower,seed)</code>
指定用于初始化正态随机数生成器的种子值，该种子在添加高斯白噪声到输入信号时使用。有关产生可重复噪声样本的信息，请参见<a href="#tips">提示</a>。</p>
<p><code>out = awgn(___,powertype)</code>
除了前面任何语法中的输入自变量之外，还将可信号和噪声功率类型指定为
<code>dB</code> 或 <code>linear</code>。</p>
<p>有关 SNR 与噪声相对功率的其他度量（例如 <span class="math inline">\(E_\mathrm{S}/N_0\)</span> 和 <span class="math inline">\(E_\mathrm{b}/N_0\)</span>）之间的关系，请参阅 <a href="https://ww2.mathworks.cn/help/comm/ug/awgn-channel.html#a1071501088">AWGN
信道噪声级别</a>。</p>
<h1 id="示例">示例</h1>
<h2 id="将-awgn-添加到锯齿波">将 AWGN 添加到锯齿波<span id="Examples-01"></span></h2>
<p>创建一个锯齿波。</p>
<figure class="highlight matlab"><table><tbody><tr><td class="code"><pre><span class="line">t = (<span class="number">0</span>:<span class="number">0.1</span>:<span class="number">10</span>)';</span><br><span class="line">x = sawtooth(t);</span><br></pre></td></tr></tbody></table></figure>
<p>添加高斯白噪声并绘制结果。</p>
<figure class="highlight matlab"><table><tbody><tr><td class="code"><pre><span class="line">y = awgn(x,<span class="number">10</span>,<span class="string">'measured'</span>);</span><br><span class="line"><span class="built_in">plot</span>(t,[x y])</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">'Original Signal'</span>,<span class="string">'Signal with AWGN'</span>)</span><br></pre></td></tr></tbody></table></figure>
<p><img data-src="../images/post/2020-11-27-matlab-awgn/2020-11-27-matlab-awgn-010-AddAWGNToSawtoothSignalExample-01.png?imageMogr2/thumbnail/!100p%7Cwatermark/2/text/QEpvc2ggR2Fv/font/YWhyb25iZC50dGY=/fontsize/14/dissolve/20/gravity/southeast/dx/5/dy/5"></p>
<h2 id="awgn-信道中的常规-qam-调制">AWGN 信道中的常规 QAM 调制<span id="Examples-02"></span></h2>
<p>在存在高斯噪声的情况下，使用非矩形 16
元星座发送和接收数据。绘制噪声星座图，并针对两种不同的信噪比估算误符号率（SER）。</p>
<p>根据电话线调制解调器的 V.29 标准创建一个 16-QAM 星座。</p>
<figure class="highlight matlab"><table><tbody><tr><td class="code"><pre><span class="line">c = [<span class="number">-5</span> <span class="number">-5</span><span class="built_in">i</span> <span class="number">5</span> <span class="number">5</span><span class="built_in">i</span> <span class="number">-3</span> <span class="number">-3</span><span class="number">-3</span><span class="built_in">i</span> <span class="number">-3</span><span class="built_in">i</span> <span class="number">3</span><span class="number">-3</span><span class="built_in">i</span> <span class="number">3</span> <span class="number">3</span>+<span class="number">3</span><span class="built_in">i</span> <span class="number">3</span><span class="built_in">i</span> <span class="number">-3</span>+<span class="number">3</span><span class="built_in">i</span> <span class="number">-1</span> <span class="number">-1</span><span class="built_in">i</span> <span class="number">1</span> <span class="number">1</span><span class="built_in">i</span>];</span><br><span class="line">M = <span class="built_in">length</span>(c);</span><br></pre></td></tr></tbody></table></figure>
<p>生成随机符号。</p>
<figure class="highlight matlab"><table><tbody><tr><td class="code"><pre><span class="line">data = randi([<span class="number">0</span> M<span class="number">-1</span>],<span class="number">2000</span>,<span class="number">1</span>);</span><br></pre></td></tr></tbody></table></figure>
<p>使用 <code>genqammod</code>
函数调制数据。由于星座图不是矩形，因此必须进行常规 QAM 调制。</p>
<figure class="highlight matlab"><table><tbody><tr><td class="code"><pre><span class="line">modData = genqammod(data,c);</span><br></pre></td></tr></tbody></table></figure>
<p>使信号通过具有 20 dB 信噪比（SNR）的 AWGN 信道。</p>
<figure class="highlight matlab"><table><tbody><tr><td class="code"><pre><span class="line">rxSig = awgn(modData,<span class="number">20</span>,<span class="string">'measured'</span>);</span><br></pre></td></tr></tbody></table></figure>
<p>显示接收信号的星座图和参考星座图。</p>
<figure class="highlight matlab"><table><tbody><tr><td class="code"><pre><span class="line">h = scatterplot(rxSig);</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line">scatterplot(c,[],[],<span class="string">'r*'</span>,h)</span><br><span class="line">grid</span><br><span class="line"><span class="built_in">hold</span> off</span><br></pre></td></tr></tbody></table></figure>
<p><img data-src="../images/post/2020-11-27-matlab-awgn/2020-11-27-matlab-awgn-020-GeneralQAMModulationInAnAWGNChannelExample-01.png?imageMogr2/thumbnail/!100p%7Cwatermark/2/text/QEpvc2ggR2Fv/fontsize/15/dissolve/60/gravity/southeast/dx/5/dy/5"></p>
<p>使用 <code>genqamdemod</code>
函数解调接收到的信号。计算误符号数和误符号率。</p>
<figure class="highlight matlab"><figcaption><span>输入</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">demodData = genqamdemod(rxSig,c);</span><br><span class="line">[numErrors,ser] = symerr(data,demodData)</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plaintext"><figcaption><span>输出</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">numErrors = 1</span><br><span class="line">ser = 5.0000e-04</span><br></pre></td></tr></tbody></table></figure>
<p>使用具有 10 dB SNR 的 AWGN 信道重复传输和解调过程。计算降低 SNR
后的误符号率。不出所料，当 SNR 降低时，性能会下降。</p>
<figure class="highlight matlab"><figcaption><span>输入</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">rxSig = awgn(modData,<span class="number">10</span>,<span class="string">'measured'</span>);</span><br><span class="line">demodData = genqamdemod(rxSig,c);</span><br><span class="line">[numErrors,ser] = symerr(data,demodData)</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plaintext"><figcaption><span>输出</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">numErrors = 462</span><br><span class="line">ser = 0.2310</span><br></pre></td></tr></tbody></table></figure>
<h2 id="用-randstream-产生可重复的-awgn">用 RandStream 产生可重复的
AWGN<span id="Examples-03"></span></h2>
<p>使用 <a href="https://ww2.mathworks.cn/help/matlab/ref/randstream.html"><code>RandStream</code></a>
和 <a href="https://ww2.mathworks.cn/help/matlab/ref/randstream.reset.html"><code>reset</code></a>
对象函数生成高斯白噪声相加的结果。</p>
<p>将 X 的功率指定为 0 dBW，添加噪声以产生 10 dB 的
SNR，并利用本地随机流。</p>
<figure class="highlight matlab"><figcaption><span>输入</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">S = RandStream(<span class="string">'mt19937ar'</span>,<span class="string">'Seed'</span>,<span class="number">5489</span>);</span><br><span class="line">sigin = <span class="built_in">sqrt</span>(<span class="number">2</span>)*<span class="built_in">sin</span>(<span class="number">0</span>:<span class="built_in">pi</span>/<span class="number">8</span>:<span class="number">6</span>*<span class="built_in">pi</span>);</span><br><span class="line">sigout1 = awgn(sigin,<span class="number">10</span>,<span class="number">0</span>,S);</span><br></pre></td></tr></tbody></table></figure>
<p>将 AWGN 添加到 <code>sigin</code>。 使用 <a href="https://ww2.mathworks.cn/help/matlab/ref/isequal.html"><code>isequal</code></a>
比较 <code>sigout1</code> 和 <code>sigout2</code>。
当不重置随机流时，输出不相等。</p>
<figure class="highlight matlab"><figcaption><span>输入</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">sigout2 = awgn(sigin,<span class="number">10</span>,<span class="number">0</span>,S);</span><br><span class="line"><span class="built_in">isequal</span>(sigout1,sigout2)</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plaintext"><figcaption><span>输出</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">ans = logical</span><br><span class="line">   0</span><br></pre></td></tr></tbody></table></figure>
<p>重置随机流对象，将对象置为初始状态，然后再将 AWGN 添加到
<code>sigout1</code>。将 AWGN 添加到 <code>sigin</code> 并将
<code>sigout1</code> 与 <code>sigout3</code> 比较。
重置随机流后，输出相等。</p>
<figure class="highlight matlab"><figcaption><span>输入</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">reset(S);</span><br><span class="line">sigout3 = awgn(sigin,<span class="number">10</span>,<span class="number">0</span>,S);</span><br><span class="line"><span class="built_in">isequal</span>(sigout1,sigout3)</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plaintext"><figcaption><span>输出</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">ans = logical</span><br><span class="line">   1</span><br></pre></td></tr></tbody></table></figure>
<h1 id="输入参数">输入参数</h1>
<h2 id="in---输入信号"><code>in</code> - 输入信号</h2>
<p>输入信号，指定为<strong>标量</strong>，<strong>向量</strong>或<strong>数组</strong>。假定输入信号的功率为0
dBW。</p>
<p><strong>数据类型</strong>：<code>double</code>
<strong>复数支持</strong>：是</p>
<h2 id="snr---信噪比snr"><code>snr</code> - 信噪比（SNR）</h2>
<p>信噪比（以 dB 为单位），指定为<strong>标量</strong>。</p>
<div class="note info"><p>注意：</p>
<p>加上噪声后，此函数会将相同的 <code>snr</code>
应用于完整输入信号的所有元素。阵列输入信号没有独立通道的概念。
要独立考虑多个频道，请参阅 <a href="https://ww2.mathworks.cn/help/comm/ref/comm.awgnchannel-system-object.html"><code>comm.AWGNChannel</code></a>。</p>
</div>
<p><strong>数据类型</strong>：<code>double</code></p>
<h2 id="signalpower---信号功率"><code>signalpower</code> - 信号功率</h2>
<p>信号功率，指定为<strong>标量</strong>或 <code>measured</code>。</p>
<ul>
<li><p>当 <code>signalpower</code> 为标量时，该值用作 <code>in</code>
的信号电平，以便根据 <code>snr</code> 的值确定适当的噪声电平。</p></li>
<li><p>当 <code>signalpower</code> 为 <code>measured</code> 时，将计算
<code>in</code> 的信号电平，以根据 <code>snr</code>
的值确定适当的噪声电平。</p></li>
</ul>
<div class="note info"><p>注意：</p>
<p>当指定 <code>measured</code>
时，此函数将使用完整输入信号的所有元素来计算信号功率。在计算功率时，阵列输入信号没有独立通道的概念。</p>
</div>
<p><strong>数据类型</strong>：<code>double</code></p>
<h2 id="randobject---随机数流对象"><code>randobject</code> -
随机数流对象</h2>
<p>随机数流对象，指定为 <a href="https://ww2.mathworks.cn/help/matlab/ref/randstream.html"><code>RandStream</code></a>
对象。 随机流对象的状态确定 <a href="https://ww2.mathworks.cn/help/matlab/ref/randn.html"><code>randn</code></a>
函数产生的数字序列。使用 <a href="https://ww2.mathworks.cn/help/matlab/ref/randstream.reset.html"><code>reset (RandStream)</code></a>
函数及其属性来配置随机流对象。</p>
<p><code>wgn</code> 使用 <a href="https://ww2.mathworks.cn/help/matlab/ref/randn.html"><code>randn</code></a>
生成正常的随机噪声样本。<a href="https://ww2.mathworks.cn/help/matlab/ref/randn.html"><code>randn</code></a>
函数使用 <a href="https://ww2.mathworks.cn/help/matlab/ref/randstream.html"><code>RandStream</code></a>
对象中的一个或多个统一值来生成每个正态值。</p>
<p>有关产生可重复噪声样本的信息，请参见<a href="#tips">提示</a>。</p>
<h2 id="seed---随机数生成器种子"><code>seed</code> -
随机数生成器种子</h2>
<p>随机数生成器种子，指定为<strong>标量</strong>。</p>
<h2 id="powertype---信号功率单元"><code>powertype</code> -
信号功率单元</h2>
<p>信号功率单元，指定为 <code>dB</code> 或 <code>linear</code>。默认为
<code>dB</code>。</p>
<ul>
<li><p>当功率类型为 <code>dB</code> 时，以 dB 为单位测量 snr，以 dBW
为单位测量信号功率。</p></li>
<li><p>当功率类型为 <code>linear</code> 时，<code>snr</code>
以比率进行测量，<code>signalpower</code> 以瓦特为单位。</p></li>
</ul>
<p>有关 SNR 与噪声相对功率的其他度量（例如 <span class="math inline">\(E_\mathrm{S}/N_0\)</span> 和 <span class="math inline">\(E_\mathrm{b}/N_0\)</span>）之间的关系，请参阅 <a href="https://ww2.mathworks.cn/help/comm/ug/awgn-channel.html#a1071501088">AWGN
信道噪声级别</a>。</p>
<h1 id="输出参数">输出参数</h1>
<h2 id="out---输出信号"><code>out</code> - 输出信号</h2>
<p>输出信号，以<strong>标量</strong>，<strong>向量</strong>或<strong>数组</strong>形式返回。
返回的输出信号是添加了高斯白噪声的输入信号。</p>
<h1 id="提示">提示<span id="tips"></span></h1>
<ul>
<li><p>要生成可重复的高斯白噪声样本，请使用以下技巧之一：</p>
<ul>
<li><p>提供静态 <code>seed</code> 值作为 <code>awgn</code>
的输入。</p></li>
<li><p>在将 <code>randobject</code> 传递为 <code>awgn</code>
的输入之前，请对 <code>randobject</code> 使用 <a href="https://ww2.mathworks.cn/help/matlab/ref/randstream.reset.html"><code>reset (RandSteam)</code></a>
函数。</p></li>
<li><p>将处于已知状态的 <code>randobject</code> 提供给
<code>awgn</code>。有关更多信息，请参见 <a href="https://ww2.mathworks.cn/help/matlab/ref/randstream.html"><code>RandStream</code></a>。</p></li>
</ul></li>
</ul>
<h1 id="扩展功能">扩展功能</h1>
<h2 id="cc-代码生成">C/C++ 代码生成</h2>
<blockquote>
<p>使用 MATLAB® Coder™ 生成 C 代码和 C++ 代码。</p>
<blockquote>
<p>用法说明和限制：</p>
<p>支持代码生成，但包括 <a href="https://ww2.mathworks.cn/help/matlab/ref/randstream.html"><code>RandStream</code></a>
对象的语法除外。</p>
</blockquote>
</blockquote>
<h1 id="版本历史">版本历史</h1>
<p>在 R2006a 之前推出</p>
<h1 id="另请参阅">另请参阅</h1>
<h2 id="函数">函数</h2>
<p><a href="https://ww2.mathworks.cn/help/matlab/ref/randstream.html"><code>RandStream</code></a>
| <a href="%5BRandStream%5D(https://ww2.mathworks.cn/help/matlab/ref/randstream.html)"><code>bsc</code></a>
| <a href="https://ww2.mathworks.cn/help/matlab/ref/randn.html"><code>randn</code></a>
| <a href="https://ww2.mathworks.cn/help/comm/ref/wgn.html"><code>wgn</code></a></p>
<h2 id="对象">对象</h2>
<p><a href="https://ww2.mathworks.cn/help/comm/ref/comm.awgnchannel-system-object.html"><code>comm.AWGNChannel</code></a></p>
<h2 id="话题">话题</h2>
<p><a href="https://ww2.mathworks.cn/help/comm/ug/awgn-channel.html#a1071501088">AWGN
Channel Noise Level</a></p>
<p>原文参考：<a href="https://ww2.mathworks.cn/help/comm/ref/awgn.html">https://ww2.mathworks.cn/help/comm/ref/awgn.html</a></p>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/css/markmap.css">

<script src="/js/markmap.js"></script>
]]></content>
      <categories>
        <category>MATLAB</category>
        <category>函数用法</category>
        <category>信号处理</category>
        <category>噪声</category>
      </categories>
      <tags>
        <tag>MATLAB</tag>
        <tag>翻译</tag>
        <tag>高斯白噪声</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo-NexT 折腾就完事儿了</title>
    <url>/posts/b158f1b4.html</url>
    <content><![CDATA[<h1 id="主题安装">主题安装</h1>
<p>NexT 官方提供了两种安装主题的方式，一种是使用将主题作为 node.js 的
Package，直接使用 <code>npm install</code> 命令进行安装，另一种是将主题
<code>git clone</code> 到 <code>&lt;path-to-blog&gt;/theme.next</code>
目录下。</p>
<p>这里更推荐将 NexT 主题作为 node.js 的 Package
进行安装，可以让整个博客文件夹更加紧凑，也方便使用 <code>npm</code>
管理版本。安装最新 Release 版 NexT 主题的命令如下：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">npm install hexo-theme-next@latest</span><br></pre></td></tr></tbody></table></figure>
<p>安装完成后在 Hexo 的配置中将主题切换为 <code>next</code> 即可，即</p>
<figure class="highlight diff"><figcaption><span>_config.yml</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="deletion">- theme: landscape</span></span><br><span class="line"><span class="addition">+ theme: next</span></span><br></pre></td></tr></tbody></table></figure>
<span id="more"></span>
<h1 id="环境依赖">环境依赖</h1>
<blockquote>
<p>更新于 2023 年 4 月 15 日</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align: center;">Package 名称</th>
<th style="text-align: center;">版本</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>hexo</code></td>
<td style="text-align: center;"><code>6.3.0</code></td>
</tr>
<tr>
<td style="text-align: center;"><code>hexo-abbrlink</code></td>
<td style="text-align: center;"><code>2.2.1</code></td>
</tr>
<tr>
<td style="text-align: center;"><code>hexo-deployer-git</code></td>
<td style="text-align: center;"><code>4.0.0</code></td>
</tr>
<tr>
<td style="text-align: center;"><code>hexo-filter-github-emojis</code></td>
<td style="text-align: center;"><code>3.0.5</code></td>
</tr>
<tr>
<td style="text-align: center;"><code>hexo-generator-archive</code></td>
<td style="text-align: center;"><code>2.0.0</code></td>
</tr>
<tr>
<td style="text-align: center;"><code>hexo-generator-category</code></td>
<td style="text-align: center;"><code>2.0.0</code></td>
</tr>
<tr>
<td style="text-align: center;"><code>hexo-generator-index</code></td>
<td style="text-align: center;"><code>3.0.0</code></td>
</tr>
<tr>
<td style="text-align: center;"><code>hexo-generator-searchdb</code></td>
<td style="text-align: center;"><code>1.4.1</code></td>
</tr>
<tr>
<td style="text-align: center;"><code>hexo-generator-sitemap</code></td>
<td style="text-align: center;"><code>3.0.1</code></td>
</tr>
<tr>
<td style="text-align: center;"><code>hexo-generator-tag</code></td>
<td style="text-align: center;"><code>2.0.0</code></td>
</tr>
<tr>
<td style="text-align: center;"><code>hexo-helper-live2d</code></td>
<td style="text-align: center;"><code>3.1.1</code></td>
</tr>
<tr>
<td style="text-align: center;"><code>hexo-neat</code></td>
<td style="text-align: center;"><code>1.0.9</code></td>
</tr>
<tr>
<td style="text-align: center;"><code>hexo-related-popular-posts</code></td>
<td style="text-align: center;"><code>5.0.1</code></td>
</tr>
<tr>
<td style="text-align: center;"><code>hexo-related-posts</code></td>
<td style="text-align: center;"><code>1.5.1</code></td>
</tr>
<tr>
<td style="text-align: center;"><code>hexo-renderer-ejs</code></td>
<td style="text-align: center;"><code>2.0.0</code></td>
</tr>
<tr>
<td style="text-align: center;"><code>hexo-renderer-pandoc</code></td>
<td style="text-align: center;"><code>0.3.1</code></td>
</tr>
<tr>
<td style="text-align: center;"><code>hexo-renderer-stylus</code></td>
<td style="text-align: center;"><code>2.1.0</code></td>
</tr>
<tr>
<td style="text-align: center;"><code>hexo-server</code></td>
<td style="text-align: center;"><code>3.0.0</code></td>
</tr>
<tr>
<td style="text-align: center;"><code>hexo-tag-cloud</code></td>
<td style="text-align: center;"><code>2.1.*</code></td>
</tr>
<tr>
<td style="text-align: center;"><code>hexo-theme-landscape</code></td>
<td style="text-align: center;"><code>0.0.3</code></td>
</tr>
<tr>
<td style="text-align: center;"><code>hexo-theme-next</code></td>
<td style="text-align: center;"><code>8.15.1</code></td>
</tr>
<tr>
<td style="text-align: center;"><code>hexo-word-counter</code></td>
<td style="text-align: center;"><code>0.1.0</code></td>
</tr>
</tbody>
</table>
<h1 id="侧边栏">侧边栏</h1>
<h2 id="新建侧边栏配置文件">新建侧边栏配置文件</h2>
<blockquote>
<p>由于 NexT 8.0.0 版本后将 <code>.swig</code> 模板换成了
<code>.njk</code> 模板，因此不同版本需要额外区分。</p>
</blockquote>
<div class="tabs" id="new-sidebar-config"><ul class="nav-tabs"><li class="tab active"><a href="#new-sidebar-config-1">NexT 8.0.0 版本及以上</a></li><li class="tab"><a href="#new-sidebar-config-2">NexT 8.0.0 版本以下</a></li></ul><div class="tab-content"><div class="tab-pane active" id="new-sidebar-config-1"><p>在博客根目录下的 <code>source/_data</code> 文件夹中新建
<code>sidebar.njk</code> 文件，并在 NexT 主题配置中启用文件。</p>
<figure class="highlight diff"><figcaption><span>_config.next.yml</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"> custom_file_path:</span><br><span class="line"><span class="deletion">-  #sidebar: source/_data/sidebar.njk</span></span><br><span class="line"><span class="addition">+  sidebar: source/_data/sidebar.njk</span></span><br></pre></td></tr></tbody></table></figure></div><div class="tab-pane" id="new-sidebar-config-2"><p>在博客根目录下的 <code>source/_data</code> 文件夹中新建
<code>sidebar.swig</code> 文件，并在 NexT 主题配置中启用文件。</p>
<figure class="highlight diff"><figcaption><span>_config.next.yml</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"> custom_file_path:</span><br><span class="line"><span class="deletion">-  #sidebar: source/_data/sidebar.swig</span></span><br><span class="line"><span class="addition">+  sidebar: source/_data/sidebar.swig</span></span><br></pre></td></tr></tbody></table></figure></div></div></div>
<h2 id="添加-tag-cloud">添加 Tag Cloud</h2>
<p>首先安装 <a href="https://github.com/D0n9X1n/hexo-tag-cloud"><code>hexo-tag-cloud</code></a>
插件。</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">npm install hexo-tag-cloud --save</span><br></pre></td></tr></tbody></table></figure>
<div class="tabs" id="sidebar-tag-cloud"><ul class="nav-tabs"><li class="tab active"><a href="#sidebar-tag-cloud-1">NexT 8.0.0 版本及以上</a></li><li class="tab"><a href="#sidebar-tag-cloud-2">NexT 8.0.0 版本以下</a></li></ul><div class="tab-content"><div class="tab-pane active" id="sidebar-tag-cloud-1"><p>添加相关代码写入 <code>sidebar.njk</code>。不喜欢标题的把
<code>&lt;h3 class="widget-title"&gt;Tag Cloud&lt;/h3&gt;</code>
去掉即可。</p>
<figure class="highlight html"><figcaption><span>source/_data/sidebar.njk</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">{% if site.tags.length &gt; 1 %}</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> <span class="attr">src</span>=<span class="string">"/js/tagcloud.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> <span class="attr">src</span>=<span class="string">"/js/tagcanvas.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"widget-wrap"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span> <span class="attr">class</span>=<span class="string">"widget-title"</span>&gt;</span>Tag Cloud<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"myCanvasContainer"</span> <span class="attr">class</span>=<span class="string">"widget tagcloud"</span> <span class="attr">style</span>=<span class="string">"font-size:20px;"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">width</span>=<span class="string">"220"</span> <span class="attr">height</span>=<span class="string">"200"</span> <span class="attr">id</span>=<span class="string">"resCanvas"</span> <span class="attr">style</span>=<span class="string">"width=100%"</span>&gt;</span></span><br><span class="line">            {{ list_tags() }}</span><br><span class="line">        <span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">{% endif %}</span><br></pre></td></tr></tbody></table></figure></div><div class="tab-pane" id="sidebar-tag-cloud-2"><p>添加相关代码写入 <code>sidebar.swig</code>。不喜欢标题的把
<code>&lt;h3 class="widget-title"&gt;Tag Cloud&lt;/h3&gt;</code>
去掉即可。</p>
<figure class="highlight html"><figcaption><span>source/_data/sidebar.swig</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">{% if site.tags.length &gt; 1 %}</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> <span class="attr">src</span>=<span class="string">"/js/tagcloud.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> <span class="attr">src</span>=<span class="string">"/js/tagcanvas.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"widget-wrap"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span> <span class="attr">class</span>=<span class="string">"widget-title"</span>&gt;</span>Tag Cloud<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"myCanvasContainer"</span> <span class="attr">class</span>=<span class="string">"widget tagcloud"</span> <span class="attr">style</span>=<span class="string">"font-size:20px;"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">width</span>=<span class="string">"220"</span> <span class="attr">height</span>=<span class="string">"200"</span> <span class="attr">id</span>=<span class="string">"resCanvas"</span> <span class="attr">style</span>=<span class="string">"width=100%"</span>&gt;</span></span><br><span class="line">            {{ list_tags() }}</span><br><span class="line">        <span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">{% endif %}</span><br></pre></td></tr></tbody></table></figure></div></div></div>
<h1 id="页面">页面</h1>
<p>在博客根目录下的 <code>source/_data</code> 文件夹中新建
<code>variables.styl</code> 文件。</p>
<h2 id="页面圆角">页面圆角</h2>
<p>在 <code>variables.styl</code> 文件里添加圆角半径值</p>
<figure class="highlight stylus"><figcaption><span>source/_data/variables.styl</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 圆角设置</span></span><br><span class="line"><span class="variable">$border</span>-radius-inner     = <span class="number">10px</span>;</span><br><span class="line"><span class="variable">$border</span>-radius           = <span class="number">10px</span>;</span><br></pre></td></tr></tbody></table></figure>
<h1 id="需要修改源代码的操作">需要修改源代码的操作</h1>
<h2 id="修改侧边栏最大高度">修改侧边栏最大高度</h2>
<p>Sidebar 的高度在 <code>themes/next/source/js/util.js</code>
文件中计算出，修改计算公式可调整 Sidebar 的最大高度。</p>
<figure class="highlight javascript"><figcaption><span>themes/next/source/js/util.js - 原 Sidebar 最大高度</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Init Sidebar &amp; TOC inner dimensions on all pages and for all schemes.</span></span><br><span class="line"><span class="comment"> * Need for Sidebar/TOC inner scrolling if content taller then viewport.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="attr">initSidebarDimension</span>: <span class="keyword">function</span>(<span class="params"></span>) {</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// Initialize Sidebar &amp; TOC Height.</span></span><br><span class="line">  <span class="keyword">var</span> sidebarWrapperHeight = <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">offsetHeight</span> - sidebarSchemePadding + <span class="string">'px'</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">},</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight javascript"><figcaption><span>themes/next/source/js/util.js - 修改后的 Sidebar 最大高度</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">initSidebarDimension</span>: <span class="keyword">function</span>(<span class="params"></span>) {</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// Initialize Sidebar &amp; TOC Height.</span></span><br><span class="line">  <span class="keyword">var</span> sidebarWrapperHeight = <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">offsetHeight</span> - sidebarSchemePadding -<span class="number">100</span> + <span class="string">'px'</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">},</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>参考文档：<a href="https://yi-yun.github.io/Hexo-Next-Custom/#更改-sidebar-大小">Hexo
Next 博客自定义配置 -&gt; 更改-sidebar-大小</a></li>
</ul>
<h1 id="数学公式">数学公式</h1>
<h2 id="mathjax-渲染带编号公式导致行溢出的问题">MathJax
渲染带编号公式导致行溢出的问题</h2>
<p>在移植博客的时候发现，带编号的长公式（如 <code>equation</code> 和
<code>align</code>
环境）在窄屏幕上（如手机）显示时会出现行溢出的问题，通过 Google Chrome
检查了一番发现，<code>mjx-container</code> 在渲染后会多出
<code>min-width</code> 属性，且每个公式的 <code>min-width</code>
不同，导致 <code>overflow</code> 无法触发，因为 <code>min-width</code>
和公式宽度是相等的，不会存在 Overflow 的情况。</p>
<figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line">element<span class="selector-class">.style</span> {</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">121.3%</span>;</span><br><span class="line">    <span class="attribute">min-width</span>: <span class="number">35.348em</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>MathJax 的 <a href="https://github.com/mathjax/MathJax/issues/2280">Github Issue</a>
中也出现了类似讨论，官方将这种行为解释为“为了避免公式和编号重叠”而做出的选择。然而实际操作中发现，在
Google Chrome 检查页面中，将 <code>min-width</code> 手动修改为
<code>0</code> 后，可以正常触发 Overflow，并生成水平方向的 Scroll
Bar，且公式和编号没有重叠。</p>
<p>因此突发奇想，能不能指定 <code>!important</code> 属性，将生成的
<code>min-width</code> 强行覆盖掉呢？于是做了如下尝试：</p>
<figure class="highlight stylus"><figcaption><span>source/_data/styles.styl</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">mjx-<span class="attribute">container</span>.MathJax.CtxtMenu_Attached_0 {</span><br><span class="line">    <span class="attribute">min-width</span>: auto <span class="meta">!important</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>然后带编号的公式就可以正常显示 Scroll Bar 了！</p>
<h1 id="不蒜子">不蒜子</h1>
<h2 id="什么是不蒜子">什么是不蒜子</h2>
<p><a href="https://busuanzi.ibruce.info/">不蒜子</a>是 <a href="http://ibruce.info/">Bruce</a>
开发的一款轻量级的网页计数器，可以将网站访问计数直接显示在网页上。</p>
<h2 id="启用不蒜子">启用不蒜子</h2>
<p>NexT 预置了不蒜子提供的网页计数功能。只需要在配置文件中启用即可。</p>
<figure class="highlight yaml"><figcaption><span>next/_config.yml</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># Show Views / Visitors of the website / page with busuanzi.</span></span><br><span class="line"><span class="comment"># Get more information on http://ibruce.info/2015/04/04/busuanzi</span></span><br><span class="line"><span class="attr">busuanzi_count:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>                          <span class="comment"># 启用不蒜子</span></span><br><span class="line">  <span class="attr">total_visitors:</span> <span class="literal">true</span>                  <span class="comment"># 网站总访客数</span></span><br><span class="line">  <span class="attr">total_visitors_icon:</span> <span class="string">fa</span> <span class="string">fa-user</span></span><br><span class="line">  <span class="attr">total_views:</span> <span class="literal">true</span>                     <span class="comment"># 网站总浏览数</span></span><br><span class="line">  <span class="attr">total_views_icon:</span> <span class="string">fa</span> <span class="string">fa-eye</span></span><br><span class="line">  <span class="attr">post_views:</span> <span class="literal">true</span>                      <span class="comment"># 文章浏览数</span></span><br><span class="line">  <span class="attr">post_views_icon:</span> <span class="string">fa</span> <span class="string">fa-eye</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="不蒜子和-live2d-冲突的问题-2020-11-27">不蒜子和 Live2D
冲突的问题 （2020-11-27）</h2>
<blockquote>
<p>Hexo 版本：5.2.0</p>
<p>NexT 版本：8.0.2</p>
<p>不蒜子版本: 2.3</p>
</blockquote>
<h3 id="问题描述">问题描述</h3>
<p>添加 Live2D 前的不蒜子显示情况如下。</p>
<figure>
<img data-src="../images/post/2020-11-27-hexo-next-busuanzi-issues/2020-11-27-hexo-next-busuanzi-issues-010-Live2D-01.png?imageMogr2/thumbnail/!100p%7Cwatermark/2/text/QEpvc2ggR2Fv/font/YWhyb25iZC50dGY=/fontsize/14/dissolve/20/gravity/southeast/dx/5/dy/5" alt="添加 Live2D 前单篇博客的不蒜子显示情况">
<figcaption aria-hidden="true">添加 Live2D
前单篇博客的不蒜子显示情况</figcaption>
</figure>
<figure>
<img data-src="../images/post/2020-11-27-hexo-next-busuanzi-issues/2020-11-27-hexo-next-busuanzi-issues-020-Live2D-02.png?imageMogr2/thumbnail/!100p%7Cwatermark/2/text/QEpvc2ggR2Fv/font/YWhyb25iZC50dGY=/fontsize/14/dissolve/20/gravity/southeast/dx/5/dy/5" alt="添加 Live2D 前网站的不蒜子显示情况">
<figcaption aria-hidden="true">添加 Live2D
前网站的不蒜子显示情况</figcaption>
</figure>
<p>添加 Live2D 后，不蒜子在页面中不显示。</p>
<figure>
<img data-src="../images/post/2020-11-27-hexo-next-busuanzi-issues/2020-11-27-hexo-next-busuanzi-issues-030-Live2D-03.png?imageMogr2/thumbnail/!100p%7Cwatermark/2/text/QEpvc2ggR2Fv/font/YWhyb25iZC50dGY=/fontsize/14/dissolve/20/gravity/southeast/dx/5/dy/5" alt="添加 Live2D 后单篇博客的不蒜子显示情况">
<figcaption aria-hidden="true">添加 Live2D
后单篇博客的不蒜子显示情况</figcaption>
</figure>
<figure>
<img data-src="../images/post/2020-11-27-hexo-next-busuanzi-issues/2020-11-27-hexo-next-busuanzi-issues-040-Live2D-04.png?imageMogr2/thumbnail/!100p%7Cwatermark/2/text/QEpvc2ggR2Fv/font/YWhyb25iZC50dGY=/fontsize/14/dissolve/20/gravity/southeast/dx/5/dy/5" alt="添加 Live2D 后网站的不蒜子显示情况">
<figcaption aria-hidden="true">添加 Live2D
后网站的不蒜子显示情况</figcaption>
</figure>
<h3 id="问题原因">问题原因</h3>
<p>经查，添加 Live2D 后网页的不蒜子部分源码的 <code>style</code> 从
<code>"display: inline;"</code> 替换为了
<code>"display: none;"</code>。</p>
<figure class="highlight html"><figcaption><span>不蒜子不正常显示的网页源码</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-meta-item"</span> <span class="attr">title</span>=<span class="string">"阅读次数"</span> <span class="attr">id</span>=<span class="string">"busuanzi_container_page_pv"</span> <span class="attr">style</span>=<span class="string">"display: none;"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-meta-item-icon"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-eye"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-meta-item-text"</span>&gt;</span> 阅读次数：<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"busuanzi_value_page_pv"</span>&gt;</span>19<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight html"><figcaption><span>不蒜子正常显示的网页源码</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-meta-item"</span> <span class="attr">title</span>=<span class="string">"阅读次数"</span> <span class="attr">id</span>=<span class="string">"busuanzi_container_page_pv"</span> <span class="attr">style</span>=<span class="string">"display: inline;"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-meta-item-icon"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-eye"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-meta-item-text"</span>&gt;</span> 阅读次数：<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"busuanzi_value_page_pv"</span>&gt;</span>18<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="解决方法">解决方法</h3>
<p>在网页生成引擎中修改代码，去掉不蒜子部分的 <code>id</code> 和
<code>style</code> 属性，重新生成网页即可解决该问题。若将
<code>class</code>
属性一并删除，会导不蒜子部分和前面的其他显示部分缺少分隔符，如下图。</p>
<p><img data-src="../images/post/2020-11-27-hexo-next-busuanzi-issues/2020-11-27-hexo-next-busuanzi-issues-050-Delimeter-01.png?imageMogr2/thumbnail/!100p%7Cwatermark/2/text/QEpvc2ggR2Fv/font/YWhyb25iZC50dGY=/fontsize/14/dissolve/20/gravity/southeast/dx/5/dy/5"></p>
<p>具体需要修改两个文件，<code>next/layout/_third-party/statistics/busuanzi-counter.swig</code>
中修改的是网页页脚部分的不蒜子显示，<code>next/layout/_macro/post.swig</code>
中修改的博客文章阅览数的不蒜子显示。</p>
<figure class="highlight html"><figcaption><span>next/layout/_third-party/statistics/busuanzi-counter.swig</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">{%- if theme.busuanzi_count.total_visitors %}</span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-meta-item"</span> <span class="attr">id</span>=<span class="string">"busuanzi_container_site_uv"</span> <span class="attr">style</span>=<span class="string">"display: inline;"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">{%- endif %}</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line"></span><br><span class="line">{%- if theme.busuanzi_count.total_views %}</span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-meta-item"</span> <span class="attr">id</span>=<span class="string">"busuanzi_container_site_pv"</span> <span class="attr">style</span>=<span class="string">"display: inline;"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">{%- endif %}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight html"><figcaption><span>next/layout/_macro/post.swig</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">{%- if not is_index and theme.busuanzi_count.enable and theme.busuanzi_count.post_views %}</span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-meta-item"</span> <span class="attr">title</span>=<span class="string">"{{ __('post.views') }}"</span> <span class="attr">id</span>=<span class="string">"busuanzi_container_page_pv"</span> <span class="attr">style</span>=<span class="string">"display: inline;"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">{%- endif %}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="不蒜子和-live2d-冲突的问题-2023-04-08">不蒜子和 Live2D
冲突的问题 （2023-04-08）</h2>
<blockquote>
<p>Hexo 版本：6.3.0</p>
<p>NexT 版本：8.15.1</p>
<p>不蒜子版本: 2.3</p>
</blockquote>
<p>重新捣鼓博客的时候发现不蒜子又不显示了，依然已经不维护的
<code>hexo-helper-live2d</code> 插件导致的。2020
年的方法写的模棱两可，NexT
的一些网页架构也有了细微改变，因此将新的解决方法附于下方。很多方法是通过直接修改
NexT 主题下的源文件实现的，但是 NexT
并不推荐这样的写法，因为主题目录下的文件是会随着主题更新而被覆盖的，而且不便于使用
Git 管理。经过寻找，在 NexT 的 Github Issues
中找到了优雅的解决方法。</p>
<p>在 <code>source/_data/styles.styl</code> 中添加如下代码即可解决。</p>
<figure class="highlight styl"><figcaption><span>source/_data/styles.styl</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="selector-id">#busuanzi_container_site_uv</span>, <span class="selector-id">#busuanzi_container_site_pv</span>, <span class="selector-id">#busuanzi_container_page_pv</span> {</span><br><span class="line">  <span class="attribute">display</span>: inline <span class="meta">!important</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>REF:</p>
<ol type="1">
<li><p>上述解决方法来源：<a href="https://github.com/next-theme/hexo-theme-next/issues/4#issuecomment-690864794">【必读】更新说明及常见问题</a></p></li>
<li><p>这篇文章分析了 <code>hexo-helper-live2d</code>
插件导致不蒜子不显示的根本原因：<a href="https://ouuan.moe/post/2022/08/busuanzi-and-live2d">busuanzi
访问量统计与 live2d 插件同时使用导致 busuanzi
不显示的根本原因以及解决方法</a></p></li>
</ol>
</blockquote>
<h1 id="重装系统后配置-hexo-next">重装系统后配置 Hexo-Next</h1>
<h2 id="安装-hexo-的支持环境">安装 Hexo 的支持环境</h2>
<p>按照 <a href="https://hexo.io/zh-cn/docs/index.html">Hexo
官方文档</a>的指导，Hexo 需要 <a href="http://nodejs.org/">Node.js</a>
(Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本) 和 <a href="http://git-scm.com/">Git</a> 方可运行，因此首先需要下载安装
Node.js 和 Git。</p>
<h3 id="生成-ssh-添加到-github">生成 SSH 添加到 GitHub</h3>
<p>使用 Git 之前需要配置用户名和邮箱，需要与 Github
用户名和邮箱一致。</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global user.email <span class="string">"you@example.com"</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global user.name <span class="string">"Your Name"</span></span></span><br></pre></td></tr></tbody></table></figure>
<p>然后创建 SSH，一路回车。</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ssh-keygen -t rsa -C <span class="string">"youremail"</span></span></span><br></pre></td></tr></tbody></table></figure>
<p>生成的 <code>id_rsa</code>
是你这台电脑的私人秘钥，不能给别人看的，<code>id_rsa.pub</code>
是公共秘钥，可以随便给别人看。把这个公钥放在 GitHub 上，这样当你链接
GitHub
自己的账户时，它就会根据公钥匹配你的私钥，当能够相互匹配时，才能够顺利的通过
git 上传你的文件到 GitHub 上。</p>
<p>而后在 GitHub 的 setting 中，找到 SSH keys 的设置选项，点击
<code>New SSH key</code> 把你的 <code>id_rsa.pub</code>
里面的信息复制进去。</p>
<p>在 gitbash 中，查看是否成功</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ssh -T git@github.com</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="安装-hexo">安装 Hexo</h2>
<p>所有必备的应用程序安装完成后，即可使用 <code>npm</code> 安装
Hexo。</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npm install -g hexo-cli</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="安装-next-用到的环境">安装 Next 用到的环境</h2>
<h3 id="安装-pandoc">安装 Pandoc</h3>
<p>若文章中包含使用 <a href="https://www.mathjax.org/">MathJax</a>
编译的公式，则需要首先安装 <a href="https://github.com/jgm/pandoc">pandoc</a>，才能编译包含公式的博客页面。</p>
<p>安装完后一定记得<strong>重启</strong>，方可正常使用。</p>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/css/markmap.css">

<script src="/js/markmap.js"></script>
]]></content>
      <categories>
        <category>Blog</category>
        <category>Hexo</category>
        <category>Next</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>Hexo</tag>
        <tag>Next</tag>
        <tag>不蒜子</tag>
        <tag>Tag Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Josh&#39;s Note — Verilog&lt;br&gt;Part 2 Verilog 语言基础</title>
    <url>/posts/fd2ca242.html</url>
    <content><![CDATA[<h1 id="两种设计方法top-down-和-bottom-up">1. 两种设计方法（Top-Down 和
Bottom-Up）</h1>
<p>在传统意义上，设计硬件电路主要是使用自底向上（Bottom-Up）的设计方法。工程师们总是从最底层的逻辑门开始，逐渐搭建成较大的模块，然后再将这些模块组成更大的模块，最后形成整个设计。</p>
<p>在 <a href="https://josh-gao.top/posts/460433dd.html">Part 1——初识
HDL 设计方法</a>中已经提到，随着 HDL
和逻辑综合技术的进步，工程师们逐渐可以使用自顶向下（Top-Down）的方法来设计硬件。这样，工程师们<strong>首先关注于设计的规格（Specification），然后将规格分解为一个个模块，再分解为更小的模块</strong>。然后采用
HDL 的可综合子集直接描述硬件的行为，由逻辑综合工具自动完成由 HDL
到门级电路的转换。</p>
<span id="more"></span>
<p>最近几年，随着 IP
核市场的逐渐兴起，许多设计者逐渐意识到<strong>利用现有的 IP
核可以帮助节约设计成本、减少设计周期</strong>，有许多设计工程师，甚至希望所有的设计模块都使用现成的模块，自己仅仅开发一些简单的粘合逻辑。这就有点像电路板设计的过程，工程师将各种芯片集成到一块电路板上，自己完成这些芯片间的互连和一些简单的
CPLD 逻辑设计，以及对微处理器的编程。使用现有的 IP
来搭建系统实际上也是一种<strong>自底向上</strong>（Bottom-Up）的设计方法。</p>
<p>从以上描述可以看出，设计硬件电路时，这两种设计方法都有可能采用。Verilog
HDL 可以完全支持这两种设计方法。</p>
<ul>
<li>在门级的设计中，用户可以直接实例化 Verilog
语言中的门级原语构建系统；</li>
<li>如果需要描述硬件的行为，可以使用 Verilog 的行为级描述功能；</li>
<li>如果要使用 IP 核，只要在设计中直接实例化 IP 核即可。</li>
</ul>
<p>EDA 行业的先行者们发明了 Verilog 硬件描述语言，其最根本的目的就是用
Verilog 来描述硬件的行为，但是有的描述是不需要实现为硬件电路的。</p>
<p>如果用户的 Verilog
描述的最终目的是要实现为硬件电路，那么要<strong>时刻提醒自己是在设计电路</strong>，这与用
C 语言对处理器编程有很大的区别。</p>
<p>硬件电路最大的特点是由一个个模块组成，模块之间使用互连线，各个模块<strong>独立并行</strong>工作。同时，它们通过输入和输出端口与相邻的模块互相沟通。每个硬件单元都有相应的<strong>延时特性</strong>，硬件的延时也是设计的目标之一。</p>
<h1 id="从-verilog-实例出发">2. 从 Verilog 实例出发</h1>
<h2 id="verilog-实例">2.1. Verilog 实例</h2>
<p><a id="HelloVlog"></a></p>
<p>首先看一个简单的如<a href="#fig.2-1">图 2-1</a>
所示的电路（模块）：<code>HelloVlog</code>。它可以是一个独立的设计，也可以是更大的系统的一个组成部分。</p>
<p><a id="fig.2-1"></a></p>
<figure>
<img data-src="../images/post/2020-11-28-josh-verilog-part-2/2020-11-28-josh-verilog-part-2-010-JoshVerilog.png" width="800" alt="图 2-1 HelloVlog 模块">
<figcaption aria-hidden="true">图 2-1 HelloVlog 模块</figcaption>
</figure>
<p>该电路首先在两个 2 位的输入数据 <code>A_in[1:0]</code> 的和
<code>B_in[1:0]</code> 之间，由 <code>sel</code>
信号做二选一。后面是一个 2-4 译码电路，将输入的信号
<code>result[1:0]</code>解析成
<code>eq0</code>、<code>eql</code>、<code>eq2</code> 和 <code>eq3</code>
这4个信号，它们同时只有一个为 1。</p>
<p>将 <code>eq0</code> 和 <code>eql</code>
相异或（xor），<code>eq2</code> 和 <code>eq3</code>
相异或。然后，将两个异或的结果 <code>A_xor_wire</code> 和
<code>XOR_B</code> 分别寄存输出给 <code>A_xor_out</code> 和
<code>B_xor_out</code>。两个输出寄存器带有低有效（active
low）的异步复位端。</p>
<p><strong>这些电路单元都是同时并行工作的，相互之间并没有先后顺序关系，这一点与软件设计程序很不一样。</strong></p>
<p>下面具体分析 <a href="#HelloVlog">HelloVlog 模块</a>
的电路功能，代码如下。</p>
<p><a id="HelloVlogCode"></a></p>
<figure class="highlight verilog"><figcaption><span>HelloVlog.v</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 编译指令, 定义时间单位和时间精度</span></span><br><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 100ps          </span><span class="comment">// 每个时间单位是1ns, 仿真精度是100ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// module名 + 端口列表</span></span><br><span class="line"><span class="keyword">module</span> HelloVlog( clk, rst_n, A_in, B_in, sel, A_xor_out, B_xor_out );</span><br><span class="line"></span><br><span class="line"><span class="comment">// IO端口声明</span></span><br><span class="line"><span class="keyword">input</span>       clk;</span><br><span class="line"><span class="keyword">input</span>       rst_n;</span><br><span class="line"><span class="keyword">input</span> [<span class="number">1</span>:<span class="number">0</span>] A_in;               <span class="comment">// 该信号的输入位宽为2</span></span><br><span class="line"><span class="keyword">input</span> [<span class="number">1</span>:<span class="number">0</span>] B_in;</span><br><span class="line"><span class="keyword">input</span>       sel;</span><br><span class="line"><span class="keyword">output</span>      A_xor_out;</span><br><span class="line"><span class="keyword">output</span>      B_xor_out;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内部线网和寄存器声明</span></span><br><span class="line"><span class="keyword">wire</span>        A_xor_wire;         <span class="comment">// 模块内wire型变量</span></span><br><span class="line"><span class="keyword">wire</span>        B_xor_wire;</span><br><span class="line"><span class="keyword">wire</span>  [<span class="number">1</span>:<span class="number">0</span>] result;</span><br><span class="line"><span class="keyword">reg</span>         eq0, eq1, eq2, eq3; <span class="comment">// 模块内reg型变量</span></span><br><span class="line"><span class="keyword">reg</span>         A_xor_out;</span><br><span class="line"><span class="keyword">reg</span>         B_xor_out;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 行为描述, DFF_A</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">    <span class="keyword">if</span> (~rst_n)</span><br><span class="line">        A_xor_out &lt;= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        A_xor_out &lt;= A_xor_wire;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 行为描述, DFF_B</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">    <span class="keyword">if</span> (~rst_n)</span><br><span class="line">        B_xor_out &lt;= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        B_xor_out &lt;= B_xor_wire;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据流描述, A_xor_wire</span></span><br><span class="line"><span class="keyword">assign</span> #<span class="number">1</span> A_xor_wire = eq0 ^ eq1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构化描述, XOR_B, 直接使用 Verilog 自带的 xor 门原句</span></span><br><span class="line"><span class="keyword">xor</span> #<span class="number">1</span> XOR_B(B_xor_wire, eq2, eq3);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据流描述, MUX21</span></span><br><span class="line"><span class="keyword">assign</span> #<span class="number">3</span> result = sel ? B_in : A_in;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 行为描述, DECODER, 一个2-4译码器</span></span><br><span class="line"><span class="keyword">always</span> @(result) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">case</span>(result)</span><br><span class="line">        <span class="number">2'b00</span>: <span class="keyword">begin</span></span><br><span class="line">            {eq3, eq2, eq1, eq0} = #<span class="number">2</span> <span class="number">4'b0001</span>;</span><br><span class="line">            <span class="built_in">$display</span> (<span class="string">"At time %t-"</span>, <span class="built_in">$time</span>, <span class="string">"eq0 = 1"</span>);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="number">2'b01</span>: <span class="keyword">begin</span></span><br><span class="line">            {eq3, eq2, eq1, eq0} = #<span class="number">2</span> <span class="number">4'b0010</span>;</span><br><span class="line">            <span class="built_in">$display</span> (<span class="string">"At time %t-"</span>, <span class="built_in">$time</span>, <span class="string">"eq1 = 1"</span>);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="number">2'b10</span>: <span class="keyword">begin</span></span><br><span class="line">            {eq3, eq2, eq1, eq0} = #<span class="number">2</span> <span class="number">4'b0100</span>;</span><br><span class="line">            <span class="built_in">$display</span> (<span class="string">"At time %t-"</span>, <span class="built_in">$time</span>, <span class="string">"eq2 = 1"</span>);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="number">2'b11</span>: <span class="keyword">begin</span></span><br><span class="line">            {eq3, eq2, eq1, eq0} = #<span class="number">2</span> <span class="number">4'b1000</span>;</span><br><span class="line">            <span class="built_in">$display</span> (<span class="string">"At time %t-"</span>, <span class="built_in">$time</span>, <span class="string">"eq3 = 1"</span>);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">default</span>: ;</span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">// module结束</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></tbody></table></figure>
<p>代码分析如下。</p>
<ol type="1">
<li><p>二选一多路选择器</p>
<p>对于 <code>MUX21</code>
这样二选一的电路，将采用如下的数据流描述（assign语句）：</p>
<figure class="highlight verilog"><figcaption><span>HelloVlog.v</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> #<span class="number">3</span> result = sel ? B_in : A_in;</span><br></pre></td></tr></tbody></table></figure>
<p><code>assign</code> 是 Verilog
中的关键词，用它赋值的语言称为<strong>连续赋值语句</strong>。</p>
<p>如果 <code>sel</code>为真（1），则选择 <code>B_in</code>，否则将选择
<code>A_in</code>，而 <code>#3</code> 表示经过 3
个延时单位，再将选择结果赋值给
<code>result</code>，这也模拟了组合逻辑的延时。由于在<a href="#HelloVlogCode">代码</a>最开头已经使用 Verilog
的编译指令将延时单位定义为
1ns（<code>timescale 1ns/100ps</code>），因此这里的 <code>#3</code> 代表
3ns 的延时。</p></li>
<li><p>2 - 4 译码器</p>
<p>关于实现 2 - 4 译码器，则采用了如下的描述：</p>
<figure class="highlight verilog"><figcaption><span>HelloVlog.v</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(result) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">case</span>(result)</span><br><span class="line">        <span class="number">2'b00</span>: <span class="keyword">begin</span></span><br><span class="line">            {eq3, eq2, eq1, eq0} = #<span class="number">2</span> <span class="number">4'b0001</span>;</span><br><span class="line">            <span class="built_in">$display</span> (<span class="string">"At time %t-"</span>, <span class="built_in">$time</span>, <span class="string">"eq0 = 1"</span>);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">default</span>: ;</span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<p>这里采用了另一种描述方式：用 <code>always</code>
语句来描述电路的行为。通过 <code>case</code> 判断 <code>result</code>
的值来决定 <code>eq0</code> ~ <code>eq3</code> 的值。同样，也采用
<code>#2</code> 来模拟组合逻辑的延时。<code>always</code> 和
<code>case</code> 也是 Verilog
中的关键词。这样的描述方法称之为<strong>行为描述</strong>，它侧重于描述电路的行为。</p>
<figure class="highlight verilog"><figcaption><span>HelloVlog.v</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">{eq3, eq2, eq1, eq0} = #<span class="number">2</span> <span class="number">4'b0001</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>该语句表示将 <code>4'b0001</code> 赋值给 <code>eq3</code> ~
<code>eq0</code> 合并成的 4 位变量。<code>{}</code> 是 Verilog
的合并符号。</p></li>
<li><p>异或门</p>
<p>对于 <code>A_xor_wire</code> 和 <code>XOR_B</code>
的两个完全一样的异或门，也采用了两种不同的描述方式：</p>
<figure class="highlight verilog"><figcaption><span>HelloVlog.v</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> #<span class="number">1</span> A_xor_wire = eq0 ^ eq1;</span><br></pre></td></tr></tbody></table></figure>
<p>和</p>
<figure class="highlight verilog"><figcaption><span>HelloVlog.v</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">xor</span> #<span class="number">1</span> XOR_B(B_xor_wire, eq2, eq3);</span><br></pre></td></tr></tbody></table></figure>
<p><code>xor</code> 是 Verilog
中自带的基本逻辑门原语。这里相当于调用了该 <code>xor</code> 门。而
<code>B_xor_wire</code>、<code>eq2</code> 和 <code>eq3</code> 是代入到
<code>xor</code> 门中的参数。<code>eq2</code> 和 <code>eq3</code>
是输入，<code>B_xor_wire</code> 是输出。这里 <code>B_xor_wire</code> 是
<code>eq2</code> 和 <code>eq3</code> 相异或的结果。</p>
<p>在 Verilog 中，<strong>将调用其他功能模块（包括 Verilog
的内嵌基本逻辑门）称为“实例化（Instantiate）”</strong>。实例化<strong>类似</strong>于软件设计中的调用，但不能简单理解为软件中的调用。软件调用过程是顺序执行的，而实例化的硬件电路在设计中是独立于其他功能块，并行运行的。</p>
<p>这种<strong>在模块中实例化其他功能模块</strong>的描述方式被称之为<strong>结构化描述</strong>。</p></li>
</ol>
<h2 id="种描述方法">2.2. 3 种描述方法<a id="toc.2.2"></a></h2>
<p>从以上的描述可以看出 Verilog 语言的 3 种基本的描述方法（基本上所有的
Verilog 功能模块都是由这 3 种方式来描述）：</p>
<ul>
<li><p><strong>数据流描述</strong>：采用 <code>assign</code>
语句，该语句被称为连续赋值语句；</p></li>
<li><p><strong>行为描述</strong>：使用 <code>always</code> 或
<code>initial</code> 语句块，其中出现的语句被称为过程赋值语句；</p></li>
<li><p><strong>结构化描述</strong>：实例化已有的功能模块。结构化描述主要有以下
3 种：</p>
<ul>
<li><p>Module 实例化：实例化已有的 module；</p></li>
<li><p>门实例化：实例化基本的门电路原语；</p></li>
<li><p>用户定义原语（UDP）实例化：实例化用户定义的原语。</p></li>
</ul></li>
</ul>
<p>在 <a href="https://josh-gao.top/posts/fd117896.html">Part
3——描述方式和设计层次</a>中会详细介绍 Verilog 语言中的这 3
种描述方式。</p>
<h1 id="verilog-的基本词法">3. Verilog 的基本词法</h1>
<ol type="1">
<li><p>Verilog HDL 是一种<strong>大小写敏感</strong>的语言，这一点与
VHDL 不同，因此在书写的时候要格外注意。在 Verilog
语言中，<strong>所有的关键字（又叫保留字）都为小写</strong>。Verilog
的内部信号名（或称为标识符）使用大写和小写都可以。标识符可以是字母、数字、<code>$</code>（美元符号）和
<code>_</code>（下划线）任意组合，只要<strong>第一个字符是字母或者下划线</strong>即可。</p>
<div class="note warning"><p>因为 Verilog HDL
对大小写敏感，因此养成良好的信号定义习惯非常重要，否则容易因为大小写不同造成信号的歧义。推荐的信号定义习惯为：<strong>所有信号和网线名均小写，用下划线分割单词，而宏变量全部用大写字母。</strong></p>
</div></li>
<li><p>在上述<a href="#HelloVlogCode">代码</a>中，用双反斜线
<code>//</code> 表示注释。另外，还有一种注释方式，用
<code>/* ...... */</code> 来表示。所不同的是前者为单行注释，而后者将
<code>/*</code> 和 <code>*/</code> 之间的内容全部看作注释内容。</p>
<div class="note info"><p>通常，注释的内容只是作者为了增强代码的可读性而增加的内容，对整个代码的功能没有任何影响。不过，在一些工具中，尤其是逻辑综合工具，定义了一些特殊的指令，用于控制工具编译过程。这些指令也是以注释的方式出现的。例如：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> bl_box(out, data, clk) <span class="comment">/* synthesis syn_black_box */</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>在 <code>module bl_box</code> 的声明处有一行注释，用
<code>/* ...... */</code> 表示。它看起来是一个注释，实际上，是综合工具
Synplify 中的一个指令，指示 Synplify
将该模块看作一个黑盒（black_box），不处理模块内部的描述。</p>
</div></li>
<li><p>在 Verilog
中，通常使用空格符、跳格符和换行符作为间隔。在书写代码的时候，适当运用间隔符可以提高代码的可读性。比如在声明
4 个 <code>reg</code> 型数据 <code>eq0~eq3</code> 时，可以采用上述<a href="#HelloVlogCode">例子</a>中的方法：</p>
<figure class="highlight verilog"><figcaption><span>HelloVlog.v</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span> eq0, eq1, eq2, eq3;</span><br></pre></td></tr></tbody></table></figure>
<p>也可以用换行符将其分开：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span> eq0;</span><br><span class="line"><span class="keyword">reg</span> eq1;</span><br><span class="line"><span class="keyword">reg</span> eq2;</span><br><span class="line"><span class="keyword">reg</span> eq3;</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>在verilog中，还有一些转义字符。比如 <code>\n</code>
表示换行符；<code>\t</code> 表示 Tab 键；防止引起歧义，就用
<code>\</code> 表示 <code>\</code> 符号本身等等。这里不再对 Verilog
的词法做过多的描述，更多可以参考 Verilog IEEE 国际标准（<a href="https://standards.ieee.org/standard/1364-2005.html">IEEE Std.
1364-2005</a>）。</p></li>
</ol>
<h1 id="模块和端口">4. 模块和端口</h1>
<p>大型设计往往是由一个个模块构成的。实际上，模块可大可小，大到一个复杂的微处理器系统，小到一个基本的晶体管，都可以作为一个模块来设计。例如，在上述代码中描述的
<a href="#HelloVlogCode">HelloVlog</a> 就是一个模块。</p>
<p>在 Verilog 中，模块（module）是基本的组成单位。</p>
<div class="note info"><p>通常，建议在一个 Verilog 文件中，只放一个 <code>module</code>
定义，而且使文件名称和 <code>module</code>
名称一致。这是一个良好的设计习惯。</p>
</div>
<p>以下是 Verilog 中 <code>module</code> 的基本语法：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> 模块名称( 端口列表 );</span><br><span class="line"><span class="comment">// 声明：</span></span><br><span class="line">    <span class="keyword">reg</span>, <span class="keyword">parameter</span>,</span><br><span class="line">    <span class="keyword">input</span>, <span class="keyword">output</span>,</span><br><span class="line">    <span class="keyword">function</span>, <span class="keyword">task</span>, ...</span><br><span class="line"><span class="comment">// 语句：</span></span><br><span class="line">    <span class="keyword">initial</span> 语句</span><br><span class="line">    <span class="keyword">always</span> 语句</span><br><span class="line">    <span class="keyword">module</span> 实例化</span><br><span class="line">    门实例化</span><br><span class="line">    用户定义原语 (UDP) 实例化</span><br><span class="line">    连续赋值 (Continuous assignment)</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></tbody></table></figure>
<p>首先，需要有一个名称来标识这个 <code>module</code>。</p>
<p>通常 <code>module</code> 具有输入和输出端口，在 <code>module</code>
名称后面的括号中列出所有的输入、输出和双向的端口名称。</p>
<p>有些 <code>module</code>
也不包含端口。例如，在仿真平台的顶层模块中，其内部已经实例化了所有的设计模块和激励模块，是一个封闭的系统，没有输入和输出。一般这种没有端口的模块都是用于仿真的，不用作实际电路。</p>
<p>在 <code>module</code>
内部的声明部分，需要声明端口的方向（<code>input</code>,
<code>output</code> 和 <code>inout</code>）和位宽。按照 Verilog
的习惯，<strong>高位写在左边，低位写在右边</strong>。比如</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">input</span> [<span class="number">1</span>:<span class="number">0</span>] A_in；</span><br></pre></td></tr></tbody></table></figure>
<p>就表示两位的总线。</p>
<p>模块内部使用的
<code>reg</code>（寄存器类型的一种）、<code>wire</code>（线网类型的一种）、参数、函数以及任务等，都将在
<code>module</code> 中声明。</p>
<p>一般来说，<code>module</code> 的</p>
<ul>
<li><code>input</code> 默认定义为 <code>wire</code> 类型；</li>
<li><code>output</code> 信号可以是 <code>wire</code>，也可以是
<code>reg</code> 类型（如果在 <code>always</code> 或
<code>initial</code> 语句块中被赋值）；</li>
<li><code>inout</code> 是双向信号，一般将其设为 <code>tri</code>
类型，表示其有多个驱动源，如无驱动时为三态。</li>
</ul>
<p>虽然变量声明只要出现在使用的相应语句之间即可，但还是建议将所有的声明放在所有的语句之前，这样具有较好的可读性。在声明之后，就应该是语句了。语句有如下几种：</p>
<ul>
<li><code>initial</code> 语句；</li>
<li><code>always</code> 语句；</li>
<li>其他子 <code>module</code> 实例化；</li>
<li>门实例化；</li>
<li>用户定义原语（User-Defined Primitive, UDP）实例化；</li>
<li>连续赋值（Continuous assignment）。</li>
</ul>
<p>Verilog 中所有的功能描述都是通过以上几种描述方式进行的。</p>
<div class="note warning"><p>需要格外注意的是，以上几种语句如果出现在同一个 <code>module</code>
内，其<strong>相互之间是没有任何顺序关系的</strong>，它们在
<code>module</code> 中出现顺序的改变不会改变 <code>module</code>
的功能，这正是硬件的一大特点。有硬件电路原理图设计经验的读者们可以想象一下画原理图的过程，先画哪个，后画哪个器件根本没有任何关系。在
Verilog 中也是类似的道理。</p>
</div>
<h1 id="编译指令">5. 编译指令</h1>
<p>在 Verilog
语言中，提供了一些编译指令，用于指导编译器的工作。例如，定义宏、文件包含、条件编译、时间单位和精度定义等。</p>
<p>Verilog 中的编译指令是从 C
语言中的“预处理指令”演变得来的。这里列出了一些常用的编译指令如下：</p>
<ul>
<li><code>`timescale</code>；</li>
<li><code>`define, `undef</code>；</li>
<li><code>`ifdef, `else, `endif</code>；</li>
<li><code>`include</code>；</li>
<li><code>`resetall</code>。</li>
</ul>
<p>与 C 语言中使用的 <code>#</code> 不同，Verilog
中使用反引号“<code>`</code>”来标识编译指令。编译器一旦遇到某个编译指令，则其在整个编译过程中有效，可以包含多个文件，直到编译器遇到另一个相同的编译指令。</p>
<h2 id="timescale">5.1. <code>`timescale</code></h2>
<p>在每一个 <code>module</code> 文件前面加上 <code>`</code>
的编译指令，就可以保证该文件中的延时信息受其自身文件中的
<code>`timescale</code>
编译指令指导。<strong>否则在编译过程中，该模块将沿用上一个</strong>
<code>`timescale</code> <strong>的值，或者使用缺省值</strong>。</p>
<p>在上述实例代码描述的 <a href="#HelloVlogCode">HelloVlog</a>
模块中使用了一个<code>`timescale 1ns/100ps</code> 编译指令。其中
<code>1ns</code> 表示延时单位，<code>100ps</code>
表示时间精度，也就是编译器所能接收的最小仿真时间粒度。<code>`timescale</code>
编译指令在模块外部出现，并且影响后面模块中所有的时延值，直到遇到下一个
<code>`timescale</code> 或 <code>`resetall</code> 指令。</p>
<p>比如语句：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> <span class="variable">#(1.16)</span> A_xor_wire = eq0 ^ eq1;</span><br></pre></td></tr></tbody></table></figure>
<p>如果采用 <code>`timescale 1ns/100ps</code> 编译指令由于延时单位是
<code>1ns</code>，同时最小时间粒度是 <code>100ps</code>，即
<code>0.1ns</code> ，那么根据四舍五入的规则，<code>1.16ns</code>
则实际上对应 <code>1.2ns</code> 延时。如果采用
<code>`timescale 1ns/10ps</code> 编译指令，由于延时单位是
<code>1ns</code>，同时最小时间粒度是 <code>10ps</code>，即
<code>0.01ns</code>，那么 <code>1.16ns</code> 则实际上对应
<code>1.16ns</code> 延时。</p>
<h2 id="define-和-undef">5.2. <code>`define</code> 和
<code>`undef</code></h2>
<p><code>`define</code> 用于定义宏。例如，首先定义一个总线宽度的宏为
16，然后利用这个宏定义一个宽度为 16 的 <code>reg</code> 类型数据
<code>Data</code>，方法如下：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">define</span> BUS_WIDTH 16</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">reg</span> [`BUS_WIDTH - <span class="number">1</span> : <span class="number">0</span>] Data</span><br></pre></td></tr></tbody></table></figure>
<p>在一个文件中出现的 <code>`define</code>，可以被多个文件使用。也就是说
<code>`define</code> 是一种<strong>全局的定义</strong>。这是
<code>`define</code> 与 <code>parameter</code>
定义的最大区别，在后面也会提到。</p>
<p><code>`define</code>
指令被编译以后，则在整个编译过程中都有效，直到遇到 <code>`undef</code>
指令，该宏就不再有效。如下：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">undef</span> BUS_WIDTH</span></span><br></pre></td></tr></tbody></table></figure>
<p>遇到该编译指令后，先前的 <code>`define</code> 指令失效。</p>
<h2 id="ifdefelse-和endif">5.3. <code>`ifdef</code>、<code>`else</code>
和<code>`endif</code></h2>
<p>再来看看如下的条件编译指令：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">ifdef</span> NARROW</span></span><br><span class="line">    <span class="keyword">parameter</span> BUS_WIDTH = <span class="number">16</span>；</span><br><span class="line"><span class="meta">`<span class="keyword">else</span></span></span><br><span class="line">    <span class="keyword">parameter</span> BUS_WIDTH = <span class="number">32</span>；</span><br><span class="line"><span class="meta">`<span class="keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure>
<p>在这个条件编译指令中，如果先前已经定义了 <code>NARROW</code>
宏，那么参数 <code>BUS_WIDTH</code> 被设置为 16，否则其被设置为
32。<code>`else</code> 指令对于 <code>`ifdef</code>
来说是可选的，也就是说可以单独使用。</p>
<h2 id="include">5.4. <code>`include</code></h2>
<p>在 Verilog 中，可以使用 <code>`include</code>
指令来嵌入某个文件的内容。例如：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">include</span> "HEADFILE.h"</span></span><br></pre></td></tr></tbody></table></figure>
<p>那么，在编译的时候，就将使用 <code>HEADFILE.h</code>
文件中的内容完全替换这一行语句。而双引号中的文件可以使用相对路径，或绝对路径，或者默认在当前路径以下。</p>
<h2 id="resetall">5.5. <code>`resetall</code></h2>
<p><code>`resetall</code>
编译指令会将所有其他编译指令重新设置为缺省值，要谨慎使用。</p>
<div class="note info"><p>Verilog
语言中的编译指令不止这几条，其他不常用的指令这里不一一介绍，有兴趣可以参考其他文献。</p>
</div>
<h1 id="逻辑值与常量">6. 逻辑值与常量</h1>
<h2 id="逻辑值">6.1. 逻辑值</h2>
<p>在二进制计数中，单位逻辑值只有 <code>1</code> 和 <code>0</code>
两种状态。而在 Verilog
语言中，为了对电路进行精确建模，增加了两种逻辑状态 <code>X</code> 和
<code>Z</code>。</p>
<ul>
<li><p><code>X</code> 表示未知值（unknown），或者不关心（don’t
care），<code>X</code> 用作信号状态时表示未知，用在条件判断时（在
<code>casex</code> 或 <code>casez</code>中）表示不关心；</p></li>
<li><p><code>Z</code>
表示高阻状态，也就是<strong>没有任何驱动</strong>，通常用来对<strong>三态总线</strong>进行建模。</p></li>
</ul>
<p>在<a href="#toc.7">第 7 节</a>将提到 Verilog 语言中的变量类型。通常
<code>net</code> 型变量如果没有初始化，其值为
<code>Z</code>，<code>register</code> 型变量如果没有初始化，其值为
<code>X</code> 。这一点在仿真时显得比较有意义。</p>
<div class="note warning"><p>但是，对综合工具而言（或者说在实际电路中），并没有什么 <code>X</code>
值，只存在 <code>0</code>、<code>1</code> 和 <code>Z</code> 这 3
种状态。在实际电路中还可能出现亚稳态，它既不是 <code>0</code>，也不是
<code>1</code>，是一种暂时的不稳定状态。</p>
</div>
<p>Verilog 语言中所有数据都是由以上描述的 4 种基本的逻辑值
<code>0</code>、<code>1</code>、<code>X</code> 和 <code>Z</code>
构成。同时，<code>X</code> 和 <code>Z</code>
是不区分大小写的。例如：<code>0z1x</code> 和 <code>0Z1X</code>
表示同一个数据。</p>
<h2 id="常量">6.2. 常量</h2>
<p>常量是 Verilog 中不变的数值。在上述<a href="#HelloVlogCode">实例代码</a>中，<code>4'b0001</code> 就表示一个 4
位的二进制整型常量：0001。</p>
<p>Verilog中的常量有3种：</p>
<ul>
<li>整数型；</li>
<li>实数型；</li>
<li>字符串型。</li>
</ul>
<h3 id="整型常量">6.2.1. 整型常量</h3>
<p>可以使用简单的十进制表示一个整型常量，例如：</p>
<ul>
<li><code>16</code> 表示十进制的 16；</li>
<li><code>-15</code> 表示十进制的 -15，用二进制补码表示，至少需要 5
位，即 10001，最高一位为符号位；如果用 6 位表示，则是
110001，同样最高一位为符号位。</li>
</ul>
<p>整数型常量也可以采用基数表示法，例如：</p>
<ul>
<li><code>8'haa</code>：表示 8
位的<strong>十六进制数</strong>，换算成二进制是
<code>1010_1010</code>。</li>
<li><code>6'o33</code>：表示 6
位的<strong>八进制数</strong>，换算成二进制是
<code>011_011</code>。</li>
<li><code>4'b1011</code>：表示 4 位的<strong>二进制数</strong>
<code>1011</code>。</li>
<li><code>3'd7</code>：表示 3 位<strong>十进制</strong>的
<code>7</code>。</li>
</ul>
<p>在基数表示法中，都是以如下格式写的：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line">[长度]'数值符号 数字</span><br></pre></td></tr></tbody></table></figure>
<p>其中<strong>长度可有可无</strong>，数值符号中，<code>h</code>
表示十六进制，<code>o</code> 表示八进制，<code>b</code>
表示二进制，<code>d</code>
表示十进制数据。如果长度比后面数字的实际位数多，则<strong><mark class="label primary">自动在数字的左边补足 0</mark></strong>；如果位数少，则<strong><mark class="label primary">自动截断数字左边超出的位数</mark></strong>。</p>
<p>如果将数字写成
<code>'haa</code>，那么这个十六进制数的长度就决定于数字本身的长度。</p>
<p>在基数表示法中，如果遇到 <code>X</code>，十六进制数中表示 4 个
<code>X</code>，八进制数中表示 3 个 <code>X</code>。</p>
<p>另外，数字中的下划线没有任何意义，只是增强可读性。例如：<code>4'b1011</code>
和 <code>4'b10_11</code> 一样。</p>
<h3 id="实数型常量">6.2.2. 实数型常量</h3>
<p>Verilog
语言中的实数型变量可以采用十进制，也可以采用科学计数法，例如：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">5</span><span class="variable">.512</span></span><br><span class="line"><span class="number">13_2</span><span class="variable">.18e2</span>       <span class="comment">// 表示13218</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="字符串型常量">6.2.3. 字符串型常量</h3>
<p>字符串是双引号中的字符序列，例如：<code>"Hello World"</code>。字符串是
8 位 ASCII 码值的序列，<code>"Hello World"</code> 就需要 11
字节存储，方法如下：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">8</span> * <span class="number">11</span>] Message;</span><br><span class="line">Message = <span class="string">"Hello World"</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>这样就将字符串常量存入到 <code>Message</code> 变量中。</p>
<h1 id="变量类型">7. 变量类型<a id="toc.7"></a></h1>
<p>在 Verilog 语言中，有两大变量类型：</p>
<ul>
<li>线网型：表示电路间的物理连线。</li>
<li>寄存器型：Verilog 中的一个抽象的存储数据单元。</li>
</ul>
<p>对于初学者而言，则需要首先遵守如下的简单规则：</p>
<div class="note primary"><ul>
<li><strong>凡是在</strong> <code>always</code> <strong>或</strong>
<code>initial</code>
<strong>语句中赋值的变量，一定是寄存器变量</strong>；</li>
<li><strong>在</strong> <code>assign</code>
<strong>中赋值的一定是线网变量</strong>。</li>
</ul>
</div>
<h2 id="线网类型">7.1. 线网类型</h2>
<p>在线网类型下，分为几种子类，它们具有线网的共性：</p>
<ul>
<li><code>wire</code>、<code>tri</code>：表示电路间连线，<code>tri</code>
主要用于多驱动源建模；</li>
<li><code>wor</code>、<code>trior</code>：表示该连线具有“线或”功能；</li>
<li><code>wand</code>、<code>triand</code>：表示该连线具有“线与”功能；</li>
<li><code>trireg</code>：表示该连线具有总线保持功能；</li>
<li><code>tri1</code>、<code>tri0</code>：表示当无驱动时，连线状态为
1（<code>tri1</code>）或 0（<code>tri0</code>）；</li>
<li><code>supply1</code>、<code>supply0</code>：分别表示电源和地信号。</li>
</ul>
<p>在以上描述的线网类型中，除了 <code>trireg</code> 未初始化时为
<code>X</code> 以外，其余的未初始化时的值为 <code>Z</code>。</p>
<p>线网类型主要用在连续赋值语句中，以及作为模块之间的互连信号。</p>
<p>在 <a href="https://josh-gao.top/posts/fd117896.html">Part
3——描述方式和设计层次</a>中会详细阐述常用线网类型的使用方法。</p>
<h2 id="寄存器类型">7.2. 寄存器类型</h2>
<p>寄存器类型变量在 Verilog 语言中通常表示一个存储数据的空间。尤其是在
Verilog 仿真器中，寄存器类型变量通常占据一个仿真内存空间。</p>
<ul>
<li><code>reg</code>：是最常用的寄存器类型数，可以是 1
位或者多位，或者是二维数组（存储器）；</li>
<li><code>integer</code>：整型数据，存储一个至少 32 位</li>
<li><code>time</code>：时间类型，存储一个至少 64 位的时间值；</li>
<li><code>real</code>，<code>realtime</code>：实数和实数时间寄存器。</li>
</ul>
<h3 id="reg-类型">7.2.1 <code>reg</code> 类型</h3>
<ol type="1">
<li><p>寄存器类型数</p>
<p><code>reg</code>
类型可以定位为一个寄存器，可以定义一位或者多位，例如：</p>
<p></p><figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span>         AB;             <span class="comment">// 定义一个名为 AB 的 1 位寄存器</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>]   ABC;            <span class="comment">// 定义一个名为 ABC 的 4 位寄存器</span></span><br></pre></td></tr></tbody></table></figure><p></p>
<p>在多位寄存器中，可以作“位选择”或“部分选择”，例如：</p>
<p></p><figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line">ABC [<span class="number">3</span>] = <span class="number">1</span>;                <span class="comment">// 将 ABC 的第 3 位赋值为 1</span></span><br><span class="line">ABC [<span class="number">0</span>] = <span class="number">0</span>;                <span class="comment">// 将 ABC 的第 0 位赋为 0</span></span><br><span class="line">ABC [<span class="number">2</span>:<span class="number">1</span>] = <span class="number">2'b01</span>;          <span class="comment">// 将 ABC 的第 1、2 位赋值为 1 和 0</span></span><br></pre></td></tr></tbody></table></figure><p></p>
<p>这样，整个 <code>ABC</code> 变量的值为
<code>4'b1010</code>。</p></li>
<li><p>寄存器类型数组</p>
<p><code>reg</code> 类型可以作为二维数组，也就是存储器，例如：</p>
<p></p><figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] MEMABC [<span class="number">0</span>:<span class="number">7</span>];     <span class="comment">// 定义一个存储器，地址为 0~7，每个存储单元是 4 位</span></span><br></pre></td></tr></tbody></table></figure><p></p>
<p>与一维的 <code>reg</code>
变量不同的是，存储器中的存储单元不能再做位选择或部分选择，而每个单元可以单独赋值。比如：</p>
<p></p><figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line">MEMABC[<span class="number">1</span>] = <span class="number">4'b0101</span>;        <span class="comment">// 为 MEMABC 中的第 1 个存储单元赋值 4'b0101</span></span><br></pre></td></tr></tbody></table></figure><p></p>
<p>同时，在 Verilog
中，<strong>不存可以对整个存储器赋值的语句</strong>，必须对每个单元独立赋值。除非使用
<code>$readmemb</code> 或 <code>$readmemh</code>
系统任务从文件中读入整个或者部分存储器的数据。</p>
<blockquote>
<p>在 <a href="https://josh-gao.top/posts/e060f513.html">Part 7——
逻辑验证与 testbench
编写</a>中将讨论如何从文件中读入数据给存储器赋值。</p>
</blockquote></li>
</ol>
<h3 id="integer-类型">7.2.2. <code>integer</code> 类型</h3>
<p><code>integer</code> 变量通常用于高层次建模，也常用在
<code>for</code> 语句的索引中，例如：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">initial</span></span><br><span class="line"><span class="keyword">begin</span>: ACCESS</span><br><span class="line">    <span class="keyword">integer</span> i;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">7</span>; i = i + <span class="number">1</span> )        <span class="comment">// 定义一个整数变量 i</span></span><br><span class="line">        MEMABC[i] = i                       <span class="comment">// 遍历 0～7 地址</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="其他寄存器类型">7.2.3. 其他寄存器类型</h3>
<p>另外，<code>time</code> 变量用于存储和处理系统时间，<code>real</code>
和 <code>realtime</code> 用来存储实数和实数时间。</p>
<h2 id="变量的物理含义">7.3. 变量的物理含义</h2>
<p>这里需要引起重视，<strong>“线网”变量可以理解为电路模块中的连线，但“寄存器”并不严格对应于电路上的存储单元</strong>，包括触发器（flip-flop）或锁存器（latch）。从纯粹语言表达的语义角度来说，寄存器类型变量的值，从一个赋值到下一个赋值被保存下来，并且在仿真过程中会保持而不会丢失。</p>
<p>实际上，从语义上来讲，在 Verilog
仿真工具对语言进行仿真的时候，<strong>寄存器类型的变量是占用仿真环境的物理内存的</strong>，这与
C
语言中的变量类似。寄存器在被赋值后，便一直保存在内存中，保持该值不变，直到再次对该寄存器变量进行赋值。而<strong>线网类型是不占用仿真内存的</strong>，它的值是由当前所有驱动该线网的其他变量（可以是寄存器或线网）决定的。这是寄存器和线网最大的区别，也是当初
Verilog 的发明者定义“线网”和“寄存器”变量的根本动机。</p>
<p>在下一小节中，将引入“驱动”和“赋值”两个概念，深入探讨两种变量的含义。</p>
<h2 id="驱动和赋值">7.4. 驱动和赋值<a id="toc.7.4"></a></h2>
<p>为了更清楚地描述寄存器和线网变量的概念，将以上述<a href="#HelloVlogCode">实例代码</a>中的语句来说明。首先，引入 Verilog
语言中两个重要的概念：驱动（Driving）和赋值（Assigning)。</p>
<div class="note primary"><ul>
<li><strong>线网是被驱动的，该值不被保持，在任意一个仿真步进上都需要重新计算</strong>；</li>
<li><strong>寄存器是被赋值的，且该值在仿真过程中被保持，直到下一个赋值的出现</strong>。</li>
</ul>
</div>
<p>在上述<a href="#HelloVlogCode">实例代码</a>中，定义了一个
<code>A_xor_wire</code> 的 <code>wire</code>，它是 <code>eq0</code> 和
<code>eq1</code> 相异或的结果。采用如下描述方式：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> #<span class="number">1</span> A_xor_wire = eq0 ^ eq1;</span><br></pre></td></tr></tbody></table></figure>
<p>实际上，也可以采用如下的另一种描述方式：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(eq0 <span class="keyword">or</span> eq1)</span><br><span class="line">    A_xor_wire = #<span class="number">1</span> eq0 ^ eq1;</span><br></pre></td></tr></tbody></table></figure>
<p>当然需要在 <code>module</code> 的声明处，将 <code>A_xor_wire</code>
首先定义成 <code>reg</code> 变量，而不是 <code>wire</code>
变量，即需要做如下定义：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span> A_xor_wire</span><br></pre></td></tr></tbody></table></figure>
<p>这两者描述的目的一样，都是一个异或门，如<a href="#fig.2-2">图 2-2</a>
所示。</p>
<p><a id="fig.2-2"></a></p>
<figure>
<img data-src="../images/post/2020-11-28-josh-verilog-part-2/2020-11-28-josh-verilog-part-2-020-XORGate.png" width="700" alt="图 2-2 异或门">
<figcaption aria-hidden="true">图 2-2 异或门</figcaption>
</figure>
<p>下面从语义上的角度探讨两种描述方式的不同。</p>
<p>第一种描述方式使用 <code>assign</code> 语句，Verilog
中将其称为连续赋值语句（Continuously
Assignment），实际上是<strong>连续驱动</strong>的过程。也就是说，在任意一个仿真时刻，当前时刻
<code>eq0</code> 和 <code>eq1</code> 相异或的结果决定了 <code>1ns</code>
以后（语句 <code>#1</code> 的延时控制）的线网变量
<code>A_xor_wire</code> 的值，<strong>不管 <code>eq0</code> 和
<code>eq1</code>
变化与否，这个驱动过程一直存在</strong>，因此称为连续驱动。（在仿真器中，线网变量是不占用仿真内存空间的。）如上<a href="#fig.2-2">图 2-2</a>
中的时序所示，这个驱动过程在任意时刻都存在。</p>
<p>在第二种描述方式中使用了 <code>always</code>
语句，后面紧跟着一个敏感列表：<code>@(eq0 or eq1)</code>
因此，这个语句只有在 <code>eq0</code> 或 <code>eq1</code>
发生变化时才会执行。如<a href="#fig.2-2">图 2-2</a> 中，在时刻 2、3 和
6，该语句都将执行，将 <code>eq0</code> 和 <code>eq1</code>
赋值的结果延时 1ns 以后赋值给 <code>A_xor_wire</code>
变量。<strong>在其他时刻，<code>A_xor_wire</code>
变量必须保持</strong>。因此，<strong>从仿真语义上讲，需要一个存储单元，也可以说是寄存器，来保存
<code>A_xor_wire</code> 变量的中间值</strong>。这就是 Verilog
语言的“寄存器类型”变量的来历，而这个 <code>A_xor_wire</code>
变量首先需要定义为 <code>reg</code> 类型。</p>
<p>不管采用哪种方式，所描述的是一样的组合逻辑电路。尤其是第二种描述，虽然其在语言中被定义为
<code>reg</code> 型，但并不是对应硬件上的触发器（flip-flop），而是
Verilog 语言仿真语义上的寄存器概念。</p>
<p>但是，在对实际电路中 D 触发器建模的时候，必须采用 <code>reg</code>
型的变量。<a href="#fig.2-3">图 2-3</a> 是 D 触发器的模型。</p>
<p><a id="fig.2-3"></a></p>
<figure>
<img data-src="../images/post/2020-11-28-josh-verilog-part-2/2020-11-28-josh-verilog-part-2-030-DFlipFlop.png" width="300" alt="图 2-3 D 触发器模型">
<figcaption aria-hidden="true">图 2-3 D 触发器模型</figcaption>
</figure>
<p>在上述<a href="#HelloVlogCode">实例代码</a>中相应的描述如下：</p>
<figure class="highlight verilog"><figcaption><span>HelloVlog.v</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">    <span class="keyword">if</span> (~rst_n)</span><br><span class="line">        A_xor_out &lt;= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        A_xor_out &lt;= A_xor_wire;</span><br></pre></td></tr></tbody></table></figure>
<p>D
触发器<strong>只对时钟和复位（置位）敏感</strong>，因此在敏感列表中，列出了
<code>clk</code> 的上升沿和 <code>rst_n</code> 的下降沿。如果
<code>rst_n</code> 为 0，就对触发器的输出复位，否则在 <code>clk</code>
的时钟上升沿发生的时候，将输入的 <code>A_xor_wire</code>
寄存到触发器的输出端 <code>A_xor_out</code>。</p>
<p>这样的代码精确地描述了一个 D 触发器的行为。这里的 <code>reg</code>
变量就对应了硬件中的 D 触发器。</p>
<p>在叙述时，为了简单起见，常常将“驱动”和“赋值”都统一说成是赋值，但是一定要清楚其中的本质。</p>
<h1 id="参数">8. 参数</h1>
<p>参数是一种常量，通常出现在 <code>module</code>
内部。它常常被用作定义状态机的状态、数据位宽和延时大小等等。例如：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">parameter</span> and_delay = <span class="number">2</span>；</span><br><span class="line"><span class="keyword">parameter</span> xor_delay = <span class="number">4</span>；</span><br></pre></td></tr></tbody></table></figure>
<p><strong>参数的值可以在编译时被改变</strong>，因此它又<strong>经常被用于一些参数可调的模块中</strong>，让用户在实例化模块时，根据需要配置参数。</p>
<p>前面介绍的 <code>`define</code> 是一种全局的定义，而
<code>parameter</code>
是出现在模块内部的<strong>局部定义</strong>，而且可以被<strong>灵活改变</strong>，这是
<code>parameter</code> 的一个重要特征。</p>
<p>在 <a href="https://josh-gao.top/posts/fd117896.html#toc.4.2">Part
3——描述方式和设计层次的 4.2
参数</a>小节会详细探讨改变模块参数的方法。</p>
<h1 id="verilog-中的并发与顺序">9. Verilog 中的并发与顺序</h1>
<p>并行概念是硬件中的一个非常重要的概念，特别是初学者或软件工程师们需要重点理解。</p>
<p>与在处理器上运行的软件不同的是，<strong>硬件电路之间的工作是并行的</strong>。</p>
<p>为了描述硬件的并行性，Verilog 语言本身就具有并发的特性。在 Verilog
语言的 <code>module</code>
中，所有的描述语句（包括连续赋值语句，行为语句块：<code>always</code> 和
<code>initial</code>，模块实例化等）之间都是并行发生的。任何功能描述语句，在
Verilog 的 <code>module</code> 中的顺序都不重要。</p>
<p>但是，在语句块（<code>always</code> 和
<code>initial</code>）内部，则可以存在两种语句组：</p>
<ul>
<li><code>begin ... end</code>：顺序语句组；</li>
<li><code>fork ... join</code>：并行语句组。</li>
</ul>
<p>在 <code>begin ... end</code> 中存在的语句，按照 Verilog
的语义，应该是顺序执行的。而在 <code>fork ... join</code>
中的语句，则是并行执行的。</p>
<p>相比较顺序运行的事物，并行的事物比较难以理解和建模。同时，用于仿真的计算机是串行执行的，而
Verilog
语言本身的语义是用计算机进行模拟的语义，是用一种串行的语义来模拟并行的硬件。</p>
<p>Verilog
仿真器用来模拟硬件的并行行为的方式类似于软件中的多任务操作系统，在某个时刻只能执行一个任务，这样，不同的任务之间看起来是并行执行的。</p>
<p>后续将会重点介绍 Verilog 语言中的这一并行特性，同时阐述 Verilog
的高级仿真原理，希望能帮助大家领会 Verilog 的语义精髓。</p>
<h1 id="操作数操作符和表达式">10.
操作数、操作符和表达式<a id="toc.10"></a></h1>
<h2 id="操作符">10.1. 操作符</h2>
<p>操作符是操作数之间的运算符号。在介绍操作数之前，先来看看 Verilog
中的各种操作符。</p>
<table>
<thead>
<tr>
<th style="text-align: center;">操作符</th>
<th style="text-align: center;">含义</th>
<th style="text-align: center;">操作符</th>
<th style="text-align: center;">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>+</code></td>
<td style="text-align: center;">一元加</td>
<td style="text-align: center;"><code>&gt;&gt;</code></td>
<td style="text-align: center;">右移</td>
</tr>
<tr>
<td style="text-align: center;"><code>-</code></td>
<td style="text-align: center;">一元减</td>
<td style="text-align: center;"><code>&lt;</code></td>
<td style="text-align: center;">小于</td>
</tr>
<tr>
<td style="text-align: center;"><code>!</code></td>
<td style="text-align: center;">一元逻辑非</td>
<td style="text-align: center;"><code>&lt;=</code></td>
<td style="text-align: center;">小于等于</td>
</tr>
<tr>
<td style="text-align: center;"><code>~</code></td>
<td style="text-align: center;">一元按位求反</td>
<td style="text-align: center;"><code>&gt;</code></td>
<td style="text-align: center;">大于</td>
</tr>
<tr>
<td style="text-align: center;"><code>&amp;</code></td>
<td style="text-align: center;">归约与</td>
<td style="text-align: center;"><code>&gt;=</code></td>
<td style="text-align: center;">大于等于</td>
</tr>
<tr>
<td style="text-align: center;"><code>~&amp;</code></td>
<td style="text-align: center;">归约与非</td>
<td style="text-align: center;"><code>==</code></td>
<td style="text-align: center;">逻辑相等</td>
</tr>
<tr>
<td style="text-align: center;"><code>^</code></td>
<td style="text-align: center;">归约异或</td>
<td style="text-align: center;"><code>!=</code></td>
<td style="text-align: center;">逻辑不等</td>
</tr>
<tr>
<td style="text-align: center;"><code>^~</code> 或 <code>~^</code></td>
<td style="text-align: center;">归约异或非</td>
<td style="text-align: center;"><code>===</code></td>
<td style="text-align: center;">全等</td>
</tr>
<tr>
<td style="text-align: center;"><code>\|</code></td>
<td style="text-align: center;">归约或</td>
<td style="text-align: center;"><code>!==</code></td>
<td style="text-align: center;">非全等</td>
</tr>
<tr>
<td style="text-align: center;"><code>~\|</code></td>
<td style="text-align: center;">归约或非</td>
<td style="text-align: center;"><code>&amp;</code></td>
<td style="text-align: center;">按位与</td>
</tr>
<tr>
<td style="text-align: center;"><code>*</code></td>
<td style="text-align: center;">乘</td>
<td style="text-align: center;"><code>^</code></td>
<td style="text-align: center;">按位异或</td>
</tr>
<tr>
<td style="text-align: center;"><code>/</code></td>
<td style="text-align: center;">除以</td>
<td style="text-align: center;"><code>^~</code> 或 <code>~^</code></td>
<td style="text-align: center;">按位异或非</td>
</tr>
<tr>
<td style="text-align: center;"><code>%</code></td>
<td style="text-align: center;">取模</td>
<td style="text-align: center;"><code>\|</code></td>
<td style="text-align: center;">按位或</td>
</tr>
<tr>
<td style="text-align: center;"><code>+</code></td>
<td style="text-align: center;">二元加</td>
<td style="text-align: center;"><code>&amp;&amp;</code></td>
<td style="text-align: center;">逻辑与</td>
</tr>
<tr>
<td style="text-align: center;"><code>-</code></td>
<td style="text-align: center;">二元减</td>
<td style="text-align: center;"><code>\|\|</code></td>
<td style="text-align: center;">逻辑或</td>
</tr>
<tr>
<td style="text-align: center;"><code>&lt;&lt;</code></td>
<td style="text-align: center;">左移</td>
<td style="text-align: center;"><code>? :</code></td>
<td style="text-align: center;">条件操作符</td>
</tr>
</tbody>
</table>
<p>其中，一元操作表示仅有一个操作数，二元操作表示有两个操作数。归约操作也是只有一个操作数，它是该操作数中的所有位之间的计算。</p>
<h3 id="算术操作符">10.1.1. 算术操作符</h3>
<table>
<thead>
<tr>
<th style="text-align: center;">操作符</th>
<th style="text-align: center;">表达式</th>
<th style="text-align: center;">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>+</code></td>
<td style="text-align: center;"><code>m + n</code></td>
<td style="text-align: center;">将 <code>n</code> 与 <code>m</code>
相加</td>
</tr>
<tr>
<td style="text-align: center;"><code>-</code></td>
<td style="text-align: center;"><code>m - n</code></td>
<td style="text-align: center;">将 <code>m</code> 减去
<code>n</code></td>
</tr>
<tr>
<td style="text-align: center;"><code>-</code></td>
<td style="text-align: center;"><code>-m</code></td>
<td style="text-align: center;">将 <code>m</code>
取反（二进制补码）</td>
</tr>
<tr>
<td style="text-align: center;"><code>*</code></td>
<td style="text-align: center;"><code>m * n</code></td>
<td style="text-align: center;">将 <code>m</code> 与 <code>n</code>
相乘</td>
</tr>
<tr>
<td style="text-align: center;"><code>/</code></td>
<td style="text-align: center;"><code>m / n</code></td>
<td style="text-align: center;">将 <code>m</code> 除以
<code>n</code></td>
</tr>
<tr>
<td style="text-align: center;"><code>%</code></td>
<td style="text-align: center;"><code>m % n</code></td>
<td style="text-align: center;">对 <code>m / n</code> 求模</td>
</tr>
</tbody>
</table>
<h3 id="按位操作符">10.1.2. 按位操作符</h3>
<table>
<colgroup>
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 50%">
</colgroup>
<thead>
<tr>
<th style="text-align: center;">操作符</th>
<th style="text-align: center;">表达式</th>
<th style="text-align: center;">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>~</code></td>
<td style="text-align: center;"><code>~m</code></td>
<td style="text-align: center;">将 <code>m</code> 的每个位取反</td>
</tr>
<tr>
<td style="text-align: center;"><code>&amp;</code></td>
<td style="text-align: center;"><code>m &amp; n</code></td>
<td style="text-align: center;">将 <code>m</code> 的每个位与
<code>n</code> 的相应位相与</td>
</tr>
<tr>
<td style="text-align: center;"><code>|</code></td>
<td style="text-align: center;"><code>m | n</code></td>
<td style="text-align: center;">将 <code>m</code> 的每个位与
<code>n</code> 的相应位相或</td>
</tr>
<tr>
<td style="text-align: center;"><code>^</code></td>
<td style="text-align: center;"><code>m ^ n</code></td>
<td style="text-align: center;">将 <code>m</code> 的每个位与
<code>n</code> 的相应位相异或</td>
</tr>
<tr>
<td style="text-align: center;"><code>~^</code><br><code>^~</code></td>
<td style="text-align: center;"><code>m ~^ n</code><br><code>m ^~ n</code></td>
<td style="text-align: center;">将 <code>m</code> 的每个位与
<code>n</code> 的相应位相异或非</td>
</tr>
</tbody>
</table>
<h3 id="归约操作符">10.1.3. 归约操作符</h3>
<table>
<colgroup>
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 50%">
</colgroup>
<thead>
<tr>
<th style="text-align: center;">操作符</th>
<th style="text-align: center;">表达式</th>
<th style="text-align: center;">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>&amp;</code></td>
<td style="text-align: center;"><code>&amp;m</code></td>
<td style="text-align: center;">将 <code>m</code>
中的所有位相与（1位结果）</td>
</tr>
<tr>
<td style="text-align: center;"><code>~&amp;</code></td>
<td style="text-align: center;"><code>~&amp;m</code></td>
<td style="text-align: center;">将 <code>m</code>
中的所有位相与非（1位结果）</td>
</tr>
<tr>
<td style="text-align: center;"><code>|</code></td>
<td style="text-align: center;"><code>|m</code></td>
<td style="text-align: center;">将 <code>m</code>
中的所有位相或（1位结果）</td>
</tr>
<tr>
<td style="text-align: center;"><code>~|</code></td>
<td style="text-align: center;"><code>~|m</code></td>
<td style="text-align: center;">将 <code>m</code>
中的所有位或非（1位结果）</td>
</tr>
<tr>
<td style="text-align: center;"><code>^</code></td>
<td style="text-align: center;"><code>^m</code></td>
<td style="text-align: center;">将 <code>m</code>
中的所有位异或（1位结果）</td>
</tr>
<tr>
<td style="text-align: center;"><code>~^</code><br><code>^~</code></td>
<td style="text-align: center;"><code>~^m</code><br><code>^~m</code></td>
<td style="text-align: center;">将 <code>m</code>
中的所有位相异或非（1位结果）</td>
</tr>
</tbody>
</table>
<h3 id="逻辑操作符">10.1.4. 逻辑操作符</h3>
<table>
<colgroup>
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 50%">
</colgroup>
<thead>
<tr>
<th style="text-align: center;">操作符</th>
<th style="text-align: center;">表达式</th>
<th style="text-align: center;">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>!</code></td>
<td style="text-align: center;"><code>!m</code></td>
<td style="text-align: center;"><code>m</code> 是否不为真？（1 位
真/假结果）</td>
</tr>
<tr>
<td style="text-align: center;"><code>&amp;&amp;</code></td>
<td style="text-align: center;"><code>m &amp;&amp; n</code></td>
<td style="text-align: center;"><code>m</code> 和 <code>n</code>
是否都为真？（1位 真/假结果）</td>
</tr>
<tr>
<td style="text-align: center;"><code>||</code></td>
<td style="text-align: center;"><code>m || n</code></td>
<td style="text-align: center;"><code>m</code> 或 <code>n</code>
是否为真？（1位 真/假结果）</td>
</tr>
</tbody>
</table>
<h3 id="相等操作符">10.1.5. 相等操作符</h3>
<table>
<thead>
<tr>
<th style="text-align: center;">操作符</th>
<th style="text-align: center;">表达式</th>
<th style="text-align: center;">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>==</code></td>
<td style="text-align: center;"><code>m == n</code></td>
<td style="text-align: center;"><code>m</code> 和 <code>n</code>
相等吗？（1 位 正确/错误结果）</td>
</tr>
<tr>
<td style="text-align: center;"><code>!=</code></td>
<td style="text-align: center;"><code>m != n</code></td>
<td style="text-align: center;"><code>m</code> 和 <code>n</code>
不等吗？（1 位 正确/错误结果）</td>
</tr>
</tbody>
</table>
<blockquote>
<p>相等操作符仅比较逻辑 1 和 0。</p>
</blockquote>
<h3 id="全等操作符">10.1.6. 全等操作符</h3>
<table>
<thead>
<tr>
<th style="text-align: center;">操作符</th>
<th style="text-align: center;">表达式</th>
<th style="text-align: center;">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>===</code></td>
<td style="text-align: center;"><code>m === n</code></td>
<td style="text-align: center;"><code>m</code> 和 <code>n</code>
全等吗？（1 位 正确/错误结果）</td>
</tr>
<tr>
<td style="text-align: center;"><code>!==</code></td>
<td style="text-align: center;"><code>m !== n</code></td>
<td style="text-align: center;"><code>m</code> 和 <code>n</code>
不全等吗？（1 位 正确/错误结果）</td>
</tr>
</tbody>
</table>
<h3 id="关系操作符">10.1.7. 关系操作符</h3>
<table>
<thead>
<tr>
<th style="text-align: center;">操作符</th>
<th style="text-align: center;">表达式</th>
<th style="text-align: center;">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>&lt;</code></td>
<td style="text-align: center;"><code>m &lt; n</code></td>
<td style="text-align: center;"><code>m</code> 小于 <code>n</code> ？（1
位 正确/错误结果）</td>
</tr>
<tr>
<td style="text-align: center;"><code>&gt;</code></td>
<td style="text-align: center;"><code>m &gt; n</code></td>
<td style="text-align: center;"><code>m</code> 大于 <code>n</code> ？（1
位 正确/错误结果）</td>
</tr>
<tr>
<td style="text-align: center;"><code>&lt;=</code></td>
<td style="text-align: center;"><code>m &lt;= n</code></td>
<td style="text-align: center;"><code>m</code> 小于等于 <code>n</code>
？（1 位 正确/错误结果）</td>
</tr>
<tr>
<td style="text-align: center;"><code>&gt;=</code></td>
<td style="text-align: center;"><code>m &gt;= n</code></td>
<td style="text-align: center;"><code>m</code> 大于等于 <code>n</code>
？（1 位 正确/错误结果）</td>
</tr>
</tbody>
</table>
<h3 id="逻辑移位操作符">10.1.8. 逻辑移位操作符</h3>
<table>
<thead>
<tr>
<th style="text-align: center;">操作符</th>
<th style="text-align: center;">表达式</th>
<th style="text-align: center;">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>&lt;&lt;</code></td>
<td style="text-align: center;"><code>m &lt;&lt; n</code></td>
<td style="text-align: center;">将 <code>m</code> 左移 <code>n</code>
位</td>
</tr>
<tr>
<td style="text-align: center;"><code>&gt;&gt;</code></td>
<td style="text-align: center;"><code>m &gt;&gt; n</code></td>
<td style="text-align: center;">将 <code>m</code> 右移 <code>n</code>
位</td>
</tr>
</tbody>
</table>
<h3 id="条件操作符">10.1.9. 条件操作符</h3>
<table>
<thead>
<tr>
<th style="text-align: center;">操作符</th>
<th style="text-align: center;">表达式</th>
<th style="text-align: center;">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>? :</code></td>
<td style="text-align: center;"><code>sel ? m : n</code></td>
<td style="text-align: center;">如果 <code>sel</code> 为真，选择
<code>m</code>，否则选择 <code>n</code></td>
</tr>
</tbody>
</table>
<h3 id="连接复制操作符">10.1.10. 连接复制操作符</h3>
<table>
<thead>
<tr>
<th style="text-align: center;">操作符</th>
<th style="text-align: center;">表达式</th>
<th style="text-align: center;">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>{ }</code></td>
<td style="text-align: center;"><code>{m,n}</code></td>
<td style="text-align: center;">将 <code>m</code> 和 <code>n</code>
连接起来，产生更大的向量</td>
</tr>
<tr>
<td style="text-align: center;"><code>{{ }}</code></td>
<td style="text-align: center;"><code>{n{m}}</code></td>
<td style="text-align: center;">将 <code>m</code> 重复 <code>n</code>
次</td>
</tr>
</tbody>
</table>
<p>在以上描述的操作符之间有优先级之分，下表体现了不同的操作数优先级由高到低排列。</p>
<table>
<thead>
<tr>
<th style="text-align: center;">操作符</th>
<th style="text-align: center;">优先级</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>!</code>、<code>~</code>、<code>+</code>、<code>-</code>（一元）</td>
<td style="text-align: center;">最高优先级</td>
</tr>
<tr>
<td style="text-align: center;"><code>*</code>、<code>/</code>、<code>%</code></td>
<td style="text-align: center;"><span class="math inline">\(\vdots\)</span></td>
</tr>
<tr>
<td style="text-align: center;"><code>+</code>、<code>-</code>（二元）</td>
<td style="text-align: center;"><span class="math inline">\(\vdots\)</span></td>
</tr>
<tr>
<td style="text-align: center;"><code>&lt;&lt;</code>、<code>&gt;&gt;</code></td>
<td style="text-align: center;"><span class="math inline">\(\vdots\)</span></td>
</tr>
<tr>
<td style="text-align: center;"><code>&lt;</code>、<code>&lt;=</code>、<code>&gt;</code>、<code>&gt;=</code></td>
<td style="text-align: center;"><span class="math inline">\(\vdots\)</span></td>
</tr>
<tr>
<td style="text-align: center;"><code>==</code>、<code>!=</code>、<code>===</code>、<code>!==</code></td>
<td style="text-align: center;"><span class="math inline">\(\vdots\)</span></td>
</tr>
<tr>
<td style="text-align: center;"><code>&amp;</code>、<code>~&amp;</code></td>
<td style="text-align: center;"><span class="math inline">\(\vdots\)</span></td>
</tr>
<tr>
<td style="text-align: center;"><code>^</code>、<code>~^</code></td>
<td style="text-align: center;"><span class="math inline">\(\vdots\)</span></td>
</tr>
<tr>
<td style="text-align: center;"><code>\|</code>、<code>~\|</code></td>
<td style="text-align: center;"><span class="math inline">\(\vdots\)</span></td>
</tr>
<tr>
<td style="text-align: center;"><code>&amp;&amp;</code></td>
<td style="text-align: center;"><span class="math inline">\(\vdots\)</span></td>
</tr>
<tr>
<td style="text-align: center;"><code>\|\|</code></td>
<td style="text-align: center;"><span class="math inline">\(\vdots\)</span></td>
</tr>
<tr>
<td style="text-align: center;"><code>? :</code></td>
<td style="text-align: center;">最低优先级</td>
</tr>
</tbody>
</table>
<blockquote>
<p>例如：<code>A + B &amp; C + D</code> 就表示
<code>(A + B) &amp; (C + D)</code>，而不是
<code>A + (B &amp; C) + D</code>。</p>
</blockquote>
<h2 id="二进制数值">10.2. 二进制数值</h2>
<p>在讨论操作数之前，先来看看二进制数中如何表示有符号数和无符号数。</p>
<p>例如，在一个 6 位二进制整形变量中，</p>
<ul>
<li>无符号数能表示的范围是：<code>0~63</code>；</li>
<li>有符号数采用二进制补码（Two’s
complement）方式，能表示的范围是：<code>-32～31</code>。其中二进制的最高位表示符号，最高位为
1 表示该数是负数，为 0 表示该数是正数。</li>
</ul>
<p>这里对具体的编码方式不过多介绍，但学过数字电路的同学必须掌握二进制中无符号数和有符号数的表示方法，以及计算的机制。</p>
<h2 id="操作数">10.3. 操作数</h2>
<p>在 Verilog 语言中，操作数可以是如下几种：</p>
<ul>
<li>常数；</li>
<li>参数；</li>
<li>线网；</li>
<li>寄存器；</li>
<li>向量的位选择;</li>
<li>向量的部分选择；</li>
<li>存储器单元；</li>
<li>系统函数或用户自定义函数调用的返回值。</li>
</ul>
<p>在选择操作数时，需要用户尤其注意的是<strong>操作数的极性</strong>。通常在
Verilog 中，无符号数用以下 3 种形式存在：</p>
<ul>
<li>线网变量；</li>
<li>一般寄存器变量；</li>
<li>基数格式表示形式的整数常数。</li>
</ul>
<p>而有符号数有：</p>
<ul>
<li>整型寄存器变量；</li>
<li>十进制形式的整型常量。</li>
</ul>
<p>首先讨论常量，如果采用基数格式表示一个数，例如：<code>-4'd12</code>，其二进制表示方式是：<code>1111_1111_1111_1111_1111_1111_1111_0100</code>（<code>1100</code>
的补码），由于基数格式的整数为无符号数，因此<code>-4'd12</code>
的值就是十进制的 <code>429496728</code>。</p>
<p>当采用普通十进制数来表示 <code>-12</code>
的时候，虽然它的二进制表示方式与上面的数相同，但 <code>-12</code>
是一个有符号数，它在运算时就表示十进制的 <code>-12</code>。</p>
<p>这里定义两个变量，一个是无符号的 <code>reg</code>
型，另一个是有符号的整型：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">4</span>:<span class="number">0</span>] Opreg;            <span class="comment">// 一个 5 位的 reg 型，存储无符号数</span></span><br><span class="line"><span class="keyword">integer</span> Opint;              <span class="comment">// 一个 32 位的 integer 型，存储有符号数</span></span><br></pre></td></tr></tbody></table></figure>
<p>做如下运算：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line">Opreg = -<span class="number">4</span>d'<span class="number">12</span>/<span class="number">4</span>;           <span class="comment">// Opreg 被赋值 29，(-4d'12/4) 的最低5位</span></span><br><span class="line">Opint = -<span class="number">4</span>d'<span class="number">12</span>/<span class="number">4</span>;           <span class="comment">// Opint 被赋值为 1073741821，共 32 位</span></span><br><span class="line">Opreg = -<span class="number">12</span>/<span class="number">4</span>;              <span class="comment">// Opreg 被赋值29，(-12/4) 的最低5位</span></span><br><span class="line">Opint = -<span class="number">12</span>/<span class="number">4</span>;              <span class="comment">// Opint 被赋值为 -3，采用 32 位的二进制补码表示方式</span></span><br></pre></td></tr></tbody></table></figure>
<div class="note warning"><p>通过以上的计算结果可以看出，<strong>无符号数和有符号数的算术运算非常不同</strong>，用户在设计常量和变量并用它们计算的时候，一定要搞清楚它们中哪些表示有符号数，哪些表示无符号数，这很重要。</p>
</div>
<h1 id="系统任务和系统函数">11. 系统任务和系统函数</h1>
<p>在 Verilog
语中，预先定义了一些任务和函数，用于完成一些特殊的功能，它们被称为系统任务和系统函数。Verilog
能提供的系统任务和系统函数类型如下：</p>
<ul>
<li>显示任务（display task）；</li>
<li>文件输入/输出任务（file I/O task）；</li>
<li>时间标度任务（timescale task）；</li>
<li>拟控制任务（simulation control task）；</li>
<li>时序验证任务（timing check task）；</li>
<li>PLA建模任务（PLA modeling task）；</li>
<li>随机建模任务（stochastic modeling task）；</li>
<li>实数变换函数（conversion functions for real）；</li>
<li>概率分布数（probabilistic distribution function)。</li>
</ul>
<p>由于 Verilog
的系统任务和函数种类很多，在这里，只重点介绍一些常用的内容，希望通过介绍可以能让大家迅速掌握，灵活使用。相信通过以下的介绍，大家可以举一反三，通过参考
Verilog 的语法文献，迅速查找到需要的系统任务和函数，完成需要的功能。</p>
<h2 id="显示任务">11.1. 显示任务</h2>
<p><code>$display</code>
是显示任务，通常用来显示变量值、字符串，以及仿真时间等信息。</p>
<p>在 <a href="#HelloVlogCode">HelloVlog
模块</a>中使用了这样的系统任务。</p>
<figure class="highlight verilog"><figcaption><span>HelloVlog.v</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">$display</span> (<span class="string">"At time %t-"</span>, <span class="built_in">$time</span>, <span class="string">"eq0 = 1"</span>);     <span class="comment">// 显示时间</span></span><br></pre></td></tr></tbody></table></figure>
<p>其中，双引号中的是字符串，<code>%t</code>
是时间格式。<code>$time</code>
是产生模拟时间的系统函数，它的返回值显示在字符串中的 <code>%t</code>
位置。</p>
<p>再如：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">$display</span>(<span class="string">"The value of ABC is %d"</span>, ABC);        <span class="comment">// 显示当前 ABC 变量的值</span></span><br></pre></td></tr></tbody></table></figure>
<p>其中，<code>%d</code> 表示十进制数。<code>ABC</code>
的值显示在字符串中的 <code>%d</code> 位置。</p>
<h2 id="文件输入出任务">11.2. 文件输入出任务</h2>
<p>系统函数 <code>$fopen</code>
用于打开一个文件，并返回一个整数的文件指针。然后，<code>$fdisplay</code>
就可以使用这个文件指针向文件中写入信息。写完后，则可以使用
<code>$fclose</code> 这个系统关闭这个文件。例如：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span> Write_Out_File;                         <span class="comment">// 定义一个文件指针</span></span><br><span class="line">Write_Out_File = <span class="built_in">$fopen</span>(<span class="string">"Write_Out_File.txt"</span>);</span><br><span class="line"><span class="built_in">$fdisplay</span>(Write_Out_File, <span class="string">"@ %h\n%h"</span>, Mpi_addr, Data_in);</span><br><span class="line"><span class="built_in">$fclose</span>(Write_Out_File);</span><br></pre></td></tr></tbody></table></figure>
<p>以上的语法，将 <code>Mpi_addr</code> 和 <code>Data_in</code>
分别显示在 <code>@ %h\n%h</code> 中两个 <code>%h</code> 的位置，写入
<code>Write_Out_File</code> 指针所指的文件
<code>Write_Out_File.txt</code> 中。</p>
<p>用户可以通过 <code>$readmemb</code> 或者 <code>$readmemh</code>
来从文件中读入数据，但是这个文件中的数据格式是一定的。例如：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] DataSource [<span class="number">0</span>:<span class="number">47</span>];</span><br><span class="line"><span class="built_in">$readmemh</span> (<span class="string">"Read_In_File.txt"</span>, DataSource);</span><br></pre></td></tr></tbody></table></figure>
<p>就是将 <code>Read_In_FiIe</code> 文件中数据读入到
<code>DataSource</code> 数组中，然后就可以直接使用。</p>
<p><code>Read_In_File</code> 数据文件的格式，可以参考如下写法：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line">@<span class="number">2</span>f</span><br><span class="line"><span class="number">24</span></span><br><span class="line">@<span class="number">2</span>e</span><br><span class="line"><span class="number">81</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></tbody></table></figure>
<p>其中，<code>@2f</code> 表示地址，是十六进制；<code>24</code>
表示该地址的数据，以此类推。</p>
<h2 id="其他系统任务和数">11.3. 其他系统任务和数</h2>
<ol type="1">
<li><p>仿真控制任务</p>
<p>Verilog 中有一些仿真控制任务，例如： <code>$finish</code>
表示使仿真器退出。 <code>$stop</code> 使仿真挂起。</p></li>
<li><p>时序验证任务和仿真时间函数</p>
<p>Verilog 仿真器也可以检查设计时序，以及返回当前仿真时间，例如：
<code>$setup</code> 系统任务用来检查建立时间。 <code>$hold</code>
系统任务用来检查保持时间。 <code>$time</code>
系统函数用来返回一个64位的模拟时间。</p></li>
<li><p>概率分布函数</p>
<p><code>$random</code>
系统函数可以用来返回一个32位的有符号整型随机数。</p></li>
</ol>
<p>需要注意的是，<strong>系统任务/函数只可以在 Verilog
仿真器中运行，仅仅对代码仿真有意义</strong>，综合和布线工具将忽略所有的系统任务和函数。</p>
<p>除了系统任务和系统函数之外，VeriIog还允许用户自己定义任务和函数。关于自定义的任务和函数的特点及使用方法，请参考后续的相关内容。</p>
<h1 id="参考文献">参考文献</h1>
<p>EDA 先锋工作室. <em>轻松成为设计高手——Verilog HDL 实用精解.</em>
北京航空航天大学出版社, 2012.</p>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/css/markmap.css">

<script src="/js/markmap.js"></script>
]]></content>
      <categories>
        <category>Josh 的学习笔记</category>
        <category>Verilog</category>
      </categories>
      <tags>
        <tag>Verilog</tag>
        <tag>HDL</tag>
        <tag>自顶向下</tag>
        <tag>自底向上</tag>
        <tag>Verilog 语法</tag>
      </tags>
  </entry>
  <entry>
    <title>Josh&#39;s Note — Verilog&lt;br&gt;Part 3 描述方式和设计层次</title>
    <url>/posts/fd117896.html</url>
    <content><![CDATA[<h1 id="描述方式">1. 描述方式</h1>
<p>在 <a href="https://josh-gao.top/posts/fd2ca242.html">Part 2——Verilog
语言基础</a>中己经介绍过，Verilog 语言有 3 种最基本的描述方式．</p>
<ul>
<li>数据流描述，采用 <code>assign</code> 连续赋值语句；</li>
<li>行为描述，使用 <code>always</code> 语句或 <code>initial</code>
语句块中的过程赋值语句；</li>
<li>结构化描述，实例化已有的功能模块或原语。</li>
</ul>
<p>下面分别说明这几种描述方式。</p>
<span id="more"></span>
<h1 id="数据流描述">2. 数据流描述</h1>
<h2 id="数据流">2.1. 数据流</h2>
<p>在数字电路中，信号经过组合逻辑时有点类似于数据的流动：信号从输入流向输出，而信号不会在其中存储。当输入发生变化时，总会在一定时间以后体现在输出端。</p>
<p>同样，可以模拟数字电路的这一特性，对其进行建模。通常将这种建模方式称为数据流建模。</p>
<p>数据流描述最基本的语句是 <code>assign</code> 连续赋值语句。</p>
<h2 id="连续赋值语句">2.2. 连续赋值语句</h2>
<p><a id="fig.3-1"></a></p>
<figure>
<img data-src="../images/post/2020-11-30-josh-verilog-part-3/2020-11-30-josh-verilog-part-3-010-XORGate.png" width="800" alt="图 3-1 一个电路模型">
<figcaption aria-hidden="true">图 3-1 一个电路模型</figcaption>
</figure>
<p><a href="#fig.3-1">图 3-1</a>
中的电路模型可以用如下的语句来描述：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> #<span class="number">1</span> A_xor_wire = eq0 ^ eq1;</span><br></pre></td></tr></tbody></table></figure>
<p>在任意一个时刻，<code>A_xor_wire</code> 线网的值是由 <code>eq0</code>
和 <code>eq1</code> 决定的，也可以说是由它们驱动的。</p>
<h3 id="连续赋值语句的特点">2.2.1. 连续赋值语句的特点</h3>
<ol type="1">
<li><p><strong>连续驱动</strong></p>
<p>在 <a href="https://josh-gao.top/posts/fd2ca242.html#toc7.4">Part
2——Verilog 语言基础的 7.4
驱动和赋值</a>部分，已经解释了驱动和赋值之间的微妙区别。</p>
<p>连续赋值语句是连续驱动的。也就是说，任何时刻输入的任何变化都将导致该语句的重新计算。</p></li>
<li><p><strong>只有线网类型能在 <code>assign</code> 中赋值</strong></p>
<p>由于仿真器中不会存储连续赋值语句中被赋值的变量值，因此该变量是线网类型（Net），不能是寄存器类型。需要记住，只有线网类型的变量才可以在
<code>assign</code> 语句中被赋值。</p>
<p>另外，线网类型的变量可以被多重驱动，也就是说，可以在多个连续赋值语句中驱动同一个线网。在
<a href="#toc.2.4">2.4
驱动源线网</a>小节中将进一步介绍。但是，寄存器变量就不同了，它不能被不同的行为进程（例如
<code>always</code> 语句块）驱动。</p></li>
<li><p><strong>使用 <code>assign</code> 对组合逻辑建模</strong></p>
<p>通常建议使用 <code>assign</code> 对组合逻辑建模。因为
<code>assign</code> 语句的连续驱动特点与组合逻辑的行为非常相似。而且，在
<code>assign</code>
语句中加延时可以非常精确的模拟组合逻辑的惯性延时。</p></li>
<li><p><strong>并行性</strong></p>
<p><code>assign</code> 语句和行为语句块（<code>always</code> 和
<code>initial</code>)、其他连续赋值语句、门级模型之间是并行的。一个连续赋值语句是一个独立的进程，进程之间是并发，同时也是交织的。</p></li>
</ol>
<h3 id="实例">2.2.2. 实例</h3>
<p><a id="fig.3-2"></a></p>
<figure>
<img data-src="../images/post/2020-11-30-josh-verilog-part-3/2020-11-30-josh-verilog-part-3-020-FullAdder.png" width="800" alt="图 3-2 两个半加器和一个或门组成全加器">
<figcaption aria-hidden="true">图 3-2
两个半加器和一个或门组成全加器</figcaption>
</figure>
<p>在<a href="#fig.3-2">图 3-2</a>
中，用两个半加器和一个或门组成一个全加器，这里将使用连续赋值语句描述这个电路。代码如下。</p>
<p><a id="HalfAdder"></a></p>
<figure class="highlight verilog"><figcaption><span>HalfAdd.v</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> HalfAdd(X, Y, sum, C_out);</span><br><span class="line"></span><br><span class="line"><span class="comment">// IO端口声明</span></span><br><span class="line"><span class="keyword">input</span> X;</span><br><span class="line"><span class="keyword">input</span> Y;</span><br><span class="line"><span class="keyword">output</span> sum;</span><br><span class="line"><span class="keyword">output</span> C_out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> sum = X ^ Y;</span><br><span class="line"><span class="keyword">assign</span> C_out = X &amp; Y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight verilog"><figcaption><span>FullAdd.v</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> FullAdd(X, Y, C_in, sum, C_out);</span><br><span class="line"></span><br><span class="line"><span class="comment">// IO端口声明</span></span><br><span class="line"><span class="keyword">input</span> X;</span><br><span class="line"><span class="keyword">input</span> Y;</span><br><span class="line"><span class="keyword">input</span> C_in;</span><br><span class="line"><span class="keyword">output</span> sum;</span><br><span class="line"><span class="keyword">output</span> C_out;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线网类型用于连接</span></span><br><span class="line"><span class="keyword">wire</span> HalfAdd_A_sum;</span><br><span class="line"><span class="keyword">wire</span> HalfAdd_A_Cout;</span><br><span class="line"><span class="keyword">wire</span> HalfAdd_B_Cout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> C_out = HalfAdd_A_Cout | HalfAdd_B_Cout;</span><br><span class="line"></span><br><span class="line">HalfAdd u_HalfAdd_A(</span><br><span class="line">    <span class="variable">.X</span>      (C_in),</span><br><span class="line">    <span class="variable">.Y</span>      (Y),</span><br><span class="line">    <span class="variable">.s</span>      (HalfAdd_A_sum),</span><br><span class="line">    <span class="variable">.C_out</span>  (HalfAdd_A_Cout)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">HalfAdd u_HalfAdd_B(</span><br><span class="line">    <span class="variable">.X</span>      (C_in),</span><br><span class="line">    <span class="variable">.Y</span>      (HalfAdd_A_sum),</span><br><span class="line">    <span class="variable">.s</span>      (sum),</span><br><span class="line">    <span class="variable">.C_out</span>  (HalfAdd_B_Cout)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></tbody></table></figure>
<p>在 <code>HalfAdd</code> 模块中，两个 <code>assign</code>
语句之间是<strong>完全并行独立执行</strong>的，它们的顺序与逻辑功能无关。同样，<code>FullAdd</code>
模块中，两个 <code>HalfAdd</code> 的实例和或门的 <code>assign</code>
语句之间的关系也是独立的。</p>
<h2 id="延时">2.3. 延时</h2>
<p>在连续赋值语句中，可以对电路的延时进行建模。当然，也可以没有延时。比如：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> #<span class="number">1</span> A_xor_wire = eq0 ^ eq1;           <span class="comment">// `timescale 1ns/1ns</span></span><br></pre></td></tr></tbody></table></figure>
<p>这个语句就表示该异或门的延时为
<code>1ns</code>，也就是说，输入端信号变化到输出端体现出来需要
<code>1ns</code> 的时间。</p>
<p>这里是比较笼统的延时模型。实际上，电路对不同的信号跳变表现出的延时往往并不一致。这些延时模型包括：</p>
<ul>
<li>上升沿延时（输出变为 1）；</li>
<li>下降沿延时（输出变为 0）；</li>
<li>关闭延时（输出变成 <code>Z</code>，高阻态）；</li>
<li>输出变成 <code>X</code> 的延时。</li>
</ul>
<p>用户可以分别描述这几种延时，比如：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> <span class="variable">#(1,2)</span> A_xor_wire = eq0 ^ eq1;</span><br><span class="line"><span class="keyword">assign</span> <span class="variable">#(1,2,3)</span> A_xor <span class="keyword">wire</span> = eq0 ^ eq1;</span><br></pre></td></tr></tbody></table></figure>
<p>第一句表示，上升延时 <code>1ns</code>，下降延时
<code>2ns</code>，关闭延时和传递到 <code>X</code>
的延时为两者中最小的，即 <code>1ns</code>。</p>
<p>第二句表示，上升延时 <code>1ns</code>，下降延时
<code>2ns</code>，关闭延时为 <code>3ns</code>，传递到 <code>X</code>
的延时取1、2、3中最小的 <code>1ns</code>。</p>
<p>在一些电路模型中，延时分为最大、典型和最小3种情况。连续赋值语句中的延时也可以采用
<code>min:typ:max</code> 的格式来表示。例如：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> <span class="variable">#(4:5:6, 3:4:5)</span> A_xor_wire = eq0 ^ eq1;</span><br></pre></td></tr></tbody></table></figure>
<p>表示上升延时的 <code>min:typ:max</code> 为
<code>4:5:6</code>，下降延时的 <code>min:typ:max</code> 为
<code>3:4:5</code>。</p>
<p>需要注意的是，在连续赋值语句中的延时具有硬件电路中惯性延时的特性。也就是说，<strong>任何小于其延时的信号变化脉冲将被滤除掉，不会体现在输出端口上</strong>。</p>
<p>另外，<code>assign</code>
语句中的延时特性通常是被逻辑综合工具忽略的。因为综合工具要将 Verilog
语言模型综合成逻辑电路，而逻辑电路的延时是由基本的单元库和走线延时决定的。用户无法对逻辑单元指定延时，但是，用户可以在综合和实现工具中加时序约束，让工具尽量满足设计的时序要求。</p>
<h2 id="驱动源线网">2.4. 驱动源线网<a id="toc.2.4"></a></h2>
<p>下面分为几种线网类型来描述当线网具有多重驱动源时的情况。</p>
<h3 id="多重驱动-wire错误">2.4.1. 多重驱动
<code>wire</code>（错误）</h3>
<figure class="highlight verilog"><figcaption><span>WS.v</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> WS (A, B, C, D, WireShort)；</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> A, B, C, D;</span><br><span class="line"><span class="keyword">output</span> WireShort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">wire</span> WireShort;         <span class="comment">//显式定义为wire类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> WireShort = A ^ B；</span><br><span class="line"><span class="keyword">assign</span> WireShort = C &amp; D；</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></tbody></table></figure>
<p>在以上代码中，由于 <code>WireShort</code> 为 <code>wire</code>
类型，同时它有多重驱动源，因此仿真时 <code>WireShort</code> 的值将是
<code>X</code>，也就是不定态。</p>
<h3 id="线或线与功能">2.4.2. 线或、线与功能</h3>
<p>可以使用 <code>wor</code>
线网类型来将不同的输出“线或”在一起，如下：</p>
<figure class="highlight verilog"><figcaption><span>// WO.v</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> WO (A, B, C, D, WireOr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> A, B, C, D;</span><br><span class="line"><span class="keyword">output</span> WireOr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">wor</span> WireOr;             <span class="comment">// 显式定义为 wor 类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> WireOr = A ^ B;</span><br><span class="line"><span class="keyword">assign</span> WireOr = C &amp; D;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></tbody></table></figure>
<p>逻辑综合以后，它具体对应的逻辑电路如<a href="#fig.3-3">图 3-3</a>
所示。</p>
<p><a id="fig.3-3"></a></p>
<figure>
<img data-src="../images/post/2020-11-30-josh-verilog-part-3/2020-11-30-josh-verilog-part-3-030-WireOr.png" width="700" alt="图 3-3 线或的功能">
<figcaption aria-hidden="true">图 3-3 线或的功能</figcaption>
</figure>
<p>同样，可以使用 <code>wand</code>
线网类型来将不同的输出“线与”在一起，如下：</p>
<figure class="highlight verilog"><figcaption><span>WA.v</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> WA (A, B, C, D, WireAnd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> A, B, C, D;</span><br><span class="line"><span class="keyword">output</span> WireAnd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">wand</span> WireAnd;           <span class="comment">// 显式定义为 wand 类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> WireAnd = A ^ B;</span><br><span class="line"><span class="keyword">assign</span> WireAnd = C &amp; D;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></tbody></table></figure>
<p>它对应的逻辑电路如<a href="#fig.3-4">图 3-4</a> 所示。</p>
<p><a id="fig.3-4"></a></p>
<figure>
<img data-src="../images/post/2020-11-30-josh-verilog-part-3/2020-11-30-josh-verilog-part-3-040-WireAnd.png" width="700" alt="图 3-4 线与的功能">
<figcaption aria-hidden="true">图 3-4 线与的功能</figcaption>
</figure>
<h3 id="三态总线功能">2.4.3. 三态总线功能</h3>
<p>如果要实现多个三态总线相连，可以采用 <code>tri</code> 型线网：</p>
<figure class="highlight verilog"><figcaption><span>WT.v</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> WT (A, B, C, D, WireTri, en1_n, en2_n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> A, B, C, D, en1_n, en2_n;</span><br><span class="line"><span class="keyword">output</span> WireTri;</span><br><span class="line"></span><br><span class="line"><span class="keyword">tri</span> WireTri;            <span class="comment">// 显式定义为 tri 类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> WireTri = (en1_n) ? <span class="number">1'bz</span> : (A ^ B);</span><br><span class="line"><span class="keyword">assign</span> WireTri = (en2_n) ? <span class="number">1'bz</span> : (C &amp; D);</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></tbody></table></figure>
<p>其实现的电路如<a href="#fig.3-5">图 3-5</a> 所示。</p>
<p><a id="fig.3-5"></a></p>
<figure>
<img data-src="../images/post/2020-11-30-josh-verilog-part-3/2020-11-30-josh-verilog-part-3-050-WireTri.png" width="700" alt="图 3-5 三态驱动总线电路">
<figcaption aria-hidden="true">图 3-5 三态驱动总线电路</figcaption>
</figure>
<h1 id="行为描述">3. 行为描述<a id="toc.3"></a><a></a></h1><a>
</a><p><a>在 </a><a href="https://josh-gao.top/posts/fd2ca242.html#toc2.2">Part
2——Verilog 语言基础的 2.2 3
种描述方法</a>中介绍过行为描述的概念。所谓行为描述，是指用语言描述电路的行为。行为描述的语句有两种：<code>initial</code>
和 <code>always</code> 语句。</p>
<h2 id="行为描述的语句格式">3.1. 行为描述的语句格式</h2>
<p><code>initial</code> 和 <code>always</code>
的后面一般跟语句或语句组（statement
group)。语句可以是：非阻塞过程赋值、阻塞过程赋值、连续过程赋值或高级编程语句。下面开始介绍。</p>
<h3 id="initial-或-always-过程块procedural-block">3.1.1.
<code>initial</code> 或 <code>always</code> 过程块（procedural
block）</h3>
<p><code>initial</code> 语句在 0
仿真时间执行，而且只执行一次；<code>always</code> 语句同样在 0
仿真时间开始执行，但是它将一直循环执行。这样的特点单单从它们的命名上就能看得出来：一个是
<code>initial</code>，就是初始化一次的意思；另一个是
<code>always</code>，就是总在运行的意思。</p>
<p>下面利用 <code>initial</code> 和 <code>always</code>
语句各自的特点，产生一个时钟发生器的模型。</p>
<figure class="highlight verilog"><figcaption><span>ClkGen.v</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"><span class="keyword">module</span> ClkGen (clk);</span><br><span class="line"></span><br><span class="line"><span class="keyword">output</span> clk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span> clk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span>             <span class="comment">// 将 clk 初始化为 0</span></span><br><span class="line">    clk = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span>              <span class="comment">// 每 5ns 将 clk 翻转一次</span></span><br><span class="line">    #<span class="number">5</span> clk = ~clk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></tbody></table></figure>
<p>在 0 时刻，<code>initial</code> 和 <code>always</code>
语句同时执行，<strong>顺序随机</strong>。假设先运行 <code>initial</code>
语句，那么 <code>clk</code> 变量被赋值为 0，这时 <code>initial</code>
语句进程将永远被挂起，再也不会执行。</p>
<p>然后，开始运行 <code>always</code> 语句。该 <code>always</code>
语句每隔 <code>5ns</code> 将 <code>clk</code>
信号翻转一次，一直不停地运行，这样就产生了一个周期是 <code>10ns</code>
的时钟信号。</p>
<div class="note warning"><p>在以上代码中，0 时刻，<code>initial</code> 和 <code>always</code>
语句同时执行，顺序随机，这样就存在一个冲突的问题。假设先执行的是
<code>always</code> 语句， <code>clk</code> 就不会被初始化为 0。</p>
</div>
<h3 id="过程块中的语句种类">3.1.2. 过程块中的语句种类</h3>
<p>在 <code>initial</code> 和 <code>always</code>
过程块中可以直接跟语句或者语句组。直接跟的语句可以是非阻塞过程赋值、阻塞过程赋值、连续过程赋值或高级编程语句。语句组可以是：<code>begin ... end</code>
和 <code>fork ... join</code> 两种。</p>
<p>语句组中可以有其他几种语句类型，而高级编程语句中也可以有语句组，它们可以互相嵌套，完成非常复杂的逻辑功能描述。</p>
<p>下面是 <code>always</code> 过程块中直接跟阻塞赋值语句：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">always</span>              <span class="comment">// 每 5ns 将 clk 翻转一次</span></span><br><span class="line">    #<span class="number">5</span> clk = ~clk;</span><br></pre></td></tr></tbody></table></figure>
<p>下面的代码描述了语句组和高级编程语句的互相嵌套：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line"><span class="keyword">begin</span>                               <span class="comment">// 语句组</span></span><br><span class="line">    <span class="keyword">if</span> (~rst_n)                     <span class="comment">// 高级编程语句</span></span><br><span class="line">    <span class="keyword">begin</span>                           <span class="comment">// 语句组</span></span><br><span class="line">        reg_A &lt;= <span class="number">0</span>;                 <span class="comment">// 非阻塞赋值语句</span></span><br><span class="line">        reg_B &lt;= <span class="number">0</span>;                 <span class="comment">// 非阻塞赋值语句</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span>                            <span class="comment">// 高级编程语句</span></span><br><span class="line">    <span class="keyword">begin</span>                           <span class="comment">// 语句组</span></span><br><span class="line">        reg_A &lt;= input_A;           <span class="comment">// 非阻塞赋值语句</span></span><br><span class="line">        reg_B &lt;= input_B;           <span class="comment">// 非阻塞赋值语句</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<p>从上例中可以看出，高级编程语句里面可以嵌套过程赋值语句，或者其他高级编程语句。</p>
<h3 id="时序控制timing-control">3.1.3. 时序控制（Timing Control）</h3>
<p>在行为描述中，有几种方式对设计模型进行时序控制，它们是：</p>
<ul>
<li>事件语句（<code>@</code>）；</li>
<li>延时语句（<code>#</code>）；</li>
<li>等待语句。</li>
</ul>
<p>当执行 <code>initial</code> 或 <code>always</code>
语句块时遇到一个事件语句（<code>@</code>）、延时语句（<code>#</code>），或其表达式值为假（false）的等待语句时，语句块（或称为进程）的执行将被挂起（suspended)。直到发生该事件，或者已经过了指定延迟的时间单位数，或者等待语句表达式变为真（ture）时，才重新执行
<code>initial</code> 或 <code>always</code>
语句块。这个过程就是时序控制。Verilog
的行为描述中，正是利用这几种时序控制语句来实现各种各样的逻辑功能。</p>
<h4 id="事件语句的用法">3.1.3.1. 事件语句（<code>@</code>）的用法</h4>
<p><a id="fig.3-6"></a></p>
<figure>
<img data-src="../images/post/2020-11-30-josh-verilog-part-3/2020-11-30-josh-verilog-part-3-060-DFlipFlop.png" width="600" alt="图 3-6 D 触发器模型">
<figcaption aria-hidden="true">图 3-6 D 触发器模型</figcaption>
</figure>
<p>要实现<a href="#fig.3-6">图 3-6</a> 中这样一个 D
触发器，通常用以下代码：</p>
<figure class="highlight verilog"><figcaption><span>TYP_DFF.v</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> TYP_DFF (clk, D, Q);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> clk, D;</span><br><span class="line"><span class="keyword">output</span> Q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span> Q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">    Q &lt;= D;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></tbody></table></figure>
<p>在 0 仿真时刻，<code>always</code> 语句块开始执行。当遇到
<code>@(posedge clk)</code> 语句时，该进程被挂起。等待 <code>clk</code>
的上升沿到来，才重新激活该进程。当 <code>clk</code> 的上升沿出现后，将
<code>D</code> 的值赋给 <code>Q</code>，<code>always</code>
语句块执行完成。</p>
<p>由于 <code>always</code> 语句的特点，<code>always</code>
语句马上开始重新执行，当遇到 <code>@(posedge clk)</code>
语句时，进程再一次挂起，等待 <code>clk</code>
的上升沿到来，才继续往下执行。</p>
<p>这样，在 <code>always</code> 语句中使用 <code>@</code>
事件语句很好地模拟了触发器的行为。综合工具会马上将上述代码映射成<a href="#fig.3-6">图 3-6</a> 中的 D 触发器。</p>
<p>同样的道理，采用如下的代码也可以得到一样的 D 触发器功能：</p>
<figure class="highlight verilog"><figcaption><span>TYP_DFF.v</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> TYP_DFF (clk, D, Q);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> clk, D;</span><br><span class="line"><span class="keyword">output</span> Q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span> Q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> <span class="keyword">begin</span></span><br><span class="line">    @(<span class="keyword">posedge</span> clk)</span><br><span class="line">    Q &lt;= D;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></tbody></table></figure>
<p>当有多个条件语句时，一般将它们用 <code>or</code>
分隔开。例如，要实现一个带异步复位端的 D 触发器可以采用如下代码：</p>
<figure class="highlight verilog"><figcaption><span>TYP_DFF.v</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> TYP_DFF (clk, D, Q, rst);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> clk, D, rst;</span><br><span class="line"><span class="keyword">output</span> Q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span> Q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">posedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (rst)</span><br><span class="line">        Q &lt;= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        Q &lt;= D;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></tbody></table></figure>
<p>当出现 <code>clk</code> 或 <code>rst</code> 的下降沿时，才会触发
<code>always</code> 语句。</p>
<h4 id="延时语句的用法">3.1.3.2. 延时语句（<code>#</code>）的用法</h4>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">always</span>              <span class="comment">// 每 5ns 将 clk 翻转一次</span></span><br><span class="line">    #<span class="number">5</span> clk = ~clk;</span><br></pre></td></tr></tbody></table></figure>
<p>这里 <code>always</code> 的语句开始执行时，马上遇到
<code>#5</code>，<code>always</code> 语句块挂起。直到 <code>5ns</code>
以后才恢复执行，这时将 <code>clk</code> 取反。当再次执行
<code>always</code> 时，动作与上一次完全一致。这里，模拟了一个周期为
<code>10ns</code> 的时钟。</p>
<p>当然，这种写法一般用于仿真激励的产生，仅仅用于仿真。由于综合工具会将延时语句
<code>#5</code> 忽略，所以如上的代码无法综合成一个 <code>10ns</code>
周期的时钟发生器电路。</p>
<p>以下代码利用延时语句产生一个复位信号：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    rst_n =<span class="number">1</span>;</span><br><span class="line">    #<span class="number">5</span> rst_n = <span class="number">0</span>;</span><br><span class="line">    #<span class="number">100</span> rst_n=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<p>当以上 <code>initial</code> 语句开始运行时，首先将 <code>rst_n</code>
赋值为 <code>1</code>。当遇到 <code>#5</code> 时，该
<code>initial</code> 的执行过程被暂时挂起，等待 <code>5ns</code>
后恢复执行，<code>rst_n</code> 被置
<code>0</code>，处于复位状态。然后，遇到 <code>#100</code>，等待
<code>100ns</code> 以后再恢复执行，<code>rst_n</code> 被置为
<code>1</code>。这时，<code>initial</code>
语句块被永远挂起，再也不会执行。于是，就产生了一个 <code>100ns</code>
的复位信号。</p>
<h4 id="等待语句的用法">3.1.3.3. 等待语句的用法</h4>
<p>下面分析一下等待语句如何做时序控制：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> MY_LATCH (Strobe, D, Q);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> Strobe, D;</span><br><span class="line"><span class="keyword">output</span> Q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span> Q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">wait</span> (Strobe == <span class="number">1</span>);</span><br><span class="line">    Q = D;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></tbody></table></figure>
<p>该语句表示，当 <code>always</code> 语句开始执行后，遇到
<code>wait()</code> 语句，如果括号内的变量不为真，则该进程被挂起，直到
<code>(Strobe == 1)</code> 为真，<code>always</code> 才继续往下执行，将
<code>D</code> 的值赋值给
<code>Q</code>，这样就模拟了一个电平敏感的锁存器。</p>
<p>要注意的是，目前多数综合工具还不支持 <code>wait</code>
语句，因此这个锁存器的功能只能在仿真时用，不能实现为具体的电路。</p>
<h2 id="过程赋值语句">3.2. 过程赋值语句<a id="toc.3.2"></a></h2>
<p>所谓过程赋值语句就是在 <code>initial</code> 和 <code>always</code>
语句块中的赋值语句。赋值对象只能是寄存器变量类型。右边的表达式可以是任意操作符的表达式。</p>
<h3 id="阻塞赋值">3.2.1. 阻塞赋值</h3>
<p>阻塞赋值的语法如下：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line">寄存器变量 = 表达式;</span><br></pre></td></tr></tbody></table></figure>
<p>所谓“阻塞赋值”，实际上有两层含义：</p>
<ol type="1">
<li><p>右边表达式的计算和对左边寄存器变量的赋值是一个统一的原子操作中的两个动作。<strong>这两个动作之间不能插入任何其他的动作</strong>。</p></li>
<li><p>如果多个阻塞赋值语句顺序出现在 <code>begin ... end</code>
语句中，<strong>前面的语句在执行时，将完全阻塞后面的语句，直到前面语句的赋值完成以后，才会执行下一句的右边表达式计算</strong>。例如
<code>begin m = n; n = m; end</code> 语句中，当 <code>m</code>
被完全赋值以后，再开始执行 <code>n=m</code>，将 <code>m</code>
的新值赋给 <code>n</code>。这样执行的结果就是的初始值不变，而且与
<code>n</code> 相等。</p></li>
</ol>
<p>由于阻塞賦值的这一特点，通常会建议在对组合逻辑建模的时候，采用阻塞賦值，先看一段代码：</p>
<p><a id="CombinationalLogicDemo"></a></p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">wire</span> A_in, B_in, C_in;</span><br><span class="line"><span class="keyword">reg</span> Temp, D_out;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">always</span> @(A_in <span class="keyword">or</span> B_in <span class="keyword">or</span> C_in) <span class="keyword">begin</span></span><br><span class="line">    Temp = A_in &amp; B_in;             <span class="comment">// 阻塞赋值</span></span><br><span class="line">    D_out = Temp | C_in;            <span class="comment">// 阻塞赋值</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<p>设计者的根本目的是得到如<a href="#fig.3-7">图 3-7</a>
所示的电路。</p>
<p><a id="fig.3-7"></a></p>
<figure>
<img data-src="../images/post/2020-11-30-josh-verilog-part-3/2020-11-30-josh-verilog-part-3-070-ACombinationalLogic.png" width="700" alt="图 3-7 一个组合逻辑">
<figcaption aria-hidden="true">图 3-7 一个组合逻辑</figcaption>
</figure>
<p>在以上代码仿真时，正是利用了阻塞赋值的这一特点才模拟了该组合逻辑的行为。</p>
<p>首先，任何一个输入发生变化，<code>D_out</code> 必然发生变化。因此，在
<code>always</code> 的敏感列表中，包括
<code>A_in</code>，<code>B_in</code> 和
<code>C_in</code>。在内部计算时，首先将 <code>A_in</code> 和
<code>B_in</code> 相与，得到一个中间结果 <code>Temp</code>。等
<code>Temp</code> 被完全赋值后，才开始执行下一个语句：将
<code>Temp</code> 的新值与 <code>C_in</code> 相或，得到
<code>D_out</code> 的值。我们也许可以感受到，这个 <code>always</code>
语句非常精确地模拟了上图中电路的行为。</p>
<p>另外，有一点会使得初学者产生较大的疑问。为什么 Verilog
规定只有寄存器（<code>register</code>）类型的变量才能够在过程赋值语句中被赋值呢？有时候在
Verilog
中定义的寄存器变量，在综合时并不一定映射成一个实在的触发器硬件。比如在以上的例子中，<code>Temp</code>
和 <code>D_out</code> 被定义成 <code>reg</code>
变量，而综合结果它们却还是组合逻辑，并不是存储单元。</p>
<p>在 Verilog
语言中，寄存器变量的特点是<strong>需要在仿真运行器件上保持它的值</strong>，也就是说，这个变量在仿真时需要占据内存空间。</p>
<p>在以上的 <code>always</code> 实例中，<code>always</code> 语句块只对
<code>A_in</code> 等 3 个输入变化敏感。如果没有这 3
个变量的变化事件，<code>Temp</code> 和 <code>D_out</code>
变量将需要保存其值，因此它们必须被定义为寄存器类型变量。但是，它们在综合之后，并不对应硬件锁存器或者触发器。</p>
<h3 id="非阻塞赋值">3.2.2. 非阻塞赋值</h3>
<p>非阻寒赋值的语法如下：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line">寄存器变量 &lt;= 表达式;</span><br></pre></td></tr></tbody></table></figure>
<p>它的特点是在执行该语句时，首先计算右边的表达式，然后并不立刻对左边的变量赋值。由于这个赋值操作在当前仿真时间事件队列中的优先级比较低，因此<strong>将赋值推迟到当前仿真时刻的后期运行</strong>。关于具体非阻塞赋值的右式计算和左式更新是何时完成的，请参考后续内容。</p>
<!-- [comment]:<> (第8章中“分层事件队列”部分内容。) -->
<p>与阻塞赋值不同的是，如果多个非阻塞赋值语句顺序出现在
<code>begin ... end</code>
语句中，前面语句的执行，并不会阻塞后面语句的执行。前面语句的计算完成，还没有赋值时，就会执行下一句的右边表达式计算。例如
<code>begin m &lt;= n; n &lt;= m; end</code>
语句中，最后的结果是将m与n值互换了。</p>
<p>如果想要采用如下代码来描述<a href="#CombinationalLogicDemo">前述组合逻辑电路</a>的功能：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">wire</span> A_in, B_in, C_in;</span><br><span class="line"><span class="keyword">reg</span> Temp, D_out;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">always</span> @(A_in <span class="keyword">or</span> B_in <span class="keyword">or</span> C_in) <span class="keyword">begin</span></span><br><span class="line">    Temp &lt;= A_in &amp; B_in;            <span class="comment">// 非阻塞赋值</span></span><br><span class="line">    D_out &lt;= Temp | C_in;           <span class="comment">// 非阻塞赋值</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<p>如果使用仿真工具去仿真这段代码，就会发现它的功能并不是所想要的功能。比如当
<code>A_in</code> 发生变化，执行 <code>always</code> 语句，其中
<code>Temp &lt;= A_in &amp; B_in;</code> 这句话并没有立刻对
<code>Temp</code> 赋值，而是放在当前仿真时刻的后期才开始执行
<code>Temp</code> 的更新。这样，当执行
<code>D_out &lt;=Temp | C_in;</code>
表达式的右式计算事件时，<code>Temp</code> 的值还是 旧的值，因此这时
<code>D_out</code> 并不会发生变化。</p>
<p>大家也许可以尝试将如上的代码用综合工具综合一下，可能同样会得到<a href="#CombinationalLogicDemo">前述组合逻辑电路</a>的情况。这是由于一些综合工具可以容忍用户的这些代码缺陷。这就造成了
RTL 仿真和综合的结果不一致的现象。</p>
<p>为什么会造成这个现象呢？因为 RTL 的仿真器严格按照 Verilog
的仿真语义执行 RTL
的仿真过程，而综合工具通常只是根据用户的代码推断设计者的意图，然后生成相应的电路结构。因此，综合的过程有一定的主观推断性，并不严格遵守
Verilog 的语义，不同的综合工具判决标准也不一样。</p>
<p>这种情况是每一个设计都应该尽量避免的，因为仿真和综合结果不一致说明源代码中很可能有隐患，不符合
Verilog 的语义，会错过许多 bug，增加设计的不稳定性。</p>
<p>所以保证仿真器和综合器都能正确理解设计的代码，是非常关键的。</p>
<div class="note info"><p><strong>通常利用非阻塞赋值的特点来对时序逻辑进行建模。</strong></p>
</div>
<p>代码如下：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">    q1 &lt;= d;</span><br><span class="line">    q2 &lt;= q1;</span><br><span class="line">    q3 &lt;= q2;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<p>其实现结果如<a href="#fig.3-8">图 3-8</a>：</p>
<p><a id="fig.3-8"></a></p>
<figure>
<img data-src="../images/post/2020-11-30-josh-verilog-part-3/2020-11-30-josh-verilog-part-3-080-ThreeFlowStateRegister.png" width="600" alt="图 3-8 三级流水的寄存器">
<figcaption aria-hidden="true">图 3-8 三级流水的寄存器</figcaption>
</figure>
<p>正是利用了语句之间的非阻塞性，才实现了这个 3 级流水线的逻辑功能。</p>
<h3 id="过程连续赋值">3.2.3. 过程连续赋值</h3>
<p>在 Verilog
语言中，还有一种过程赋值语句叫做“过程连续赋值”，它们也是出现在
<code>always</code> 和 <code>initial</code> 语句块中的。</p>
<p>过程连续赋值主要有两种：</p>
<ul>
<li><code>assign</code> 与
<code>deassign</code>：在过程语句块中对寄存器变量强制赋值和放开；</li>
<li><code>force</code> 与
<code>release</code>：在过程语句块中对寄存器和线网进行强制赋值和放开。</li>
</ul>
<p>例如，在下面的代码实例中用 <code>assign</code> 和
<code>deassign</code> 描述了一个带异步清零端的 D 触发器。</p>
<figure class="highlight verilog"><figcaption><span>DEF.V</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> DEF(D, clr, clk, Q);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> D, clr, clk;</span><br><span class="line"><span class="keyword">output</span> Q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span> Q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(clr) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!clr)</span><br><span class="line">        <span class="keyword">assign</span> Q = <span class="number">0</span>;       <span class="comment">// D 的值对 Q 无效, 将 Q 强制为 0</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">deassign</span> Q;         <span class="comment">// 将强制的 Q 值放开</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">negedge</span> clk)</span><br><span class="line">    Q = D;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></tbody></table></figure>
<p>这里不再对过程连续赋值进行过多阐述，有兴趣可以参考其他文献。</p>
<!-- [comment]:<> (在第8章中的8．6“再谈阻塞与非阻塞赋值”一节中，通过一个实例，将再次深入阐述非阻塞和阻塞赋值语句的本质。) -->
<h2 id="语句组">3.3. 语句组</h2>
<p>语句组是两条以上语句的组合，它们看起来像一个独立的语句。语句组也是出现在
<code>initial</code> 和 <code>always</code> 的过程块中的。</p>
<p>根据其中语句的执行顺序，语句组可以分为“顺序语句组”和“并行语句组”两种。</p>
<h3 id="顺序语句组-begin-...-end">3.3.1. 顺序语句组
<code>begin ... end</code></h3>
<p>在顺序语句组中，其中的语句是一条一条顺序执行的。比如下面的语句：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(A_in <span class="keyword">or</span> B_in <span class="keyword">or</span> C_in) <span class="keyword">begin</span></span><br><span class="line">    Temp = A_in &amp; B_in;                 <span class="comment">// 阻塞赋值</span></span><br><span class="line">    D_out = Temp | C_in;                <span class="comment">// 阻塞赋值</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<p>首先执行第一句，将 <code>A_in</code> 和 <code>B_in</code>
相与，然后将结果赋给 <code>Temp</code> 变量；再执行第一句，将新的
<code>Temp</code> 值 <code>C_in</code> 相或，结果立刻赋给
<code>D_out</code>。</p>
<p>当然，这里是同时利用了 <code>begin ... end</code>
语句组和阻塞赋值的特点，才实现了用户想要的逻辑功能。</p>
<p>再比如要产生一个值序列：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">initial</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    DataBin = <span class="number">0</span>;</span><br><span class="line">    #<span class="number">6</span> DataBin = <span class="number">0</span>;</span><br><span class="line">    #<span class="number">4</span> DataBin = <span class="number">1</span>;</span><br><span class="line">    #<span class="number">2</span> DataBin = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<p>由于语句是顺序执行的，产生的波形如<a href="#fig.3-9">图 3-9</a>
所示。</p>
<p><a id="fig.3-9"></a></p>
<figure>
<img data-src="../images/post/2020-11-30-josh-verilog-part-3/2020-11-30-josh-verilog-part-3-090-SequentialWave.png" width="500" alt="图 3-9 顺序语句块的执行波形">
<figcaption aria-hidden="true">图 3-9 顺序语句块的执行波形</figcaption>
</figure>
<h3 id="并行语句组-fork-...-join">3.3.2. 并行语句组
<code>fork ... join</code></h3>
<p>在<code>fork ... join</code>
语句组中，语句是并行执行的。将上一小节的代码改写如下：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">initial</span></span><br><span class="line"><span class="keyword">fork</span></span><br><span class="line">    DataBin = <span class="number">0</span>;</span><br><span class="line">    #<span class="number">6</span> DataBin = <span class="number">0</span>;</span><br><span class="line">    #<span class="number">4</span> DataBin = <span class="number">1</span>;</span><br><span class="line">    #<span class="number">2</span> DataBin = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">join</span></span><br></pre></td></tr></tbody></table></figure>
<p>由于其中的所有语句并行执行，也就是以上 4 条语句都是从 0
时刻开始同时执行的，产生的波形如<a href="#fig.3-10">图 3-10</a>。</p>
<p><a id="fig.3-10"></a></p>
<figure>
<img data-src="../images/post/2020-11-30-josh-verilog-part-3/2020-11-30-josh-verilog-part-3-100-ParallelWave.png" width="500" alt="图 3-10 并行语句块的执行波形">
<figcaption aria-hidden="true">图 3-10 并行语句块的执行波形</figcaption>
</figure>
<h3 id="语句组的标识符">3.3.3. 语句组的标识符</h3>
<p>语句组可以有标识符，也可以没有。</p>
<p><strong>当一个语句组有标识符时，在语句组内部可以定义局部变量，而不会传递到语句组的外部</strong>。然而，在仿真语义上，这个变量是静态变量，它的值在整个仿真运行周期中是不变的，但是不会与其他语句组中同一个名称的变量发生冲突。例如：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span> i;              <span class="comment">// always 语句以外的 i 变量</span></span><br><span class="line"><span class="keyword">always</span> @(...)</span><br><span class="line"><span class="keyword">begin</span>: SORT</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">integer</span> i;          <span class="comment">// 语句组内部的 i 变量</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>;i &lt;= <span class="number">7</span>; i = i + <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<p>在 <code>always</code> 以外的i变量和 <code>always</code>
里面定义的i变量属于<strong>两个不同的变量，并不冲突</strong>。它们在仿真的时候将占用两块不同的内存，类似于
C 语言中的静态局部变量。</p>
<h2 id="高级编程语句">3.4. 高级编程语句<a id="toc.3.4"></a></h2>
<h3 id="为什么需要编程语句">3.4.1. 为什么需要编程语句</h3>
<p>Verilog
作为硬件描述语言，最重要的特性就是其设计层次比较高，不仅停留在晶体管级和门级，而是可以在更高的层次如
RTL 级甚至是行为级描述硬件系统的行为，或者编写测试激励。</p>
<p>为了达到提高描述能力、提高抽象层次，Verilog 语言从 C
语言等编程语言中借鉴了一语句，同时也创造了一些语句，例如
<code>if</code>、<code>case</code>、<code>while</code>、<code>for</code>、<code>repeat</code>
和 <code>forever</code> 等。这些语句被称为高级编程语句。有了这些语句
Verilog 才可以描述比较复杂的电路行为。</p>
<p>编程语句只能出现在 <code>initial</code> 和 <code>always</code>
的过程块中。编程语句中可以嵌套其他的语句，比如过程赋值语句或者其他编程语句。</p>
<p>高级编程语分为3大类：</p>
<ul>
<li><code>if ... else</code> 语句；</li>
<li><code>case</code> 语句；</li>
<li>循环语句：<code>forever</code>、<code>repeat</code>、<code>while</code>、<code>for</code>。</li>
</ul>
<p>下面将逐一介绍。</p>
<h3 id="if-...-else-语句">3.4.2. <code>if ... else</code> 语句</h3>
<p><code>if</code> 语句后面跟语句或语句组（<code>begin ... end</code> 或
<code>fork ... join</code>)。常和 <code>else</code>
搭配来实现不同条件的各种情况。<code>if</code> 也可以单独使用，没有
<code>else</code> 配合。</p>
<p>现考虑以下代码：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(sel_a <span class="keyword">or</span> sel_b <span class="keyword">or</span> a <span class="keyword">or</span> b <span class="keyword">or</span> c) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (sel_a)</span><br><span class="line">        q = a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (sel_b)</span><br><span class="line">        q = b;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        q = c;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<p>它要实现的逻辑如<a href="#fig.3-11">图 3-11</a>。</p>
<p><a id="fig.3-11"></a></p>
<figure>
<img data-src="../images/post/2020-11-30-josh-verilog-part-3/2020-11-30-josh-verilog-part-3-110-IfElseStatement.png" width="600" alt="图 3-11 if ... else 语句">
<figcaption aria-hidden="true">图 3-11 <code>if ... else</code>
语句</figcaption>
</figure>
<p>在 <code>if ... else</code>
语句中，条件是从上到下逐条检查的。因此，当满足一个条件时，就执行其后的语句，跳过
<code>else</code> 后面的语句、当所有条件都不满足，便执行最后一条
<code>else</code> 后面的语句。因此 <code>if ... else</code>
语句实际上是有优先级顺序的。</p>
<div class="note info"><p>实际在上例中使用了 <code>if ... else</code>
优先级编码的特点，<code>sel_a</code>
的判断优先级最高，因此在逻辑中的级数要明显少一些，参考上图。<strong>如果
<code>sel_a</code>
为关键路径的话，就可以利用这样的优先级编码提高设计的性能</strong>。</p>
</div>
<p>在使用 <code>if ... else</code>
语句时，<strong>尤其是用在组合逻辑中，需要注意不要引入 Latch
电路</strong>。先来看如下的代码：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(sel <span class="keyword">or</span> a <span class="keyword">or</span> b <span class="keyword">or</span> c) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (sel == <span class="number">2'b00</span>)</span><br><span class="line">        q = a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (sel == <span class="number">2'b01</span>)</span><br><span class="line">        q = b;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (sel == <span class="number">2'b10</span>)</span><br><span class="line">        q = c;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<p>由于，最后一个条件 <code>sel == 2'b11</code>
的语句没有被显式地写出，言下之意是，当 <code>sel</code> 为
<code>2'b11</code> 时，<code>q</code>
值需要保持不变。这个代码在综合时自然就会产生锁存器，如<a href="#fig.3-12">图 3-12</a>。</p>
<p><a id="fig.3-12"></a></p>
<figure>
<img data-src="../images/post/2020-11-30-josh-verilog-part-3/2020-11-30-josh-verilog-part-3-120-CombinationalLogicwithLatch.png" width="800" alt="图 3-12 产生锁存器">
<figcaption aria-hidden="true">图 3-12 产生锁存器</figcaption>
</figure>
<div class="note warning"><p><strong>锁存器在数字同步逻辑设计中应该尽量避免。因为锁存器容易引起竞争冒险，同时静态时序分析工具也不好分析穿过锁存器的路径。</strong></p>
</div>
<p>在下面的代码中，己经明确写出：当 <code>se</code> 为
<code>2'b11</code> 时，<code>q</code> 值不关心，赋值为
<code>x</code>。</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(sel <span class="keyword">or</span> a <span class="keyword">or</span> b <span class="keyword">or</span> c) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (sel == <span class="number">2'b00</span>)</span><br><span class="line">        q = a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (sel == <span class="number">2'b01</span>)</span><br><span class="line">        q = b;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (sel == <span class="number">2'b10</span>)</span><br><span class="line">        q = c;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        q = <span class="number">1'bx</span>;       <span class="comment">// 当 sel 为 2'b11 时, q 值不关心</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<p>既然不关心 <code>sel</code> 为 <code>2'b11</code> 时 <code>q</code>
的值，那么有的综合工具就顺手将 <code>sel</code> 等于 <code>2'b11</code>
时 <code>q</code> 的值也赋值为
<code>c</code>，这样就避免了锁存器的产生。实现电路如<a href="#fig.3-13">图 3-13</a>。</p>
<p><a id="fig.3-13"></a></p>
<figure>
<img data-src="../images/post/2020-11-30-josh-verilog-part-3/2020-11-30-josh-verilog-part-3-130-CombinationalLogicwithoutLatch.png" width="800" alt="图 3-13 无锁存器的组合逻辑电路">
<figcaption aria-hidden="true">图 3-13
无锁存器的组合逻辑电路</figcaption>
</figure>
<p>然而，在描述时序逻辑时，通常将利用 <code>if</code>
语句的隐式条件对带时钟使能的 D 触发器建模。代码如下：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (~rst_n)</span><br><span class="line">        sum &lt;= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (en)</span><br><span class="line">        sum &lt;= a + b;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<p>以上语句表示在时钟正沿来临时，如果 <code>en</code> 为 1，则将
<code>a + b</code> 的值付给 <code>sum</code>。言下之意：如果
<code>en</code> 为 0，那么 <code>sum</code>
保持原值不变。因此，这里综合工具会把代码综合成一个时钟使能的寄存器，如<a href="#fig.3-14">图 3-14</a> 所示。</p>
<p><a id="fig.3-14"></a></p>
<figure>
<img data-src="../images/post/2020-11-30-josh-verilog-part-3/2020-11-30-josh-verilog-part-3-140-DFlipFlopClock.png" width="800" alt="图 3-14 带时钟使能的 D 触发器">
<figcaption aria-hidden="true">图 3-14 带时钟使能的 D
触发器</figcaption>
</figure>
<p>其中，<code>en</code> 信号时 D 触发器的时钟使能端，<code>rst_n</code>
是 D 触发器的异步清零信号。</p>
<h3 id="case-语句">3.4.3. <code>case</code> 语句</h3>
<p><code>case</code>
语句的功能同正一类似，但是又有很大的不同。它后面也可以跟语句或语句组（<code>begin ... end</code>
或 <code>fork ... join</code>）。</p>
<p>如下例：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(sel <span class="keyword">or</span> a <span class="keyword">or</span> b <span class="keyword">or</span> c) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">case</span>(sel)</span><br><span class="line">        <span class="number">2'b00</span>: q = a;</span><br><span class="line">        <span class="number">2'b01</span>: q = b;</span><br><span class="line">        <span class="number">2'b10</span>: q = c;</span><br><span class="line">        <span class="keyword">default</span>: q = <span class="number">1'bx</span>；</span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<p>在 <code>case</code> 语句中，<code>default:</code>
一条描述了所有没有明确说明的其他可能情况。比如，这里的
<code>default</code> 就包含了 <code>sel</code> 为
<code>2'b11</code>、<code>2'bzz</code> 和 <code>2'bxx</code>
等情况。</p>
<p>以上的代码将实现如上的<a href="#fig.3-13">无锁存器的组合逻辑电路</a>。</p>
<p>与 <code>if ... else</code> 语句不同的是，在 <code>case</code>
语句中，所有被判断的分支条件都具有一样的优先级。</p>
<p>与 <code>if ... else</code>
类似的是，语句同样需要考虑所有可能的情况，否则将会产生不想要的锁存器。如果将代码改为：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(sel <span class="keyword">or</span> a <span class="keyword">or</span> b <span class="keyword">or</span> c) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">case</span>(sel)</span><br><span class="line">        <span class="number">2'b00</span>: q = a;</span><br><span class="line">        <span class="number">2'b01</span>: q = b;</span><br><span class="line">        <span class="number">2'b10</span>: q = c;</span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<p>这样，将会产生与如上的<a href="#fig.3-12">带锁存器的组合逻辑电路</a>。这是设计者不愿意看到的。</p>
<p>对于 <code>case</code> 语句，有两个派生语句，即 <code>casez</code> 及
<code>casex</code>。</p>
<p><code>casez</code> 语句将分支条件中所有的 <code>z</code>
看作“不关心”的值，而不看作任何逻辑值。条件中的 <code>z</code> 可以改写为
<code>?</code>，如下例：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">casez</span> (encoder)</span><br><span class="line">    <span class="number">4'b1</span>???: high_lvl = <span class="number">3</span>;</span><br><span class="line">    <span class="number">4'b01</span>??: high_lvl = <span class="number">2</span>;</span><br><span class="line">    <span class="number">4'b001</span>?: high_lvl = <span class="number">1</span>;</span><br><span class="line">    <span class="number">4'b0001</span>: high_lvl = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">default</span>: high_lvl = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">endcase</span></span><br></pre></td></tr></tbody></table></figure>
<p>这里，如果 <code>encoder</code> 为 <code>4b'1zzz</code> 则
<code>high_lvl</code> 取值为 3。</p>
<p><code>casex</code> 语句将分支条件中所有的 <code>x</code> 和
<code>z</code> 看作“不关心”的值，而不看作任何逻辑值。如下例：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">casex</span> (encoder)</span><br><span class="line">    <span class="number">4'b1xxx</span>: high_lvl = <span class="number">3</span>;</span><br><span class="line">    <span class="number">4'b01xx</span>: high_lvl = <span class="number">2</span>;</span><br><span class="line">    <span class="number">4'b001x</span>: high_lvl = <span class="number">1</span>;</span><br><span class="line">    <span class="number">4'b0001</span>: high_lvl = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">default</span>: high_lvl = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">endcase</span></span><br></pre></td></tr></tbody></table></figure>
<p>这里，如果 <code>encoder</code> 为 <code>4'b1xzx</code>，则
<code>high-lvl</code> 取值为 3。</p>
<h3 id="循环语句">3.4.4. 循环语句</h3>
<p>循环语句一般用于重复的操作。</p>
<p>循环语句后面可以跟语句或语句组（<code>begin ... end</code> 或
<code>fork ... join</code>)。</p>
<ol type="1">
<li><p><code>forever</code> 循环：永远执行</p>
<p></p><figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    clk = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">forever</span> #<span class="number">25</span> clk = ~clk;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure><p></p>
<p>以上语句产生了一个周期为 50 个时间单位的时钟。</p></li>
<li><p><code>repeat</code> 循环：执行固定的次数</p>
<p></p><figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (rotate == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">repeat</span> (<span class="number">8</span>)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        tmp = data[<span class="number">15</span>];</span><br><span class="line">        data = {data&lt;&lt;<span class="number">1</span>, temp};</span><br><span class="line">    <span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure><p></p>
<p>以上语句中，当 <code>rotate</code> 为 1 时，重复对 <code>data</code>
数据做 8 次循环左移。</p></li>
<li><p><code>while</code> 循环：当表达式为真时执行</p>
<p></p><figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (count &lt; <span class="number">101</span>) <span class="keyword">begin</span></span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">"Count = %d"</span>, count);</span><br><span class="line">        count = count + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure><p></p>
<p>在 <code>while</code>
语句中，只要后面的条件满足，就持续执行该语句，直到条件不满足，跳出循环。这里，将
<code>count</code> 从 0 递增到 101，逐步打印出来。</p></li>
<li><p><code>for</code> 循环：从初始值开始，如果表达式为真就执行</p>
<p></p><figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span> i;          <span class="comment">// 为 for 循环声明索引</span></span><br><span class="line"><span class="keyword">always</span> @(inp <span class="keyword">or</span> cnt) <span class="keyword">begin</span></span><br><span class="line">    result[<span class="number">7</span>:<span class="number">4</span>] = <span class="number">0</span>;</span><br><span class="line">    result[<span class="number">3</span>:<span class="number">0</span>] = inp;</span><br><span class="line">    <span class="keyword">if</span> (cnt == <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">4</span>; i &lt;= <span class="number">7</span>; i = i + <span class="number">1</span>)</span><br><span class="line">            result[i] = result[i-<span class="number">4</span>];</span><br><span class="line">        result[<span class="number">3</span>:<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure><p></p>
<p><code>for</code> 语句开始执行直到 <code>i</code> 大于
7，跳出循环。如上代码实现了一个位的左移器。</p></li>
</ol>
<p>简单介绍了 Verilog 中的高级编程语句，只要对 C
语言有一定基础，就能迅速掌握其中的用法。</p>
<h1 id="结构化描述">4. 结构化描述</h1>
<p>结构化描述就是在设计中<strong>实例化已有的功能模块</strong>，这些功能模块包括：门原语、用户自定义原语（UDP）、其他模块（module）。以下是结构化描述的
3 种实例类型：实例化其他模块、实例化门及实例化UDP。</p>
<p>下例是由两个半加器组成的全加器的模型，其中所有模块都采用了结构化描述方法。</p>
<figure class="highlight verilog"><figcaption><span>HalfAdd.v</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> HalfAdd(X, Y, sum, C_out);                   <span class="comment">// 半加器模块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> X;</span><br><span class="line"><span class="keyword">input</span> Y;</span><br><span class="line"><span class="keyword">output</span> sum;</span><br><span class="line"><span class="keyword">output</span> C_out;</span><br><span class="line"></span><br><span class="line"><span class="comment">// assign sum = X ^ Y;</span></span><br><span class="line"><span class="comment">// assign C_out = X &amp; Y;</span></span><br><span class="line"><span class="keyword">xor</span> u_xor(sum, X, Y);                               <span class="comment">// 门级原语实例</span></span><br><span class="line"><span class="keyword">and</span> u_and(C_out, X, Y);                             <span class="comment">// 门级原语实例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight verilog"><figcaption><span>FullAdd.v</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> FullAdd(X, Y, C_in, sum, C_out);             <span class="comment">// 全加器模块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> X;</span><br><span class="line"><span class="keyword">input</span> Y;</span><br><span class="line"><span class="keyword">input</span> C_in;</span><br><span class="line"><span class="keyword">output</span> sum;</span><br><span class="line"><span class="keyword">output</span> C_out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">wire</span> HalfAdd_A_sum;</span><br><span class="line"><span class="keyword">wire</span> HalfAdd_A_Cout;</span><br><span class="line"><span class="keyword">wire</span> HalfAdd_B_Cout;</span><br><span class="line"></span><br><span class="line"><span class="comment">// assign C_out = HalfAdd_A_Cout | HalfAdd_B_Cout;</span></span><br><span class="line"><span class="keyword">or</span> u_or(C_out, HalfAdd_A_Cout, HalfAdd_B_Cout);     <span class="comment">// 门级原语实例</span></span><br><span class="line"></span><br><span class="line">HalfAdd u_HalfAdd_A(                                <span class="comment">// 半加器实例 A</span></span><br><span class="line">    <span class="variable">.X</span>      (C_in),</span><br><span class="line">    <span class="variable">.Y</span>      (Y),</span><br><span class="line">    <span class="variable">.sum</span>    (HalfAdd_A_sum),</span><br><span class="line">    <span class="variable">.C_out</span>  (HalfAdd_A_Cout)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">HalfAdd u_HalfAdd_B(                                <span class="comment">// 半加器实例 B</span></span><br><span class="line">    <span class="variable">.X</span>      (C_in),</span><br><span class="line">    <span class="variable">.Y</span>      (HalfAdd_A_sum),</span><br><span class="line">    <span class="variable">.sum</span>    (sum),</span><br><span class="line">    <span class="variable">.C_out</span>  (HalfAdd_B_Cout)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></tbody></table></figure>
<p>上例已将<a href="#HalfAdder">原半加器代码</a>中的语句改为门原语的实例化。在全加器的模块中，有两个半加器模块的实例和一个
<code>or</code> 门原语的实例。</p>
<p>在以上代码中，实例化的 <code>or</code> 门原语是 Verilog
语言自带的电路，实例化的半加器模块则是用户自己设计的模块。</p>
<p>实现电路如<a href="#fig.3-15">图 3-15</a>。</p>
<p><a id="fig.3-15"></a></p>
<figure>
<img data-src="../images/post/2020-11-30-josh-verilog-part-3/2020-11-30-josh-verilog-part-3-150-FullAdder.png" width="800" alt="图 3-15 全加器">
<figcaption aria-hidden="true">图 3-15 全加器</figcaption>
</figure>
<p>以上内容提到了实例化基本门和其他模块。</p>
<p>关于
UDP，它是用户自定义的原语，由于应用不广泛，其功能基本上可以由模块替代，因此不再介绍。</p>
<h2 id="实例化模块的方法">4.1. 实例化模块的方法</h2>
<p>在结构化描述中，需要将模块实例与外部信号相连接。下面谈谈模块实例的端口连接规则。</p>
<p>先看一个模块内部输入/输出/双向端口的内部属性：</p>
<ul>
<li><strong><code>input</code>：在模块内部默认是一个线网类型；</strong></li>
<li><strong><code>output</code>：在模块内部是一个寄存器（在过程赋值语句中被赋值）或者线网类型；</strong></li>
<li><strong><code>inout</code>：在模块内部默认是一个线网类型，是双向信号，一般定义为
<code>tri</code>。</strong></li>
</ul>
<p>当这个模块被实例化时，与之相连的信号类型如下：</p>
<ul>
<li><strong>与模块 <code>input</code>
端口相连：可以是一个线网或者寄存器；</strong></li>
<li><strong>与模块 <code>output</code>
端口相连：一定是驱动到一个线网；</strong></li>
<li><strong>与模块 <code>inout</code>
端口相连：输入时从一个线网驱动来，输出时驱动到一个线网。</strong></li>
</ul>
<p>初学者经常犯这样一个错误，将寄存器变量驱动 <code>inout</code>
端口，导致编译出错。因为，只有线网类型可以驱动 <code>inout</code>
端口。</p>
<p><a href="#fig.3-16">图 3-16</a>
清楚地了模块端口在内部和外部的类型。</p>
<p><a id="fig.3-16"></a></p>
<figure>
<img data-src="../images/post/2020-11-30-josh-verilog-part-3/2020-11-30-josh-verilog-part-3-160-ModuleConnection.png" width="800" alt="图 3-16 模块实例端口连接规则">
<figcaption aria-hidden="true">图 3-16 模块实例端口连接规则</figcaption>
</figure>
<p>下面举例说明模块内部和外部的端口：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line">HalfAdd u_HalfAdd_A(                                <span class="comment">// 半加器实例 A</span></span><br><span class="line">    <span class="variable">.X</span>      (C_in),</span><br><span class="line">    <span class="variable">.Y</span>      (Y),</span><br><span class="line">    <span class="variable">.sum</span>    (HalfAdd_A_sum),</span><br><span class="line">    <span class="variable">.C_out</span>  (HalfAdd_A_Cout)</span><br><span class="line">    );</span><br></pre></td></tr></tbody></table></figure>
<p>点 <code>.</code> 后面紧跟的信号是 <code>HalfAdd</code>
内的端口名称，而括号中的信号是上一层 <code>FullAdd</code>
模块中的驱动源或被驱动信号。</p>
<p>模块实例的端口对应方式有以下两种：名称对应及位置对应。</p>
<ol type="1">
<li><p>名称对应</p>
<p>所谓名称对应是指：将模块实例外部的信号直接对应于模块的端口名称。在实例化
<code>HalfAdd</code> 时就是采用了名称对应的方法。</p>
<p>在这种端口对应方式下，<strong>端口对应的顺序可以是任意的</strong>。在没有对应外部信号的时候，可以将端口后面的括号留空。如下：</p>
<p></p><figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line">模块 实例名称(</span><br><span class="line">    .模块端口名称           (实例外部信号),</span><br><span class="line">    .模块端口名称           (实例外部信号),</span><br><span class="line">    .模块端口名称           (),             <span class="comment">//无对应信号</span></span><br><span class="line">    ...);</span><br></pre></td></tr></tbody></table></figure><p></p></li>
<li><p>位置对应</p>
<p>位置对应方式就是在模块实例化的时候外部的信号需要按照该模块端口声明的顺序一一对应。例如：</p>
<p></p><figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> HalfAdd(X, Y, sum, C_out);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></tbody></table></figure><p></p>
<p>在实例化该模块的时候，可以使用：</p>
<p></p><figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line">HaIfAdd u_HalfAdd(E_X, E_Y, E_sum, E_C_out);</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>其中 <code>E_X</code>、<code>E_Y</code>、<code>E_sum</code> 和
<code>E_C_out</code> 分别对应 <code>HalfAdd</code> 的端口
<code>X</code>、<code>Y</code>、<code>sum</code> 和
<code>C_out</code>，严格按照<code>HalfAdd</code>
模块的端口位置顺序。如果在没有对应外部信号的时候，就需要<strong>将位置留空</strong>。例如：</p>
<p></p><figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line">HaIfAdd u_HalfAdd(E_X, E_Y, , E_C_out);</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>其中 <code>E_X</code>、<code>E_Y</code> 和 <code>E_C_out</code>
分别对应 <code>HaIfAdd</code> 的端口 <code>X</code>、<code>Y</code> 和
<code>C_out</code>，模块端口 <code>sum</code>
没有对应的外部信号。</p></li>
</ol>
<h2 id="参数">4.2. 参数</h2>
<p>在本小节中将讨论可参数化的模块。</p>
<h3 id="参数定义">4.2.1. 参数定义</h3>
<p><code>module</code> 中的参数一般是定义其中常量的工具。</p>
<p>如下的代码中定义了半加器的“与门”和“异或门”的延时分别为 2 和 4
个时间单位：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> half_adder(co, sum, a, b)</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> a, b;</span><br><span class="line"><span class="keyword">output</span> co, sum;</span><br><span class="line"></span><br><span class="line"><span class="keyword">parameter</span> and_delay = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">parameter</span> xor_delay = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">and</span> #and_delay u1(co, a, b);</span><br><span class="line"><span class="keyword">xor</span> #xor_delay u2(sum, a, b);</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></tbody></table></figure>
<p>实际上，在 Verilog
语言中，<strong>当实例化模块时用户可以修改模块中的参数</strong>，用来实现不同的特性。这个定制过程是通过“新参数直接带入”或“参数重定义”完成的。</p>
<p>Verilog
模块参数的这一特性非常有用，用户可以定义一个通用的模块，其具有缺省的参数值，然后通过改变参数来做成不同的实例模块。</p>
<p>例如，可以设计一个通用的 RAM
模块，将其位宽和地址深度定义为参数。在具体使用时，如果需要用到不同的位宽和深度，用户则可以通过改变模块中的参数实现。</p>
<h3 id="参数的定制">4.2.2. 参数的定制</h3>
<p>参数的用户定制有两种方法：</p>
<ol type="1">
<li>通过 <code>defparam</code> 关键字对模块中的参数重新定义；</li>
<li>参数直接在实例化模块时代入。</li>
</ol>
<p>有意思的是，两家最大的 PLD 供应商 Altera 和 Xilinx
的通用模块定制恰好分别采用了这两种方法。</p>
<ul>
<li><p>比如 Altera 的 Quartus II 开发环境中，用 MegaWiard 工具定制一个宽
8 深 32 位的单口 RAM 时，将产生如下的代码：</p>
<p></p><figure class="highlight verilog"><figcaption><span>ran_w8_d32.v</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> ran_w8_d32(address, clock, data, wren, q);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> [<span class="number">4</span>:<span class="number">0</span>] address;</span><br><span class="line"><span class="keyword">input</span>       clock;</span><br><span class="line"><span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] data;</span><br><span class="line"><span class="keyword">input</span>       wren;</span><br><span class="line"><span class="keyword">output</span>      q;</span><br><span class="line"></span><br><span class="line">altsyncram altsyncram_component(</span><br><span class="line">    <span class="variable">.wren_a</span>        (wren),</span><br><span class="line">    <span class="variable">.clock0</span>        (clock),</span><br><span class="line">    <span class="variable">.address_a</span>     (address),</span><br><span class="line">    <span class="variable">.data_a</span>        (data),</span><br><span class="line">    <span class="variable">.q_a</span>           (q),</span><br><span class="line">    <span class="variable">.aclr0</span>         (<span class="number">1'b0</span>),</span><br><span class="line">    <span class="variable">.aclr1</span>         (<span class="number">1'b0</span>),</span><br><span class="line">    <span class="variable">.q_b</span>           (),</span><br><span class="line">    <span class="variable">.clocken1</span>      (<span class="number">1'b1</span>),</span><br><span class="line">    <span class="variable">.clocken0</span>      (<span class="number">1'b0</span>),</span><br><span class="line">    <span class="variable">.data_b</span>        (<span class="number">1'b1</span>),</span><br><span class="line">    <span class="variable">.rden_b</span>        (<span class="number">1'b1</span>),</span><br><span class="line">    <span class="variable">.address_b</span>     (<span class="number">1'b1</span>),</span><br><span class="line">    <span class="variable">.wren_b</span>        (<span class="number">1'b0</span>),</span><br><span class="line">    <span class="variable">.byteena_b</span>     (<span class="number">1'b0</span>),</span><br><span class="line">    <span class="variable">.addressstall_a</span>(<span class="number">1'b0</span>),</span><br><span class="line">    <span class="variable">.byteena_a</span>     (<span class="number">1'b1</span>),</span><br><span class="line">    <span class="variable">.addressstall_b</span>(<span class="number">1'b0</span>),</span><br><span class="line">    <span class="variable">.clocken1</span>      (<span class="number">1'b1</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"><span class="keyword">defparam</span></span><br><span class="line">    altsyncram_component<span class="variable">.clock_enable_input_a</span> = <span class="string">"BYPASS"</span>,</span><br><span class="line">    altsyncram_component<span class="variable">.clock_enable_output_a</span> = <span class="string">"BYPASS"</span>,</span><br><span class="line">    altsyncram_component<span class="variable">.intended_device_family</span> = <span class="string">"Stratix II"</span>,</span><br><span class="line">    altsyncram_component<span class="variable">.lpm_hint</span> = <span class="string">"ENABLE_RUNTIME_MOD = NO"</span>,</span><br><span class="line">    altsyncram_component<span class="variable">.lpm_type</span> = <span class="string">"altsyncram"</span>,</span><br><span class="line">    altsyncram_component<span class="variable">.numwords_a</span> = <span class="number">32</span>,               <span class="comment">// 32 个字</span></span><br><span class="line">    altsyncram_component<span class="variable">.operation_mode</span> = <span class="string">"SINGLE_PORT"</span>,</span><br><span class="line">    altsyncram_component<span class="variable">.outdata_aclr_a</span> = <span class="string">"NONE"</span>,</span><br><span class="line">    altsyncram_component<span class="variable">.outdata_reg_a</span> = <span class="string">"UNREGISTERED"</span>,</span><br><span class="line">    altsyncram_component<span class="variable">.power_up_uninitialized</span> = <span class="string">"FALSE"</span>,</span><br><span class="line">    altsyncram_component<span class="variable">.ram_block_type</span> = <span class="string">"M4K"</span>,</span><br><span class="line">    altsyncram_component<span class="variable">.widthad_a</span> = <span class="number">5</span>,                 <span class="comment">// 5 位地址</span></span><br><span class="line">    altsyncram_component<span class="variable">.width_a</span> = <span class="number">8</span>,                   <span class="comment">// 8 位宽的数据</span></span><br><span class="line">    altsyncram_component<span class="variable">.width_byteena_a</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></tbody></table></figure><p></p>
<p>其中，<code>altsyncram</code> 是 Altera 的块 RAM 的通用模型。它可以在
Altera 的仿真文件“alteramf.v”中找到。</p>
<p><code>altsyncram-component</code> 是实例名称，<code>.</code>
后面是参数的名称，定义的参数值，有的是字符串，有的是整数。</p>
<p>在 <code>defparam</code> 关键字后面的是参数重定义的语句：</p>
<p></p><figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line">altsyncram_component<span class="variable">.width_a</span> = <span class="number">8</span>,               <span class="comment">// 8 位宽的数据</span></span><br></pre></td></tr></tbody></table></figure><p></p>
<p>以上就是将 <code>altsyncram-component</code> 中的参数
<code>width_a</code> 重新定义为 8。</p>
<p>使用 <code>defparam</code>
的方法重新定义参数时，可以根据需要对部分的参数重新定义，其他的会保留模块的缺省值。</p></li>
<li><p>用 Xilinx 设计工具 ISE 中的 CORE Generator 产生一个单端口 8
位宽、32 位深的 RAM。注意观察，其中RAM的参数是如何带入的：</p>
<p></p><figure class="highlight verilog"><figcaption><span>ram_w8_d32.v</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> ram_w8_d32(addr, clk, din, dout, we)</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> [<span class="number">4</span>:O] addr;</span><br><span class="line"><span class="keyword">input</span>       clk;</span><br><span class="line"><span class="keyword">input</span> [<span class="number">7</span>:O] din.</span><br><span class="line"><span class="keyword">output</span> [<span class="number">7</span>:<span class="number">0</span>] dout;</span><br><span class="line"><span class="keyword">input</span> we;</span><br><span class="line"></span><br><span class="line"><span class="comment">// synopsys translate_off</span></span><br><span class="line">BLKMEMSP_V6_1 #(</span><br><span class="line">    <span class="number">5</span>,                  <span class="comment">// c_addr_width</span></span><br><span class="line">    <span class="string">"0"</span>,                <span class="comment">// c_default_data</span></span><br><span class="line">    <span class="number">32</span>,                 <span class="comment">// c_depth</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">// c_enable_rlocs</span></span><br><span class="line">    <span class="number">1</span>,                  <span class="comment">// c_has_default_data</span></span><br><span class="line">    <span class="number">1</span>,                  <span class="comment">// c_has_din</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">// c_has_en</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">// c_has_limit_data_pitch</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">// c_has_nd</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">// c_has_rdy</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">// c_has_rfd</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">// c_has_sinit</span></span><br><span class="line">    <span class="number">1</span>,                  <span class="comment">// c_has_we</span></span><br><span class="line">    <span class="number">18</span>,                 <span class="comment">// c_limit_data_pitch</span></span><br><span class="line">    <span class="string">"mif_file_16_1"</span>,    <span class="comment">// c_em_init_file</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">// c_pipe_stages</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">// c_reg_inputs</span></span><br><span class="line">    <span class="string">"0"</span>,                <span class="comment">// c_sinit_value</span></span><br><span class="line">    <span class="number">8</span>,                  <span class="comment">// c_width</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">// c_write_mode</span></span><br><span class="line">    <span class="string">"0"</span>,                <span class="comment">// c_ybottom_addr</span></span><br><span class="line">    <span class="number">1</span>,                  <span class="comment">// c_yclk_is_rising</span></span><br><span class="line">    <span class="number">1</span>,                  <span class="comment">// c_yen_is_high</span></span><br><span class="line">    <span class="string">"hierarchy1"</span>,       <span class="comment">// c_hierarchy</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">// c_ymake_bmm</span></span><br><span class="line">    <span class="string">"32kx1"</span>,            <span class="comment">// c_yprimitive_type</span></span><br><span class="line">    <span class="number">1</span>,                  <span class="comment">// c_ysinit_is_high</span></span><br><span class="line">    <span class="string">"1024"</span>,             <span class="comment">// c_ytop_addr</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">// c_yuse_single_primitive</span></span><br><span class="line">    <span class="number">1</span>,                  <span class="comment">// c_ywe_is_high</span></span><br><span class="line">    <span class="number">1</span>                   <span class="comment">// c_yydisable_warnings</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">inst(</span><br><span class="line">    <span class="variable">.ADDR</span> (addr),</span><br><span class="line">    <span class="variable">.CLK</span>  (clk),</span><br><span class="line">    <span class="variable">.DIN</span>  (din),</span><br><span class="line">    <span class="variable">.DOUT</span> (dout),</span><br><span class="line">    <span class="variable">.WE</span>   (we),</span><br><span class="line">    <span class="variable">.EN</span>   (),</span><br><span class="line">    <span class="variable">.ND</span>   (),</span><br><span class="line">    <span class="variable">.RFD</span>  (),</span><br><span class="line">    <span class="variable">.RDY</span>  (),</span><br><span class="line">    <span class="variable">.SINIT</span>()</span><br><span class="line">    );</span><br><span class="line"><span class="comment">// synopsys translate_on</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></tbody></table></figure><p></p>
<p>其中 <code>BLKMEMSP_V6_1</code> 是 Xilinx
的块状RAM的通用模型。<code>inst</code>
是用户实例名称。用户需要在通用RAM类型的基础上，通过参数带入实现。采用
<code>#(...)</code> 方法来实现参数逐个覆盖。</p>
<p>使用上面这种参数直接带入法时，要注意一点，所有的参数都需要全部按顺序列出来，不能遗漏，也不能颠倒顺序，否则就容易对应不上。</p></li>
</ul>
<h1 id="设计层次">5. 设计层次<a id="toc.5"></a></h1>
<p>在前面几节中，介绍了 Verilog 的描述方式。</p>
<p>Verilog
语言是一种强大的硬件描述语言，可以支持多个设计层次。在这里将进行简单的介绍。</p>
<h2 id="系统级和行为级">5.1. 系统级和行为级<a id="toc.5.1"></a></h2>
<p>Verilog
语言作为一种用户工具，提供给用户许多描述硬件的手段，如前面所述：数据流描述、行为描述（<code>always</code>
和 <code>initial</code>
语句）、结构化描述。同时，不同用户可以根据自己的需要，在不同抽象层次上对硬件进行描述。有如下设计层次金字塔供参考。</p>
<p><a id="fig.3-17"></a></p>
<figure>
<img data-src="../images/post/2020-11-30-josh-verilog-part-3/2020-11-30-josh-verilog-part-3-170-DesignLevelPyramid.png" width="600" alt="图 3-17 设计层次金字塔">
<figcaption aria-hidden="true">图 3-17 设计层次金字塔</figcaption>
</figure>
<p>下面简单介绍几种不同角色的工作特点，以及它们所处的设计层次：</p>
<ol type="1">
<li><p>系统构架师：在目前业界主流的设计方法学中，系统构架师（System
Architect）通常用高级语言，如
SystemC，来描述一个系统的规格，仿真整个系统的功能和性能等。这种早期的设计和探索往往不涉及到具体的实现细节，甚至于软件和硬件的划分都没有开始。系统构架师也可以采用
Verilog
来描述系统的功能，它们往往不考虑硬件实现的细节。因而称这种设计层次为系统级或算法级。</p></li>
<li><p>逻辑设计工程师：他们利用前面所讲的 Verilog 各种描述手段，设计 RTL
级的代码，精确到时钟周期。逻辑设计工程师的代码，通过综合工具的综合，可以转换为
Verilog 的门级网表，其中所有的功能块都是由基本的门单元组成的。</p></li>
<li><p>物理设计工程师：他们将这些门级网表进行布局和布线，做成实际的芯片。</p></li>
<li><p>验证工程师：他们负责对设计的电路进行验证，他们编写的代码主要是用来产生激励，这些激励大部分需要的抽象层次更高，以使仿真的效率更高。然后在工具中对电路进行仿真，检查响应结果。这些代码不会实现为具体癭件，有些并不需要精确到时钟周期，而只是在软件的仿真工具中运行，实现一定的功能即可，称这种描述层次为行为级。</p></li>
</ol>
<p>这里的行为级描述，不同于 <a href="#toc.3">3.
行为描述</a>中所述的“行为描述方式”。这里特指一种描述的抽象层次。</p>
<p>下面举一个实例说明 RTL 级和行为级的区别，要实现的状态机一部分如<a href="#fig.3-18">图 3-18</a> 所示。=</p>
<p><a id="fig.3-18"></a></p>
<figure>
<img data-src="../images/post/2020-11-30-josh-verilog-part-3/2020-11-30-josh-verilog-part-3-180-ASimpleHandshakingStateMachine.png" width="500" alt="一个简单的握手协议状态机">
<figcaption aria-hidden="true">一个简单的握手协议状态机</figcaption>
</figure>
<p>上图中只有两个状态，当在左边的状态时，<code>REQ</code> 输出
1；当在右边的状态时，<code>REQ</code> 输出 0。<code>ACK</code>
是状态机的输入信号，决定了状态的跳转。</p>
<p>如果是让一个 RTL
设计工程师来设计，他马上就会与硬件实现的细节联系起来，很可能就会用如下代码实现：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/************************</span></span><br><span class="line"><span class="comment">RTL 描述</span></span><br><span class="line"><span class="comment">************************/</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>] curr_sm;</span><br><span class="line"><span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>] next_sm;              <span class="comment">// 定义状态寄存器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">parameter</span> ...;</span><br><span class="line">state0 = <span class="number">2'b01</span>;</span><br><span class="line">state1 = <span class="number">2'b10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// state registers</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">posedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (rst)</span><br><span class="line">        curr_sm &lt;= ...;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        curr_sm &lt;= next_sm;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// next state logic</span></span><br><span class="line"><span class="keyword">always</span> @(curr_sm <span class="keyword">or</span> ACK) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">case</span>(curr_sm)</span><br><span class="line">        ...</span><br><span class="line">        state0: <span class="keyword">begin</span></span><br><span class="line">            REQ = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (ACK == <span class="number">1</span>)</span><br><span class="line">                next_sm = state1;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                next_sm = state0;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        state1: <span class="keyword">begin</span></span><br><span class="line">            REQ = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (ACK == <span class="number">0</span>)</span><br><span class="line">                next_sm = ...;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                next_sm = state1;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<p>然而，如果让一个逻辑验证工程师来设计这个状态机，他不考虑硬件实现的细节，只需要在语义上满足要求即可。甚至可以不出现状态寄存器。如下例：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/************************</span></span><br><span class="line"><span class="comment">行为描述</span></span><br><span class="line"><span class="comment">************************/</span></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    REQ = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">wait</span> (ACK == <span class="number">1</span>);</span><br><span class="line">    REQ = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">wait</span> (ACK == <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<p>从上例中可以看出，逻辑验证工程师设计的方式十分简单，仅仅利用了
<code>begin ... end</code> 语句组的顺序执行特性，同时利用
<code>wait</code>
语句来实现状态的转移。这是典型的行为级设计风格，也是逻辑验证工程师们所追求的思维方式。</p>
<h2 id="rtl-级">5.2. RTL 级</h2>
<p>所谓寄存器传输级（RTL级），就是描述电路的时候，只需要关注寄存器本身，以及寄存器到寄存器之间的逻辑功能，而不用关心寄存器和组合逻辑的实现细节（具体用了多少逻辑门等）。</p>
<p>随着逻辑综合工具的兴起，工程师才可以从 RTL
级进行电路设计了，而不需要像传统设计方法一样从门级电路搭起。它们的 RTL
设计代码将直接通过逻辑综合工具，综合成门级的设计网表，通常是由基本的门单元组成的。逻辑综合是
EDA 流程的重要组成部分。</p>
<p>Verilog 设计电路最常用的设计层次就是 RTL 级。在 RTL
描述时，设计者需要关注寄存器的行为，其中保存着数据；同时需要关注寄存器和寄存器之间的组合逻辑功能，是否能满足功能需求和时序需求。RTL
级模型是严格精确到时钟周期的模型。</p>
<p><a href="https://josh-gao.top/posts/ecb88422.html">Part 4 —— RTL
概念与常用 RTL 建模</a>、<a href="https://josh-gao.top/posts/53b8b42e.html">Part 5 —— RTL
设计与编码指导</a>和<a href="https://josh-gao.top/posts/d860a67e.html">Part 6——
如何写好状态机</a>会重点介绍 RTL 设计的方法和技巧。</p>
<div class="note info"><p>RTL 级是 HDL 语言最重要的概念之一，RTL
级是综合器最常用的设计输入层次。目前使用 FPGA/CPLD
等可编程逻辑器件时，设计输入都为 RTL
级。这是因为门级输入过于繁琐；而对于行为级和系统级设计输入，很多综合器不支持，并容易产生综合歧义。</p>
</div>
<h2 id="门级">5.3. 门级</h2>
<p>在 Verilog
语义中，使用一些基本的门原语可以直接描述电路的门级功能。例如：</p>
<figure class="highlight verilog"><figcaption><span>HalfAdd.v</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> HalfAdd(X, Y, sum, C_out);                   <span class="comment">// 半加器模块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> X;</span><br><span class="line"><span class="keyword">input</span> Y;</span><br><span class="line"><span class="keyword">output</span> sum;</span><br><span class="line"><span class="keyword">output</span> C_out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">xor</span> u_xor(sum, X, Y);                               <span class="comment">// 门级原语实例</span></span><br><span class="line"><span class="keyword">and</span> u_and(C_out, X, Y);                             <span class="comment">// 门级原语实例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></tbody></table></figure>
<p>其中直接调用了 <code>xor</code> 和 <code>and</code> 的两个 Verilog
门原语。</p>
<p>门级设计就是指在逻辑门一级将电路搭出来。特别是对于大设计来说，这种设计非常耗时、效率低下，同时容易出错。但是对于一些逻辑容量较小，性能和面积要求非常高的设计，有时还采用门级设计，以满足一些特殊的需求。</p>
<p>门级设计类似于软件中的汇编语言设计，非常精确，但是耗时耗力。</p>
<h2 id="晶体管级">5.4. 晶体管级</h2>
<p>逻辑门是由一个个晶体管组成的。在 Verilog 语言中，有用于直接描述 NMOS
和 PMOS 的原语。这里不过多叙述，有兴趣可查阅相关资料。</p>
<h2 id="混合描述">5.5. 混合描述</h2>
<p>Verilog 支持不同设计层次的混描述。</p>
<p>实际上，这些描述层次之间没有严格的界限。这里只是想将概念描述清楚，这一点对初学者非常重要。</p>
<h1 id="参考文献">参考文献</h1>
<p>EDA 先锋工作室. <em>轻松成为设计高手——Verilog HDL 实用精解.</em>
北京航空航天大学出版社, 2012.</p>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/css/markmap.css">

<script src="/js/markmap.js"></script>
]]></content>
      <categories>
        <category>Josh 的学习笔记</category>
        <category>Verilog</category>
      </categories>
      <tags>
        <tag>Verilog</tag>
        <tag>HDL</tag>
        <tag>Verilog 语法</tag>
        <tag>描述方式</tag>
        <tag>设计层次</tag>
      </tags>
  </entry>
  <entry>
    <title>Lost - Cher Lloyd</title>
    <url>/posts/8cb867fe.html</url>
    <content><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="420" height="86" src="//music.163.com/outchain/player?type=2&amp;id=1443007197&amp;auto=0&amp;height=66">
</iframe>
<table>
<colgroup>
<col style="width: 22%">
<col style="width: 77%">
</colgroup>
<thead>
<tr>
<th style="text-align: center;"></th>
<th style="text-align: center;">“Lost”</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">Cover</td>
<td style="text-align: center;"><img data-src="../images/post/Album%20Cover/Cher%20Lloyd/Cher%20Lloyd-Lost-Cover.jpg" width="300px/"></td>
</tr>
<tr>
<td style="text-align: center;">Singer</td>
<td style="text-align: center;">Cher Lloyd</td>
</tr>
<tr>
<td style="text-align: center;">Album Type</td>
<td style="text-align: center;">Single</td>
</tr>
<tr>
<td style="text-align: center;">Released</td>
<td style="text-align: center;">24 April 2020</td>
</tr>
<tr>
<td style="text-align: center;">Length</td>
<td style="text-align: center;">2:55</td>
</tr>
<tr>
<td style="text-align: center;">Label</td>
<td style="text-align: center;">Universal, Polydor</td>
</tr>
<tr>
<td style="text-align: center;">Songwriter(s)</td>
<td style="text-align: center;">Raphaella, Casey Smith, Patrick
Jordan-Patrikios, Boy Matthews, Youthonix, Cher Lloyd</td>
</tr>
<tr>
<td style="text-align: center;">Producer(s)</td>
<td style="text-align: center;">Hitimpulse</td>
</tr>
</tbody>
</table>
<span id="more"></span>
<p>“Lost” is a song by English singer Cher Lloyd from her upcoming third
studio album. Released on April 24, 2020,<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>
under Universal Music Group, the song is the second single released off
of Lloyd’s upcoming album, following “M.I.A” in 2019.<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> An
accompanying video directed by Raja Virdi was released on April 24.<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> Writing for The Guardian, Leonie
Cooper said: “There is something heartening about this largely harmless
return.”<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a></p>
<h1 id="background-and-production">Background and production</h1>
<p>After releasing her album Sorry I’m Late in 2014, Lloyd went on a
musical hiatus before releasing several songs between 2016 and 2019.
After signing a new record deal with Polydor Records &amp; Universal
Music Germany, she released “None of My Business” in 2018 and “M.I.A” in
2019. 2020 brought “Lost” which was teased for a week before being
released in April.<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a></p>
<p>The song was written by Raphaella, Casey Smith, Patrick
Jordan-Patrikios, Boy Matthews, Youthonix &amp; Cher Lloyd while it was
mixed and mastered by Lex Barkey. Hitimpulse produced the song and have
been consistent collaborators with Cher doing production on 2018’s “None
Of My Business” and additional production on 2019’s “M.I.A”.<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a></p>
<h1 id="critical-reception">Critical Reception</h1>
<p>Mike Wass of Idolator called the song a “cute bop” stating “Cher
Lloyd returns with a fiery kiss-off anthem called ‘Lost’, which is the
musical equivalent of posturing on social media so your ex can see how
amazing your life is.”<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a> While Pip Williams writing for The
Line Of Best Fit stated “Lost” is far and away the strongest release of
Lloyd’s career to date, blowing those who still reference “Swagger
Jagger” as a career high out of the water. The new cut sees Lloyd
embrace languid balladry as a vehicle for a surprisingly hard-hitting
lyric. It’s still slickly produced and radio-friendly, but there’s a
heart and soul to it that many mainstream stars would struggle to
match.”<a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a></p>
<h1 id="music-video">Music video</h1>
<p>The official video to the single premiered on YouTube the day of
release. The video was shot in a single take with no cuts or edits made,
depicting Lloyd on a bed with neon and pastel lights changing behind her
as she sings. Lloyd commented in an Instagram Livestream that the
lighting was the most difficult aspect of filming the video. The video
was produced by Phase Films and directed by frequent collaborator Raja
Virdi who worked on her previous single “M.I.A”.<a href="#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a></p>
<div data-align="center">
<p><iframe width="560" height="315" src="https://www.youtube.com/embed/DDw1aCfaUxI" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></p>
</div>
<h1 id="lyrics">Lyrics</h1>
<p><font size="3" face="Comic Sans MS, Comic Sans, cursive"> [Verse
1]<br> I heard from a friend of a friend<br> That you’ve been checking
back in, Mhm-mhm<br> ’Cause I said goodbye, moved overnight<br> And you
haven’t heard much since then<br> Wondering how I’m doing now<br> <br>
[Pre-Chorus]<br> It’s none of your business, first of all<br> Wondering
how I’m doing now<br> But if you’ve got to know, well sure<br> Well
sure<br> <br> [Chorus]<br> You think I’d be lost<br> Think I’d be lost
without you, lost<br> Is it hard knowing you’re wrong?<br> See I got
lots without you, lots without you<br> <br> [Post-Chorus]<br> Great sex
in the morning, sex in the morning, someone to hold me<br> I got
lo-oh-oh-oh-oh, lots<br> Stay out in the nighttime, out in the
nighttime, have me a wild time<br> I got lo-oh-oh-oh-oh, lots<br> <br>
[Verse 2]<br> You heard from a friend of a friend<br> That I’ve been
doing just fine, I-I<br> You don’t want me, you just want me<br> To keep
wanting you all of the time<br> But if you were wondering<br> <br> <br>
[Pre-Chorus]<br> It’s none of your business first of all<br> Wondering
how I’m doing now<br> But if you’ve got to know, well sure<br> Well
sure<br> <br> [Chorus]<br> You think I’d be lost<br> Think I’d be lost
without you, lost<br> Is it hard knowing you’re wrong?<br> See I got
lots without you, lots without you<br> <br> [Post-Chorus]<br> Great sex
in the morning, sex in the morning, someone to hold me<br> I got
lo-oh-oh-oh-oh, lots (Yeah)<br> Stay out in the nighttime, out in the
nighttime, have me a wild time<br> I got lo-oh-oh-oh-oh, lots<br> <br>
[Bridge]<br> To be honest, I think I dodged a bullet with you<br> And I
don’t know how I didn’t see it coming, but ooh<br> <br> [Verse 3]<br>
Yeah, you got a God complex<br> Now I’m thanking God you’re my ex<br> I
hope you don’t trip up on yourself<br> If you think you’re so hot, go
back to hell (Go back to hell)<br> ’Cause you think that I’d…<br> <br>
<br> [Chorus]<br> You think I’d be lost (Be lost, be lost)<br> Think I’d
be lost without you, lost<br> Is it hard knowing you’re wrong? (Knowing
you’re wrong)<br> See I got lots without you, lots without you<br> <br>
[Post-Chorus]<br> Great sex in the morning, sex in the morning, someone
to hold me<br> I got lo-oh-oh-oh-oh, lots (Yeah)<br> Stay out in the
nighttime, out in the nighttime, have me a wild time<br> I got
lo-oh-oh-oh-oh, lots<br> <br> [Outro]<br> La-la-la-la-la-la-la-la-la<br>
La-la-la-la-la-la-la-la-la </font></p>
<h1 id="reference">Reference</h1>
<ul>
<li><p><a href="https://en.wikipedia.org/wiki/Lost_(Cher_Lloyd_song)">“Lost (Cher
Lloyd song)”</a>. Retrieved November 15, 2020.</p></li>
<li><p><a href="https://genius.com/Cher-lloyd-lost-lyrics">Cher Lloyd
Lost Lyrics</a>. Retrieved November 15, 2020.</p></li>
</ul>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr>
<ol>
<li id="fn1"><p><a href="https://www.instagram.com/p/B_WvduVnFKg/">“Cher
Lloyd on Instagram:”My new single LOST is OUT NOW!!!! Head to the link
in my bio to listen / download / share!! The official video will be
premiered at 5pm uk…“”</a>. Instagram. Retrieved August 27, 2020.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p><a href="https://www.billboard.com/articles/columns/pop/8532778/cher-lloyd-mia">“Cher
Lloyd Returns With ‘M.I.A.,’ an Anthem For Your Post-Party Plans -
Billboard”</a>. Retrieved September 25, 2020.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p><a href="https://www.youtube.com/watch?v=DDw1aCfaUxI">“Cher Lloyd - Lost
(Official Music Video) - YouTube”</a>. <em>www.youtube.com</em>.
Retrieved September 24, 2020.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p><a href="https://www.theguardian.com/music/2020/may/08/katy-j-pearson-track-of-week">“Tracks
of the week reviewed: Katy J Pearson, Cher Lloyd, the 1975 - The
Guardian”</a>. Retrieved September 25, 2020.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p><a href="https://www.instagram.com/p/B-95yOQnXXR/?utm_source=ig_web_copy_link">“Cher
Lloyd teases ‘Lost’”</a>. Retrieved September 25, 2020.<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><p><a href="https://open.spotify.com/playlist/5lhDKO2VX6QzjO1RFoHKZT?si=LfBWWAIWTUm5Vc2igV5yWg">“Hitimpulse
Official Spotify Playlist of songs produced/written by them”</a>.
Retrieved September 25, 2020.<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7"><p><a href="https://www.idolator.com/7909784/cher-lloyd-sizzles-in-one-take-lost-video?view-all">“Cher
Lloyd Sizzles in one take ‘Lost’ video”</a>. Retrieved September 25,
2020.<a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8"><p><a href="https://www.thelineofbestfit.com/features/interviews/cher-lloyd-is-bigger-than-the-bullshit">“Cher
Lloyd is bigger than the bullshit - The Line Of Best Fit”</a>. Retrieved
September 25, 2020.<a href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn9"><p><a href="https://rajavirdi.com/promos">“Raja Virdi Music
Videos”</a>. Retrieved September 25, 2020.<a href="#fnref9" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/css/markmap.css">

<script src="/js/markmap.js"></script>
]]></content>
      <categories>
        <category>Music</category>
        <category>Cher Lloyd</category>
      </categories>
      <tags>
        <tag>Cher Lloyd</tag>
        <tag>Music</tag>
        <tag>2020</tag>
        <tag>Pop</tag>
      </tags>
  </entry>
  <entry>
    <title>Josh&#39;s Note — Verilog&lt;br&gt;Part 5 RTL 设计与编码指导</title>
    <url>/posts/53b8b42e.html</url>
    <content><![CDATA[<h1 id="一般性指导原则">1. 一般性指导原则</h1>
<p>RTL
级设计的评判标准有很多，如时序性能、所占面积、可测试性、可重要性、功耗、时钟域的分配、复位信号设计、是否与所用
EDA 工具匹配等。如果设计目标是在 FPGA 或 CPLD
等可编程逻辑器件上实现，则还需考虑是否能发挥这些 PLD
的结构特点等。根据以上所述这些目标的组合和优先级可以派生出很多不同的设计原则。这里仅仅讨论一般意义的指导原则。</p>
<p>这里抛砖引玉地提出 4
个基本设计原则，这些指导原则范畴非常广，不仅仅是要学习它们，更重要的是理解，并在今后的工作实践中充实、完善。</p>
<ol type="1">
<li><p><strong>面积和速度的平衡与互换原则</strong></p>
<p>面积和速度的平衡与互换原则提出了 RTL
设计的两个基本目标，并探讨了这两个目标对立统一的矛盾关系。</p></li>
<li><p><strong>硬件原则</strong></p>
<p>硬件原则重点在于转化软件设计的思路，理解 HDL
语言设计的本质。</p></li>
<li><p><strong>系统原则</strong></p>
<p>系统原则希望能够通过全局、整体上把握设计，从而提高设计质址，优化设计效果。</p></li>
<li><p><strong>同步设计原则</strong></p>
<p>同步设计原则是设计时序稳定的基本要求，也是高速 RTL
设计的通用法则。</p></li>
</ol>
<span id="more"></span>
<h2 id="面积和速度的平衡与互换原则">1.1. 面积和速度的平衡与互换原则</h2>
<p>这里“面积”是指一个设计所消耗的目标器件（如 FPGA/CPLD/ASIC
等）的硬件资源数量：</p>
<ul>
<li>对于 FPGA，可以用所消耗的触发器（FF）和查找表（LUT）来衡量；</li>
<li>对于 CPLD，常用宏单元（MC）衡量；</li>
<li>对于 ASIC 可以用设计的系统门衡量。</li>
</ul>
<p>“速度”指设计在芯片上稳定运行时所能够达到的最高频率，这个频率由设计的时序状况决定，与设计满足的时钟周期、PAD
to PAD Time、Clock Setup Time、Clock Hold Time 和 Clock-to-Output Delay
等众多时序特征量密切相关。</p>
<div class="note info"><p>面积（Area）和速度（Speed）这两个指标贯穿着 RTL
设计的始终，是设计质量评价的终极标准。</p>
</div>
<p>这里就讨论一下设计中关于面积和速度的基本原则：<mark class="label primary">面积和速度的平衡与互换</mark>。</p>
<p>面积和速度是一对对立统一的矛盾体。要求一个设计同时具备设计面积最小，运行频率最高，这是不现实的。科学的设计目标应该是：</p>
<ul>
<li>在满足设计时序要求（包含对设计最高频率的要求）的前提下，占用最小的芯片面积；</li>
<li>或者在所规定的面积下，使设计的时序余量更大、频率更高。</li>
</ul>
<p>这两种目标充分体现了面积和速度的平衡思想。关于面积和速度的要求，不应该简单地理解为工程师水平的提高和设计完美性的追求，而应该认识到它们是和产品的质量、成本直接相关的。</p>
<ul>
<li><strong>如果设计的时序余量比较大，运行的频率比较高，则意味着设计的健壮性更强，整个系统的质量更有保证；</strong></li>
<li><strong>另一方面，设计所消耗的面积更小，则意味着在单位芯片上实现的功能模块更多，需要的芯片数量更少，整个系统的成本也随之大幅度削减。</strong></li>
</ul>
<p>作为矛盾的两个组成部分，面积和速度的地位是不一样的。相比之下，满足时序、工作频率的要求更重要一些，当两者冲突时，采用<strong>速度优先</strong>的准则。</p>
<p>面积和速度的互换是 RTL
设计的一个重要思想。从理论上讲，一个设计如果时序余量较大，所能跑的频率远远高于设计要求，那么就能通过功能模块复用减少整个设计消耗的芯片面积，这就是<strong>用速度的优势换面积的节约</strong>；反之，如果一个设计的时序要求很高，普通方法达不到设计频率，那么一般可以通过将数据流串/并转换，并行复制多个操作模块，对整个设计采取“乒乓操作”和“串/并转换”的思想进行处理，在芯片输出模块处再对数据进行“并/串转换”。从宏观上看，整个芯片满足了处理速度的要求，这相当于<strong>用面积复制换取速度的提高</strong>。面积和速度互换的具体操技巧很多，比如模块复用、“乒乓操作”、“串/并转换”等，需要在工作中不断积累。下面举例说明如何使用“速度换面积”和“面积换速度”。</p>
<h3 id="用速度的优势换面积的节约举例">1.1.1.
“用速度的优势换面积的节约”举例</h3>
<p>WCDMA（宽带码分多址）系统中使用到了快速哈达码（Fast Hadamard
Transform, FHT）运算， FHT 由 4 步相同的算法完成，如<a href="#fig.5-1">图 5-1</a> 所示。</p>
<p><a id="fig.5-1"></a></p>
<figure>
<img data-src="../images/post/2020-12-05-josh-verilog-part-5/2020-12-05-josh-verilog-part-5-010-FastHadamardTransform.png" width="1000" alt="图 5-1 FHT 原理图">
<figcaption aria-hidden="true">图 5-1 FHT 原理图</figcaption>
</figure>
<p>FHT 单步算法如下：</p>
<p><span class="math display">\[
\begin{align}
&amp;\mathrm{Out}[2i]=\mathrm{In}[2i] +
\mathrm{In}[2i+8],&amp;i=0\sim7\\
&amp;\mathrm{Out}[2i+1]=\mathrm{In}[2i+1] -
\mathrm{In}[2i+1+8],&amp;i=0\sim7
\end{align}
\]</span></p>
<p>考虑流水线式数据处理的要求，最自然的设计方法就是设计不同端口宽度的 4
个单步 FHT，并用将这 4
个单步模块串联起来，从而完成数据流的流水线处理。该 FHT
实现方式的代码如下：</p>
<figure class="highlight verilog"><figcaption><span>fhtpart.v</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">该模块是 FHT 的顶层，调用 4 个不同端口宽度的单步 FHT 模块，完成整个 FHT 算法</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> fhtpart(</span><br><span class="line">    Clk,Reset,FhtStarOne,FhtStarTwo,FhtStarThree,FhtStarFour,</span><br><span class="line">    I0,I1,I2,I3,I4,I5,I6,I7,I8,</span><br><span class="line">    I9,I10,I11,I12,I13,I14,I15,</span><br><span class="line">    Out0,Out1,Out2,Out3,Out4,Out5,Out6,Out7,Out8,</span><br><span class="line">    Out9,Out10,Out11,Out12,Out13,Out14,Out15</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>           Clk;                <span class="comment">// 设计的主时钟</span></span><br><span class="line"><span class="keyword">input</span>           Reset;              <span class="comment">// 异步复位</span></span><br><span class="line"><span class="keyword">input</span>           FhtStarOne,FhtStarTwo,FhtStarThree,FhtStarFour;</span><br><span class="line">                                    <span class="comment">// 4 个单步算法的时序控制信号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// FHT 的 16 个输入</span></span><br><span class="line"><span class="keyword">input</span>   [<span class="number">11</span>:<span class="number">0</span>]  I0,I1,I2,I3,I4,I5,I6,I7,I8;</span><br><span class="line"><span class="keyword">input</span>   [<span class="number">11</span>:<span class="number">0</span>]  I9,I10,I11,I12,I13,I14,I15;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FHT 的 16 个输出</span></span><br><span class="line"><span class="keyword">output</span>  [<span class="number">15</span>:<span class="number">0</span>]  Out0,Out1,Out2,Out3,Out4,Out5,Out6,Out7;</span><br><span class="line"><span class="keyword">output</span>  [<span class="number">15</span>:<span class="number">0</span>]  Out8,Out9,Out10,Out11,Out12,Out13,Out14,Out15;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第 1 次 FHT 单步运算的输出</span></span><br><span class="line"><span class="keyword">wire</span>    [<span class="number">12</span>:<span class="number">0</span>]  m0,m1,m2,m3,m4,m5,m6,m7,m8,m9;</span><br><span class="line"><span class="keyword">wire</span>    [<span class="number">12</span>:<span class="number">0</span>]  m10,m11,m12,m13,m14,m15;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第 2 次 FHT 单步运算的输出</span></span><br><span class="line"><span class="keyword">wire</span>    [<span class="number">13</span>:<span class="number">0</span>]  mm0,mm1,mm2,mm3,mm4,mm5,mm6,mm7,mm8,mm9;</span><br><span class="line"><span class="keyword">wire</span>    [<span class="number">13</span>:<span class="number">0</span>]  mm10,mm11,mm12,mm13,mm14,mm15;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第 3 次 FHT 单步运算的输出</span></span><br><span class="line"><span class="keyword">wire</span>    [<span class="number">14</span>:<span class="number">0</span>]  mmm0,mmm1,mmm2,mmm3,mmm4,mmm5,mmm6,mmm7,mmm8,mmm9;</span><br><span class="line"><span class="keyword">wire</span>    [<span class="number">14</span>:<span class="number">0</span>]  mmm10,mmm11,mmm12,mmm13,mmm14,mmm15;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第 4 次 FHT 单步运算的输出</span></span><br><span class="line"><span class="keyword">wire</span>    [<span class="number">15</span>:<span class="number">0</span>]  Out0,Out1,Out2,Out3,Out4,Out5,Out6,Out7,Out8,Out9;</span><br><span class="line"><span class="keyword">wire</span>    [<span class="number">15</span>:<span class="number">0</span>]  Out10,Out11,Out12,Out13,Out14,Out15;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第 1 次 FHT 单步运算</span></span><br><span class="line">fht_unit1 fht_unit1(</span><br><span class="line">    Clk,Reset,FhtStarOne,</span><br><span class="line">    I0,I1,I2,I3,I4,I5,I6,I7,I8,I9,I10,I11,I12,</span><br><span class="line">    I13,I14,I15,</span><br><span class="line">    m0,m1,m2,m3,m4,m5,m6,m7,m8,m9,m10,m11,m12,</span><br><span class="line">    m13,m14,m15</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第 2 次 FHT 单步运算</span></span><br><span class="line">fht_unit2 fht_unit2(</span><br><span class="line">    Clk,Reset,FhtStarTwo,</span><br><span class="line">    m0,m1,m2,m3,m4,m5,m6,m7,m8,m9,m10,m11,m12,</span><br><span class="line">    m13,m14,m15,</span><br><span class="line">    mm0,mm1,mm2,mm3,mm4,mm5,mm6,mm7,mm8,mm9,mm10,mm11,mm12,</span><br><span class="line">    mm13,mm14,mm15</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第 3 次 FHT 单步运算</span></span><br><span class="line">fht_unit3 fht_unit3(</span><br><span class="line">    Clk,Reset,FhtStarThree,</span><br><span class="line">    mm0,mm1,mm2,mm3,mm4,mm5,mm6,mm7,mm8,mm9,mm10,mm11,mm12,</span><br><span class="line">    mm13,mm14,mm15,</span><br><span class="line">    mmm0,mmm1,mmm2,mmm3,mmm4,mmm5,mmm6,mmm7,mmm8,mmm9,mmm10,mmm11,mmm12,</span><br><span class="line">    mmm13,mmm14,mmm15</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第 4 次 FHT 单步运算</span></span><br><span class="line">fht_unit4 fht_unit4(</span><br><span class="line">    Clk,Reset,FhtStarFour,</span><br><span class="line">    mmm0,mmm1,mmm2,mmm3,mmm4,mmm5,mmm6,mmm7,mmm8,mmm9,mmm10,mmm11,mmm12,</span><br><span class="line">    mmm13,mmm14,mmm15,</span><br><span class="line">    Out0,Out1,Out2,Out3,Out4,Out5,Out6,Out7,Out8,Out9,Out10,Out11,Out12,</span><br><span class="line">    Out13,Out14,Out15</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></tbody></table></figure>
<p>单步 FHT 运算举例如下（仅举例第 1 步的模块）：</p>
<figure class="highlight verilog"><figcaption><span>fht_unit1.v</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">第 1 次 FHT 单步运算</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"><span class="keyword">module</span> fht_unit1(</span><br><span class="line">    Clk,Reset,FhtStar,</span><br><span class="line">    In0,In1,In2,In3,In4,In5,In6,In7,In8,In9,In10,In11,In12,</span><br><span class="line">    In13,In14,In15,</span><br><span class="line">    Out0,Out1,Out2,Out3,Out4,Out5,Out6,Out7,Out8,Out9,Out10,Out11,Out12,</span><br><span class="line">    Out13,Out14,Out15</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>           Clk;        <span class="comment">// 设计的主时钟</span></span><br><span class="line"><span class="keyword">input</span>           Reset;      <span class="comment">// 异步复位</span></span><br><span class="line"><span class="keyword">input</span>           FhtStar;    <span class="comment">// 单步 FHT 运算控制信号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 单步 FT运算输入</span></span><br><span class="line"><span class="keyword">input</span>   [<span class="number">11</span>:<span class="number">0</span>]  In0,In1,In2,In3,In4,In5,In6,In7,In8,In9;</span><br><span class="line"><span class="keyword">input</span>   [<span class="number">11</span>:<span class="number">0</span>]  In10,In11,In12,In13,In14,In15;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单步 FT运算输出</span></span><br><span class="line"><span class="keyword">output</span>  [<span class="number">12</span>:<span class="number">0</span>]  Out0,Out1,Out2,Out3,Out4,Out5,Out6,Out7,Out8,Out9;</span><br><span class="line"><span class="keyword">output</span>  [<span class="number">12</span>:<span class="number">0</span>]  Out10,Out11,Out12,Out13,Out14,Out15;</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span>     [<span class="number">12</span>:<span class="number">0</span>]  Out0,Out1,Out2,Out3,Out4,Out5;</span><br><span class="line"><span class="keyword">reg</span>     [<span class="number">12</span>:<span class="number">0</span>]  Out6,Out7,Out8,Out9,Out10,Out11;</span><br><span class="line"><span class="keyword">reg</span>     [<span class="number">12</span>:<span class="number">0</span>]  Out12,Out13,Out14,Out15;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 补码运算</span></span><br><span class="line"><span class="keyword">wire</span>    [<span class="number">11</span>:<span class="number">0</span>]  In8Co  =~ In8+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">wire</span>    [<span class="number">11</span>:<span class="number">0</span>]  In9Co  =~ In9+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">wire</span>    [<span class="number">11</span>:<span class="number">0</span>]  In10Co =~ In10+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">wire</span>    [<span class="number">11</span>:<span class="number">0</span>]  In11Co =~ In11+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">wire</span>    [<span class="number">11</span>:<span class="number">0</span>]  In12Co =~ In12+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">wire</span>    [<span class="number">11</span>:<span class="number">0</span>]  In13Co =~ In13+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">wire</span>    [<span class="number">11</span>:<span class="number">0</span>]  In14Co =~ In14+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">wire</span>    [<span class="number">11</span>:<span class="number">0</span>]  In15Co =~ In15+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> Clk <span class="keyword">or</span> <span class="keyword">negedge</span> Reset) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span>(!Reset) <span class="keyword">begin</span></span><br><span class="line">        Out0&lt;=<span class="number">0</span> ; Out1&lt;=<span class="number">0</span> ; Out2&lt;= <span class="number">0</span>; Out3&lt;= <span class="number">0</span>;</span><br><span class="line">        Out4&lt;=<span class="number">0</span> ; Out5&lt;=<span class="number">0</span> ; Out6&lt;= <span class="number">0</span>; Out7&lt;= <span class="number">0</span>;</span><br><span class="line">        Out8&lt;=<span class="number">0</span> ; Out9&lt;=<span class="number">0</span> ; Out10&lt;=<span class="number">0</span>; Out11&lt;=<span class="number">0</span>;</span><br><span class="line">        Out12&lt;=<span class="number">0</span>; Out13&lt;=<span class="number">0</span>; Out14&lt;=<span class="number">0</span>; Out15&lt;=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(FhtStar) <span class="keyword">begin</span></span><br><span class="line">            Out0  &lt;= {In0[<span class="number">11</span>],In0 } + {In8[<span class="number">11</span>],In8 };</span><br><span class="line">            Out1  &lt;= {In0[<span class="number">11</span>],In0 } + {In8Co[<span class="number">11</span>],In8Co };</span><br><span class="line">            Out2  &lt;= {In1[<span class="number">11</span>],In1 } + {In9[<span class="number">11</span>],In9 };</span><br><span class="line">            Out3  &lt;= {In1[<span class="number">11</span>],In1 } + {In9Co[<span class="number">11</span>],In9Co };</span><br><span class="line">            Out4  &lt;= {In2[<span class="number">11</span>],In2 } + {In10[<span class="number">11</span>],In10 };</span><br><span class="line">            Out5  &lt;= {In2[<span class="number">11</span>],In2 } + {In10Co[<span class="number">11</span>],In10Co };</span><br><span class="line">            Out6  &lt;= {In3[<span class="number">11</span>],In3 } + {In11[<span class="number">11</span>],In11 };</span><br><span class="line">            Out7  &lt;= {In3[<span class="number">11</span>],In3 } + {In11Co[<span class="number">11</span>],In11Co };</span><br><span class="line">            Out8  &lt;= {In4[<span class="number">11</span>],In4 } + {In12[<span class="number">11</span>],In12 };</span><br><span class="line">            Out9  &lt;= {In4[<span class="number">11</span>],In4 } + {In12Co[<span class="number">11</span>],In12Co };</span><br><span class="line">            Out10 &lt;= {In5[<span class="number">11</span>],In5 } + {In13[<span class="number">11</span>],In13 };</span><br><span class="line">            Out11 &lt;= {In5[<span class="number">11</span>],In5 } + {In13Co[<span class="number">11</span>],In13Co };</span><br><span class="line">            Out12 &lt;= {In6[<span class="number">11</span>],In6 } + {In14[<span class="number">11</span>],In14 };</span><br><span class="line">            Out13 &lt;= {In6[<span class="number">11</span>],In6 } + {In14Co[<span class="number">11</span>],In14Co };</span><br><span class="line">            Out14 &lt;= {In7[<span class="number">11</span>],In7 } + {In15[<span class="number">11</span>],In15 };</span><br><span class="line">            Out15 &lt;= {In7[<span class="number">11</span>],In7 } + {In15Co[<span class="number">11</span>],In15Co };</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></tbody></table></figure>
<p>评估一下系统的流水线时间余量后，发现整个流水线有 16 个时钟周期，而
FHT 模块的频率很高，加法本身仅消耗 1
个时钟周期，加上数据的选择和分配所消耗时间，也完全能满足系统频率要求，所以<strong>将单步
FHT 运算复用 4
次</strong>，就能大幅度节约所消耗的资源。这种复用单步算法的FHT
实现框图如<a href="#fig.5-2">图 5-2</a> 所示，由输入选择寄存、单步FHT
模块、输出选择寄存和计数器构成。</p>
<p><a id="fig.5-2"></a></p>
<figure>
<img data-src="../images/post/2020-12-05-josh-verilog-part-5/2020-12-05-josh-verilog-part-5-020-FHTOperationReuseStructureDiagram.png" width="600" alt="图 5-2 FHT 运算复用结构图">
<figcaption aria-hidden="true">图 5-2 FHT 运算复用结构图</figcaption>
</figure>
<p>代码如下：</p>
<figure class="highlight verilog"><figcaption><span>wch_fht.v</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">优化后的 FHT 运算</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"><span class="keyword">module</span> wch_fht(</span><br><span class="line">    Clk,Reset,</span><br><span class="line">    PreFhtStar,</span><br><span class="line">    In0,In1,In2,In3,In4,In5,In6,In7,</span><br><span class="line">    In8,In9,In10,In11,In12,In13,In14,In15,</span><br><span class="line">    Out0,Out1,Out2,Out3,Out4,Out5,Out6,Out7,Out8,</span><br><span class="line">    Out9,Out10,Out11,Out12,Out13,Out14,Out15</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>           Clk;        <span class="comment">// 设计的主时钟</span></span><br><span class="line"><span class="keyword">input</span>           Reset;      <span class="comment">// 异步复位信号</span></span><br><span class="line"><span class="keyword">input</span>           PreFhtStar; <span class="comment">// FHT 运算指示信号, 和上级模块运算关联</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// FHT 的 16 个输入</span></span><br><span class="line"><span class="keyword">input</span>   [<span class="number">11</span>:<span class="number">0</span>]  In0,In1,In2,In3,In4,In5,In6,In7;</span><br><span class="line"><span class="keyword">input</span>   [<span class="number">11</span>:<span class="number">0</span>]  In8,In9,In10,In11,In12,In13,In14,In15;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FHT 的 16 个输出</span></span><br><span class="line"><span class="keyword">output</span>  [<span class="number">15</span>:<span class="number">0</span>]  Out0,Out1,Out2,Out3,Out4,Out5,Out6,Out7;</span><br><span class="line"><span class="keyword">output</span>  [<span class="number">15</span>:<span class="number">0</span>]  Out8,Out9,Out10,Out11,Out12,Out13,Out14,Out15;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FHT 输出寄存信号</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>] Out0,Out1,Out2,Out3,Out4,Out5,Out6,Out7;</span><br><span class="line"><span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>] Out8,Out9,Out10,Out11,Out12,Out13,Out14,Out15;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FHT 的中间结果</span></span><br><span class="line"><span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] Temp0,Temp1,Temp2,Temp3,Temp4,Temp5,Temp6,Temp7;</span><br><span class="line"><span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] Temp8,Temp9,Temp10,Temp11,Temp12,Temp13,Temp14,Temp15;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FHT 运算控制计数器，和前一级流水线模块配合</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">2</span>:<span class="number">0</span>] Cnt3;             <span class="comment">//count from 0 to 4,when Reset Cnt3=7;</span></span><br><span class="line"><span class="keyword">reg</span> FhtEn;                  <span class="comment">//Enable fht culculate</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> Clk <span class="keyword">or</span> <span class="keyword">negedge</span> Reset) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!Reset)</span><br><span class="line">        Cnt3&lt;= #<span class="number">1</span> <span class="number">3'b111</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (PreFhtStar)</span><br><span class="line">            Cnt3&lt;= #<span class="number">1</span> <span class="number">3'b100</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            Cnt3&lt;= #<span class="number">1</span> Cnt3-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> Clk <span class="keyword">or</span> <span class="keyword">negedge</span> Reset)</span><br><span class="line"><span class="keyword">if</span> (!Reset)</span><br><span class="line">   FhtEn&lt;= #<span class="number">1</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (PreFhtStar)</span><br><span class="line">        FhtEn&lt;= #<span class="number">1</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>  (Cnt3==<span class="number">1</span>)</span><br><span class="line">        FhtEn&lt;= #<span class="number">1</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 补码运算, 复制符号位</span></span><br><span class="line"><span class="keyword">assign</span> Temp0  = (Cnt3 == <span class="number">4</span>) ? {In0[<span class="number">11</span>],In0[<span class="number">11</span>],In0[<span class="number">11</span>],In0[<span class="number">11</span>],In0}     :Out0;</span><br><span class="line"><span class="keyword">assign</span> Temp1  = (Cnt3 == <span class="number">4</span>) ? {In1[<span class="number">11</span>],In1[<span class="number">11</span>],In1[<span class="number">11</span>],In1[<span class="number">11</span>],In1}     :Out1;</span><br><span class="line"><span class="keyword">assign</span> Temp2  = (Cnt3 == <span class="number">4</span>) ? {In2[<span class="number">11</span>],In2[<span class="number">11</span>],In2[<span class="number">11</span>],In2[<span class="number">11</span>],In2}     :Out2;</span><br><span class="line"><span class="keyword">assign</span> Temp3  = (Cnt3 == <span class="number">4</span>) ? {In3[<span class="number">11</span>],In3[<span class="number">11</span>],In3[<span class="number">11</span>],In3[<span class="number">11</span>],In3}     :Out3;</span><br><span class="line"><span class="keyword">assign</span> Temp4  = (Cnt3 == <span class="number">4</span>) ? {In4[<span class="number">11</span>],In4[<span class="number">11</span>],In4[<span class="number">11</span>],In4[<span class="number">11</span>],In4}     :Out4;</span><br><span class="line"><span class="keyword">assign</span> Temp5  = (Cnt3 == <span class="number">4</span>) ? {In5[<span class="number">11</span>],In5[<span class="number">11</span>],In5[<span class="number">11</span>],In5[<span class="number">11</span>],In5}     :Out5;</span><br><span class="line"><span class="keyword">assign</span> Temp6  = (Cnt3 == <span class="number">4</span>) ? {In6[<span class="number">11</span>],In6[<span class="number">11</span>],In6[<span class="number">11</span>],In6[<span class="number">11</span>],In6}     :Out6;</span><br><span class="line"><span class="keyword">assign</span> Temp7  = (Cnt3 == <span class="number">4</span>) ? {In7[<span class="number">11</span>],In7[<span class="number">11</span>],In7[<span class="number">11</span>],In7[<span class="number">11</span>],In7}     :Out7;</span><br><span class="line"><span class="keyword">assign</span> Temp8  = (Cnt3 == <span class="number">4</span>) ? {In8[<span class="number">11</span>],In8[<span class="number">11</span>],In8[<span class="number">11</span>],In8[<span class="number">11</span>],In8}     :Out8;</span><br><span class="line"><span class="keyword">assign</span> Temp9  = (Cnt3 == <span class="number">4</span>) ? {In9[<span class="number">11</span>],In9[<span class="number">11</span>],In9[<span class="number">11</span>],In9[<span class="number">11</span>],In9}     :Out9;</span><br><span class="line"><span class="keyword">assign</span> Temp10 = (Cnt3 == <span class="number">4</span>) ? {In10[<span class="number">11</span>],In10[<span class="number">11</span>],In10[<span class="number">11</span>],In10[<span class="number">11</span>],In10}:Out10;</span><br><span class="line"><span class="keyword">assign</span> Temp11 = (Cnt3 == <span class="number">4</span>) ? {In11[<span class="number">11</span>],In11[<span class="number">11</span>],In11[<span class="number">11</span>],In11[<span class="number">11</span>],In11}:Out11;</span><br><span class="line"><span class="keyword">assign</span> Temp12 = (Cnt3 == <span class="number">4</span>) ? {In12[<span class="number">11</span>],In12[<span class="number">11</span>],In12[<span class="number">11</span>],In12[<span class="number">11</span>],In12}:Out12;</span><br><span class="line"><span class="keyword">assign</span> Temp13 = (Cnt3 == <span class="number">4</span>) ? {In13[<span class="number">11</span>],In13[<span class="number">11</span>],In13[<span class="number">11</span>],In13[<span class="number">11</span>],In13}:Out13;</span><br><span class="line"><span class="keyword">assign</span> Temp14 = (Cnt3 == <span class="number">4</span>) ? {In14[<span class="number">11</span>],In14[<span class="number">11</span>],In14[<span class="number">11</span>],In14[<span class="number">11</span>],In14}:Out14;</span><br><span class="line"><span class="keyword">assign</span> Temp15 = (Cnt3 == <span class="number">4</span>) ? {In15[<span class="number">11</span>],In15[<span class="number">11</span>],In15[<span class="number">11</span>],In15[<span class="number">11</span>],In15}:Out15;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> Clk <span class="keyword">or</span> <span class="keyword">negedge</span> Reset) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!Reset) <span class="keyword">begin</span></span><br><span class="line">        Out0&lt;=<span class="number">0</span>;Out1&lt;=<span class="number">0</span>;Out2&lt;=<span class="number">0</span>;Out3&lt;=<span class="number">0</span>;Out4&lt;=<span class="number">0</span>;Out5&lt;=<span class="number">0</span>;Out6&lt;=<span class="number">0</span>;Out7&lt;=<span class="number">0</span>;</span><br><span class="line">        Out8&lt;=<span class="number">0</span>;Out9&lt;=<span class="number">0</span>;Out10&lt;=<span class="number">0</span>;Out11&lt;=<span class="number">0</span>;Out12&lt;=<span class="number">0</span>;Out13&lt;=<span class="number">0</span>;Out14&lt;=<span class="number">0</span>;Out15&lt;=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> ((Cnt3&lt;=<span class="number">4</span>) &amp;&amp; Cnt3&gt;=<span class="number">0</span> &amp;&amp; FhtEn) <span class="keyword">begin</span></span><br><span class="line">            Out0[<span class="number">15</span>:<span class="number">0</span>]  &lt;= #<span class="number">1</span> Temp0[<span class="number">15</span>:<span class="number">0</span>] + Temp8[<span class="number">15</span>:<span class="number">0</span>];</span><br><span class="line">            Out1[<span class="number">15</span>:<span class="number">0</span>]  &lt;= #<span class="number">1</span> Temp0[<span class="number">15</span>:<span class="number">0</span>] - Temp8[<span class="number">15</span>:<span class="number">0</span>];</span><br><span class="line">            Out2[<span class="number">15</span>:<span class="number">0</span>]  &lt;= #<span class="number">1</span> Temp1[<span class="number">15</span>:<span class="number">0</span>] + Temp9[<span class="number">15</span>:<span class="number">0</span>];</span><br><span class="line">            Out3[<span class="number">15</span>:<span class="number">0</span>]  &lt;= #<span class="number">1</span> Temp1[<span class="number">15</span>:<span class="number">0</span>] - Temp9[<span class="number">15</span>:<span class="number">0</span>];</span><br><span class="line">            Out4[<span class="number">15</span>:<span class="number">0</span>]  &lt;= #<span class="number">1</span> Temp2[<span class="number">15</span>:<span class="number">0</span>] + Temp10[<span class="number">15</span>:<span class="number">0</span>];</span><br><span class="line">            Out5[<span class="number">15</span>:<span class="number">0</span>]  &lt;= #<span class="number">1</span> Temp2[<span class="number">15</span>:<span class="number">0</span>] - Temp10[<span class="number">15</span>:<span class="number">0</span>];</span><br><span class="line">            Out6[<span class="number">15</span>:<span class="number">0</span>]  &lt;= #<span class="number">1</span> Temp3[<span class="number">15</span>:<span class="number">0</span>] + Temp11[<span class="number">15</span>:<span class="number">0</span>];</span><br><span class="line">            Out7[<span class="number">15</span>:<span class="number">0</span>]  &lt;= #<span class="number">1</span> Temp3[<span class="number">15</span>:<span class="number">0</span>] - Temp11[<span class="number">15</span>:<span class="number">0</span>];</span><br><span class="line">            Out8[<span class="number">15</span>:<span class="number">0</span>]  &lt;= #<span class="number">1</span> Temp4[<span class="number">15</span>:<span class="number">0</span>] + Temp12[<span class="number">15</span>:<span class="number">0</span>];</span><br><span class="line">            Out9[<span class="number">15</span>:<span class="number">0</span>]  &lt;= #<span class="number">1</span> Temp4[<span class="number">15</span>:<span class="number">0</span>] - Temp12[<span class="number">15</span>:<span class="number">0</span>];</span><br><span class="line">            Out10[<span class="number">15</span>:<span class="number">0</span>] &lt;= #<span class="number">1</span> Temp5[<span class="number">15</span>:<span class="number">0</span>] + Temp13[<span class="number">15</span>:<span class="number">0</span>];</span><br><span class="line">            Out11[<span class="number">15</span>:<span class="number">0</span>] &lt;= #<span class="number">1</span> Temp5[<span class="number">15</span>:<span class="number">0</span>] - Temp13[<span class="number">15</span>:<span class="number">0</span>];</span><br><span class="line">            Out12[<span class="number">15</span>:<span class="number">0</span>] &lt;= #<span class="number">1</span> Temp6[<span class="number">15</span>:<span class="number">0</span>] + Temp14[<span class="number">15</span>:<span class="number">0</span>];</span><br><span class="line">            Out13[<span class="number">15</span>:<span class="number">0</span>] &lt;= #<span class="number">1</span> Temp6[<span class="number">15</span>:<span class="number">0</span>] - Temp14[<span class="number">15</span>:<span class="number">0</span>];</span><br><span class="line">            Out14[<span class="number">15</span>:<span class="number">0</span>] &lt;= #<span class="number">1</span> Temp7[<span class="number">15</span>:<span class="number">0</span>] + Temp15[<span class="number">15</span>:<span class="number">0</span>];</span><br><span class="line">            Out15[<span class="number">15</span>:<span class="number">0</span>] &lt;= #<span class="number">1</span> Temp7[<span class="number">15</span>:<span class="number">0</span>] - Temp15[<span class="number">15</span>:<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></tbody></table></figure>
<p>为了便于对比两种实现方式的资源消耗，在 Synplify Pro
中对两种实现方法分别做了综合。两次综合选用的参数都完全一致，所以仅考察设计所消耗的寄存器和逻辑资源，选中
Disable I/O Insertion 选项，不插入 I/O，取消 Synplify Pro 中诸如 FSM
Compiler、FSM Explorer、Resource
Sharing、Retiming、Pipelining等综合优化选项。两次综合的结果如<a href="#fig.5-3">图 5-3</a> 和<a href="#fig.5-4">图 5-4</a> 所示。</p>
<p><a id="fig.5-3"></a></p>
<figure>
<img data-src="../images/post/2020-12-05-josh-verilog-part-5/2020-12-05-josh-verilog-part-5-030-FHTPARTResource.bmp" alt="图 5-3 未采用复用方案的 fhtpart 模块综合所消耗的资源">
<figcaption aria-hidden="true">图 5-3 未采用复用方案的
<code>fhtpart</code> 模块综合所消耗的资源</figcaption>
</figure>
<p><a id="fig.5-4"></a></p>
<figure>
<img data-src="../images/post/2020-12-05-josh-verilog-part-5/2020-12-05-josh-verilog-part-5-040-WCHFHTResource.bmp" alt="图 5-4 采用复用方案的 wch_fht 模块综合所消耗的资源">
<figcaption aria-hidden="true">图 5-4 采用复用方案的
<code>wch_fht</code> 模块综合所消耗的资源</figcaption>
</figure>
<p>通过对比可以清晰地观察到，采用复用实现方案所占面积约为原方案的
1/4，而得到这个好处的代价是，完成整个 FHT 运算的周期为原来的 4
倍。这个例子通过运算周期的加长，换取了消耗芯片面积的减少，是前面所述的用频率换面积的一种体现。本例所述“频率换面积”的前提是，FHT
模块频率较高，运算周期的余量较大，采用 4
步复用后，仍然能够满足系统流水线设计的要求。其实，如果流水线时序允许，FHT
运算甚至可以采用 1 bit
串行方案实现，该方案所消耗的芯片面积资源更少！</p>
<h3 id="用面积复制换取速度的提高举例">1.1.2.
“用面积复制换取速度的提高”举例</h3>
<p>举一个通过复制模块，并行处理达到高处理带宽的例子（可实际应用于无线系统、有线接入、路由器、视频系统等）。假设输入数据流的速率是
800 Mbit/s，而 FPGA 上设计的数据处理模块的处理速度最大为 200
Mbit/s，由于处理模块的数据吞吐量满足不了要求，直接在 FPGA
上实现这个设计是一个“impossible mission”！</p>
<p>这种情况下。就应该利用“面积换速度”的思想，至少复制 4
个处理模块，<strong>首先将输入数据进行串/并转换</strong>，然后利用这 4
个模块并行处理分配的数据，<strong>最后将处理结果并/串变换</strong>，完成数据速率的要求。在整个处理模块的两端看，数据速率仍然是
800 Mbit/s，而在 FPGA 的内部看，每个子模块处理的数据速率仅为 200
Mbit/s，其实整个数据的吞吐量的保障是依赖于 4
个子模块并行处理完成的，也就是说利用了占用更多的芯片面积，实现了高速处理，通过使用“面积的复制换取处理速度的提高”的思想实现了设计。设计的示意框图如<a href="#fig.5-5">图 5-5</a> 所示。</p>
<p><a id="fig.5-5"></a></p>
<figure>
<img data-src="../images/post/2020-12-05-josh-verilog-part-5/2020-12-05-josh-verilog-part-5-050-MoreAreaforSpeed.png" width="700" alt="图 5-3 “面积换速度”示意图">
<figcaption aria-hidden="true">图 5-3 “面积换速度”示意图</figcaption>
</figure>
<p>“面积复制换取速度提高”或者说“面积复制换取数据吞吐量的提高”是目前 FPGA
设计的常用技巧之一。现代高速FPGA 基本都有 DDR/DDR2/DDR3 的 I/O
硬件电路，通过这种 I/O 硬件电路，可以实现输入数据流的 1:2 和 1:4
的串/并变换和并/串变换，很多中高端 FPGA 在 I/O BANK
附近还专门设计了硬件的 DLL 或 PLL，配合 DDR/DDR2/DDR3 的 I/O
硬件电路完成对应的采样时钟的降速和倍速。调用这些 I/O
的硬件模块，可以方便、可靠地实现数据流的并行化（输入端）和串行化（输出端），从而更利于实现“面积复制换取速度提高”，或“面积复制换取数据吞吐量的提高”的设计思想。</p>
<p>上面仅仅是对“面积换速度“思想的一个简单的举例，其实具体操作过程中还涉及很多的方法和技巧，例如，对高速数据流进行串/并转换，采用“乒乓操作”方法提高数据处理速率等。希望大家通过平时的应用进一步积累经验。</p>
<h2 id="硬件原则">1.2. 硬件原则</h2>
<p>硬件原则主要针对 HDL 代码编写而言。首先应该明确 FPGA/CPLD、ASIC
的逻辑设计所采用的硬件描述语言（HDL） 同软件语言（如 C、C++
等）是有本质区别的！以 Verilog 语言为例，虽然 Verilog 很多语法规则和 C
语言相似，但是 Verilog
作为硬件描述语言，它的本质作用在于描述硬件，应该认识到 Verilog 是采用了
C
语言形式的硬件的抽象，它的<strong>最终实现结果是芯片内部的实际电路</strong>。</p>
<p>所以评判一段 HDL
代码优劣的最终标准是其描述并实现的硬件电路的性能（包括面积和速度两个方面）。评价一个设计的代码水平较高，仅仅是说<strong>这个设计由硬件向
HDL
代码这种表现形式转换得更流畅、合理</strong>。而一个设计的最终性能，在更大程度上取决于设计工程师所构想的硬件实现方案的效率以及合理性。</p>
<p>初学者，特别是由软件转行的初学者，片面追求代码的整洁、简短，这是错误的，是与评价
HDL
的标准背道而驰的！正确的编码方法是，首先要做到对所需实现的硬件电路“胸有成竹”，对该部分硬件的结构与连接十分清晰，然后再用适当的
HDL 语句表达出来即可。</p>
<p>前面已经讨论过 HDL 语言与 C 语言等软件语言相比的最显著区别在于：HDL
语言便于描述“互联”、”并发”、”时间”这 3 个硬件设计的基本概念。</p>
<ul>
<li><p><strong>互连（connectivity）</strong>:
互连是硬件电路的一个基本要素，在 C
语言中，并没有直接可以用来表示模块间互连的变量；而 HDL
的网线型变最则专为模块互连而设计，描述电路连接清晰明确。如 Verilog 的
<code>wire</code>
型变量配合一些驱动结构就能有效地描述各个模块直接的端口与网线连接关系。</p></li>
<li><p><strong>并发（concurrency）</strong> : C
语言天生是<strong>串行</strong>的，不能描述硬件之间并发的特性， C
语言编译后，其机器指令在 CPU 的高速缓冲队列中基本是顺序执行；而 Verilog
可以有效地描述并行的硬件系统，硬件系统比软件系统速度快、实时性高的一个重要原因就是硬件系统中<strong>各个单元的运算是独立的，信号流是并行的</strong>。所以在使用
HDL
建模时，应该充分理解硬件系统的并行处理特点，合理安排数据流的时序，提高整个设计的效率。</p></li>
<li><p><strong>时间（time）</strong>：C
程序运行的时候，没有一个严格的时间概念，程序运行的时间长短，取决于处理器本身的性能；而
HDL
语言定义了绝对和相对的时间度量，在仿真时可以通过时间度量与周期关系描述信号直接的时间关系。</p></li>
</ul>
<p>Verilog 作为一种 HDL
语言，对系统行为的建模方式是分层次的。比较重要的层次有系统级（System）、算法级（Algorithm）、寄存器传输级（RTL）、逻辑级（Logic）、门级（Gate）和电路开关级（Switch）等。系统级和算法级与
C 语言更相似，可用的语法和表现形式也更丰富。自 RTL 级以后，HDL
语言的功能就越来越侧重于硬件电路的描述，可用的语法和表现形式的局限性也越大。相比之下，
C 语言与系统级和算法级 Verilog 描述更相近一些，而与 RTL 级、Gate
级、Switch 级描述从描述目标和表现形式上都有较大的差异。</p>
<p>下举例说明 RTL 级 Verilog 描述语法和 C 语言描述语法的区别。</p>
<p>在C 语言的描述中，为了使代码执行效率高，表述简洁，经常用到下面的
<code>for</code> 循环语句：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = O; i &lt; <span class="number">16</span>; i++)</span><br><span class="line">    DoSomething();</span><br></pre></td></tr></tbody></table></figure>
<p>但是在实际工作中，除了描述仿真测试激励（testbench）时使用
<code>for</code> 循环语句外，RTL 级编码中<strong>必须要慎用
<code>for</code> 循环</strong>。其原因是 <strong><code>for</code>
循环会被综合器展开为所有变量情况的执行语句，每个变量独立占用寄存器资源，有些情况下不能有效地复用硬件逻辑资源，造成资源浪费</strong>。在
RTL 硬件描述中，遇到类似算法，常用的方式是先搞清楚设计的时序要求，做一个
<code>reg</code>
型计数器，在每个时钟沿累加，并在每个时钟沿判断计数器情况，做相应的处理，能复用的处理模块尽量复用，即使所有操作不易复用，也可以采用
<code>case</code> 语句展开描述。代码如下：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] counter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk)</span><br><span class="line">    <span class="keyword">if</span> (syn_rst)</span><br><span class="line">        counter &lt;= <span class="number">4'b0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        counter &lt;= counter + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">case</span> (counter)</span><br><span class="line">        <span class="number">4'b0000</span>:</span><br><span class="line">        <span class="number">4'b0001</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<p>另外，在 C 描述中有 <code>if ... else</code> 和 <code>switch</code>
条件判断语句，其语法如下：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (flag)       <span class="comment">// 表示flag为真</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    ...</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (variable) {</span><br><span class="line">    <span class="keyword">case</span> value1: ...; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> value2: ...; <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">default</span>: ...;     <span class="keyword">break</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>两者之间的区别主要在于 <code>switch</code> 是多分支选择语句，而
<code>if</code> 语句只有两个分支可供选择。虽然可以用嵌套的
<code>if</code> 语句来实现多分支选择，但那样的程序冗长难读。</p>
<p>对应 Verilog 也有 <code>if ... else</code> 语句和 <code>case</code>
语句，<code>if</code> 语句的语法相似，<code>case</code>
语句的语法如下：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> (<span class="keyword">var</span>)</span><br><span class="line">    var_value1: ...;</span><br><span class="line">    var_value2: ...;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">default</span>: ...;</span><br></pre></td></tr></tbody></table></figure>
<p>通过 <a href="https://josh-gao.top/posts/ecb88422.html#toc.3.10">Part
4——RTL 概念与常用 RTL 建模的 3.10 用 <code>case</code> 和
<code>if ... else</code> 建模</a>的学习，我们会发现 <code>case</code>
语句和 <code>if ... else if ... else if ...</code> 语句以及
<code>if ... if ... if ...</code>
语句建模时可以建立无优先级和带有优先级的判断结构，使用 HDL
语言建模时，关键在于其综合实现结果的硬件结构。</p>
<p>这里进一步引申讨论一下 Verilog 的 <code>for</code> 循环。前面讲过
Verilog
语言是分层次的，即使同一个语法关键字在不同的应用层次也有不同的理解，for
循环就是一个非常好的例子。</p>
<ul>
<li><code>for</code>
循环在行为级描述测试激励时的应用：前面介绍过，推荐使用 Behavior
级方式描述测试激励，在描述测试激励时，推荐使用 <code>for</code>
循环。好处主要有两个，一是描述简单，代码清晰；二是仿真器会对
<code>for</code> 循环开放一片内存，提高代码执行效率，加快仿真进程。</li>
</ul>
<!-- [comment]:<> (如7. 2. 1 小节就论述了如何使用for 语句实现遍历测试。) -->
<ul>
<li><code>for</code> 循环在 RTL 级描述硬件电路时的应用：在 RTL
级描述硬件时，一定要慎用 <code>for</code>
循环。前面已经介绍过，<code>for</code>
循环在硬件实现时会被综合器展开，不利于硬件资源复用，如果应用不当，还会造成资源浪费。但是任何问题不是绝对的，如果用户非常清晰
<code>for</code>
循环会被综合器展开这一基本原则，则可以逆向思维，对某些硬件上无法复用的展开结构抽象为
<code>for</code> 循环描述，大大提高代码的可读性。</li>
</ul>
<!-- [comment]:<> (例如8. 6. 2" 案例分析“小节就分别列举了使用展开结构和使用for 循环语句对某＂冒泡排序“寻找最小值电路的建模方法，请读者仔细琢磨。) -->
<h2 id="系统原则">1.3. 系统原则</h2>
<p>系统原则包含两个层次的含义：一是实现的目标器件本身可以看作一个系统，需要充分有效地发挥该系统的每个单元的功效。如果设计的实现目标为
FPGA，因为当代 FPGA
内嵌了很多固有的硬件资源（如：可编程输入/输出单元、基本可编程逻辑单元、嵌入式块
RAM
、丰富的布线资源、底层嵌入功能单元和内嵌专用硬核等），如何合理地使用这些硬件资源，对设计的全局有个宏观上的合理安排，比如合理安排时钟域、模块复用、约束、面积和速度等问题就显得至关重要。如果实现目标是
SoC，则需要分析什么样的算法和功能适合放在硬件系统里面实现，什么样的算法和功能适合放在微处理器系统（如
DSP、CPU 等）里面实现，并进一步合理划分软硬件之间的数据交换。</p>
<p>从更高层面上看，对于任何一个硬件系统，如何进行模块划分与任务分配，什么样的算法和功能适合放在可编程逻辑器件或
ASIC 里面实现，什么样的算法和功能适合放在 DSP、CPU
等微处理器实现，如何划分软硬件功能，安排模块接口设计等问题都非常重要。要知道<strong>在系统上复用模块节省的面积远比在代码上小打小闹来得实惠多。</strong></p>
<p><a href="#fig.5-6">图 5-6</a> 描述了FPGA
设计的系统规划流程。我们可以发现<strong>对设计从整体上进行模块复用应该在系统功能定义后就充分考虑</strong>，并指导模块的具体划分。模块划分非常重要，除了关系到是否最大程度上发挥项目成员的协同设计能力，而且直接决定着设计的综合、实现效果和相关的操作时间，模块划分的具体方法请参考
4.2 小节中关于模块划分技巧的论述。</p>
<p><a id="fig.5-6"></a></p>
<figure>
<img data-src="../images/post/2020-12-05-josh-verilog-part-5/2020-12-05-josh-verilog-part-5-060-SystemPlanningProc.png" width="700" alt="图 5-6 系统规划的简化流程">
<figcaption aria-hidden="true">图 5-6 系统规划的简化流程</figcaption>
</figure>
<p>对系统原则做一点引申，简单谈谈模块化设计方法。模块化设计是系统原则的一个很好的体现，它不仅是一种设计工具，它更是一种设计思路、设计方法，它是由顶向下、模块划分、分工协作设计思路的集中体现，是当代大型复杂系统的推荐设计方法。目前很多的
EDA
厂商都提高了模块化设计工具，通过这类工具划分每个模块的设计区域，然后单独设计和优化每个模块，最后将每个模块融合到顶层设计中，从而实现了团队协作、并行设计的模块化设计方法。合理使用模块化设计方法，能在最大程度上继承以往设计成果，并行分工协作，有效利用开发资源，缩短开发周期。</p>
<p>下举例说明如何在系统层次复用模块。</p>
<p>利用“可编程匹配滤波器“实现 WCDMA
基站的方案，其核心是在合理规划系统的基础上，合理划分模块并安排操作时序，提高单元模块的复用率令从而大大降低硬件消耗，其设计思想是系统原则的集中体现。可编程匹配滤波器原理框图如<a href="#fig.5-7">图 5-7</a> 所示。</p>
<p><a id="fig.5-7"></a></p>
<figure>
<img data-src="../images/post/2020-12-05-josh-verilog-part-5/2020-12-05-josh-verilog-part-5-070-ProgrammableMatchFilter.png" width="600" alt="图 5-7 可编程匹配滤波器原理框图">
<figcaption aria-hidden="true">图 5-7
可编程匹配滤波器原理框图</figcaption>
</figure>
<p>其设计思想是：利用信道固有特点（如信道 pilot
导频、信道结构等），应用现代可编程数字信号处理的技术（如 DSP、FPGA
等），采取反馈与控制匹配滤波方式，实现对某信道的已扩信息的自动解扩解扰。该可编程
MF 的主要组成部分为本地码发生器、可编程信号 MF（S
MF）、帧匹配滤波器（FRAME
MF）和控制器。本地码发生器可生成各种所需的扩频、加扰序列，可接收控制器的指示脉冲，产生规定的本地解扩、解扰序列，作为
S MF 的参考序列；S MF
是完成匹配滤波的主体，可接收控制器的指示脉冲，将自己的匹配状态切换到下一匹配状态；FMF
完成对导频信号等特殊信号（信息位待选集有限）的检测，生成指示相关峰，通知控制器将
SMF
切换到下一匹配状态；控制器统一协调各部分工作。这种可编程滤波器可以在如越区切换、同步方面、CPCH
收发信机等多方面应用，如果适当安排时序流程，可以在较大程度上节约硬件资源。</p>
<h1 id="同步设计原则和多时钟处理">2. 同步设计原则和多时钟处理</h1>
<h2 id="同步设计原则">2.1. 同步设计原则<a id="toc.2.1"></a></h2>
<p>同步设计是 PLD 和 ASIC 设计的最重要原则。本小节首先阐释为什么在 PLD
设计中要采用同步时序设计，然后重点论述同步时序设计的要点。</p>
<h3 id="异步时序设计与同步时序设计">2.1.1.
异步时序设计与同步时序设计</h3>
<p>简单比较一下异步电路和同步电路的异同。</p>
<table>
<colgroup>
<col style="width: 23%">
<col style="width: 76%">
</colgroup>
<thead>
<tr>
<th style="text-align: center;">电路类型</th>
<th style="text-align: left;">特点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">异步电路</td>
<td style="text-align: left;">· 电路的核心逻辑用组合电路实现，比如异步的
FIFO/RAM 读/写信号、地址译码等电路。<br>·
电路的主要信号、输出信号等并不依赖于任何一个时钟性信号，不是由时钟信号驱动触发器（FF）产生的。<br>·
异步时序电路的最大缺点是容易产生毛刺。在布局布线后仿真和用高分辨率逻辑分析仪观测实际信号时，这种毛刺尤其明显。<br>·
不利于器件移植，这包括 FPGA 器件族之间的移植和从 FPGA 向结构化 ASIC
的移植。<br>· 不利于静态时序分析（STA）、验证设计时序性能。</td>
</tr>
<tr>
<td style="text-align: center;">同步电路</td>
<td style="text-align: left;">·
电路的核心逻辑用各种各样的触发器实现。<br>·
电路的主要信号、输出信号等都是由某个时钟沿驱动触发器产生的。<br>·
同步时序电路可以很好地避免毛刺。布局布线后仿真和用高速逻辑分析仪采样实际工作信号皆无毛刺。<br>·
利于器件移植，这包括 FPGA 器件族之间的移植和从 FPGA 向结构化 ASIC
的移植。<br>· 有利于静态时序分析（STA）、验证设计时序性能。</td>
</tr>
</tbody>
</table>
<p>早期 PLD 设计经常使用行波计数器（Ripple
Counters）或者异步脉冲生成器等典型的异步逻辑设计方式以节约设计所消耗的面积资源。但是<strong>异步逻辑设计的时序正确性完全依赖于每个逻辑元件和布线的延迟</strong>，所以其时序约束相对繁杂而困难，并且<strong>极易产生亚稳态、毛刺等，造成设计的稳定性下降和设计频率不高</strong>。随着数字逻辑的不断经济化，器件资源已经不再成为设计的主要矛盾，而同步时序电路对全面提高设计的频率和稳定性至关重要，从这个层面上讲，尽量使用同步时序电路更加重要。</p>
<p>另一方面，随着 PLD 和 ASIC
的逻辑规模不断扩大，在芯片中完成复杂且质量优良的异步时序设计<strong>过于费时费力</strong>，其所需调整的时序路径和需要附加的相关约束相当繁琐，<strong>异步时序方法是和可编程设计理念背道而驰的</strong>。</p>
<p>随着EDA
工具的发展，大规模设计的综合、实现的优化效果越来越强。但是目前大多数综合、实现等EDA
工具都是基于时序驱动（Timing
Driven）优化策略的。异步时序电路增加了时序分析的难度，需要确定最佳时序路径所需的计算量超出想象，所需时序约束相当繁琐，而且<strong>对于异步电路很多综合、实现工具的编译会带来歧义</strong>。而对于同步时序设计则恰恰相反，其<strong>时序路径清晰，相关时序约束简单明了，综合、实现优化容易，布局布线计算量小</strong>。所以目前可编程逻辑的
EDA 工具都推荐使用同步时序设计。</p>
<div class="note info"><p>综上所述，<strong>现代数字芯片设计推荐采用同步时序设计方式！</strong></p>
</div>
<h3 id="同步时序设计">2.1.2. 同步时序设计</h3>
<p>同步时序设计的基本原则是<strong>使用时钟沿触发所有的操作</strong>。如果所有寄存器的时序要求（Setup、Hold
时间等指标）都能够满足，则同步时序设计与异步时序设计相比，在不同的
PVT（工艺、电压、温度）条件下能获得更佳的系统稳定性与可靠性。</p>
<p>同步设计中，稳定可靠的数据采样必须遵从以下两个基本原则：</p>
<ul>
<li><p>在有效时钟沿到达前，数据输入至少已经稳定了采样寄存器的 Setup
时间之久，这条原则简称<strong>满足 Setup 时间原则</strong>；</p></li>
<li><p>在有效时钟沿到达后，数据输入至少还将稳定保持采样寄存器的 Hold
时间之久，这条原则简称<strong>满足 Hold 时间原则</strong>。</p></li>
</ul>
<p>同步时序设计有以下几个注意事项：</p>
<ul>
<li><p>异步时钟域的数据转换。详见 <a href="#toc.2.3">2.3
小节“异步时钟域数据同步”</a>。</p></li>
<li><p>组合逻辑电路的设计方法。详见<a href="#toc.5">第 5
节“组合逻辑的注意事项”</a>。</p></li>
<li><p>同步时序电路的时钟设计。 详见<a href="#toc.6">第 6
节“时钟设计的注意事项”</a>。</p></li>
<li><p>同步时序电路的延迟。</p>
<p>同步时序设计中电路延迟最常用的设计方法是用分频或倍频的时钟或者同步计数器完成所需延迟。换句话说，同步时序电路的延时被当作一个电路逻辑来设计。对于<strong>比较大的和特殊定时要求的延时，一般用高速时钟产生一个计数器，根据计数器的计数，控制延时</strong>；对于<strong>比较小的延时，可以用
D
触发器打一下</strong>，这种做法<strong>不仅使信号延时了一个时钟周期，而且完成了信号与时钟的初次同步</strong>，在输入信号采样或增加时序约束余量时使用。另外许多初学者用行为级（Behavioral
Level）方法描述延时，如 <code>#5 a&lt;= 4'b0101;</code>
这种行为级描述方法常用于仿真测试激励，但是<strong>在电路综合时会被忽略、并不能起到延时作用</strong>。</p></li>
</ul>
<h2 id="亚稳态">2.2. 亚稳态<a id="toc.2.2"></a></h2>
<p>在后续文章中会介绍异步时钟域转换的问题，在谈这个话题之前，先分析一下什么是亚稳态，以及如何避免。</p>
<p>异步时钟域的转换的核心就是要保证下级时钟对上级数据采样的 Setup 时间和
Hold 时间。如果触发器的Setup 时间或者 Hold
时间不满足，就可能产生亚稳态，<strong>此时触发器输出端 Q
在有效时钟沿之后比较长的一段时间内处于不确定的状态，在这段时间内 Q
端产生毛刺并不断振荡，最终固定在某一电压值，此电压值并不一定等于原来数据输入端
D 的数值</strong>，这段时间称为决断时间（Resolution time）。经过
Resolution time 之后 Q 端将稳定到 0 或1, 但是究竟是 0
还是1，这是随机的，与输入没有必然的关系，其产生示意图如<a href="#fig.5-8">图 5-8</a> 所示。</p>
<p><a id="fig.5-8"></a> <img data-src="../images/post/2020-12-05-josh-verilog-part-5/2020-12-05-josh-verilog-part-5-080-MetastableGenerate.png" width="800" alt="图 5-8 亚稳态产生示意图"></p>
<p><strong>亚稳态的危害主要体现在破坏系统的稳定性</strong>。由于输出在稳定下来之前可能是毛刺、振荡、固定的某一电压值，因此亚稳态将<strong>导致逻辑误判</strong>，严重情况下输出
0~1
之间的中间电压值还会<strong>使下一级产生亚稳态，即导致亚稳态的传播</strong>。逻辑误判导致功能性错误，而亚稳态的传播则扩大了故障面。另外，在亚稳态状态下，任何诸如环境噪声、电源于扰等细微扰动都将导致更恶劣的状态不稳定。这时这个系统的传输延迟增大，状态输出错误，在某些情况下甚至会使寄存器在两个有效判定门限（<span class="math inline">\(\mathrm{V_{oL}}\)</span> 、<span class="math inline">\(\mathrm{V_{oH}}\)</span>）之间长时间的振荡。</p>
<p><strong>只要系统中有异步元件，亚稳态就无法避免</strong>，因此设计的电路<strong>首先要减少亚稳态导致的错误</strong>，<strong>其次要使系统对产生的错误不敏感</strong>。前者要靠同步设计来实现，而后者则根据不同的设计应用不同的处理办法。</p>
<p><strong>使用两级以上寄存器采样可以有效地减少亚稳态继续传播的概率</strong>。在<a href="#fig.5-9">图 5-9</a>
中，左边为异步输入端，经过两级触发器采样，在右边的输出与
<code>bclk</code>
同步，而且该输出基本不存在亚稳态。其原理是使第一个触发器的输出端存在亚稳态，经过一个
clk 周期后，第二个触发器 D
端的电平仍未稳定的概率非常小，因此第二个触发器 Q
端基本不会产生亚稳态。理论上如果再添加一级寄存器，使同步采样达到 3
级，则末级输出为亚稳态的概率几乎为 0。</p>
<p><a id="fig.5-9"></a></p>
<figure>
<img data-src="../images/post/2020-12-05-josh-verilog-part-5/2020-12-05-josh-verilog-part-5-090-TwoStageRegisterSampling.png" width="800" alt="图 5-9 两级寄存器采样降低亚稳态概率">
<figcaption aria-hidden="true">图 5-9
两级寄存器采样降低亚稳态概率</figcaption>
</figure>
<p>使用<a href="#fig.5-9">图 5-9</a>
两级寄存器采样仅能降低亚稳态的概率，但是并不能保证第二级输出的稳态电平就是正确电平。前面说过经过
Resolution time
之后寄存器输出的电平是一个不确定的稳态值，也就是说<strong>这种处理方法并不能排除采样错误的产生</strong>，这时就<strong>要求所设计的系统对采样错误有一定的容忍度</strong>。有些应用本身就对采样错误不敏感，如一帧图像编码，一段话音编码等。而有些系统对错误采样比较敏感。这类由于亚稳态造成的采样是一些突发的错误，所以可以采用一些纠错编码手段完成错误的纠正。</p>
<h2 id="异步时钟域数据同步">2.3.
异步时钟域数据同步<a id="toc.2.3"></a></h2>
<p>异步时钟域数据同步是芯片设计的一个常见问题，<strong>既是一个重点也是一个难点问题</strong>。很多设计工作时的不稳定都是源于异步时钟域数据同步不稳定。</p>
<h3 id="两类异步时钟域同步的表现形式">2.3.1.
两类异步时钟域同步的表现形式</h3>
<p>异步时钟域数据同步，也被称为数据接口同步，顾名思义，是指<strong>如何在两个时钟不同步的数据域之间可靠地进行数据交换</strong>。数据的时钟域不同步主要有两种情况：</p>
<ul>
<li>两个域的时钟频率相同，但是相位差不固定，或者相差固定但是不可测，简称为同频异相问题；</li>
<li>两个时钟域频率根本不同，简称为异频问题。</li>
</ul>
<h3 id="两种不推荐的异步时钟域操作方法">2.3.2.
两种不推荐的异步时钟域操作方法</h3>
<p>首先讨论两种在设计中不推荐的异步时钟域转换方法：一种是通过增加 Buffer
或者其他门延时调整采样；另一种是盲目使用时钟正负沿调整数据采样。</p>
<ol type="1">
<li><p>通过 Buffer 等组合逻辑延迟线调整采样时间</p>
<p>在早期逻辑电路图设计阶段，有一些设计者养成了手工加入 Buffer
或者非门调整数据延迟的习惯，从而保证本级模块的时钟对上级模块数据的建立、保持时间的要求。这些做法目前主要应用的场合有两种：</p>
<ul>
<li><p>一是使用分立逻辑元件（如 74 系列）搭建数字逻辑电路；</p></li>
<li><p>另一种是在 ASIC
设计领域。<strong>目前使用分立逻辑元件搭建数字逻辑电路的场合一般为系统复杂度相对较低，系统灵活性要求不高的场合</strong>。</p></li>
</ul>
<p>在上述场合使用分立逻辑器件设计数字逻辑电路，由于可以使用的调整延时的手段相对有限，而且采用插入
Buffer 、数字延迟逻辑甚至两个非门等手段调整采样的 Setup 和 Hold
时间是可以接受的。而 ASIC
设计领域采用这种方法是以严格的仿真和约束条件作为强力支持的。</p>
<p>正如 <a href="#toc.2.1">2.1
同步设计原则</a>所述，<strong>使用组合逻辑方法产生延迟，容易产生毛刺</strong>，而且这种设计方法的<strong>时序余量较差</strong>，一旦外界条件变换（环境试验，特别是高低温试验），采样时序就有可能完全紊乱，造成电路瘫痪。另外，一旦芯片更新换代，或者移植到其他器件族的芯片上，采样时延必须重新调整，电路的可维护性和继承性都很差。</p></li>
<li><p>盲目使用时钟正负沿调整数据采样</p>
<p>很多初学者习惯随意使用时钟的正负沿调整采样，甚至产生一系列不同相位或不同占空比的时钟，使用其正负沿调整数据。这种做法是不推荐的，原因如下：</p>
<ol type="1">
<li><p>如果在一个时钟周期内，使用时钟的双沿同时操作，则使用该时钟的同相倍频时钟也能实现相同的功能。换句话说，一个时钟周期内，使用时钟的双沿同时操作，相当于使用了一个同相的倍频时钟。此时因为设计的时钟频率提升，所有相关的使用约束都会变得更紧，不利于可靠实现。</p></li>
<li><p>芯片中的 PLL 和 DLL 一般都能较好地保证某个时钟沿的 Jitter、Skew
和占空比等各种参数指标，而对于另一个时钟沿的指标控制并不是那么严格。特别对于综合、实现等
EDA
的软件，如果没有明确对另外一个沿进行相关，这个沿的时序分析不一定完善，其综合或实现结果就不一定能严格满足用户期望的时序要求（比如
Setup、Hold 时间等），往往造成在该沿操作不稳定的结果。</p></li>
</ol>
<p>总结这两点，如果设计者并不十分清楚同时使用上下沿的方法，不如直接使用同相倍频时钟更加简单、明确、可靠。但是如果设计者十分清楚同一周期使用双沿的注意事项，附加了相应的约束，这种做法并非不可。</p>
<p>针对使用两个时钟沿，在这里还想补充以下两点：</p>
<ul>
<li><p>使用者虽然使用了同一个时钟的两个沿，但是<strong>保证不在同一个周期内同时使用双沿，则不会增加时钟频率</strong>。</p></li>
<li><p>DDR 、QDR
本身就是利用了上下沿采样的原理，随着存储器件高速发展，时钟速度已经成为存取器件的瓶颈，所以可用时钟上下沿操作缓解对单沿
RAM 时钟振荡器的要求。但是必须清楚，硬件的 DDR、QDR 电路（包括 ASIC 的
DDR、QDR 与 FPGA 内嵌的 DDR、QDR
电路）是专用高速设计电路，对时钟的正沿、负沿的 Jitter 、Skew
和占空比等指标都有详细和明确的要求，这一点是和普通逻辑设计，特别是实现在
FPGA 中设计的情况截然不同，希望大家加以区分。</p></li>
</ul></li>
</ol>
<h3 id="异步时钟域数据同步常用方法">2.3.3.
异步时钟域数据同步常用方法</h3>
<p>下面分别介绍 <a href="#toc.2.3">2.3
小节</a>提出的两大类异步时钟域数据同步问题的解决方法。</p>
<ol type="1">
<li><p>同频异相问题</p>
<p>同频异相问题的简单解决方法是<strong>用后级时钟对前级数据采样两次</strong>，即通常所述的<strong>用寄存器打两次</strong>。数据同步如<a href="#fig.5-10">图 5-10</a>
所示，这样的做法是有效地减少了亚稳态的传播，使后级电路数据都是有效电平值。但是这种做法并不能保证两级寄存器采样后的数据是正确的电平值，因为一旦
Setup 或 Hold 时间不满足，采样发生亚稳态，则经判决时间（Resolution
Time）后，还是可能判决到错误电平值。所以<strong>这种方法仅仅适用于对少量错误不敏感的功能单元</strong>。</p>
<p><a id="fig.5-10"></a></p>
<figure>
<img data-src="../images/post/2020-12-05-josh-verilog-part-5/2020-12-05-josh-verilog-part-5-100-DataSynchronization.png" width="800" alt="图 5-10 数据同步">
<figcaption aria-hidden="true">图 5-10 数据同步</figcaption>
</figure>
<p>可靠的做法是用 DPRAM 、FIFO 或者一段寄存器 Buffer
完成异步时钟域的数据转换。把数据存放在 DPRAM 或FIFO
的方法如下：将上级芯片提供的数据随路时钟作为写信号，将数据写入 DPRAM
或者FIFO, 然后使用本级的采样时钟（
一般是数据处理的主时钟），将数据读出即可。由于时钟频率相同，所以 DPRAM
或 FIFO 两端的数据吞吐率一致，实现起来相对简单。</p></li>
<li><p>异频问题</p>
<p>可靠完成异频问题的解决方法就是使用 DPRAM 或 FIFO
。其实现思路与前面所述一致，用上级随路时钟写上级数据，然后用本级时钟读出数据。但是由于时钟频率不同，所以两个端口的数据吞吐率不一致，设计时一定要开好缓冲区，并通过监控（Full、Half、Empty
等指示）确保数据流不会溢出。</p></li>
</ol>
<h1 id="代码风格">3. 代码风格</h1>
<p>代码风格，即 Coding Style，其分为一般性 Coding Style
和针对综合工具、实现工具、器件类型的 Coding Style。</p>
<h2 id="coding-style-的分类">3.1. Coding Style 的分类</h2>
<p>所谓一般性的 Coding
Style，是指不依赖于综合、实现工具和器件类型的代码风格。不同的综合实现工具对一些语法细节的阐释略有不同，特别是那些关于优先级实现的先后顺序等，所以不同的综合工具在个别细节上对
Coding Style 的解释有一定的差异。本文所述的 Coding
Style，如果没有特别声明，都是不依赖于具体 EDA 工具， 一般意义上的 Coding
Style，适用于不同厂商的综合实现工具和不同目标器件。</p>
<p>还有一类 Coding Style
是针对某种综合工具或者特定器件结构的，根据器件硬件结构，正确地实例化底层单元模块，合理地使用其内嵌的硬件电路，以达到最优化的设计效果。另外需要特别声明一点，一般
ASIC 设计的 Coding Style 和 PLD（主要指 FPGA 和 CPLD）设计的 Coding
Style 有明显差异。这主要是因为 PLD
设计是基于固有的硬件结构（如：逻辑单元、块
RAM、PLL/DLL、时钟资源等）。而 ASIC
设计结构灵活，目标多样，特别是在功耗、速度、时序等要求上，与 PLD
设计有明显差异。例如， ASIC
设计中根据要求会有意识地采样某些组合逻辑、门控时钟等降低功耗或提高速度。这里讲述的
Coding Style 和基本原则如不特殊声明，均基于 PLD 设计要求。</p>
<p>另外本文所述 Coding Style 主要是基于
RTL（寄存器传输级）而言，并非其他描述层次。所以诸如业界非常热门的结构化设计方法（Architectural-based
Design）的代码风格的原则和方法与本章无关，甚至有很多原则和方法是与本章所述背道而驰的。</p>
<h2 id="coding-style-的重要性">3.2. Coding Style 的重要性</h2>
<p>当代的可编程逻辑设计日趋复杂，其系统复杂度和设计频率要求与 5
年前不可同日而语。良好的 Coding Style
对设计的工作频率，所消耗的芯片面积，甚至整个系统的稳定性都非常重要，良好规范的Coding
Style 便于设计移植。</p>
<p>随着 EDA
技术的不断发展，综合、实现工具的优化能力越来越强大，可以自动完成许多复杂设计的面积和时序方面的优化，并且其优化效果日趋先进。但是如果盲目依赖综合、实现等
EDA 工具的优化，而忽略自己设计的代码风格，就大错特错了。因为 Coding
Style 对综合、实现等 EDA
工具的优化结果的影响可以用这样一句话来概括：<strong>好的 Coding Style
会使综合、实现等优化事半功倍，达到最优化的结果；不良的 Coding Style
会使综合、实现优化南辕北辙，甚至产生错误的结果</strong>。所以必须明确：综合、实现等
EDA 工具的优化能力和正确性最终取决于设计的 Coding Style 的优劣。</p>
<p>在后面的几节中，将详细谈谈设计和代码风格。</p>
<h1 id="结构层次和模块划分">4. 结构层次和模块划分<a id="toc.4"></a></h1>
<h2 id="结构层次化编码">4.1. 结构层次化编码</h2>
<p>结构层次化编码（Hierarchical
Coding）是模块化设计思想的一种体现。目前大型设计中必须采用结构层次化编码风格，以提高代码的可读性，易于模块划分，易于分工协作，易于设计仿真测试激励。最基本的结构化层次是由一个顶层模块和若干个子模块构成，每个子模块根据需要还可以包含自己的子模块。结构层次化编码结构如<a href="#fig.5-11">图 5-11</a> 所示。</p>
<p><a id="fig.5-11"></a></p>
<figure>
<img data-src="../images/post/2020-12-05-josh-verilog-part-5/2020-12-05-josh-verilog-part-5-110-StructuredCoding.png" width="600" alt="结构层次化编码示意图">
<figcaption aria-hidden="true">结构层次化编码示意图</figcaption>
</figure>
<p>结构层次化编码有如下注意事项：</p>
<ul>
<li><p><strong>结构的层次不易太深，一般为 3~5
层即可</strong>。在综合时，
一般综合工具为了获得更好的综合效果，特别是为了使综合结果所占用的面积更小，会默认将
RTL
代码的层次打平（Flatten）。而有时为了在综合后仿真和布局布线后的时序仿真中较方便地找出一些中间信号，比如子模块之间的接口信号等，可以在综合工具中设置保留结构层次，以便于仿真信号的查找和观察。</p></li>
<li><p><strong>顶层模块最好仅包含对所有模块的组织和调用，而不应该完成比较复杂的逻辑功能</strong>。较为合理的顶层模块由输入/输出管脚声明、模块的调用与实例化、全局时钟资源、全局置位/复位、三态缓冲和一些简单的组合逻辑等构成。</p></li>
<li><p><strong>所有的 I/O
信号，如输入、输出、双向信号等的描述在顶层模块完成。</strong></p></li>
<li><p><strong>子模块之间也可以有接口，但是最好不要建立子模块间跨层次的接口</strong>，例如，上图中模块
<code>A1</code> 到模块 <code>B1</code>
之间不宜直接连接，两者需要交换的信号可以通过模块 <code>A</code> 模块
<code>B</code>
的接口传递。这样做的好处是增加了设计的可读性和可维护性。</p></li>
<li><p>子模块的合理划分非常重要，应该综合考虑子模块的功能、结构、时序、复杂度等多方面因素。</p></li>
</ul>
<p>结构层次化编码的本质不应该简单地理解为一种具体的设计手段，而应该认识到它更是<strong>一种系统层次的设计方法</strong>。很多初学者都有这样一个疑问：一个设计完全可以在同一个模块内完整描述，为什么还要将其中的时序逻辑和组合逻辑、不同优化目标、不同功能的电路分成多级层次，使用多个模块描述呢？模块划分增加了内部接口描述的工作量，这不是“自讨苦吃“么？</p>
<p>虽然理论上任何设计都可以在同一个模块中完成，但是如果将不同功能、不同层次、不同类型的电路混淆在同一个模块中，这不是一种好的系统设计方法，对于比较复杂的设计，将会导致整个设计杂乱无章，不利于设计的阅读与维护，也会给综合和实现过程带来许多麻烦。</p>
<h2 id="模块划分的技巧">4.2. 模块划分的技巧</h2>
<p>结构层次化设计方法的第一个要点就是模块划分，模块划分非常重要，关系到能否最大程度上发挥项目成员协同设计的能力，更重要的是它直接决定着设计的综合、实现的耗时与效率。模块划分的基本原则介绍如下：</p>
<ol type="1">
<li><p><strong>对每个同步时序设计的子模块的输出使用寄存器</strong></p>
<p>这也被称为用寄存器分割同步时序模块的原则。使用寄存器分割同步时序单元的好处是：便于综合工具权衡所分割的子模块中的组合电路部分和同步时序电路部分，从而达到更好的时序优化效果，这种模块划分符合时序约束的习惯，便于利用约束属性进行时序约束。</p></li>
<li><p><strong>将相关的逻辑或者可以复用的逻辑划分在同一模块内</strong></p>
<p>这个做法有时被称为<strong>呼应系统原则</strong>。这样做的好处有：一方面将相关的逻辑和可以复用的逻辑划分在同一模块，可在最大程度上复用资源，减少设计所消耗的面积；另一方面更利于综合工具优化某个具体功能的时序关键路径。其原因是，传统的综合工具只能同时优化某一部分的逻辑，而所能同时优化的逻辑的从本单元就是模块，所以将相关功能划分在同一模块将在时序和面积上获得更好的综合优化效果。</p></li>
<li><p><strong>将不同优化目标的逻辑分开</strong></p>
<p>在介绍速度、面积平衡与互换原则时，合理的设计目标应该综合考虑面积最小和频率最高两个指标。好的设计，在规划阶段设计者就应该初步规划了设计的规模和时序关键路径，并对设计的优化目标有一个整体上的把握。</p>
<p>对于时序紧张的部分，应该独立划分为一个模块，其优化目标为“Speed”，这种划分方法便于设计者进行时序约束，也便于综合和实现工具进行优化。目前很多综合与实现工具都支持物理区域位置约束，以模块为单元进行物理区域约束，从而优化关键路径时序，以达到更高的系统工作频率就更为方便有效。</p>
<p>另一类情况是，设计的矛盾主要集中在芯片的资源消耗上。这时应该将资源消耗过大的部分划分为独立的模块，这类模块的优化目标应该定为“Area”
。同理，将它们规划到一起，更有利于区域布局与约束。这种根据优化目标进行优化的方法最大好处是，对于某个模块综合器仅需要考虑一种优化目标和策略，从而比较容易达到较好的优化效果。相反，如果同时考虑两种优化目标，会使综合器陷入互相制约的困境，耗费巨大的综合优化时间也得不到令人满意的综合优化结果。</p></li>
<li><p><strong>将时序约束较松的逻辑归到同一模块</strong></p>
<p>有些逻辑的时序非常宽松，不需要较高的时序约束，可以将这类逻辑归入同一模块，如多周期路径（Multi-cycle
Path）等。将这些模块归类，并指定宽松约束，则可以让综合器尽量节省面积资源。</p></li>
<li><p><strong>将存储逻辑独立划分成模块</strong></p>
<p>RAM、ROM、CAM 和 FIFO
等存储单元应该独立划分模块。这样做的好处是便于利用综合约束属性显化指定这些存储单元的结构和所使用的资源类型，也便于综合器将这些存储单元自动类推为指定器件的硬件原语。另一个好处是在仿真时消耗的内存也会减少，便于提高仿真速度。这是因为大多数仿真器对大面积的
RAM 都有独特的内存管理方式，以提高仿真效率。</p></li>
<li><p><strong>合适的模块规模</strong></p>
<p>从理论上讲，模块的规模越大，越利于模块资源共享（Resource
Sharing）。但是庞大的模块，将要求对综合器同时处理更多的逻辑结构，这将对综合器的处理能力和计算机的配置提出了较高的要求。另外，庞大的模块划分，不利于发挥目前非常流行的增拭综合与实现技术的优势。</p></li>
</ol>
<h1 id="组合逻辑的注意事项">5. 组合逻辑的注意事项<a id="toc.5"></a></h1>
<p>相对复杂一些的设计都是由两部分组成的，分别为时序逻辑（Sequential
Logic）和组合逻辑（Combination
Logic）。同步时序设计系统中并不是不包含组合逻辑，而是要更加合理地设计、划分组合逻辑。在以下几小节中将介绍组合逻辑设计的一些问题。</p>
<h2 id="always-组合逻辑信号敏感表">5.1. <code>always</code>
组合逻辑信号敏感表</h2>
<p>几乎所有的编码指导手册都有关于信号敏感表的论述。时序逻辑的信号敏感表比较好写，在信号敏感表中写明时钟信号的正负触发沿即可，关于信号敏感表的主要问题集中在组合逻辑的信号敏感表的写法。在此，仅强调组合逻辑的信号敏感表的相关要点：</p>
<ul>
<li><p>正确的信号敏感表设计方法是将 <code>always</code>
模块中<strong>使用到的所有输入信号和条件判断信号都列在信号敏感表中</strong>。</p></li>
<li><p>希望通过信号敏感表的增减完成某项逻辑功能是不可能的。</p></li>
<li><p>不完整的信号敏感表会造成前仿真结果和综合、实现后仿真结果不一致。</p></li>
<li><p>一般综合工具对于不完整的信号敏感表的默认做法是，将处理进程中用到的所有输入和判断条件信号都默认添加到综合结果的信号敏感表中，并对原设计代码敏感表中遗漏的信号报警告（warning）信息。</p></li>
</ul>
<p>有些初学者发现在信号敏感表中增减一些信号，会得到不同的仿真结果，于是企图依靠修改信号敏感表，而方便地完成某些逻辑的设计，这种做法是不可能的。其实一般综合工具的默认操作都是将
<code>always</code>
模块中使用到的所有输入信号和条件判断信号都当作触发信号，综合到信号敏感表中，所以增减信号敏感表，其实得到的综合结果完全一致。而增减信号敏感表，得到的仿真结果不同是因为仿真器的工作机制决定的，大多数仿真器是数据流和时钟周期驱动的，如果信号敏感表中没有某个信号，则无法触发和该信号相关的仿真进程，从而得到的仿真结果不同。</p>
<h2 id="组合逻辑环路">5.2. 组合逻辑环路</h2>
<p><strong>组合逻辑反馈环路是数字同步逻辑设计的大忌</strong>，它最容易因振荡、毛刺、时序违规等引起整个系统的不稳定和不可靠。</p>
<p>典型的组合逻辑反馈环路如<a href="#fig.5-12">图 5-12</a>
所示，寄存器的 Q 端输出直接通过组合逻辑反馈到寄存器的异步复位端，如果 Q
输出为 0
时，经组合逻辑运算后为异步复位端有效，则电路进入不断清零的死循环。</p>
<p><a id="fig.5-12"></a></p>
<figure>
<img data-src="../images/post/2020-12-05-josh-verilog-part-5/2020-12-05-josh-verilog-part-5-120-CombinatorialLogicFeedbackLoop.png" width="400" alt="组合逻辑反馈环路示意图">
<figcaption aria-hidden="true">组合逻辑反馈环路示意图</figcaption>
</figure>
<p>组合逻辑反馈环路是一种<strong>高风险</strong>设计方式，主要原因如下：</p>
<ul>
<li><p>组合反馈环的逻辑功能完全依赖于其反馈环路上组合逻辑的门延迟和布线延迟等，如果这些传播延迟有任何改变，则该组合反馈环单元的整体逻辑功能将彻底改变，而且改变后的逻辑功能很难确定。</p></li>
<li><p><strong>组合反馈环的时序分析是无穷循环的时序计算</strong>，综合、实现等
EDA 工具迫不得已必须主动割断其时序路径，以完成相关的时序计算，而不同的
EDA
工具对组合反馈环的处理方法各不相同，所以组合反馈环的最终实现结果有很多不确定因素。</p></li>
</ul>
<p>同步时序系统中应该避免使用组合逻辑反馈环路，注意事项主要有以下两点：</p>
<ul>
<li><p>牢记<strong>任何反馈环路必须包含寄存器</strong>。</p></li>
<li><p>检查综合、实现报告的 Warning 信息，发现 Combinational Loops
后进行相应修改。</p></li>
</ul>
<h2 id="脉冲产生器">5.3. 脉冲产生器</h2>
<p>在异步时序设计中，常用延时链（Delay
Chains）产生脉冲，常用的异步脉冲产生方法如<a href="#fig.5-13">图
5-13</a> 所示。</p>
<p><a id="fig.5-13"></a></p>
<figure>
<img data-src="../images/post/2020-12-05-josh-verilog-part-5/2020-12-05-josh-verilog-part-5-130-AsynchronousPulseGeneration.png" width="600" alt="图 5-13 常用的异步脉冲产生方法示意图">
<figcaption aria-hidden="true">图 5-13
常用的异步脉冲产生方法示意图</figcaption>
</figure>
<p>这类异步方法设计的脉冲产生电路的脉冲宽度取决于 Delay Chains
的门延迟和线延迟，而在 FPGA/CPLD 中，大多数 Timing Driven
的综合、布线工具无法保证其布线延迟恒定。另外，PLD 器件本身在不同的
PVT（工艺、电压、温度）环境下其延时参数也有微小波动，所以脉冲宽度无法准确确定。而且
STA
工具也无法准确分析脉冲的特性，为时序仿真和验证带来了很多的不确定性。</p>
<p>异步脉冲序列产生电路（Multi-Vibrators）也被称为毛刺生成器（Glitch
Generator），<strong>利用组合反馈环路振荡而不断产生毛刺</strong>。正如前面所述，组合反馈环是同步时序必须避免的，这类基于组合反馈环的
Multi-Vibrator
也会给设计带来稳定性、可靠性等方面的问题，必须避免使用。</p>
<p>同步时序设计脉冲电路的常用方法如<a href="#fig.5-14">图 5-14</a>
所示。该设计的脉冲宽度不因器件或设计移植而改变，恒等于时钟周期，而且避免了异步设计的诸多不确定因素，其时序路径便于计算、STA
分析和仿真验证。</p>
<p><a id="fig.5-14"></a></p>
<figure>
<img data-src="../images/post/2020-12-05-josh-verilog-part-5/2020-12-05-josh-verilog-part-5-140-SynchronousPulseGeneration.png" width="600" alt="图 5-14 常用的同步脉冲产生方法示意图">
<figcaption aria-hidden="true">图 5-14
常用的同步脉冲产生方法示意图</figcaption>
</figure>
<h2 id="慎用锁存器">5.4. 慎用锁存器</h2>
<p>同步时序设计要尽量慎用锁存器（Latch），
特别要注意综合出与设计意图不一致的 Latch
导致仿真和设计的错误。对于某些特定设计一定要使用 Latch
时，设计者必须明确该 Latch
是否为有意设计的。综合出与设计意图不吻合的Latch
结构的主要原因在于：在设计组合逻辑时，使用不完全的条件判断语句。如：有
<code>if</code> 而没有 <code>else</code>，或不完整的 <code>case</code>
语句等（这仅是一种可能，并不一定生成
Latch）；另外一种情况是设计中有组合逻辑的反馈环路（Combinatorial
Feedback Loops）等异步逻辑。</p>
<figure class="highlight verilog"><figcaption><span>latch.v</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">因if语句不完整而产生Latch的典型情况</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> latch (cond_1, data_in, data_out);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>   cond_1;</span><br><span class="line"><span class="keyword">input</span>   data_in;</span><br><span class="line"><span class="keyword">output</span>  data_out;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="keyword">reg</span>     data_out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(cond_1 <span class="keyword">or</span> data_in) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (cond_1)</span><br><span class="line">        data_out &lt;= data_in;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></tbody></table></figure>
<p>上述描述，由于未指定在条件 <code>cond_1</code> 等于 <code>0</code>
时的动作，一般情况下会生成 Latch 结构如<a href="#fig.5-15">图 5-15</a>
所示。</p>
<p><a id="fig.5-15"></a></p>
<figure>
<img data-src="../images/post/2020-12-05-josh-verilog-part-5/2020-12-05-josh-verilog-part-5-150-LatchRTL.png" width="500" alt="图 5-15 Latch 的 RTL 示意图">
<figcaption aria-hidden="true">图 5-15 Latch 的 RTL 示意图</figcaption>
</figure>
<p>防止产生非目的性的Latch 的措施如下：</p>
<ul>
<li>使用完备的 <code>if ... else</code> 语句。</li>
<li>检查设计中是否含有组合逻辑反馈环路。</li>
<li>为每个输入条件设计输出操作，对 <code>case</code> 语句设置
<code>default</code> 操作。特别是在状态机设计中，最好有一个
<code>default</code> 的状态转移，而且每个状态最好也有一个
<code>default</code> 的操作。</li>
<li>如果使用 <code>case</code>
语句时，特别是在设计状态机时，尽量附加综合约束属性，综合为完全条件
<code>case</code> 语句（full case）。目前，大多数综合工具支持 full case
的综合约束属性，具体的语法请参考综合工具的约束属性指南。</li>
</ul>
<div class="note info"><p>仔细检查综合器的综合报告，目前大多数的综合器对所综合出的 Latch
都会报“warning”， 通过综合报告可以较为方便地找出无意中生成的 Latch。</p>
</div>
<h1 id="时钟设计的注意事项">6. 时钟设计的注意事项<a id="toc.6"></a></h1>
<p>时钟是同步设计的基础，在同步设计中，所有操作都是基于时钟沿触发的，所以时钟的设计对同步时序电路而言非常重要。对于
PLD 设计，通常推荐使用 FPGA 内嵌的 PLL 或 DLL
完成时钟的频率与相位变化，并用全局时钟和专用时钟选择器进行时钟布线。对于
ASIC
设计，常会用到各种各样的组合逻辑产生的时钟，但是这些设计如果直接移植到同步时序电路中会带来各种各样的问题，本节旨在辨析一些常用的时钟电路的优劣。</p>
<h2 id="内部逻辑产生的时钟">6.1. 内部逻辑产生的时钟</h2>
<p><strong>如果需要使用内部逻辑产生时钟，必须要在组合逻辑产生的时钟后插入寄存器</strong>，如<a href="#fig.5-16">图 5-16</a>
所示。如果直接使用组合逻辑产生的信号作为时钟信号或者异步置位/复位信号，会使设计不稳定。这是因为组合逻辑难免产生毛刺，这些毛刺到达一般数据路径，在经过寄存器采用后一般影响不大，但是如果作为时钟信号或者异步置位/复位信号时，如果毛刺的宽度足以驱动寄存器的时钟端或者异步置位/复位端，则必将产生错误的逻辑操作；即使毛刺的宽度不足以驱动时钟端或异步置位/复位端，也会带来寄存器的不稳定，甚至激发寄存器产生亚稳态。所以对于时钟路径，必须插入寄存器以过滤毛刺。</p>
<p><a id="fig.5-16"></a></p>
<figure>
<img data-src="../images/post/2020-12-05-josh-verilog-part-5/2020-12-05-josh-verilog-part-5-160-InternalClockDesignwithRegister.png" width="800" alt="图 5-16 内部时钟设计必须插入寄存器">
<figcaption aria-hidden="true">图 5-16
内部时钟设计必须插入寄存器</figcaption>
</figure>
<p>另一方面，组合逻辑产生的时钟还会带来另外一个问题，组合逻辑电路的
Jitter 和 Skew
都比较大，如果时钟产生逻辑的延迟比数据路径的延迟更大，会带来负的
Skew，负的 Skew
同步逻辑设计是灾难性的。所以<strong>使用组合逻辑产生内部时钟仅适用于时钟频率较低、时钟精度要求不高的情况</strong>。另外，<strong>这类时钟应该使用快速布线资源布线，而且需要对组合逻辑电路附加一定的约束条件，以确保时钟质质量</strong>。</p>
<h2 id="ripple-counter">6.2. Ripple Counter</h2>
<p>所谓 Ripple
Counter，即行波计数器，其结构为：一组寄存器级连，每个寄存器的输出端接到下一级寄存器的时钟管脚，这种计数器常常用于异步分频电路。早期的
PLD 设计经常使用 Ripple Counter 以节约芯片资源。但是由于 Ripple Counter
是一种典型的异步时序逻辑，正如前面“<a href="#toc.2.1">同步设计原则</a>”所述，异步时序逻辑会带来各种各样的时序问题，<strong>在同步时序电路设计中必须严格避免使用
Ripple Counter</strong>。</p>
<h2 id="时钟选择">6.3. 时钟选择</h2>
<p>在通信系统中，为了适应不同的数据速率要求，经常要进行时钟切换。有时为了节约功耗，也会把高速时钟切换到低速时钟，或者进行时钟休眠操作。时钟切换的最佳途径是使用芯片内部的专用
Clock MUX 。这些 MUX
的反应速度快，锁定时间短，切换瞬间带来的冲击和抖动小。</p>
<p>如果所需器件没有专用的 Clock MUX，应该尽量满足如下几点：</p>
<ul>
<li>时钟切换控制逻辑在配置后将不再改变。</li>
<li>时钟切换后，对所有相关电路复位，以保证所有寄存器、状态机和 RAM
等电路的状态不会锁死或进入死循环。</li>
<li>所设计系统对时钟切换过程发生的短暂错误不敏感。</li>
</ul>
<h2 id="门控时钟">6.4. 门控时钟</h2>
<p>门控时钟即 Gated Clock，如<a href="#fig.5-17">图 5-17</a> 所示，是 IC
设计的一种常用减少功耗的手段。通过 Gating Logic
的控制，可以控制门后端的所有寄存器不再翻转，从而非常有效地节约功耗。</p>
<p><a id="fig.5-17"></a></p>
<figure>
<img data-src="../images/post/2020-12-05-josh-verilog-part-5/2020-12-05-josh-verilog-part-5-170-GatedClock.png" width="800" alt="图 5-17 门控时钟">
<figcaption aria-hidden="true">图 5-17 门控时钟</figcaption>
</figure>
<p>但是 Gated Clock 不是同步时序电路，其 Gating Logic（门控逻辑）会污染
Clock 的质量，通过控制门后会产生毛刺并使时钟的
Skew（偏斜）、Jitter（延时）等指标恶化。正如“<a href="#toc.2.1">同步设计原则</a>”
一节所述，在同步时序电路中，应该尽量不使用 Gated Clock 。</p>
<p>虽然有些材料指出当功耗成为主要矛盾时，可以使用门控时钟改进电路如<a href="#fig.5-18">图 5-18</a>
所示的电路完成类似门控时钟的功能，但是笔者仍强烈建议在 PLD
设计中不要使用该图所示的门控时钟改进电路。虽然这个改进电路已经在较大程度上解决了门控电路产生的毛刺，但是请注意，这个电路工作的前提是时钟源Clock
的占空比（Duty Cycle）是非常理想的 50%，如果时钟的占空比不能保证
50%，则会产生许多有规律的毛刺信号。另外这个电路还有一个前提，那就是
Clock 与 Enable 信号的不布线 Skew 为 0，否则也会造成宽度为 Skew
的毛刺。</p>
<p><a id="fig.5-18"></a></p>
<figure>
<img data-src="../images/post/2020-12-05-josh-verilog-part-5/2020-12-05-josh-verilog-part-5-180-ImprovedGatedClock.png" width="800" alt="图 5-18 门控时钟">
<figcaption aria-hidden="true">图 5-18 门控时钟</figcaption>
</figure>
<p>如果功耗真的成为了 PLD
设计的首要问题，建议采用其他方法减少功耗。如果最近发展起来的低核电压芯片（Core
电压为 1.0V），芯片休眠功能，Clock MUX
等新技术器件能有效地节约芯片功耗。</p>
<h2 id="时钟同步使能端">6.5. 时钟同步使能端</h2>
<p>大多数像寄存器这样的同步单元，都支持时钟的同步使能（Synchronous Clock
Enable）。需要注意的是，虽然使能无效时这些单元无输出，但是这种方法并不能如
Gated Clock 一样减少功耗。但 Synchronous Clock Enable
却能够非常方便地完成一些逻辑功能，通过使用同步时钟使能端完成某些逻辑功能，有时可以节约芯片面积并提高设计频率。</p>
<p>同步使能端如<a href="#fig.5-19">图 5-19</a>
所示，上半部分是同步使能功能，在目前大多数的器件上可以直接将使能信号连接到芯片的同步使能端实现，如<a href="#fig.5-19">图 5-19</a> 的下半部分所示。</p>
<p><a id="fig.5-19"></a></p>
<figure>
<img data-src="../images/post/2020-12-05-josh-verilog-part-5/2020-12-05-josh-verilog-part-5-190-EnableSynchronization.png" width="500" alt="图 5-19 同步使能端">
<figcaption aria-hidden="true">图 5-19 同步使能端</figcaption>
</figure>
<h1 id="rtl-代码优化技巧">7. RTL 代码优化技巧<a id="toc.7"></a></h1>
<h2 id="使用-pipelining-技术优化时序">7.1. 使用 Pipelining
技术优化时序</h2>
<p>Pipelining，即流水线时序优化方法，其<strong>本质是调整一个较长的组合逻辑路径中的寄存器位置</strong>，用寄存器合理分割该组合逻辑路径，从而降低了对路径的
Output 和 Setup
等时间参数的要求，达到提高设计频率的目的。但是必须要注意的是，使用
Pipelining
优化技术<strong>只能合理地调整寄存器位置，而不应该凭空增加寄存器级数</strong>，所以
Pipelining 有时也被称为 Register Balance。</p>
<p>目前一些先进的综合工具能根据用户参数配置，自动运用 Pipelining
技术，通过用寄存器平衡设计中的较长组合路径（Register
Balance），在一定程度上提高设计的工作频率。这种时序优化手段对乘法器、ROM
等单元效果显著。</p>
<h2 id="模块复用与-resource-sharing">7.2. 模块复用与 Resource
Sharing</h2>
<p>本小节的模块复用和Resource Sharing
主要站在微观的角度观察节约面积的问题。为了便与理解，首先看两个例子。</p>
<p>这是一个补码平方器的例子，输入是 8
位补码，求其平方和。由于输入是补码，所以当最高位是 1
时，表示原值是负数，需要按位取反，加 1 后再平方；当最高位是 0
时，表示原值是正数，直接求平方。</p>
<p>第一种实现方式：</p>
<figure class="highlight verilog"><figcaption><span>resource_share1.v</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> resource_share1 (data_in,square);</span><br><span class="line"><span class="keyword">input</span>   [ <span class="number">7</span>:<span class="number">0</span>]  data_in;        <span class="comment">// 输入是补码</span></span><br><span class="line"><span class="keyword">output</span>  [<span class="number">15</span>:<span class="number">0</span>]  square;</span><br><span class="line"><span class="keyword">wire</span>    [ <span class="number">7</span>:<span class="number">0</span>]  data_bar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> data_bar = ~data_in + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">assign</span> square=(data_in[<span class="number">7</span>]) ? (data_bar*data_bar) : (data_in*data_in);</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></tbody></table></figure>
<p>第二种实现方式：</p>
<figure class="highlight verilog"><figcaption><span>resource_share2</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> resource_share2 (data_in,square);</span><br><span class="line"><span class="keyword">input</span>   [ <span class="number">7</span>:<span class="number">0</span>]  data_in;        <span class="comment">// 输入是补码</span></span><br><span class="line"><span class="keyword">output</span>  [<span class="number">15</span>:<span class="number">0</span>]  square;</span><br><span class="line"><span class="keyword">wire</span>    [ <span class="number">7</span>:<span class="number">0</span>]  data_tmp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> data_tmp = (data_in[<span class="number">7</span>]) ? (~data_in + <span class="number">1</span>) : data_in;</span><br><span class="line"><span class="keyword">assign</span> square = data_tmp * data_tmp;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></tbody></table></figure>
<p>仔细观察一下可以发现：第一种实现方式需要两个 16
位乘法器，同时平方，然后根据输入补码的符号选择输出结果，其关键在于使用了两个乘法器，选择器在乘法器之后；第二种实现方法，首先根据输入补码的符号，换算为正数，然后平方，其关键在于选择器在乘法器之前，仅使用了一个乘法器，节约了资源。第二种实现方式与第一种实现方式相比节约的资源有两部分：第一部分，节约了一个
16 bit 乘法器；第二部分，后者的选择器是 1 bit 判断 8 bit 输出，而前者是
1 bit 判断 16 bit 输出。</p>
<p>两种代码的硬件结构示意图如<a href="#fig.5-20">图 5-20</a> 和图5 - 21
所示。</p>
<p><a id="fig.5-20"></a></p>
<figure>
<img data-src="../images/post/2020-12-05-josh-verilog-part-5/2020-12-05-josh-verilog-part-5-200-TwoMultipliedwithoutResourceSharing.png" width="800" alt="图 5-20 未 Resource Sharing，2 个乘法器的实现方案">
<figcaption aria-hidden="true">图 5-20 未 Resource Sharing，2
个乘法器的实现方案</figcaption>
</figure>
<p><a id="fig.5-21"></a></p>
<figure>
<img data-src="../images/post/2020-12-05-josh-verilog-part-5/2020-12-05-josh-verilog-part-5-210-OneMultipliedwithResourceSharing.png" width="800" alt="图 5-21 Resource Sharing，1 个乘法器的实现方案">
<figcaption aria-hidden="true">图 5-21 Resource Sharing，1
个乘法器的实现方案</figcaption>
</figure>
<p>对于综合后的 RTL 视图，这里需要强调以下几点：</p>
<ol type="1">
<li><p>上例资源共享的单元是乘法器，通过 Resource
Sharing，节省了一个乘法器和一些选择器占用的资源。其实如果拓展一下思维，将乘法器换成加法器、除法器等，甚至推广到<strong>任何一个普通的模块</strong>，后续结构含有选择器，都可以使用本例的设计思想，通过
Resource Sharing 成倍地节省前级模块所消耗的资源。</p></li>
<li><p>不同的综合工具、同一综合工具的不同版本、不同的优化参数、不同厂商的目标器件、同一厂商的不同器件族等因素都可能造成不同的综合结果。</p></li>
<li><p>目前很多综合工具都有“Resource
Sharing”之类的优化参数，选择该参数，综合工具会自动考察设计中是否有可以资源共享的单元，在保证逻辑功能不变的情况下，进行
Resource Sharing，以<strong>获得面积更小的综合结果</strong>。</p></li>
<li><p>最后需要强调的是，<strong>不能因为综合工具的优化能力增强，而片面依靠综合工具放松对自己
Coding Style
的要求</strong>。这是因为：第一，综合工具的优化力度毕竟有限，很多情况下不能智能地发现需要
Resource Sharing
的逻辑；第二，前面已经说过，“不同的综合工具、同一综合工具的不同版本、不同的优化参数、不同厂商的目标器件、同一厂商的不同器件族等因素”都会直接影响综合工具的优化能力和效果，所以依靠综合工具的优化能力十分不可靠；第三，在
ASIC 设计中，综合工具非常忠于用户意图，这时 Coding Style
更加重要。所以逻辑工程师必须注意自己 Coding Style
方面的修养并不断提高。</p></li>
</ol>
<h2 id="逻辑复制">7.3. 逻辑复制</h2>
<p>逻辑复制是一种通过增加面积而改善时序条件的优化手段。逻辑复制最常使用的场合是调整信号的扇出。如果某个信号需要驱动后级的很多单元，换句话说，也就是其扇出非常大，那么为了增加这个信号的驱动能力，必须插入很多级
Buffer，这样就在一定程度上增加了这个信号路径的延时。这时可以复制生成这个信号的逻辑，使多路同频同相的信号驱动后续电路，平均到每路的扇出变低，不需要加
Buffer
也能满足驱动能力的要求，这样就节约了该信号的路径时延。用逻辑复制改善扇头电路如<a href="#fig.5-22">图 5-22</a> 所示。</p>
<p><a id="fig.5-22"></a></p>
<figure>
<img data-src="../images/post/2020-12-05-josh-verilog-part-5/2020-12-05-josh-verilog-part-5-220-DuplicationtoImproveFanOut.png" width="800" alt="图 5-22 用逻辑复制改善扇出">
<figcaption aria-hidden="true">图 5-22 用逻辑复制改善扇出</figcaption>
</figure>
<p>需要说明的是，现在很多综合工具都可以自动设置最大扇出值（Max
Fanout），如果某个信号的扇出值大于最大扇出，则该信号自动被综合工具复制。最大扇出值和器件的工艺密切相关，其合理值应该根据器件手册的声明和工程经验设置。这里举例用逻辑复制手段调整扇出，达到优化路径时延仅仅是为了讲述逻辑复制的概念，其实逻辑复制还有其他很多形式。例如，香农扩展（Shannon
Expansion）等时序优化技术，香农扩展在后面将会有详细的介绍。</p>
<p>有的读者会有疑问，逻辑复制和资源共享是两个矛盾的概念，既然使用了资源共享优化技术，为什么还要做逻辑复制呢？</p>
<p>其实这个问题的本质，还是面积与速度的平衡，<strong>逻辑复制与前面的
Resource Sharing 是两个对立统一的概念</strong>。<strong>Resource Sharing
的目的是为了节省面积资源，而逻辑复制的目的是为了提高工作频率</strong>。当使用逻辑复制手段提高工作频率的时候，必然会增加面积资源，这是与资源共享相对立的；但是正如前面介绍的面积与速度的对立统一一样，<strong>逻辑复制和资源共享都是到达设计目标的两种手段</strong>，一个侧重于速度目标，一个侧重于面积目标，两者存在一种转换与平衡的关系，所以两者又是统一的。</p>
<p>首先看下面的一个加法器资源共享的例子。</p>
<p>这个例子和前面乘法器的例子非常相似，只是将平方器换成了加法器。实现这个加法器也有两种代码写法，对应两种不同的硬件结构，资源共享如<a href="#fig.5-23">图 5-23</a> 所示。</p>
<p><a id="fig.5-23"></a></p>
<figure>
<img data-src="../images/post/2020-12-05-josh-verilog-part-5/2020-12-05-josh-verilog-part-5-230-ResourceSharingExample.png" width="700" alt="图 5-23 资源共享示例">
<figcaption aria-hidden="true">图 5-23 资源共享示例</figcaption>
</figure>
<p>第一种写法，对应左边的 RTL 结构示意图：</p>
<figure class="highlight verilog"><figcaption><span>mod_copy1.v</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> mod_copy1 (sel, a, b, c, d, data_out);</span><br><span class="line"><span class="keyword">input</span>   sel, a, b, c, d;</span><br><span class="line"><span class="keyword">output</span>  data_out;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="keyword">assign</span> data_out= (sel)? (a+b) : (c+d) ;</span><br><span class="line"><span class="comment">// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></tbody></table></figure>
<p>第二种写法，对应右边的 RTL 结构示意图：</p>
<figure class="highlight verilog"><figcaption><span>mod_copy2.v</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> mod_copy2 (sel, a, b, c, d, data_out);</span><br><span class="line"><span class="keyword">input</span>   sel, a, b, c, d;</span><br><span class="line"><span class="keyword">output</span>  data_out;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="keyword">wire</span> temp1, temp2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> temp1 = (sel) ? (a) : (c) ;</span><br><span class="line"><span class="keyword">assign</span> temp2 = (sel) ? (b) : (d) ;</span><br><span class="line"><span class="keyword">assign</span> data_out = temp1 + temp2;</span><br><span class="line"><span class="comment">// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></tbody></table></figure>
<p>第一种写法比第二种省了一个加法器。而且第一种写法比第二种写法耗时略少一些，这在本例还不算十分明显，当运算模块不是加法器而是一些较复杂的逻辑时，会比较明显。当<strong>设计的时序满足要求，或者设计的面积紧张时，一般会采用资源共享的优化方法</strong>，将第一种设计转换为第二种设计，绝大多数情况如是；但是<strong>在某些特殊情况下，时序非常紧张，就会反其道而行之，将第二种设计转换为第一种设计</strong>，从而便于调整组合逻辑信号的到达时间，提高这个加法选择器的工作频率。</p>
<h2 id="香农扩展">7.4. 香农扩展</h2>
<p>前面已经讲到，香农扩展（Shannon
Expansion）也是一种逻辑复制、增加面积、提高频率的时序优化手段。</p>
<p>其定义如下，布尔逻辑可以做如下扩展：</p>
<p><span class="math display">\[\begin{equation}
F\left(a,b,c\right) = aF\left(a,b,c\right) +\bar{a}F\left(a,b,c\right)
\end{equation}\]</span></p>
<p>从上面的定义可以看到，香农扩展即布尔逻辑扩展，是卡诺逻辑化简反向运算，香农扩展相当于逻辑复制，提高频率；而卡诺逻辑化简相当于资源共享，节约面积。</p>
<p>香农扩展通过增加
MUX，从而缩短了某个优先级，但是组合路径长的信号路径时延，从而提高了该关键路径的工作频率。通过下面的例子，会对香农扩展有更全面的理解。</p>
<p>设所需的运算逻辑表达式为：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line">F= ((({<span class="number">8</span>{late}} | in0) + in1) == in2) &amp; en;</span><br></pre></td></tr></tbody></table></figure>
<p>其中信号 <code>in0</code> 、<code>in1</code> 和
`<code>in2 都是 8 bit 的数据，信号</code>late<code>和信号</code>en<code>是控制信号，信号</code>late`
是本逻辑运算的关键路径信号，延时最大。</p>
<p>使用香农扩展。</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line">F = late<span class="variable">.F</span>(late = <span class="number">1</span>) + ~late<span class="variable">.F</span>(late = <span class="number">0</span>)</span><br><span class="line">= late.[((({<span class="number">8</span>{<span class="number">1'b1</span>}} | i0)+in1) == in2) &amp; en] + ~late.[((({<span class="number">8</span>{<span class="number">11</span>b0}} | in0) + in1) == in2) &amp; en]</span><br><span class="line">= late.[(<span class="number">8'b1</span> + inl) == in2) &amp; en] + ~late[((in0 + in1) == in2) &amp; en]</span><br></pre></td></tr></tbody></table></figure>
<p>这相当于一个以 <code>late</code> 为选择信号，以
<code>[(8'b1 + in1) == in2) &amp; en]</code> 和
<code>[((in0 + in1) == in2) &amp; en]</code> 为两个输入信号的 2 选 1
的MUX 。因此， <code>late</code>
信号的优先级被提高，其信号路径的延时降低，但是其代价是设计的面积增加了，并且需要两个比较运算符。</p>
<p>未使用香农扩展的 Verilog 代码描述如下：</p>
<figure class="highlight verilog"><figcaption><span>un_shannon.v</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> un_shannon (in0, in1, in2, late, en, out);</span><br><span class="line"><span class="keyword">input</span>   [<span class="number">7</span>:<span class="number">0</span>]   in0, in1, in2;</span><br><span class="line"><span class="keyword">input</span>           late, en;</span><br><span class="line"><span class="keyword">output</span>          out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> out = ((({<span class="number">8</span>{late}} | in0) + in1) == in2) &amp; en;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></tbody></table></figure>
<p><a id="fig.5-24"></a></p>
<figure>
<img data-src="../images/post/2020-12-05-josh-verilog-part-5/2020-12-05-josh-verilog-part-5-240-BeforeShannonExtension.png" width="1000" alt="图 5-24 未使用香农扩展前的逻辑表达式对应的RTL视图">
<figcaption aria-hidden="true">图 5-24
未使用香农扩展前的逻辑表达式对应的RTL视图</figcaption>
</figure>
<p>从图中可以清晰地看到，未使用香农扩展时，从输入 PAD late 到输出 PAD
out 之间共有4 个逻辑单元， 5 段路径。其综合结果使用了 8 个 2 输入或门，1
个 8 bit 输入加法器， 1 个 8 bit 比较器， 1 个 2 输入与门。</p>
<p>使用香农扩展的 Verilog 代码如下：</p>
<figure class="highlight verilog"><figcaption><span>shannon_fast.v</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> shannon_fast (in0, in1, in2, late, en, out);</span><br><span class="line"><span class="keyword">input</span>   [<span class="number">7</span>:<span class="number">0</span>]   in0, in1, in2;</span><br><span class="line"><span class="keyword">input</span>           late, en;</span><br><span class="line"><span class="keyword">output</span>          out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">wire</span>            late_eq_0, late_eq_1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> late_eq_0 = ((in0+in1) == in2) &amp; en;</span><br><span class="line"><span class="comment">//assign late_eq_0 = ((({8{1'b0}} | in0) + in1) == in2) &amp; en;</span></span><br><span class="line"><span class="keyword">assign</span> late_eq_1 = ((<span class="number">8'b1</span>+in1) == in2) &amp; en;</span><br><span class="line"><span class="comment">//assign late_eq_1 = ((({8{1'b1}} | in0) + in1) == in2) &amp; en;</span></span><br><span class="line"><span class="keyword">assign</span> out = (late) ? late_eq_1 : late_eq_0;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></tbody></table></figure>
<p><a id="fig.5-25"></a></p>
<figure>
<img data-src="../images/post/2020-12-05-josh-verilog-part-5/2020-12-05-josh-verilog-part-5-250-AfterShannonExtension.png" width="1000" alt="图 5-25 香农扩展后的逻辑表达式对应的RTL视图">
<figcaption aria-hidden="true">图 5-25
香农扩展后的逻辑表达式对应的RTL视图</figcaption>
</figure>
<p>在图中可以清晰地看到，使用香农扩展后，从输入 PAD late 到输出 PAD out
之间共有 1 个逻辑单元，2 段路径。其综合结果使用了 2 个 8 bit
输入加法器， 2 个 8 bit 比较器，2 个输入与门和一个 2 输入选择器。</p>
<p>从RTL 视图可以清晰地看到，采用香农扩展后，对于 <code>late</code>
信号这一关键路径，消除了 3
个逻辑层次，从而在一定程度上提高了设计的工作频率。作为提高工作频率的代价，是多用
1 个加法器和选择器，消耗了更多的面积。由于本例十分简单，所以多消耗的 LUT
和缩短的路径时延都不十分显著，如果在复杂设计中运用香农扩展，就会取得更加显著的效果。</p>
<p>正如前面反复强调的面积和速度的平衡关系所述，<strong>是否使用香衣扩展时序优化手段，关键要看被优化对象的优化目标是面积还是路径</strong>。</p>
<h1 id="小结">8. 小结</h1>
<p><a href="#fig.5-26">图 5-26</a> 罗列了 RTL
编码的全面设计目标，它们是：</p>
<ul>
<li>时序（Timing）：要求设计满足预期的时序约束条件，满足预期频率要求。</li>
<li>面积（Area）：要求设计所消耗的资源满足所规划的面积要求。</li>
<li>时钟（Clocks）：要求设计中的时钟质量满足规划要求。</li>
<li>验证（Verification）：要求设计通过仿真验证的测试。</li>
<li>可测试性（DFT, Design For
Test）：要求设计时充分考量设计的可测试性。</li>
<li>可重用性（Reuse）：希望设计便于被重用，便千继承设计成果。</li>
<li>功耗（Power）：要求设计的最大功耗在规定范围之内。</li>
<li>Vendor Policies（原厂的要求）：这里主要指 EDA 工具的优化测量和 PLD
或 ASIC 厂方的设计规格与软硬件需求。</li>
</ul>
<p><a id="fig.5-26"></a></p>
<figure>
<img data-src="../images/post/2020-12-05-josh-verilog-part-5/2020-12-05-josh-verilog-part-5-260-GoalsofRTLCode.png" width="1000" alt="图 5-26 RTL代码的设计目标">
<figcaption aria-hidden="true">图 5-26 RTL代码的设计目标</figcaption>
</figure>
<p>对一个 RTL
设计求全责备地要求它同时满足上述所有目标是非常困难的，应该根据这个RTL
设计的实现载体和具体应用，分析上述要求对本设计的重要性，然后综合考虑以上因素。</p>
<h1 id="参考文献">参考文献</h1>
<p>EDA 先锋工作室. <em>轻松成为设计高手——Verilog HDL 实用精解.</em>
北京航空航天大学出版社, 2012.</p>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/css/markmap.css">

<script src="/js/markmap.js"></script>
]]></content>
      <categories>
        <category>Josh 的学习笔记</category>
        <category>Verilog</category>
      </categories>
      <tags>
        <tag>Verilog</tag>
        <tag>HDL</tag>
        <tag>RTL</tag>
        <tag>同步</tag>
        <tag>多时钟</tag>
        <tag>速度</tag>
        <tag>面积</tag>
      </tags>
  </entry>
  <entry>
    <title>Latex Miscellanea</title>
    <url>/posts/5da41bb3.html</url>
    <content><![CDATA[<p>本文主要记录一些使用 LaTex 过程中碰到的问题与解决办法。</p>
<span id="more"></span>
<h1 id="文档类及基本设置">文档类及基本设置</h1>
<h1 id="文本格式">文本格式</h1>
<h1 id="版式">版式</h1>
<h2 id="分栏">分栏</h2>
<h3 id="全文单栏">全文单栏</h3>
<p>在文档类声明时使用 <code>onecolumn</code>。</p>
<figure class="highlight latex"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>[onecolumn]{ctexart}</span><br></pre></td></tr></tbody></table></figure>
<div data-align="center">
<p><img data-src="../images/post/2021-02-27-latex-multicolum/2021-02-27-latex-multicolum-010-AllOneColumn.png" width="600px" alt="全文单栏效果图"></p>
</div>
<h3 id="全文双栏">全文双栏</h3>
<p>在文档类声明时使用 <code>twocolumn</code>。</p>
<figure class="highlight latex"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>[twocolumn]{ctexart}</span><br></pre></td></tr></tbody></table></figure>
<div data-align="center">
<p><img data-src="../images/post/2021-02-27-latex-multicolum/2021-02-27-latex-multicolum-020-AllTwoColumn.png" width="600px" alt="全文双栏效果图"></p>
</div>
<h3 id="部分双栏">部分双栏</h3>
<p>使用宏包 <code>multicol</code>，创建双栏环境。</p>
<figure class="highlight latex"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>[twocolumn]{ctexart}</span><br><span class="line"><span class="keyword">\usepackage</span>{multicol}</span><br><span class="line"><span class="keyword">\begin</span>{document}</span><br><span class="line"></span><br><span class="line">复杂的室内环境造成定位信号的衰减，如何提高对弱信号成功捕获能力成为定位接收机研究的关键技术。</span><br><span class="line"></span><br><span class="line">本文讨论的是基于地面移动广播网络的时分码分正交频分复用（Time  <span class="keyword">\&amp;</span> Code Division-Orthogonal Frequency Division Multiplexing，TC-OFDM）信号体制接收机面临的弱信号捕获问题。</span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>{multicols}{2}</span><br><span class="line">    通过对TC-OFDM信号系统仿真分析和传统弱信号捕获算法对比，提出了一种新    型的差分相干累加弱信号捕获算法；该算法采用一种差分相干累加损耗的补偿方法，能够有效提高捕获相对峰值，从而实现对弱信号的有效捕获。</span><br><span class="line"></span><br><span class="line">    实验结果表明，在低信噪比的条件下，该算法能够提高TC-OFDM定位接收机捕获弱信号能力 1-2dB，从而提高弱信号的捕获概率。</span><br><span class="line"><span class="keyword">\end</span>{multicols}</span><br><span class="line"></span><br><span class="line"><span class="keyword">\end</span>{document}</span><br></pre></td></tr></tbody></table></figure>
<div data-align="center">
<p><img data-src="../images/post/2021-02-27-latex-multicolum/2021-02-27-latex-multicolum-030-PartTwoColumn.png" width="600px" alt="部分双栏效果图"></p>
</div>
<h3 id="参考">参考</h3>
<p><a href="https://segmentfault.com/a/1190000019462299?utm_source=tag-newest">如何用
latex 分双栏(分两列)</a></p>
<h1 id="数学公式">数学公式</h1>
<h1 id="浮动环境">浮动环境</h1>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/css/markmap.css">

<script src="/js/markmap.js"></script>
]]></content>
      <categories>
        <category>Latex</category>
        <category>版式</category>
      </categories>
      <tags>
        <tag>Latex</tag>
        <tag>排版</tag>
      </tags>
  </entry>
  <entry>
    <title>Josh&#39;s Note — Verilog&lt;br&gt;Part 4 RTL 概念与常用 RTL 建模</title>
    <url>/posts/ecb88422.html</url>
    <content><![CDATA[<h1 id="rtl-和综合">1. RTL 和综合</h1>
<p>从 <a href="https://josh-gao.top/posts/fd117896.html#toc.5">Part
3——描述方式和设计层次的 5. 设计层次</a>可知，HDL 语言是分层次的。</p>
<div class="note default"><p>最常用的层次概念有系统级（System Level）或功能模块级（Functional
Model Level）、行为级（Behavioral Level）、寄存器传输级（RTL，Register
Transfer Level）和门级（Gate Level） 等。</p>
</div>
<span id="more"></span>
<p>其中寄存器传输级（RTL，Register Transfer
Level）指：<strong><mark class="label primary"> 不关注寄存器和组合逻辑的细节（如使用了多少逻辑门，逻辑门之间的连接拓扑结构等），通过描述寄存器到寄存器之间的逻辑功能描述电路的 HDL 层次</mark></strong>。RTL
级是比门级更高的抽象层次，使用 RTL
级语言描述硬件电路一般比门级描述电路简单、高效得多。</p>
<p>RTL 级语言的最重要特性就是：<mark class="label primary">RTL 级描述是可综合的描述层次</mark>。</p>
<p>综合（Synthesize）指<strong>将 HDL
语言、原理图等设计输入翻译成由与、或、非门等基本逻辑单元组成的门级连接（网表），并根据设计目标与要求（约束条件）优化所生成的逻辑连接，输出门级网表文件</strong>。RTL
级综合指将 RTL 级源代码翻译并优化为门级网表。</p>
<p>随着综合工具的不断智能化，使用 RTL
级语言描述硬件电路越来越方便。特别是在可编程逻辑器件（PLD，主要指 FPGA
和 CPLD）设计领域，最重要的代码设计层次就是 RTL 级。</p>
<h1 id="rtl-级的基本要素和设计步骤">2. RTL 级的基本要素和设计步骤</h1>
<p>典型的 RTL 设计包含以下3个部分：</p>
<ol type="1">
<li><p><strong>时钟域描述</strong></p>
<p>描述设计所使用的所有时钟，时钟之间的主从与派生关系，时钟域之间的转换。</p></li>
<li><p>时序逻辑描述（寄存器描述）</p>
<p>根据时钟沿的变换，描述寄存器之间的数据传输方式。</p></li>
<li><p>组合逻辑描述</p>
<p>描述电平敏感信号的逻辑组合方式与逻辑功能。</p></li>
</ol>
<p>RTL
描述中时序逻辑和组合逻辑的连接关系和拓扑结构决定了设计的性能，如何调整时序逻辑、组合逻辑的连接关系和拓扑结构以达到最佳的性能就是后面讨论的编码风格（Coding
Style）的核心。</p>
<p>工程师们设计 RTL
级代码的顺序各种各样，这里推荐使用如下的设计步骤：</p>
<ol type="1">
<li><p><strong>功能定义与模块划分</strong></p>
<p>根据系统功能的定义和模块划分准则（详见 <a href="https://josh-gao.top/posts/53b8b42e.html#toc.4">Part 5——RTL
设计与编码指导的 4.
结构层次和模块划分</a>小节）划分各个功能模块。</p></li>
<li><p><strong>定义所有模炔的接口</strong></p>
<p>首先清晰定义每个模块的接口，完成每个模块的信号列表。这种思路也和
Modular
Design（模块化设计方法）一致，利于模块重用、调试、修改。</p></li>
<li><p><strong>设计的时钟域</strong></p>
<p>根据设计的时钟复杂程度定义时钟之间的派生关系，分析设计中有哪些时钟域，是否存在异步时钟域之间的数据交换。对于
PLD 设计，还需确认全局时钟和是否使用 PLL/DLL
完成时钟的分频、倍频、移相等功能，哪些时钟使用全局资源布线，哪些时钟使用第二全局时钟资源布线。</p>
<p>全局时钟资源的特点是：几乎没有 Clock Skew（时钟偏斜），有一定的 Clock
Delay（时钟延迟），驱动能力最强；第二全局时钟的特点是：有较小的 Clock
Skew，较小的 Clock DeIay，时钟驱动能力较强。</p></li>
<li><p><strong>考虑设计的关键路径</strong></p>
<p>关键路径是指设计中<strong>时序要求最难以满足的路径</strong>。设计的时序要求主要体现在频率、建立时间、保持时间等时序指标上。在设计初期，设计者可以根据系统的频率要求，粗略地分析出设计的时序难点（如最高频率的路径，计数器的最低位，包含复杂组合逻辑的时序路径等），通过一些时序优化手段（如
Pipeline、Retiming、逻辑复制等，这些时序优化手段在 <a href="https://josh-gao.top/posts/53b8b42e.html#toc.7">Part 5——RTL
设计与编码指导的 7. RTL
代码优化技巧</a>部分有详细介绍）<strong>从代码上缓解设计的时序压力</strong>，这种方法比单依靠综合与布局布线工具的自动优化有效得多。</p></li>
<li><p><strong>顶层设计</strong></p>
<p>常用的设计方法有两种，一种是<strong>自顶而下</strong>的设计方法，即先描述设计的顶层，然后描述设计的每个子模块；另一种是<strong>由底向上</strong>的设计方法，即首先描述设计的子模块，最后定义设计的顶层。</p>
<p><strong>RTL
设计推荐使用自顶而下的设计方法</strong>，因为这种设计方法与模块规划的顺序一致，而且更利于进行
Modular
Design（模块化设计方法），并行开展设计工作，提高模块重用率。</p></li>
<li><p><strong>FSM 设计</strong></p>
<p>有限状态机（FSM）是逻辑设计的最重要内容之一。<a href="https://josh-gao.top/posts/d860a67e.html">Part
6——如何写好状态机</a>主要讨论如何写好 FSM。</p></li>
<li><p><strong>时序逻辑设计</strong></p>
<p>首先根据时钟域规划好寄存器组，然后描述各个寄存器组之间的数据传输方式。</p></li>
<li><p><strong>组合逻辑设计</strong></p>
<p>一般来说，<strong>大段的组合逻辑最好与时序逻辑分开描述</strong>，这样更利于时序约束和时序分析，使综合器和布局布线器达到更好的优化效果。</p></li>
</ol>
<h1 id="常用-rtl-级建模">3. 常用 RTL 级建模</h1>
<h2 id="非阻塞赋值阻塞赋值连续赋值">3.1.
非阻塞赋值、阻塞赋值、连续赋值</h2>
<p>有很多文章论述阻塞赋值和非阻塞赋值的概念，<a href="https://josh-gao.top/posts/fd117896.html#toc.3.2">Part
3——描述方式和设计层次的 3.2
过程赋值语句</a>部分详细讨论了因不当使用阻塞赋值和非阻塞赋值引起的仿真与设计意图不一致。为了避免不当使用阻塞賦值和非阻塞赋值而造成的种种歧义和错误，这里推荐：</p>
<ol type="1">
<li><p><strong>对于时序逻辑，即 <code>always</code>
模块的敏感表为<mark class="label primary">沿敏感信号</mark>（多为时钟或复位的正沿或负沿），统一使用非阻塞賦值
<code>&lt;=</code></strong>。例如：</p>
<p></p><figure class="highlight verilog"><figcaption><span>cnt1.v</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">时序逻辑中使用非阻塞赋值。</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> cnt1 (clock, cnt_out);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>        clock;</span><br><span class="line"><span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>] cnt_out;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] cnt_out;</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clock)</span><br><span class="line">    cnt_out &lt;= cnt_out + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></tbody></table></figure><p></p></li>
<li><p><strong>对于 <code>always</code>
模块的敏感表为<mark class="label primary">电平敏感</mark>信号的组合逻辑，统一使用阻塞賦值</strong>。例如：</p>
<p><a id="cnt2.v"></a></p>
<p></p><figure class="highlight verilog"><figcaption><span>cnt2.v</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">always 模块的敏感表为电平敏感信号的组合逻辑, 使用阻塞赋值。请注意, 此例</span></span><br><span class="line"><span class="comment">"cnt_out_plus" 虽然被指定为 reg 型, 但是实现时是纯组合逻辑。</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> cnt2 (cnt_out, cnt_out_plus);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>  [<span class="number">3</span>:<span class="number">0</span>] cnt_out;</span><br><span class="line"><span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>] cnt_out_plus;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] cnt_out_plus;</span><br><span class="line"><span class="keyword">always</span> @(cnt_out)</span><br><span class="line">    cnt_out_plus = cnt_out + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></tbody></table></figure><p></p></li>
<li><p><strong>对于 <code>assign</code>
关键字描述的<mark class="label primary">组合逻辑</mark>，称为连续赋值语句，统一使用
<code>=</code>，变量被定义为 <code>wire</code>
型信号</strong>。例如：</p>
<p></p><figure class="highlight verilog"><figcaption><span>cnt3.v</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">assign 描述的组合逻辑。"cnt_out_plus" 被定义为 wire 型信号。</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> cnt3 (cnt_out, cnt_out_plus);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>  [<span class="number">3</span>:<span class="number">0</span>] cnt_out;</span><br><span class="line"><span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>] cnt_out_plus;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] cnt_out_plus;</span><br><span class="line"><span class="keyword">assign</span> cnt_out_plus = cnt_out + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></tbody></table></figure><p></p></li>
</ol>
<div class="note warning"><p>在 2 和 3 中，为什么不采用类似例 1 中的
<code>cnt_out &lt;= cnt_out + 1;</code>
呢？因为，<strong>这样会产生组合逻辑环</strong>。组合逻辑环是同步时序逻辑设计的大忌，它会使得时序路径无法被工具所分析，<strong>因不同的芯片的延时差异，而造成逻辑功能不稳定</strong>。有些已经完成很久的设计，在换了芯片批次后，逻辑功能不正确，大多数都是由组合逻辑环造成的。</p>
</div>
<p>对于初学者而言，以上几点是必须遵循的法则，详细原因可以参考 <a href="https://josh-gao.top/posts/fd117896.html">Part
3——描述方式和设计层次</a>和 <a href="https://josh-gao.top/posts/53b8b42e.html">Part 5——RTL
设计与编码指导</a>的论述。</p>
<h2 id="寄存器电路建模">3.2. 寄存器电路建模</h2>
<p>寄存器和组合逻辑是数字逻辑电路的两大基本要素。寄存器一般和同步时序逻辑关联，其特点为仅当时钟的沿（上升沿或下降沿）到达时，才有可能发生输出的改变。根据实现目标不同，寄存器的建模结构略有不同，需要注意如下要点：</p>
<ol type="1">
<li><p><strong>寄存器信号声明</strong></p>
<p><strong>寄存器定义是 <code>reg</code> 型</strong>。</p>
<p></p><div class="note info"><p>请注意，这个命题的反命题不一定成立。<strong>某些信号虽然被定义为
<code>reg</code>
型，但是最终综合实现结果并不是寄存器</strong>，如上述例子 <a href="#cnt2.v">cnt2.v</a> 中 <code>cnt_out_plus</code> 虽然被指定为
<code>reg</code> 型，但是实现时是纯组合逻辑。<strong>只有定义为
<code>reg</code> 型，且 <code>always</code> 的敏感表为
<code>posedge</code> 或 <code>negedge</code>
沿敏感操作时，该信号才是寄存器</strong>。在 <a href="https://josh-gao.top/posts/fd2ca242.html">Part 2——Verilog
语言基础</a> 和 <a href="https://josh-gao.top/posts/fd117896.html">Part
3——描述方式和设计层次</a> 也有相关内容描述这个问题。</p>
</div><p></p></li>
<li><p><strong>时钟输入</strong></p>
<p>在每个时钟的正沿或负沿对数据进行处理。数据的正沿或负沿起作用，是在
<code>always</code> 的敏感表中通过 <code>posedge</code> 和
<code>negedge</code> 指定的。</p>
<p></p><figure class="highlight verilog"><figcaption><span>cnt4.v</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">指定寄存器的触发沿是时钟的下降沿。</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> cnt4 (clock, cnt_out);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>        clock;</span><br><span class="line"><span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>] cnt_out;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] cnt_out;</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">negedge</span> clock)</span><br><span class="line">    cnt_out &lt;= cnt_out + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></tbody></table></figure><p></p></li>
<li><p><strong>异步复位/置位</strong></p>
<p>绝大多数目标器件的寄存器模型都包含异步复位/置位端。异步复位/置位是指无论时钟沿是否有效，当复位/置位信号有效沿到达时，复位/置位立即发挥功能。指定异步复位/置位时，<strong>只需在
<code>always</code>
的敏感表中加入复位/置位信号的有效沿即可</strong>。下例描述的异步复位电路是最常用的寄存器复位形式之一。</p>
<p></p><figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">最常用的异步复位电路, 设异步复位信号"reset_"是低有效信号(也即下降沿开始复</span></span><br><span class="line"><span class="comment">位)。用户可以在 begin/end 结构之间填入复杂的用户逻辑。</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// reg_counter.v</span></span><br><span class="line"><span class="keyword">module</span> reg_counter (clock, reset_, cnt_reg_s, cnt_reg_a);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>        clock;</span><br><span class="line"><span class="keyword">input</span>        reset_;</span><br><span class="line"><span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>] cnt_reg_s;</span><br><span class="line"><span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>] cnt_reg_a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] cnt_reg_s;  <span class="comment">// asynchronous reset</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clock <span class="keyword">or</span> <span class="keyword">negedge</span> reset_)</span><br><span class="line">    <span class="keyword">if</span> (!reset_)</span><br><span class="line">        cnt_reg_s &lt;= <span class="number">4'b0000</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        cnt_reg_s [<span class="number">2</span>:<span class="number">0</span>] &lt;= cnt_reg_s [<span class="number">2</span>:<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">        cnt_reg_s [<span class="number">3</span>]   &lt;= ~cnt_reg_s [<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="comment">// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] cnt_reg_a;  <span class="comment">// synchronous reset</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clock)</span><br><span class="line">    <span class="keyword">if</span> (!reset_)</span><br><span class="line">        cnt_reg_a &lt;= <span class="number">4'b0000</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        cnt_reg_a [<span class="number">2</span>:<span class="number">0</span>] &lt;= cnt_reg_a [<span class="number">2</span>:<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">        cnt_reg_a [<span class="number">3</span>]   &lt;= ~cnt_reg_a [<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></tbody></table></figure><p></p></li>
<li><p><strong>同步复位/置位</strong></p>
<p>任何寄存器都可实现同步复位/置位功能。指定同步复位/置位时，<strong><code>always</code>
的敏感表中仅有时钟沿信号</strong>，当同步复位/置位信号变化时，同步复位/置位并不立即发生，仅仅当时钟沿采到同步复位/置位的有效电平时，才会在时钟沿到达时刻进行复位/置位操作。</p>
<p></p><figure class="highlight verilog"><figcaption><span>reg_counter.v</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">常用的同步复位电路, 设异步复位信号"reset_"是低电平有效信号。请比较上例,</span></span><br><span class="line"><span class="comment">对比 always 的敏感表。</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> reg_counter (clock, reset_, cnt_reg_s, cnt_reg_a);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>        clock;</span><br><span class="line"><span class="keyword">input</span>        reset_;</span><br><span class="line"><span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>] cnt_reg_s;</span><br><span class="line"><span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>] cnt_reg_a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] cnt_reg_s;  <span class="comment">// asynchronous reset</span></span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> clock <span class="keyword">or</span> <span class="keyword">negedge</span> reset_)</span><br><span class="line">    <span class="keyword">if</span> (!reset_)</span><br><span class="line">        cnt_reg_s &lt;= <span class="number">4'b0000</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        cnt_reg_s [<span class="number">2</span>:<span class="number">0</span>] &lt;= cnt_reg_s [<span class="number">2</span>:<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">        cnt_reg_s [<span class="number">3</span>]   &lt;= ~cnt_reg_s [<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] cnt_reg_a;  <span class="comment">// synchronous reset</span></span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> clock)</span><br><span class="line">    <span class="keyword">if</span> (!reset_)</span><br><span class="line">        cnt_reg_a &lt;= <span class="number">4'b0000</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        cnt_reg_a [<span class="number">2</span>:<span class="number">0</span>] &lt;= cnt_reg_a [<span class="number">2</span>:<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">        cnt_reg_a [<span class="number">3</span>]   &lt;= ~cnt_reg_a [<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="comment">// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></tbody></table></figure><p></p>
<blockquote>
<p>关于同步复位和异步复位的优缺点，在 <a href="#toc.3.9">3.9 小节</a>
有详细介绍。</p>
</blockquote></li>
<li><p><strong>同时使用时钟上升和下降沿的问题</strong></p>
<p>有时因为数据采样或调整数据相位等需求，设计者会在一个
<code>always</code> 的敏感表中同时使用时钟的 <code>posedge</code> 和
<code>negedge</code>，或者在两个 <code>always</code>
的敏感表中分别使用时钟的 <code>posedge</code> 和 <code>negedge</code>
对某些寄存器电路操作。在这两种描述下，当时钟上沿或下沿到达时，该寄存器电路都会做相应的操作。<strong>这个双沿电路往往可以等同于使用了原时钟的倍频时钟的单沿操作电路</strong>。</p>
<p>对于实现在 PLD 的设计而言，同时使用时钟的上、下沿往往是不推荐的，因为
PLD 内嵌的 PLL/DLL
和一些时钟电路往往只能对时钟的一个沿保证非常好的指标，而另个沿的抖动、偏斜、斜率等指标不见得非常优化，有时同时使用时钟的正负沿会因时钟的抖动、偏斜、占空比、斜率等问题造成一定的性能恶化。</p>
<p>因此推荐的做法是：将原时钟通过 PLL/DLL
倍频，然后使用倍频时钟的单沿（如上升沿）进行操作。但是电路设计不可一概而论，如果必须使用时钟的双沿对同一个寄存器操作时，请设计者明确此时相当于使用了倍频时钟。</p>
<p></p><figure class="highlight verilog"><figcaption><span>clock_edge.v</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">某电路使用 50MHz 时钟双沿操作相当于使用同相位 100MHz 倍频时钟操作。</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> clock_edge (clk_50M, clk_100M, rst_, cnt1, cnt2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>        clk_50M, clk_100M, rst_;</span><br><span class="line"><span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>] cnt1, cnt2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="keyword">reg</span>    [<span class="number">3</span>:<span class="number">0</span>] cnt_temp1, cnt_temp2;</span><br><span class="line"><span class="keyword">wire</span>   [<span class="number">3</span>:<span class="number">0</span>] cnt1;</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk_50M <span class="keyword">or</span> <span class="keyword">negedge</span> rst_ )</span><br><span class="line">    <span class="keyword">if</span> (!rst_)</span><br><span class="line">        cnt_temp1 &lt;= <span class="number">4'b0000</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cnt_temp1 &lt;= cnt_temp2 + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">negedge</span> clk_50M <span class="keyword">or</span> <span class="keyword">negedge</span> rst_ )</span><br><span class="line">    <span class="keyword">if</span> (!rst_)</span><br><span class="line">        cnt_temp2 &lt;= <span class="number">4'b0000</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cnt_temp2 &lt;= cnt_temp1 + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> cnt1 = (clk_50M)? cnt_temp2 : cnt_temp1;</span><br><span class="line"><span class="comment">// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span>    [<span class="number">3</span>:<span class="number">0</span>] cnt2;</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk_100M <span class="keyword">or</span> <span class="keyword">negedge</span> rst_ )</span><br><span class="line">    <span class="keyword">if</span> (!rst_)</span><br><span class="line">        cnt2 &lt;= <span class="number">4'b0000</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cnt2 &lt;= cnt2 + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></tbody></table></figure><p></p>
<p>这里相当于使用与 50MHz 时钟 <code>clk_50M</code> 同相位的 2 倍频时钟
<code>cIk_100M</code> 进行累加计算，等效描述如下：</p>
<p></p><figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span>    [<span class="number">3</span>:<span class="number">0</span>] cnt2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk_100M <span class="keyword">or</span> <span class="keyword">negedge</span> rst_ )</span><br><span class="line">    <span class="keyword">if</span> (!rst_)</span><br><span class="line">        cnt2 &lt;= <span class="number">4'b0000</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cnt2 &lt;= cnt2 + <span class="number">1</span>;</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>以上代码综合后，对应的电路结构如<a href="#fig.4-1">图 4-1</a>
所示。</p>
<p><a id="fig.4-1"></a></p>
<figure>
<img data-src="../images/post/2020-12-02-josh-verilog-part-4/2020-12-02-josh-verilog-part-4-010-RegisterCircuitModeling-01.png" width="900" alt="图 4-1 某双沿加法电路与等价倍频时钟单沿加法电路结构示意图">
<figcaption aria-hidden="true">图 4-1
某双沿加法电路与等价倍频时钟单沿加法电路结构示意图</figcaption>
</figure>
<p>RTL 仿真波形如<a href="#fig.4-2">图 4-2</a> 所示。</p>
<p><a id="fig.4-2"></a></p>
<figure>
<img data-src="../images/post/2020-12-02-josh-verilog-part-4/2020-12-02-josh-verilog-part-4-020-RegisterCircuitModeling-02.png" width="900" alt="图 4-2 某双沿加法电路与等价倍频时钟单沿加法电路仿真波型图">
<figcaption aria-hidden="true">图 4-2
某双沿加法电路与等价倍频时钟单沿加法电路仿真波型图</figcaption>
</figure>
<p>通过这个例子可以看出
，某些使用双沿操作的电路等价于使用倍频时钟的单沿电路，也就是说，这些电路使用了时钟的双沿触发寄存器，则<strong>相当于提高了设计频率，提高了设计要求的时序难度</strong>。对于这些电路，在附加时序约束和进行时序分析时一定要考虑充分。</p></li>
</ol>
<h2 id="组合逻辑建模">3.3. 组合逻辑建模</h2>
<p>组合逻辑是逻辑电路设计的另一重要组成部分。组合逻辑的特点是输出的变化仅仅和输入的电平相关，而与时钟沿无关。RTL
级常用组合逻辑的建模有两种：第一种是 <code>always</code>
模块的敏感表为电平敏感信号的电路；第二种是 <code>assign</code>
等关键字描述的组合逻辑电路。</p>
<ol type="1">
<li><p><strong><code>always</code>
模块的敏感表为电平敏感信号的组合逻辑电路</strong></p>
<p>这种形式描述组合逻辑电路应用非常广泛，如果不考虑代码的复杂性，几乎任何组合逻辑电路都可以用这种方式建模。<code>always</code>
模块的敏感表为所有判定条件和输入信号，<strong>在使用这种结构描述组合逻辑时一定要将敏感表列写完整</strong>。在
<code>always</code> 模块中可以使用
<code>if ... else</code>、<code>case</code>、<code>for</code> 循环等各种
RTL 关键字结构。</p>
<p>下面以某组合逻辑译码电路为例，说明这种组合逻辑建模方式。如前所述，在这种组合逻辑
<code>always</code> 模块中．推荐使用阻塞赋值
<code>=</code>，虽然信号被定义为 <code>reg</code>
型，但是最终综合实现结果并不是寄存器，而是组合逻辑，定义为
<code>reg</code> 型仅是纯语法需要而已。</p>
<p></p><figure class="highlight verilog"><figcaption><span>decode_cmb.v</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">某组合逻辑译码电路。</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> decode_cmb (addr, CS, cs1, cs2, cs3, cs4);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>  [<span class="number">7</span>:<span class="number">0</span>]      addr;         <span class="comment">// only the 2 MSB bits used</span></span><br><span class="line"><span class="keyword">input</span>             CS;           <span class="comment">// Low effect</span></span><br><span class="line"><span class="keyword">output</span> cs1, cs2, cs3, cs4;      <span class="comment">// Low effect</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="keyword">reg</span>    cs1, cs2, cs3, cs4;</span><br><span class="line"><span class="keyword">parameter</span> chip1_decode = <span class="number">2'b00</span>,</span><br><span class="line">          chip2_decode = <span class="number">2'b01</span>,</span><br><span class="line">          chip3_decode = <span class="number">2'b10</span>,</span><br><span class="line">          chip4_decode = <span class="number">2'b11</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(CS <span class="keyword">or</span> addr)</span><br><span class="line">    <span class="keyword">if</span> (CS)</span><br><span class="line">        {cs1, cs2, cs3, cs4} = <span class="number">4'b1111</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span> (addr[<span class="number">7</span>:<span class="number">6</span>])</span><br><span class="line">            chip1_decode: {cs1, cs2, cs3, cs4} = <span class="number">4'b0111</span>;</span><br><span class="line">            chip2_decode: {cs1, cs2, cs3, cs4} = <span class="number">4'b1011</span>;</span><br><span class="line">            chip3_decode: {cs1, cs2, cs3, cs4} = <span class="number">4'b1101</span>;</span><br><span class="line">            chip4_decode: {cs1, cs2, cs3, cs4} = <span class="number">4'b1110</span>;</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="comment">// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></tbody></table></figure><p></p>
<p>综合后对应的结构示意图如<a href="#fig.4-3">图 4-3</a> 所示。</p>
<p><a id="fig.4-3"></a></p>
<figure>
<img data-src="../images/post/2020-12-02-josh-verilog-part-4/2020-12-02-josh-verilog-part-4-030-CombinatorialLogictModeling.png" width="700" alt="图 4-3 某组合逻辑译码电路的结构示意图">
<figcaption aria-hidden="true">图 4-3
某组合逻辑译码电路的结构示意图</figcaption>
</figure></li>
<li><p><code>assign</code> 等语句描述的组合逻辑电路</p>
<p>这种形式描述组合逻辑电路适用于描述那些相对简单的组合逻辑。信号一般被定义为
<code>wire</code> 型，常用的 <code>assign</code>
结构除了直接赋值逻辑表达式外，还可以使用 <code>?</code> 语句。</p>
<p></p><figure class="highlight verilog"><figcaption><span>decode_cmb2.v</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">使用 assign 结构描述该组合逻辑译码电路。</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> decode_cmb2 (addr, CS, cs1, cs2, cs3, cs4);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>  [<span class="number">7</span>:<span class="number">0</span>]      addr;           <span class="comment">// only the 2 MSB bits used</span></span><br><span class="line"><span class="keyword">input</span>             CS;             <span class="comment">// Low effect</span></span><br><span class="line"><span class="keyword">output</span> cs1, cs2, cs3, cs4;        <span class="comment">// Low effect</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="keyword">wire</span>   cs1, cs2, cs3, cs4;</span><br><span class="line"><span class="keyword">parameter</span> chip1_decode = <span class="number">2'b00</span>,</span><br><span class="line">          chip2_decode = <span class="number">2'b01</span>,</span><br><span class="line">          chip3_decode = <span class="number">2'b10</span>,</span><br><span class="line">          chip4_decode = <span class="number">2'b11</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> cs1 = (!CS &amp;&amp; (addr[<span class="number">7</span>:<span class="number">6</span>] == chip1_decode))? <span class="number">0</span> : <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">assign</span> cs2 = (!CS &amp;&amp; (addr[<span class="number">7</span>:<span class="number">6</span>] == chip2_decode))? <span class="number">0</span> : <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">assign</span> cs3 = (!CS &amp;&amp; (addr[<span class="number">7</span>:<span class="number">6</span>] == chip3_decode))? <span class="number">0</span> : <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">assign</span> cs4 = (!CS &amp;&amp; (addr[<span class="number">7</span>:<span class="number">6</span>] == chip4_decode))? <span class="number">0</span> : <span class="number">1</span> ;</span><br><span class="line"><span class="comment">// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></tbody></table></figure><p></p>
<p>该描述方式实现的电路同<a href="#fig.4-3">图 4-3</a>。</p></li>
</ol>
<div class="note "><p>可以看到，对于简单的组合逻辑使用 <code>assign</code> 和
<code>?</code>
语句比较清晰。但是如果所描述的组合逻辑过于复杂，则需要很多条
<code>assign</code> 语句或者嵌套的 <code>?</code>
语句来描述，不易解读，此时推荐使用第一种组合逻辑建模方法。</p>
</div>
<h2 id="双线端口与三态信号建模">3.4. 双线端口与三态信号建模</h2>
<p>前面谈到所有的<strong>双向总线（既作输出又作输出的总线）应该在顶层模块定义为三态信号，禁止在顶层以外的其他子层次定义双向端口</strong>。某些早期
EDA
软件和器件支持在子模块定义双向总线，实例化三态信号，其实从理论上讲任何子模块中定义的三态信号都可以迁移到顶层来。实际上，很多流行的综合工具也是对子模块定义的三态信号综合为选择器，将子模块例化的三态信号迁移到顶层。</p>
<p>为了避免仿真和综合实现结果不一致，并便于维护，强烈建议仅在顶层定义双向总线和例化的三态信号，禁止在除顶层以外的其他层次赋值高阻态
<code>Z</code>，在顶层将双向信号分为输入信号和输出信号两种类型，然后根据需要分别传递到不同的子模块中。这样做的另一个好处是便于描述仿真激励。</p>
<p>以下介绍几种典型的双向信号和三态信号的描述方法。</p>
<ol type="1">
<li><p>为了清晰起见，在顶层可以将一个双向总线分成输入和输出两条总线，然后分别引入子模块使用。</p>
<p></p><figure class="highlight verilog"><figcaption><span>bibus.v</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">将双向总线 data_bus 分为输入总线 data_in 和输出总线 data_in, 然后分别使用。</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> bibus (clk, rst, sel, data_bus, addr);</span><br><span class="line"><span class="keyword">input</span>       clk, rst, sel;</span><br><span class="line"><span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] addr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="keyword">inout</span> [<span class="number">7</span>:<span class="number">0</span>] data_bus;</span><br><span class="line"><span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] data_in, data_out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> data_in = data_bus;</span><br><span class="line"><span class="keyword">assign</span> data_bus = (sel) ? data_out : <span class="number">8'bZ</span>;</span><br><span class="line"><span class="comment">// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span></span><br><span class="line"></span><br><span class="line">decode decode_inst (</span><br><span class="line">    <span class="variable">.clock</span> (clk),</span><br><span class="line">    <span class="variable">.reset</span> (rst),</span><br><span class="line">    <span class="variable">.data_bus_in</span> (data_in),</span><br><span class="line">    <span class="variable">.addr_bus</span> (addr),</span><br><span class="line">    <span class="variable">.data_bus_out</span> (data_out)</span><br><span class="line">    );</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></tbody></table></figure><p></p>
<p>简单的三态信号用 <code>assign</code> 语法描述，如上述
<code>bibus.v</code> 代码中，描述三态总线为：</p>
<p></p><figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> data_bus = (sel) ? data_out : <span class="number">8'bZ</span>;</span><br></pre></td></tr></tbody></table></figure><p></p></li>
<li><p>如果三态总线的使能关系比较复杂，不是单一信号，此时可以使用嵌套的问号表达式，或者使用语句描述（当然也可以用
<code>if ... else</code> 结构）。</p>
<p></p><figure class="highlight verilog"><figcaption><span>complex_bibus.v</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">双向总线 databus 的输出由 3 个使能信号 sel1、sel2、se13共同确定, 下述代码中</span></span><br><span class="line"><span class="comment">中使用嵌套的问号表达式描述了该三态总线的使能选择。</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> complex_bibus (clk, rst, sel1, sel2, sel3, data_bus, addr);</span><br><span class="line"><span class="keyword">input</span>       clk, rst;</span><br><span class="line"><span class="keyword">input</span>       sel1, sel2, sel3;</span><br><span class="line"><span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] addr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] data_in;</span><br><span class="line"><span class="comment">//wire [7:0] data_out;         //use wire type</span></span><br><span class="line"><span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] decode_out;</span><br><span class="line"><span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] cnt_out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> data_in = data_bus;</span><br><span class="line"></span><br><span class="line">decode decode_inst (</span><br><span class="line">    <span class="variable">.clock</span> (clk),</span><br><span class="line">    <span class="variable">.reset</span> (rst),</span><br><span class="line">    <span class="variable">.data_bus_in</span> (data_in),</span><br><span class="line">    <span class="variable">.addr_bus</span> (addr),</span><br><span class="line">    <span class="variable">.data_bus_out</span> (decode_out)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">counter counter_inst (</span><br><span class="line">    <span class="variable">.clock</span> (clk),</span><br><span class="line">    <span class="variable">.reset</span> (rst),</span><br><span class="line">    <span class="variable">.data_bus_in</span> (data_in),</span><br><span class="line">    <span class="variable">.cnt_out</span> (cnt_out)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="keyword">inout</span> [<span class="number">7</span>:<span class="number">0</span>] data_bus;</span><br><span class="line"><span class="keyword">assign</span> data_bus = (sel1) ? decode_out : ((sel2) ? cnt_out : ((sel3) ?</span><br><span class="line">    <span class="number">8'b11111111</span> : <span class="number">8'bZZZZZZZZ</span>));</span><br><span class="line"><span class="comment">// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></tbody></table></figure><p></p>
<p>但是如果使能情况更复杂，就不宜再使用上述 <code>complex-bibus.v</code>
中嵌套的问号表达式了。更清晰的描述方法是 <code>case</code>
语句，</p></li>
<li><p>通过 <code>case</code>
语句可以清晰地罗列每种使能组合情况下的输出情况。</p>
<p></p><figure class="highlight verilog"><figcaption><span>complex_bibus2.v</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">这种描述需要使到组合逻辑的模块，此时需要引入中间变量 data_out，并定义为 reg</span></span><br><span class="line"><span class="comment">型</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> complex_bibus2 (clk, rst, sel1, sel2, sel3, data_bus, addr);</span><br><span class="line"><span class="keyword">input</span>       clk, rst;</span><br><span class="line"><span class="keyword">input</span>       sel1, sel2, sel3;</span><br><span class="line"><span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] addr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> data_in = data_bus;</span><br><span class="line"></span><br><span class="line">decode decode_inst (</span><br><span class="line">    <span class="variable">.clock</span> (clk),</span><br><span class="line">    <span class="variable">.reset</span> (rst),</span><br><span class="line">    <span class="variable">.data_bus_in</span> (data_in),</span><br><span class="line">    <span class="variable">.addr_bus</span> (addr),</span><br><span class="line">    <span class="variable">.data_bus_out</span> (decode_out)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">counter counter_inst (</span><br><span class="line">    <span class="variable">.clock</span> (clk),</span><br><span class="line">    <span class="variable">.reset</span> (rst),</span><br><span class="line">    <span class="variable">.data_bus_in</span> (data_in),</span><br><span class="line">    <span class="variable">.cnt_out</span> (cnt_out)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="keyword">inout</span> [<span class="number">7</span>:<span class="number">0</span>] data_bus;</span><br><span class="line"></span><br><span class="line"><span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] data_in;</span><br><span class="line"><span class="keyword">reg</span>  [<span class="number">7</span>:<span class="number">0</span>] data_out;    <span class="comment">//use reg type, but not registers</span></span><br><span class="line"><span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] decode_out;</span><br><span class="line"><span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] cnt_out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(decode_out <span class="keyword">or</span> cnt_out <span class="keyword">or</span> sel1 <span class="keyword">or</span> sel2 <span class="keyword">or</span> sel3) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">case</span> ({sel1, sel2, sel3})</span><br><span class="line">        <span class="number">3'b100</span>:  data_out = decode_out;</span><br><span class="line">        <span class="number">3'b010</span>:  data_out = cnt_out;</span><br><span class="line">        <span class="number">3'b001</span>:  data_out = <span class="number">8'b11111111</span>;</span><br><span class="line">        <span class="keyword">default</span>: data_out = <span class="number">8'bZZZZZZZZ</span>;</span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> data_bus = data_out;</span><br><span class="line"><span class="comment">// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></tbody></table></figure><p></p>
<p>请注意，虽然输出的中间变量 <code>data_out</code>，被定义为
<code>reg</code>
型，但是在物理实现时它并不是寄存器，而是纯组合逻辑。引入这个变量的原因是
<code>inout</code> 类型的信号只能被定义为 <code>wire</code> 或
<code>tri</code> 型，不能在组合逻辑的 <code>always</code>
模块中直接赋值。</p>
<p></p><figure class="highlight verilog"><figcaption><span>counter.v</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">三态实例中调用的子模块</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> counter (clock,</span><br><span class="line">                reset,</span><br><span class="line">                data_bus_in,</span><br><span class="line">                cnt_out</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>        clock, reset;</span><br><span class="line"><span class="keyword">input</span>  [<span class="number">7</span>:<span class="number">0</span>] data_bus_in;</span><br><span class="line"><span class="keyword">output</span> [<span class="number">7</span>:<span class="number">0</span>] cnt_out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span>    [<span class="number">7</span>:<span class="number">0</span>] cnt_out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clock <span class="keyword">or</span> <span class="keyword">posedge</span> reset)</span><br><span class="line">    <span class="keyword">if</span> (reset)</span><br><span class="line">        cnt_out &lt;= <span class="number">8'b00000000</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cnt_out &lt;= data_bus_in + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></tbody></table></figure><p></p>
<p></p><figure class="highlight verilog"><figcaption><span>decode.v</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">三态实例中调用的子模块</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> decode (clock, reset, data_bus_in, addr_bus, data_bus_out);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>        clock, reset;</span><br><span class="line"><span class="keyword">input</span>  [<span class="number">7</span>:<span class="number">0</span>] data_bus_in;</span><br><span class="line"><span class="keyword">input</span>  [<span class="number">7</span>:<span class="number">0</span>] addr_bus;</span><br><span class="line"></span><br><span class="line"><span class="keyword">output</span> [<span class="number">7</span>:<span class="number">0</span>] data_bus_out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span>    [<span class="number">7</span>:<span class="number">0</span>] data_bus_out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clock <span class="keyword">or</span> <span class="keyword">posedge</span> reset)</span><br><span class="line">    <span class="keyword">if</span> (reset)</span><br><span class="line">        data_bus_out &lt;= <span class="number">8'b00000000</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">case</span> (addr_bus)</span><br><span class="line">            <span class="number">8</span>'b <span class="number">11110000</span>: data_bus_out &lt;= <span class="number">8'b00001111</span>;</span><br><span class="line">            <span class="number">8</span>'b <span class="number">00001111</span>: data_bus_out &lt;= <span class="number">8'b11110000</span>;</span><br><span class="line">            <span class="number">8</span>'b <span class="number">10100000</span>: data_bus_out &lt;= <span class="number">8'b11111111</span>;</span><br><span class="line">            <span class="keyword">default</span>:      data_bus_out &lt;= data_bus_in;</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></tbody></table></figure><p></p></li>
</ol>
<h2 id="mux-建模">3.5. mux 建模</h2>
<p>mux 也是一种组合逻辑电路，它的常用建模方式也有两种：对于简单的
mux，可以直接用 <code>assign</code> 和 <code>?</code>
表达式建模，对于复杂的 mux，则需要使用 <code>always</code> 和
<code>if ... else</code>、<code>case</code> 等条件判断语句建模。</p>
<ol type="1">
<li><p><strong>简单的 mux 用 <code>?</code> 表达式建模。信号被定义为
<code>wire</code> 型，<code>?</code>
表达式的判断条件是的选择端。</strong></p>
<p></p><figure class="highlight verilog"><figcaption><span>mux.v</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">使用"?"表达式描述一个 2 选 1 的 mux。</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> mux (en, a, b, mux_out);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>        en;</span><br><span class="line"><span class="keyword">input</span>        a, b;</span><br><span class="line"><span class="keyword">output</span>       mux_out;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="keyword">wire</span> mux_out;</span><br><span class="line"><span class="keyword">assign</span> mux_out = (en)? a : b;</span><br><span class="line"><span class="comment">// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></tbody></table></figure><p></p></li>
<li><p><strong>复杂的 mux 用 <code>case</code> 或嵌套的
<code>if ... else</code> 建模。信号被定义为 <code>reg</code>
型，每个<code>case</code> 或 <code>if ... else</code> 的条件分支即一路
mux 的选择输出。</strong></p>
<p></p><figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">使用 case 描述一个 4 选 1 的 mux。</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// mux2.v</span></span><br><span class="line"><span class="keyword">module</span> mux2 (en, a, b, c, d, mux_out);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>  [<span class="number">1</span>:<span class="number">0</span>] en;</span><br><span class="line"><span class="keyword">input</span>        a, b, c, d;</span><br><span class="line"><span class="keyword">output</span>       mux_out;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="keyword">reg</span> mux_out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(en <span class="keyword">or</span> a <span class="keyword">or</span> b <span class="keyword">or</span> c <span class="keyword">or</span> d)</span><br><span class="line">    <span class="keyword">case</span>(en)</span><br><span class="line">        <span class="number">2'b00</span>:  mux_out = a;</span><br><span class="line">        <span class="number">2'b01</span>:  mux_out = b;</span><br><span class="line">        <span class="number">2'b10</span>:  mux_out = c;</span><br><span class="line">        <span class="number">2'b11</span>:  mux_out = d;</span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="comment">// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></tbody></table></figure><p></p></li>
</ol>
<h2 id="存储器建模">3.6. 存储器建模</h2>
<p>逻辑电路设计经常使用一些单口 RAM，双口 RAM 和 ROM 等存储器。Verilog
语法中基本的存储单元定义格式为：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span> [dataWidth] MemoryName [addressWidth];</span><br></pre></td></tr></tbody></table></figure>
<p>例如，定义一个数据位宽为 8bit，地址为 63 位的
RAM8x64，则可定义为：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] RAM8x64 [<span class="number">0</span>:<span class="number">63</span>];</span><br></pre></td></tr></tbody></table></figure>
<p>在使用存储单元时，不能直接操作存储器的某地址的某位，如想取地址为
<code>32</code> 的第 2 位和高两位，但是这两种描述都是错误的。</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line">RAM8x64 [<span class="number">32</span>][<span class="number">2</span>]</span><br><span class="line">RAM8x64 [<span class="number">32</span>][<span class="number">6</span>:<span class="number">7</span>]</span><br></pre></td></tr></tbody></table></figure>
<p>正确的操作方法是：<strong>先将存储单元赋值给某个寄存器，然后再对该寄存器的某位进行相关操作</strong>。如下例所示。</p>
<figure class="highlight verilog"><figcaption><span>ram_basic.v</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">一个简单的 8 位宽, 64 位地址 RAM 的读/写电路，读的时候，先将 RAM8x64 某地址的数</span></span><br><span class="line"><span class="comment">据读到 mem_data 寄存器，然后就可以对寄存器的任意位进行相关操作。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> ram_basic (clk, CS, WR, addr, data_in, data_out, en);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>         clk;</span><br><span class="line"><span class="keyword">input</span>         CS;           <span class="comment">// CS = 1, RAM enable</span></span><br><span class="line"><span class="keyword">input</span>         WR;           <span class="comment">// WR =1 then WRite enable; WR = 0 then read enable</span></span><br><span class="line"><span class="keyword">input</span>         en;           <span class="comment">// data_out enable, convert the data sequency</span></span><br><span class="line"><span class="keyword">input</span>  [<span class="number">5</span>:<span class="number">0</span>]  addr;</span><br><span class="line"><span class="keyword">input</span>  [<span class="number">7</span>:<span class="number">0</span>]  data_in;</span><br><span class="line"><span class="keyword">output</span> [<span class="number">7</span>:<span class="number">0</span>]  data_out;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] RAM8x64 [<span class="number">0</span>:<span class="number">63</span>];</span><br><span class="line"><span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] mem_data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk)</span><br><span class="line">    <span class="keyword">if</span> (WR &amp;&amp; CS)           <span class="comment">// write</span></span><br><span class="line">        RAM8x64 [addr] &lt;= data_in [<span class="number">7</span>:<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (~WR &amp;&amp; CS)     <span class="comment">// read</span></span><br><span class="line">        mem_data &lt;= RAM8x64 [addr];</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> data_out = (en)? mem_data[<span class="number">7</span>:<span class="number">0</span>] : {~mem_data[<span class="number">7</span>], mem_data[<span class="number">6</span>:<span class="number">0</span>]};</span><br><span class="line"><span class="comment">// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></tbody></table></figure>
<p>上面讲解的仅仅是 Verilog 语法建模存储单元的一般方法。而对于 PLD
设计、由于几乎所有的 FPGA 都内嵌有 RAM 资源，则<strong>并不推荐使用
Verilog 直接建模 RAM</strong>。FPGA 内嵌的 RAM 资源大致分为两类：块
RAM（Block RAM）资源和分布式 RAM 资源（Distributed
RAM，是一种基于特殊底层逻辑单元，通过查找表和触发器实现的 RAM
结构）。PLD中使用存储结构的基本方法有两大类：</p>
<ul>
<li><p>第一种方法是：通过器件商的开发平台中内嵌的 <strong>IP
生成器</strong>，在图形化界面中直接选择存储器类型（如双口 RAM、单口
RAM、ROM、分布式 RAM 等），配置存储器参数，生产相应
IP，然后在用户逻辑中直接调用该 IP 即可。<strong>这种设计方法是 PLD
设计中推荐的方法</strong>，因为器件商最了解 PLD 的底层硬件结构，通过 IP
生成器，可以自动地选择使用 PLD 内嵌的 RAM
资源，并生成存储器的粘合逻辑（glue logic），方便、高效、可靠。</p></li>
<li><p>第二种方法是：直接根据上面的描述用 Verilog
语言建模存储器，由综合器根据代码描述类推并优化存储器结构，调用器件内嵌的硬件存储器资源。这种方法有两个问题：第一是要清晰合理地在代码中描述存储器，有一定的设计难度；第二是最终实现结果在很大的程度上取决于综合器的类推算法，有一定的不确定性。这种方法经常使用在两个场合；第一是
PLD 本身没有块 RAM 或分布式 RAM 等专用存储单元（如 CPLD
等）；第二是用户非常熟悉综合器的类推算法，并能通过综合器的相关约束属性指定所需使用的底层硬件
RAM 资源。</p></li>
</ul>
<h2 id="简单的时钟分频电路">3.7. 简单的时钟分频电路</h2>
<p>时钟电路是 PLD 设计的核心。<a href="https://josh-gao.top/posts/53b8b42e.html">Part 5——RTL
设计与编码指导</a>中介绍了同步时序电路的相关知识，并介绍了如何处理一些常用时钟电路设计。</p>
<p>对于 PLD 设计而言，由于大多数 PLD（特别是FPGA）都内嵌有专用 PLL/DLL
模块，通过这些内嵌的 PLL 或
DLL，可以实现灵活的分频/倍频（一般可实现小数分频倍频）、移相等调整与运算。所以这类
PLD 设计时钟电路的方法如上小节一样，都推荐使用器件商的开发平台中内嵌的
IP 生成器，在图形化界面中直接配置 PLL/DLL 的参数，生产相应的
IP，然后在用户逻辑中直接调用该 IP 即可。</p>
<p>这里介绍的一般时钟分频电路建模方法，适用于没有上述内嵌 PLL/DLL
时钟电路（如 CPLD、ASIC 设计等），或内嵌 PLL/DLL
资源不能满足所需时钟关系时的一些处理方法。</p>
<p>一般来说，PLD
中的<strong>主要时钟处理为分频和移相</strong>。偶数分频十分简单，只需用高速时钟做一个同小计数器，然后在相应的位抽头即可。奇数分频电路相对复杂一些。移相的基本方法是通过高速时钟调整相位，或者通过时钟反向调整相位。</p>
<ol type="1">
<li><p><strong>偶数分频 + 相位控制</strong></p>
<p></p><figure class="highlight verilog"><figcaption><span>clk_div_phase.v</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">将一个 200kHz 时钟做 2 分频、4 分频、8 分频, 要求分频后的 3 个时钟同相, 而且</span></span><br><span class="line"><span class="comment">与源时钟近似同相。在这个设计中, 因为输入时钟速率很低, 仅有 200kHz, 而一般</span></span><br><span class="line"><span class="comment">PLD 内嵌的 PLL的输入频率下限都在 MHz 级，所以无法使用 PLL 完成分频与相位调整</span></span><br><span class="line"><span class="comment">要求。另外对于低速时钟的分频，使用计数器既能满足时序要求，也比较节约器件资源。</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> clk_div_phase (rst, clk_200K, clk_100K, clk_50K, clk_25K);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>        clk_200K;</span><br><span class="line"><span class="keyword">input</span>        rst;</span><br><span class="line"><span class="keyword">output</span>       clk_100K, clk_50K, clk_25K;</span><br><span class="line"><span class="keyword">wire</span>         clk_100K, clk_50K, clk_25K;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">2</span>:<span class="number">0</span>] cnt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk_200K <span class="keyword">or</span> <span class="keyword">negedge</span> rst)</span><br><span class="line">    <span class="keyword">if</span> (!rst)</span><br><span class="line">        cnt &lt;= <span class="number">3'b000</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cnt &lt;= cnt + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> clk_100K = ~cnt [<span class="number">0</span>];</span><br><span class="line"><span class="keyword">assign</span> clk_50K  = ~cnt [<span class="number">1</span>];</span><br><span class="line"><span class="keyword">assign</span> clk_25K  = ~cnt [<span class="number">2</span>];</span><br><span class="line"><span class="comment">// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></tbody></table></figure><p></p>
<p>这个设计的<strong>难点在于如何调整所有时钟的相位关系</strong>。本例巧妙地<strong><mark class="label primary">通过对计数器每个 bit 的反向，完成了所有分频后时钟的相位调整，保证了3个分频后时钟的相位严格同相</mark></strong>。对硬件结构比较清晰则会发现，这
3
个派生时钟与源时钟相比有一个非常小的相位差，<strong>这个相位差是由寄存器的固有
<span class="math inline">\(T_{\mathrm{co}}\)</span>（延迟）和计数器累加的组合逻辑造成的</strong>，一般来说在
PLD 中寄存器固有 <span class="math inline">\(T_{\mathrm{co}}\)</span>
的典型值为 1~2ns，而简单的加法运算的组合逻辑门延迟也约为 ns
级，这两个延迟的总和与时钟周期相比微乎其微。如果忽略这个 ns
级的延迟，则通过每个分频时钟的反向，使 3
个分频时钟与源时钟同相，也就是说这 4 个时钟有共同的上升沿。</p></li>
<li><p><strong>奇数分频</strong></p>
<p></p><figure class="highlight verilog"><figcaption><span>clk_3div.v</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">对源时钟做 3 分频, 要求 3 分频时钟占空比为50％。</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> clk_3div (clk, reset, clk_out);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>       clk, reset;</span><br><span class="line"><span class="keyword">output</span>      clk_out;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>]   state;</span><br><span class="line"><span class="keyword">reg</span>         clk1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> reset)</span><br><span class="line">    <span class="keyword">if</span>(!reset)</span><br><span class="line">        state &lt;= <span class="number">2'b00</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">case</span>(state)</span><br><span class="line">            <span class="number">2'b00</span>:  state &lt;=  <span class="number">2'b01</span>;</span><br><span class="line">            <span class="number">2'b01</span>:  state &lt;=  <span class="number">2'b11</span>;</span><br><span class="line">            <span class="number">2'b11</span>:  state &lt;=  <span class="number">2'b00</span>;</span><br><span class="line">            <span class="keyword">default</span>:state &lt;=  <span class="number">2'b00</span>;</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">negedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> reset)</span><br><span class="line">    <span class="keyword">if</span>(!reset)</span><br><span class="line">        clk &lt;= <span class="number">1'b0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        clk1 &lt;= state[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> clk_out = state[<span class="number">0</span>] &amp; clk1;</span><br><span class="line"><span class="comment">// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></tbody></table></figure><p></p>
<p>3 分频、5 分频等奇数分频时钟可以使用 <code>case</code>
结构或简单的状态机（FSM）描述，设计<strong>难点在于如何通过组合逻辑调整分频时钟的占空比。</strong></p></li>
</ol>
<h2 id="串并转换建模">3.8. 串/并转换建模</h2>
<p>数据流串/并转换的实现方法多种多样，根据数据的排序和数量的要求，可以选用移位寄存器、RAM
等实现。对于<strong>数量比较小的设计可以采用移位寄存器</strong>完成串/并转换；对于<strong>排列顺序有规定的串/并转换，可以用
<code>case</code>
语句判断实现</strong>；对于<strong>复杂的串/并转换，还可以用状态机实现</strong>。</p>
<figure class="highlight verilog"><figcaption><span>srl2pal.v</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">简单的串行到并行转换, 数据排列顺序是高位在前。</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> srl2pal (clk, rst, srl_in, pal_out);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>        clk;</span><br><span class="line"><span class="keyword">input</span>        rst;</span><br><span class="line"><span class="keyword">input</span>        srl_in;</span><br><span class="line"><span class="keyword">output</span> [<span class="number">7</span>:<span class="number">0</span>] pal_out;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="keyword">reg</span>    [<span class="number">7</span>:<span class="number">0</span>] pal_out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst)</span><br><span class="line">    <span class="keyword">if</span> (!rst)</span><br><span class="line">        pal_out &lt;= <span class="number">8'b0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pal_out &lt;= {pal_out,srl_in};</span><br><span class="line"><span class="comment">// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="同步复位和异步复位">3.9.
同步复位和异步复位<a id="toc.3.9"></a></h2>
<p>复位电路是每个数字逻辑电路的最重要组成部分之一。复位的目的有两个方面：第一是仿真的时候使电路进入初始状态或者其他预知状态；第二是对于综合实现的真实电路，通过复位使电路进入初始状态或者其他预知状态。一般来说，逻辑电路的任何一个寄存器，存储器结构和其他逻辑单元都必须要附加复位逻辑以保证电路能够从错误状态中恢复，可靠地工作。</p>
<p><strong>常用的复位信号为低电平有效信号，在应用时外部引脚接<mark class="label primary">上拉电阻</mark>，这样能增加复位电路的抗干扰性能。</strong></p>
<p>复位方式大致分为两类：同步复位和异步复位。这两种复位方式各有优缺点，因而应用场合不同。</p>
<h3 id="同步复位">3.9.1. 同步复位</h3>
<p>所谓同步复位是指：当复位信号变化时，并<strong>不立即生效，只有当有效时钟沿采样到已变化的复位信号后，才对所有寄存器复位</strong>。同步复位的应用要点如下：</p>
<h4 id="同步复位电路建模">3.9.1.1. 同步复位电路建模</h4>
<ol type="1">
<li><p>指定<strong>同步复位时，<code>always</code>
的敏感表中仅有时钟沿信号</strong>，仅仅当时钟沿采到同步复位的有效电平时，才会在时钟沿到达时刻进行复位操作。如果目标器件或可用库中的触发器本身包含同步复位端口，则在实现时可用直接调用同步复位端。然而很多目标器件（如
PLD）和 ASIC
库的触发器本身并不包含同步复位端口，则复位信号与输入信号组成某种组合逻辑（比如复位低电平有效，则复位与输入信号两者相与即可），然后输入至寄存器的输入端。<strong>为了提高复位电路的优先级，一般在电路描述时使用带有优先级的
<code>if ... else</code> 结构，复位电路在第一个 <code>if</code>
下描述，其他电路在 <code>else</code> 或 <code>else ... if</code>
分支中描述。</strong></p>
<p></p><figure class="highlight verilog"><figcaption><span>syn_rst.v</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">同步复位电路建模。</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> syn_rst (clk, rst_, cnt1, cnt2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>        clk;</span><br><span class="line"><span class="keyword">input</span>        rst_;</span><br><span class="line"><span class="keyword">output</span> [<span class="number">4</span>:<span class="number">0</span>] cnt1 , cnt2;</span><br><span class="line"><span class="keyword">reg</span>    [<span class="number">4</span>:<span class="number">0</span>] cnt1 , cnt2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk)</span><br><span class="line">    <span class="keyword">if</span> (!rst_) <span class="keyword">begin</span></span><br><span class="line">        cnt1 &lt;= <span class="number">4'b0</span>;</span><br><span class="line">        cnt2 &lt;= <span class="number">4'b0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (cnt1 &lt; <span class="number">2'b11</span>)</span><br><span class="line">            cnt1 &lt;= cnt1 + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cnt1 &lt;= cnt1;</span><br><span class="line">        cnt2 &lt;= cnt1 - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="comment">// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></tbody></table></figure><p></p></li>
<li><p>很多目标器件（如 FPGA 和 CPLD）和 ASIC
库的触发器本身并不包含同步复位端口，则同步复位会被实现为如<a href="#fig.4-4">图 4-4</a> 所示的结构。</p>
<p><a id="fig.4-4"></a></p>
<figure>
<img data-src="../images/post/2020-12-02-josh-verilog-part-4/2020-12-02-josh-verilog-part-4-040-SynchronousReset-01.png" width="600" alt="图 4-4 同步复位实现结构示意图">
<figcaption aria-hidden="true">图 4-4
同步复位实现结构示意图</figcaption>
</figure></li>
</ol>
<h4 id="同步复位的优点">3.9.1.2. 同步复位的优点</h4>
<ul>
<li><p>同步复位利于基于周期机制的仿真器进行仿真。</p></li>
<li><p>使用同步复位可以设计 100%
的同步时序电路，利于时序分析，其综合结果的频率往往较高。</p></li>
<li><p>同步复位仅在时钟的有效沿生效，可以<strong>有效地避免因复位电路毛刺造成的亚稳态和错误</strong>。在进行复位和释放复位信号时，都是仅当时钟沿采到复位信号电平变化时才进行相关操作，如果复位信号树的组合逻辑出现了某种毛刺，此时时钟沿采样到毛刺的概率非常低，通过时钟沿采样，可以十分有效地过滤复位电路组合逻辑产生的毛刺，增强电路稳定性。</p>
<div class="note info"><p>同步时序电路的概念参见 <a href="https://josh-gao.top/posts/53b8b42e.html#toc.2.1">Part 5——RTL
设计与编码指导的 2.1 同步设计原则</a>小节；亚稳态的概念参见 <a href="https://josh-gao.top/posts/53b8b42e.html#toc.2.2">Part 5——RTL
设计与编码指导的 2.2 亚稳态</a>小节。</p>
</div></li>
</ul>
<h4 id="同步复位的缺点">3.9.1.3. 同步复位的缺点</h4>
<ul>
<li><p>很多目标器件（如 FPGA 和 CPLD）和 ASIC
库的触发器本身并不包含同步复位端口，使用同步复位会增加更多逻辑资源。</p></li>
<li><p>同步复位的最大问题在于必须保证复位信号的有效时间足够长，从而才能保证所有触发器都有效地复位。由于仅当时钟沿采样到复位信号时才会进行复位操作，所以<strong>同步复位信号的持续时间起码要大于设计的最长时钟周期</strong>，以保证所有时钟的有效沿都能采样到同步复位信号。其实仅仅保证同步复位信号的持续时间大于最慢的时钟周期还是不够的，设计中<strong>还要考虑到同步复位信号树通过所有相关组合逻辑路径的延时以及由于时钟布线产生的偏斜（skew）</strong>，<strong><mark class="label primary">只有同步复位大于时钟最大周期加上同步信号穿过的组合逻辑路径延迟加上时钟偏斜时，才能保证同步复位可靠、彻底</mark></strong>。</p>
<p>同步复位实现结构如<a href="#fig.4-5">图 4.5</a>
所示，假设同步复位逻辑树组合逻辑的延时为 <span class="math inline">\(\mathtt{t1}\)</span>，复位信号传播路径的最大延迟为
<span class="math inline">\(\mathtt{t2}\)</span>，最慢时钟的周期为 <span class="math inline">\(\mathtt{Period max}\)</span>，时钟的 skew 为 <span class="math inline">\(\mathtt{(clk2 - clk1)}\)</span>，则同步复位的周期
<span class="math inline">\(\mathtt{Tsyn\_rst}\)</span>
应该满足下述公式：</p>
<p><span class="math display">\[
  \mathtt{Tsyn\_rst &gt; Period max + \left(clk2 - clk1 \right) + t1 +
t2}
  \]</span></p>
<p><a id="fig.4-5"></a></p>
<figure>
<img data-src="../images/post/2020-12-02-josh-verilog-part-4/2020-12-02-josh-verilog-part-4-050-SynchronousReset-02.png" width="800" alt="图 4-5 同步复位实现结构示意图">
<figcaption aria-hidden="true">图 4-5
同步复位实现结构示意图</figcaption>
</figure></li>
</ul>
<h3 id="异步复位">3.9.2. 异步复位</h3>
<h4 id="异步复位电路建模">3.9.2.1. 异步复位电路建模</h4>
<ol type="1">
<li><p>指定异步复位时，只需在 <code>always</code>
的敏感表中加入复位信号的有效沿即可，当复位信号有效沿到达时，无论时钟沿是否有效，复位立即发挥功能。</p>
<p></p><figure class="highlight verilog"><figcaption><span>asyn_rst.v</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">异步复位电路建模。</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> asyn_rst (clk, rst_, cnt1, cnt2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>        clk;</span><br><span class="line"><span class="keyword">input</span>        rst_;</span><br><span class="line"><span class="keyword">output</span> [<span class="number">4</span>:<span class="number">0</span>] cnt1 , cnt2;</span><br><span class="line"><span class="keyword">reg</span>    [<span class="number">4</span>:<span class="number">0</span>] cnt1 , cnt2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_)</span><br><span class="line">    <span class="keyword">if</span> (!rst_) <span class="keyword">begin</span></span><br><span class="line">        cnt1 &lt;= <span class="number">4'b0</span>;</span><br><span class="line">        cnt2 &lt;= <span class="number">4'b0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (cnt1 &lt; <span class="number">2'b11</span>)</span><br><span class="line">        cnt1 &lt;= cnt1 + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cnt1 &lt;= cnt1;</span><br><span class="line">    cnt2 &lt;= cnt1 - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="comment">// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></tbody></table></figure><p></p></li>
<li><p>大多数目标器件（如 FPGA 和 CPLD）和 ASIC
库的触发器都包含异步复位端口，异步复位会被直接接到触发器的异步复位端口。同步复位实现结构如<a href="#fig.4-6">图 4-6</a> 所示。</p></li>
</ol>
<p><a id="fig.4-6"></a></p>
<figure>
<img data-src="../images/post/2020-12-02-josh-verilog-part-4/2020-12-02-josh-verilog-part-4-060-AsynchronousReset-01.png" width="500" alt="图 4-6 异步复位实现结构示意图">
<figcaption aria-hidden="true">图 4-6
异步复位实现结构示意图</figcaption>
</figure>
<h4 id="异步复位的优点">3.9.2.2. 异步复位的优点</h4>
<ul>
<li><p>由于多数目标器件（如FPGA 和 CPLD）和 ASIC
库的触发器都包含异步复位端口，异步复位会节约逻辑资源。</p></li>
<li><p>异步复位设计简单。</p></li>
<li><p>对于大多数 FPGA, 都有专用的全局异步复位/置位资源（GSR, Global Set
Reset），使用 GSR
资源，异步复位到达所有寄存器的偏斜（skew）最小。</p></li>
</ul>
<h4 id="异步复位的缺点">3.9.2.3. 异步复位的缺点</h4>
<ul>
<li><p>异步复位的作用和释放与时钟沿没有直接关系，在异步复位生效时问题并不明显，但是当异步复位释放时，如果异步复位信号释放时间和时钟的有效沿到达时间几乎一致，则容易造成触发器输出为<strong>亚稳态</strong>，造成逻辑错误。</p></li>
<li><p>另外，如果异步复位逻辑树的组合逻辑产生了<strong>毛刺</strong>，则毛刺的有效沿会使触发器误复位，造成逻辑错误。</p></li>
</ul>
<h4 id="推荐的复位电路设计方式">3.9.2.4. 推荐的复位电路设计方式</h4>
<ol type="1">
<li><p>推荐的复位电路设计方式是<strong>异步复位，同步释放</strong>。这种方式，可以有效地继承异步复位设计简单的优势，并克服异步复位的上述风险与缺陷。</p></li>
<li><p>在 FPGA/CPLD
等可编程逻辑器件设计中，使用<strong>异步复位，同步释放</strong>可以节约器件资源，并获得稳定可靠地复位效果，是推荐的复位设计方式。</p></li>
</ol>
<figure class="highlight verilog"><figcaption><span>asyn_rst_syn_release.v</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">异步复位，同步释放电路建模。异步复位，同步释放的具体设计方法很多，关键是如何保证</span></span><br><span class="line"><span class="comment">同步地释放复位信号，本例举例的方法是在复位信号释放时，用系统时钟采样后再将复位信</span></span><br><span class="line"><span class="comment">号送到寄存器的异步复位端。</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> asyn_rst_syn_release(clk, rst_, cnt1, cnt2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>        clk;</span><br><span class="line"><span class="keyword">input</span>        rst_;</span><br><span class="line"><span class="keyword">output</span> [<span class="number">4</span>:<span class="number">0</span>] cnt1 , cnt2;</span><br><span class="line"><span class="keyword">reg</span>    [<span class="number">4</span>:<span class="number">0</span>] cnt1 , cnt2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="comment">// reset release circuit</span></span><br><span class="line"><span class="keyword">reg</span> reset_reg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk)</span><br><span class="line">     reset_reg &lt;= rst_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> reset_reg)</span><br><span class="line">    <span class="keyword">if</span> (!rst_) <span class="keyword">begin</span></span><br><span class="line">        cnt1 &lt;= <span class="number">4'b0</span>;</span><br><span class="line">        cnt2 &lt;= <span class="number">4'b0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (cnt1 &lt; <span class="number">2'b11</span>)</span><br><span class="line">            cnt1 &lt;= cnt1 + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cnt1 &lt;= cnt1;</span><br><span class="line">        cnt2 &lt;= cnt1 - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="comment">// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></tbody></table></figure>
<p>上例使用时钟<strong>将外部输入的异步复位信号寄存一个节拍</strong>后，再送到触发器异步复位端口的设计方法的另一个好处在于：做
STA（静态时序分析）分析时，时序工具会自动检查同步后的异步复位信号和时钟的到达（Recovery）/撤销（Removal）时间关系，如果因布线造成的
skew 导致该到达I撤销时间不能满足，STA
工具会上报该路径，帮助设计者进一步分析问题。异步部位同步化电路如<a href="#fig.4-7">图 4-7</a> 所示。</p>
<p><a id="fig.4-7"></a></p>
<figure>
<img data-src="../images/post/2020-12-02-josh-verilog-part-4/2020-12-02-josh-verilog-part-4-070-AsynchronousReset-02.png" width="500" alt="图 4-7 异步复位同步化">
<figcaption aria-hidden="true">图 4-7 异步复位同步化</figcaption>
</figure>
<h2 id="用-case-和-if-...-else-建模">3.10. 用 <code>case</code> 和
<code>if ... else</code> 建模<a id="toc.3.10"></a></h2>
<p>一般来说， <code>case</code> 语句是“平行”（Balance,
Parallel）的结构，即每个 <code>case</code>
分支的条件判断和执行都是并行的，没有“优先级（Prior）” 。而
<code>if ... else</code>、<code>if ... else if ...</code>
语句可以建模<strong>无优先级</strong>的判断结构，<code>if ... if ... if ...</code>
结构可以建模具<strong>有优先级</strong>的判断结构。</p>
<p>一般来说，<strong>建立优先级结构（优先级树）会消耗组合逻辑资源</strong>，如果非设计需要，推荐使用
<code>case</code> 或 <code>if ... else</code>
建立无优先级的判断结构。但是某些设计中，有些信号要求先到达（如：关键使能信号、选择信号等），而有些信号需要后到达（如：慢速信号、有效时间较长的信号等），此时则需要使用
<code>if ... if ...</code> 结构建立具有优先级的判断结构。</p>
<p>目前综合工具的优化能力越来越强，大多数情况下可以将不必要的优先级树优化掉，综合结果是否具有优先级，很大的程度上取决于综合工具的类型、综合工具的版本、目标器件（目标库）的固有硬件结构。</p>
<p>为了形象地理解优先级判断结构建模的问题，下面使用几个简单的例子，分别使用业界最流行的两个综合工具
Synplify Pro 和 Precision RTL 分别综合，分析其综合结果的 RTL
视图和结构视图（初学者不用关心这两个综合工具的使用方法，而需要重点观察综合结果的
RTL 视图和结构视图，分析不同语句建模的区别）。</p>
<figure class="highlight verilog"><figcaption><span>case1.v</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">casex语句建模</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> case1(a, b, c, d, sel0, sel1, sel2, sel3, z);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> a, b, c, d;</span><br><span class="line"><span class="keyword">input</span> sel0, sel1, sel2, sel3;</span><br><span class="line"><span class="keyword">output</span> z;</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span> z;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="keyword">always</span> @(a <span class="keyword">or</span> b <span class="keyword">or</span> c <span class="keyword">or</span> d <span class="keyword">or</span> sel0, sel1, sel2, sel3) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">casex</span> ({sel0, sel1, sel2, sel3})</span><br><span class="line">        <span class="number">4'b1xxx</span>: z = d;</span><br><span class="line">        <span class="number">4'bx1xx</span>: z = c;</span><br><span class="line">        <span class="number">4'bxx1x</span>: z = b;</span><br><span class="line">        <span class="number">4'bxxx1</span>: z = a;</span><br><span class="line">        <span class="keyword">default</span>: z = <span class="number">1'b0</span>;</span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight verilog"><figcaption><span>single_if.v</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">单if语句(if ... else if ... else if ...)建模</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> single_if(a, b, c, d, sel0, sel1, sel2, sel3, z);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> a, b, c, d;</span><br><span class="line"><span class="keyword">input</span> sel0, sel1, sel2, sel3;</span><br><span class="line"><span class="keyword">output</span> z;</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span> z;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="keyword">always</span> @(a <span class="keyword">or</span> b <span class="keyword">or</span> c <span class="keyword">or</span> d <span class="keyword">or</span> sel0 <span class="keyword">or</span> sel1 <span class="keyword">or</span> sel2 <span class="keyword">or</span> sel3) <span class="keyword">begin</span></span><br><span class="line">    z = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (sel3)</span><br><span class="line">        z = d;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (sel2)</span><br><span class="line">        z = c;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (sel1)</span><br><span class="line">        z = b;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (sel0)</span><br><span class="line">        z = a;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight verilog"><figcaption><span>mult_if.v</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">多if语句(if ... if ... if ...)建模</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> mult_if(a, b, c, d, sel0, sel1, sel2, sel3, z);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> a, b, c, d;</span><br><span class="line"><span class="keyword">input</span> sel0, sel1, sel2, sel3;</span><br><span class="line"><span class="keyword">output</span> z;</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span> z;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="keyword">always</span> @(a <span class="keyword">or</span> b <span class="keyword">or</span> c <span class="keyword">or</span> d <span class="keyword">or</span> sel0 <span class="keyword">or</span> sel1 <span class="keyword">or</span> sel2 <span class="keyword">or</span> sel3) <span class="keyword">begin</span></span><br><span class="line">    z = <span class="number">0</span>;                <span class="comment">// must add default value</span></span><br><span class="line">    <span class="keyword">if</span> (sel0) z = a;</span><br><span class="line">    <span class="keyword">if</span> (sel1) z = b;</span><br><span class="line">    <span class="keyword">if</span> (sel2) z = c;</span><br><span class="line">    <span class="keyword">if</span> (sel3) z = d;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></tbody></table></figure>
<p>上面的描述如果在 Synopsys 公司的 Design compiler 或 FPGA Compiler
等综合工具的较早版本下综合，多 <code>if</code>
语句（<code>if ... if ... if ...</code>）综合结构如<a href="#fig.4-8">图
4-8</a> 所示，而单 <code>if</code>
语句（<code>if ... else if ... else if ...</code>）和 <code>casex</code>
语句综合结构如<a href="#fig.4-9">图 4-9</a> 所示。从图中分析可以看到多
<code>if</code> 语句建模结构带有优先级，这时最后一条 <code>if</code>
语句对应的 <code>sel3</code> 和 <code>d</code> 的优先级最高；而单
<code>if</code> 语句和 <code>casex</code> 语句建模时没有建立优先级。</p>
<p><a id="fig.4-8"></a></p>
<figure>
<img data-src="../images/post/2020-12-02-josh-verilog-part-4/2020-12-02-josh-verilog-part-4-080-MultipleIf.png" width="800" alt="图 4-8 多 if 语句 Design Compiler 综合结构视图">
<figcaption aria-hidden="true">图 4-8 多 <code>if</code> 语句 Design
Compiler 综合结构视图</figcaption>
</figure>
<p><a id="fig.4-9"></a></p>
<figure>
<img data-src="../images/post/2020-12-02-josh-verilog-part-4/2020-12-02-josh-verilog-part-4-090-SingleIf.png" width="800" alt="图 4-9 单 if 语句和 casex 语句建模使用 Design Compiler 综合结构视图">
<figcaption aria-hidden="true">图 4-9 单 <code>if</code> 语句和
<code>casex</code> 语句建模使用 Design Compiler
综合结构视图</figcaption>
</figure>
<p>但是由于综合工具的综合优化策略不同，即使对于相同的代码，其综合结果也不尽相同。为了加深理解，使用业界最流行的
PLD 综合工具 Synplify Pro 和 Precision RTL 对多 <code>if</code>
语句（<code>if ... if ... if ...</code>）、单 <code>if</code>
语句（<code>if ... else if ... else if ...</code>）和 <code>casex</code>
语句分别综合，其中多 <code>if</code> 语句的 Synplify Pro 综合结果对应的
RTL 视图和工艺结构视图分别如<a href="#fig.4-10">图 4-10</a>、<a href="#fig.4-11">图 4-11</a> 所示；多 <code>if</code> 语句的 Precision
RTL 综合结果对应的 RTL 视图和工艺结构视图分别如<a href="#fig.4-12">图
4-12</a>、<a href="#fig.4-13">图 4-13</a> 所示。简单分析即可发现，这 3
种语句的 Synplify Pro 和 Precision RTL
综合结果基本一致，都没有明显的优先级结构。这是因为 Synplify Pro 和
Precision RTL
这两种综合工具为了节约硬件资源，根据其优化算法．优化掉了冗余的优先级判断结构。</p>
<p><a id="fig.4-10"></a></p>
<figure>
<img data-src="../images/post/2020-12-02-josh-verilog-part-4/2020-12-02-josh-verilog-part-4-100-MultipleIfSynplifyProRTLView.png" width="600" alt="图 4-10 多 if 语句的 Synplify Pro 综合结果 RTL 视图">
<figcaption aria-hidden="true">图 4-10 多 <code>if</code> 语句的
Synplify Pro 综合结果 RTL 视图</figcaption>
</figure>
<p><a id="fig.4-11"></a></p>
<figure>
<img data-src="../images/post/2020-12-02-josh-verilog-part-4/2020-12-02-josh-verilog-part-4-110-MultipleIfSynplifyProTechView.png" width="800" alt="图 4-11 多 if 语句的 Synplify Pro 综合结果工艺结构视图">
<figcaption aria-hidden="true">图 4-11 多 <code>if</code> 语句的
Synplify Pro 综合结果工艺结构视图</figcaption>
</figure>
<p><a id="fig.4-12"></a></p>
<figure>
<img data-src="../images/post/2020-12-02-josh-verilog-part-4/2020-12-02-josh-verilog-part-4-120-MultipleIfPrecisionRTLRTLView.png" width="800" alt="图 4-12 多 if 语句的 Precision RTL 综合结果 RTL 视图">
<figcaption aria-hidden="true">图 4-12 多 <code>if</code> 语句的
Precision RTL 综合结果 RTL 视图</figcaption>
</figure>
<p><a id="fig.4-13"></a></p>
<figure>
<img data-src="../images/post/2020-12-02-josh-verilog-part-4/2020-12-02-josh-verilog-part-4-130-MultipleIfPrecisionRTLTechView.png" width="800" alt="图 4-13 多 if 语句的 Precision RTL 综合结果工艺结构视图">
<figcaption aria-hidden="true">图 4-13 多 <code>if</code> 语句的
Precision RTL 综合结果工艺结构视图</figcaption>
</figure>
<p>所以，从语法上讲，多 <code>if</code>
语句（<code>if ... if ... if ...</code>）可以建模具有优先级的条件判断结构，而单
<code>if</code> 语句（<code>if ... else if ... else if ...</code>）和
<code>case</code>
语句用于建模不带优先级的条件判断。但是随着综合工具优化能力的不断增强，新型的综合工具，大多时候会自动优化掉优先级结构，以减少芯片面积，提高时序性能。条件结构的综合结果是否带有优先级不但取决于综合工具的类型和版本．还和目标器件或目标库有直接关系。</p>
<p>这里推荐初学者尽量使用 <code>case</code> 或单 <code>if</code>
语句（<code>if ... else if ... else if ...</code>）建模判断结构，这样不论何种综合工具，
一般情况下都不会产生不必要的优先级结构。使用单 <code>if</code>
结构．如果没有为所有的 <code>if</code> 指定默认的输出，则会生成
Latch（锁存器），如将上例代码删除 <code>z=0</code>
这一默认输出，而改为下面的描述，则会生成 Latch。使用 Synplify Pro
综合的综合结果的RTL 视图和工艺结构视图分别如<a href="#fig.4-14">图
4-14</a> 、<a href="#fig.4-15">图 4-15</a> 所示。</p>
<figure class="highlight verilog"><figcaption><span>mult_if.v</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">多if语句(if ... if ... if ...)建模, 未指定默认输出, 生成 Latch</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> mult_if(a, b, c, d, sel0, sel1, sel2, sel3, z);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> a, b, c, d;</span><br><span class="line"><span class="keyword">input</span> sel0, sel1, sel2, sel3;</span><br><span class="line"><span class="keyword">output</span> z;</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span> z;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="keyword">always</span> @(a <span class="keyword">or</span> b <span class="keyword">or</span> c <span class="keyword">or</span> d <span class="keyword">or</span> sel0 <span class="keyword">or</span> sel1 <span class="keyword">or</span> sel2 <span class="keyword">or</span> sel3) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (sel0) z = a;</span><br><span class="line">    <span class="keyword">if</span> (sel1) z = b;</span><br><span class="line">    <span class="keyword">if</span> (sel2) z = c;</span><br><span class="line">    <span class="keyword">if</span> (sel3) z = d;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></tbody></table></figure>
<p><a id="fig.4-14"></a></p>
<figure>
<img data-src="../images/post/2020-12-02-josh-verilog-part-4/2020-12-02-josh-verilog-part-4-140-MultipleIfSynplifyProRTLView.png" width="800" alt="图 4-14 多 if 语句无默认输出时 Synplify Pro 综合结果 RTL 视图">
<figcaption aria-hidden="true">图 4-14 多 <code>if</code>
语句无默认输出时 Synplify Pro 综合结果 RTL 视图</figcaption>
</figure>
<p><a id="fig.4-15"></a></p>
<figure>
<img data-src="../images/post/2020-12-02-josh-verilog-part-4/2020-12-02-josh-verilog-part-4-150-MultipleIfSynplifyProTechView.png" width="800" alt="图 4-14 多 if 语句无默认输出时 Synplify Pro 综合结果工艺结构视图">
<figcaption aria-hidden="true">图 4-14 多 <code>if</code>
语句无默认输出时 Synplify Pro 综合结果工艺结构视图</figcaption>
</figure>
<p>如果生成的 Latch
并非设计者意愿，则会造成与设计意图的偏离甚至是错误。而使用完整的
<code>if. .. else</code> 或 <code>case</code>（全译码或加有
<code>default</code> 关键字）语句，则可以有效地避免无意之中生成的 Latch
。在 <a href="https://josh-gao.top/posts/fd117896.html#toc.3.4">Part
3——描述方式和设计层次的 3.4 高级编程语句</a>中也有防止产生不必要 Latch
的相关描述，可以参考。</p>
<h2 id="可综合的-verilog-语法子集">3.11. 可综合的 Verilog 语法子集</h2>
<p>通过上节建模的感性认识，可以发现，在RTL 级建模时，使用的可综合的
Verilog 语法是整个 Verilog 语法的一个非常小的子集。其实可综合的 Verilog
常用的关键字非常有限，这恰恰体现了 Verilog
语言是硬件描述语言的本质。Verilog HDL
作为硬件描述语言，其本质在于把硬件电路流畅、合理地转换为语言形式，而使用较少的一些关键字就可以有效地将电路转换到可综合的
RTL 语言结构。</p>
<p>常用的RTL 语法结构列举如下：</p>
<ul>
<li>模块声明：<code>module ... endmodule</code>；</li>
<li>端口声明：<code>input</code>、<code>output</code>、<code>inout</code>；</li>
<li>信号类型： <code>wire</code>、<code>reg</code>、<code>tri</code>等，
<code>integer</code> 通常用于 <code>for</code> 语句中的索引；</li>
<li>参数定义： <code>parameter</code>；</li>
<li>运算操作符：各种逻辑操作、移位操作、算术操作符，请参考<a href="https://josh-gao.top/posts/fd2ca242.html#toc.10">Part 2——Verilog
语言基础的 10. 操作数、操作符和表达式</a>部分；</li>
<li>比较判断：
<code>case [default] endcase (casex/casez)</code>、<code>if ... else ...</code>；</li>
<li>连续赋值： <code>assign</code>、问号表达式；</li>
<li><code>always</code> 模块：建模时序和组合逻辑（敏感表为电平或
<code>posedge</code> 或 <code>negedge</code> 的沿信号）；</li>
<li>语法分割符： <code>begin ... end</code>；</li>
<li>任务定义：<code>task ... end task</code>；</li>
<li>循环语句： <code>for</code>。</li>
</ul>
<p>这些关键字的语法在 <a href="https://josh-gao.top/posts/fd2ca242.html">Part 2——Verilog
语言基础</a>和 <a href="https://josh-gao.top/posts/fd117896.html">Part
3——描述方式和设计层次</a> 中都有详细介绍，请参考这部分内容。</p>
<h1 id="小结">4. 小结</h1>
<p>本文首先介绍了 RTL
和综合的基本概念，然后摆脱长篇大论的理论说教模式，通过一个个具体范例，力图使初学者逐步建立起可综合
RTL 子集的概念。希望大家认真琢磨常用电路结构的建模方法，在实践中掌握 RTL
级设计的基本技巧。</p>
<h1 id="参考文献">参考文献</h1>
<p>EDA 先锋工作室. <em>轻松成为设计高手——Verilog HDL 实用精解.</em>
北京航空航天大学出版社, 2012.</p>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/css/markmap.css">

<script src="/js/markmap.js"></script>
]]></content>
      <categories>
        <category>Josh 的学习笔记</category>
        <category>Verilog</category>
      </categories>
      <tags>
        <tag>Verilog</tag>
        <tag>HDL</tag>
        <tag>非阻塞赋值</tag>
        <tag>阻塞赋值</tag>
        <tag>组合逻辑</tag>
        <tag>三态</tag>
        <tag>同步复位</tag>
        <tag>异步复位</tag>
        <tag>条件语句</tag>
      </tags>
  </entry>
  <entry>
    <title>Josh&#39;s Note — 多抽样率信号处理&lt;br&gt;Part 1 抽样率转换</title>
    <url>/posts/e1b609bc.html</url>
    <content><![CDATA[<h1 id="本文要点">本文要点</h1>
<ul>
<li>什么是抽取？什么是内插？两者的作用分别是什么？</li>
<li>抽取、内插前后信号在时域和频域如何变化？</li>
<li>抗混叠滤波器和除镜像滤波器的原理和作用是什么？</li>
<li>如何实现分数倍抽样率转换？</li>
<li>如何利用 MATLAB 实现抽样率转换？</li>
</ul>
<p>  多抽样率信号处理的研究对象是不同抽样率<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>下的信号，其中抽样率转换 (Sampling
Rate Conversion, SRC)
是核心问题之一。早期的抽样率转换通常采用模拟方法，即将给定的抽样信号通过数模转换器
(Digital-to-Analog Converter, DAC) 转换成模拟信号
(连续时间信号)，再对该模拟信号进行新的抽样，经模数转换器
(Analog-to-Digital Converter, DAC)
得到所需的抽样信号。而随着数字电路的普及和数字信号处理技术的发展，采用数字方法，即直接在离散时间域上完成抽样率转换已成为当前的主要方式。相比于模拟方法，数字方法不需要进行D/A和A/D转换，降低了系统的复杂度，同时避免了由量化、编码等过程产生的失真问题。</p>
<p>  本文首先回顾采样的概念；随后介绍抽样率转换的两个基本运算单元，即抽取和内插；进而讨论如何利用抽取和内插实现分数倍抽样率转换；最后介绍抽样率转换在
MATLAB 上的实现。</p>
<span id="more"></span>
<h1 id="采样">采样</h1>
<p>  采样 (sampling)
是将连续时间信号转换成离散时间信号的过程。设连续时间信号 <span class="math inline">\(x_c(t)\)</span>, 现对其进行均匀采样 (uniform
sampling)，即每隔时间 <span class="math inline">\(T\)</span>
取一个点，于是得到一组离散点列, 记作</p>
<p><span class="math display">\[\begin{equation}
  x\left[ n \right] =\left. x_c\left( t \right) \right|_{t=nT}=x_c\left(
nT \right)
\end{equation}
\]</span></p>
<p>称 <span class="math inline">\(x_c\left( nT \right)\)</span> 为 <span class="math inline">\(x_c\left( t \right)\)</span> 的采样信号，其中
<span class="math inline">\(T\)</span> 为采样间隔，<span class="math inline">\(F_s = 1/T\)</span> 称为采样率或抽样率 (sampling
rate) ，单位为 Hz。</p>
<p>  傅里叶变换是信号分析与处理的重要工具。定义连续时间信号的傅里叶变换为</p>
<p><span class="math display">\[\begin{equation}
  X_c\left( j\Omega \right) =\int_{-\infty}^{\infty}{x_c\left( t \right)
e^{-j\Omega t}\mathrm{d}t}
\end{equation}\]</span></p>
<p>其中 <span class="math inline">\(\Omega\)</span> 为模拟角频率 (analog
radian frequency) ，单位为 <span class="math inline">\(\text{rad/s}\)</span>，即 <span class="math inline">\(\Omega = 2\pi F\)</span>，其中 <span class="math inline">\(F\)</span> 为信号的实际频率，单位为 Hz。</p>
<p>  下面分析采样信号与原始连续时间信号 (下简称原始信号)
的频谱关系。注意到采样信 号可表示为原始信号与脉冲序列的乘积，即</p>
<p><span class="math display">\[\begin{equation}
  X_c\left( nT \right) =x_c\left( t \right)
\sum_{n=-\infty}^{\infty}{\delta \left( t-nT \right)}
\end{equation}\]</span></p>
<p>对上式作傅里叶变换，记采样信号的频谱为 <span class="math inline">\(X_s\left( j\Omega
\right)\)</span>，原始信号的频谱为 <span class="math inline">\(X_c\left(
j\Omega
\right)\)</span>，同时注意到脉冲序列的傅里叶变换依然是脉冲序列，根据卷积定理可知，采样信号与原始信号的频谱具有如下关系：</p>
<p><span class="math display">\[\begin{equation} \label{Relationship
between the spectrum of the sampled signal and the original signal}
X_s\left( j\Omega \right) =\frac{1}{2\pi}X_c\left( j\Omega \right) \ast
\frac{2\pi}{T}\sum_{n=-\infty}^{\infty}{\delta \left( \Omega -n\Omega _s
\right)}=\frac{1}{T}\sum_{n=-\infty}^{\infty}{X_c\left( j\left( \Omega
-\Omega _s \right) \right)}
\end{equation}\]</span></p>
<p>其中 <span class="math inline">\(\Omega_s =
\displaystyle\frac{2\pi}{T}=2\pi F_s\)</span> 为采样角频率
(亦简称为采样率) 。</p>
<p>  式 <span class="math inline">\(\eqref{Relationship between the
spectrum of the sampled signal and the original signal}\)</span>
说明，采样信号的频谱是将原始信号频谱以 <span class="math inline">\(\Omega_s\)</span> 进行周期延拓，且幅度变为原来的
<span class="math inline">\(1/T\)</span>，<a href="#图1.1">图 1.1</a>
给出了该过程的示意图。显然，若采样率过低则会造成相邻周期的频谱交叠在一起产生失真，这种现象称为混叠
(aliasing)。为避免混叠，采样率应大于信号最高频率的 2
倍。在此条件下，通过适当选取一个低通滤波器，可以从采样信号的频谱恢复出原始信号的频谱。这就是著名的
Nyquist-Shannon 采样定理。</p>
<p><a id="图1.1"></a></p>
<figure>
<img data-src="../images/post/2021-12-08-josh-msp-part-1/2021-12-08-josh-msp-part-1-010-RelationshipBetweenSampledSignalandAnalogSignal.png?imageMogr2/thumbnail/!100p%7Cwatermark/2/text/QEpvc2ggR2Fv/font/YWhyb25iZC50dGY=/fontsize/14/dissolve/20/gravity/southeast/dx/5/dy/5" width="500" alt="图1.1 采样信号与模拟信号的关系">
<figcaption aria-hidden="true">图1.1
采样信号与模拟信号的关系</figcaption>
</figure>
<p><strong>定理 1.1 (Nyquist-Shannon 采样定理)</strong> 设 <span class="math inline">\(x\left(t\right)\)</span> 是带限信号，频带范围为
<span class="math inline">\(\left(-\Omega_M,\Omega_M\right)\)</span>。如果采样率满足</p>
<p><span class="math display">\[
\Omega_s &gt; 2\Omega_M
\]</span></p>
<p>则 <span class="math inline">\(x\left( t \right)\)</span>
可以从其采样信号 <span class="math inline">\(x\left( nT \right)\)</span>
重建：</p>
<p><span class="math display">\[\begin{equation}
x\left( t \right) =\sum_{n=-\infty}^{\infty}{x\left( nT \right)
\frac{T\sin \left( \Omega _c\left( t-nT \right) \right)}{\pi \left( t-nT
\right)}}
\end{equation}\]</span></p>
<p>其中 <span class="math inline">\(\Omega_c\)</span>
为理想低通滤波器的截止频率，<span class="math inline">\(\Omega
_M\leqslant \Omega _c\leqslant \Omega _s-\Omega
_M\)</span>。特别地，若取 <span class="math inline">\(\Omega_c =
\displaystyle\frac{\Omega_s}{2} =
\frac{\pi}{T}\)</span>，则重建公式为</p>
<p><span class="math display">\[\begin{equation}
x\left( t \right) =\sum_{n=-\infty}^{\infty}{x\left( nT \right)
\mathrm{sinc}\left( \frac{t-nT}{T} \right)}
\end{equation}\]</span></p>
<p>  上述分析过程只涉及连续时间信号的傅里叶变换，而注意到采样信号本质上是离散时间信号，通常采用离散时间傅里叶变换
(DTFT) 分析更为方便。定义 <span class="math inline">\(x\left[ n
\right]\)</span> 的离散时间傅里叶变换</p>
<p><span class="math display">\[\begin{equation} \label{Definition of
DTFT}
X\left( e^{j\omega} \right) =\sum_{n=-\infty}^{\infty}{x\left[ n \right]
e^{-j\omega n}}
\end{equation}\]</span></p>
<p>其中 <span class="math inline">\(\omega\)</span> 为归一化角频率
(normalized radian frequency) 或数字角频率，单位为 <span class="math inline">\(\mathrm{rad}\)</span>，其与模拟角频率的关系为
<span class="math inline">\(\omega = \displaystyle\frac{\Omega}{F_s} =
\frac{\Omega}{T}\)</span>。</p>
<p>  对比式 <span class="math inline">\(\eqref{Definition of
DTFT}\)</span> 与 <span class="math inline">\(\eqref{Relationship
between the spectrum of the sampled signal and the original
signal}\)</span>，易知</p>
<p><span class="math display">\[\begin{equation}
X\left( e^{j\omega} \right) =\left. X_s\left( j\Omega \right)
\right|_{\Omega =\frac{w}{T}}
\end{equation}\]</span></p>
<p>上式表明，<span class="math inline">\(X\left( e^{j\omega}
\right)\)</span>
的频率坐标轴进行了归一化，两者本质上描述的都是采样信号的频谱。注意到
<span class="math inline">\(X\left( e^{j\omega} \right)\)</span> 是以
<span class="math inline">\(2\pi\)</span> 为周期的，通常选取一个完整周期
(例如 <span class="math inline">\(\left[-\pi,\pi\right]\)</span>)
进行分析即可。</p>
<p>  对于离散时间信号，经常还会使用z变换进行分析。定义 <span class="math inline">\(x\left[ n \right]\)</span> 的 <span class="math inline">\(z\)</span> 变换为</p>
<p><span class="math display">\[\begin{equation}
X\left( z \right) =\sum_{n=-\infty}^{\infty}{x\left[ n \right] z^{-n}}
\end{equation}\]</span></p>
<p>当 <span class="math inline">\(z = e^{j\omega}\)</span> 时，<span class="math inline">\(z\)</span> 变换即为离散时间傅里叶变换。</p>
<p>  本文假定读者对以上提及的变换及相关的变换域分析方法十分熟悉，因此不再过多阐述，相关内容可参阅数字信号处理教材。</p>
<h1 id="整数倍抽取">整数倍抽取</h1>
<p>  当信号的数据量较大时，为了减少数据量，便于计算和存储，我们希望降低采样率。这可以通过抽取（decimation）来实现，即从原采样信号中均匀地抽出一些点，形成新的采样信号。具体而言，设抽取前的信号为
$x( nT_1 ) $，现每隔 <span class="math inline">\(D − 1\)</span>
个点抽取一个点，其中 <span class="math inline">\(D\)</span>
为整数，称为抽取因子，于是得到抽取后的信号 $y_D( nT_2 )
$。易知两者的关系为</p>
<p><span class="math display">\[\begin{equation}\label{1.2.1}
y_D\left( nT_2 \right) =x\left( nDT_1 \right)
\end{equation}\]</span></p>
<p>其中 <span class="math inline">\(T_1\)</span>、<span class="math inline">\(T_2\)</span> 分别为抽取前后的采样间隔，且 <span class="math inline">\(T_2 = DT_1\)</span>。<a href="#图1.2">图
1.2(a)</a> 给出了 <span class="math inline">\(D=3\)</span>
时抽取过程的示意图。</p>
<p><a id="图1.2"></a></p>
<figure>
<img data-src="../images/post/2021-12-08-josh-msp-part-1/2021-12-08-josh-msp-part-1-020-DecimationDemostration.png?imageMogr2/thumbnail/!100p%7Cwatermark/2/text/QEpvc2ggR2Fv/font/YWhyb25iZC50dGY=/fontsize/14/dissolve/20/gravity/southeast/dx/5/dy/5" width="500" alt="图1.2 抽取">
<figcaption aria-hidden="true">图1.2 抽取</figcaption>
</figure>
<p>  上述关系也可以简记为</p>
<p><span class="math display">\[\begin{equation}\label{1.2.2}
y_D\left[ n \right] =x\left[ Dn \right]
\end{equation}\]</span></p>
<p>事实上，式 <span class="math inline">\(\eqref{1.2.1}\)</span> 与
<span class="math inline">\(\eqref{1.2.2}\)</span>
是等价的。第一种记法明确了信号所处的采样率
(即采样间隔的倒数)，这种记法有利于分析一些复杂的多抽样率网络。而第二种记法符合离散时间信号的表示习惯，也更为简便。在本文中，两种记法经常交替使用。值得注意的是，在使用第一种记法时应遵照信号实际的采样率，避免产生歧义。例如，如果将
<span class="math inline">\(y_D\left( nT_2 \right)\)</span> 写成 <span class="math inline">\(y_D\left( nDT_1
\right)\)</span>，尽管从数学形式上来看似乎没什么问题 (因为 <span class="math inline">\(T_2 = DT_1\)</span>），但由于 <span class="math inline">\(y_D\)</span> 实际所处的采样率为 <span class="math inline">\(F_2 = 1/T_2\)</span>，而 <span class="math inline">\(y_D\left( nDT_1 \right)\)</span> 意味着采样率为
<span class="math inline">\(F_1 =
1/T_1\)</span>，违背了实际的物理意义。同理，$x( nDT_1 ) $ 也不能写成
<span class="math inline">\(x\left( nT_2 \right)\)</span>。</p>
<p>  抽取只是降低信号的采样率，不会改变信号的幅值，故也称为下采样（downsampling）。实现抽取过程的单元称为抽取器（decimator），记为
<span class="math inline">\(\boxed{\downarrow D}\)</span> ，如<a href="#图1.2">图 1.2(b)</a> 所示。</p>
<p>  下面分析信号抽取前后的频域关系。不妨假设 <span class="math inline">\(x\left[ n \right]\)</span>、<span class="math inline">\(y_D\left[ n \right]\)</span>
均是由某个连续时间信号 <span class="math inline">\(x_c\left( t
\right)\)</span> 采样得到的，即 <span class="math inline">\(x\left[ n
\right] =x_c\left( nT_1 \right)\)</span>，$y_D=x_c( nT_2 ) $，其中 <span class="math inline">\(T_2 = DT_1\)</span>。故根据式 <span class="math inline">\(\eqref{Relationship between the spectrum of the
sampled signal and the original signal}\)</span>，</p>
<p><span class="math display">\[\begin{aligned}
x\left[ n \right] =x_c\left( nT_1 \right)
\overset{\mathrm{FT}}{\longleftrightarrow}X\left( e^{j\omega _1} \right)
=\frac{1}{T_1}\sum_{n=-\infty}^{\infty}{X_c\left[ j\left( \frac{\omega
_1-2n\pi}{T_1} \right) \right]}
\end{aligned}\]</span></p>
<p><span class="math display">\[\begin{equation}\label{1.2.4}
y_D\left[ n \right] =x_c\left( nT_2 \right)
\overset{\mathrm{FT}}{\longleftrightarrow}XY_D\left( e^{j\omega _2}
\right) =\frac{1}{T_2}\sum_{n=-\infty}^{\infty}{X_c\left[ j\left(
\frac{\omega _2-2n\pi}{T_2} \right) \right]}
\end{equation}\]</span></p>
<p>其中 <span class="math inline">\(\omega_1, \omega_2\)</span> 分别为
<span class="math inline">\(F_1, F_2\)</span> 对应的归一化角频率，且
<span class="math inline">\(\omega_2 = \Omega T_2 = \Omega DT_1 = D
\omega_1\)</span>。</p>
<p>  将 <span class="math inline">\(T_2 = DT_1\)</span> 代入 <span class="math inline">\(\eqref{1.2.4}\)</span>，并令 <span class="math inline">\(n=Dm+k\)</span>，</p>
<p><span class="math display">\[\begin{equation}\begin{aligned}
Y_D\left( e^{j\omega _2} \right)
&amp;=\frac{1}{DT_1}\sum_{n=-\infty}^{\infty}{\begin{array}{c}
  X_c\left[ j\left( \frac{D\omega _1-2n\pi}{DT_1} \right) \right]\\
\end{array}}
\\
&amp;=\frac{1}{DT_1}\sum_{k=0}^{D-1}{\sum_{m=-\infty}^{\infty}{\begin{array}{c}
  X_c\left[ j\left( \frac{D\omega _1-2\pi \left( Dm+k \right)}{DT_1}
\right) \right]\\
\end{array}}}
\\
&amp;=\frac{1}{D}\sum_{k=0}^{D-1}{\frac{1}{T_1}\sum_{m=-\infty}^{\infty}{\begin{array}{c}
  X_c\left[ j\left( \frac{\left( \omega _1-2\pi k/D \right) -2m\pi}{T_1}
\right) \right]\\
\end{array}}}
\\
&amp;=\frac{1}{D}\sum_{k=0}^{D-1}{X\left( e^{j\left( \omega _1-2\pi k/D
\right)} \right)}
\end{aligned}\end{equation}\]</span></p>
<p>注意到 <span class="math inline">\(\omega_2 =
D\omega_1\)</span>，上式等式两端可统一用变量 <span class="math inline">\(\omega_2\)</span>
表示，此时下标也可省略，于是得到信号抽取前后在频域的关系为</p>
<p><span class="math display">\[\begin{equation}
Y_D\left( e^{j\omega} \right) =\frac{1}{D}\sum_{k=0}^{D-1}{X\left(
e^{j\frac{\omega -2\pi k}{D}} \right)}
\end{equation}\]</span></p>
<!-- # 整数倍内插

# 分数倍抽样率转换

# 以时变滤波的角度分析抽样率转换

# 抽样率转换的 MATALAB 实现

# 小结 -->
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr>
<ol>
<li id="fn1"><p>又称采样率，在本文中，“采样”与“抽样”涵义相同，两者经常交换使用。<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/css/markmap.css">

<script src="/js/markmap.js"></script>
]]></content>
      <categories>
        <category>Josh 的学习笔记</category>
        <category>多抽样率信号处理</category>
      </categories>
      <tags>
        <tag>抽样率转换</tag>
        <tag>抽取</tag>
        <tag>内插</tag>
        <tag>分数倍抽样</tag>
      </tags>
  </entry>
  <entry>
    <title>Josh&#39;s Note — 凸优化&lt;br&gt;Part 1.1 凸集—仿射集合和凸集</title>
    <url>/posts/43146ee9.html</url>
    <content><![CDATA[<h1 id="直线与线段">1. 直线与线段</h1>
<p>$ $  设 <span class="math inline">\(x_1 \ne x_2\)</span> 是 <span class="math inline">\(\mathbf{R}^n\)</span>
空间中的两个点，则具有下列形式的点</p>
<p><span class="math display">\[
y = \theta x_1 + (1-\theta)x_2,\theta \in \mathbf{R}
\]</span></p>
<p>组成一条穿过 <span class="math inline">\(x_1\)</span> 和 <span class="math inline">\(x_2\)</span>
的<strong>直线</strong>（<em>line</em>）。参数 <span class="math inline">\(\theta = 0\)</span> 和 <span class="math inline">\(\theta = 1\)</span> 分别对应 <span class="math inline">\(y=x_2\)</span> 和 <span class="math inline">\(y =
x_1\)</span>。参数 <span class="math inline">\(\theta\)</span> 的值在 0
和 1 之间变动，构成了 <span class="math inline">\(x_1\)</span> 和 <span class="math inline">\(x_2\)</span>
之间的（闭）<strong>线段</strong>（(closed) <em>line
segment</em>）。</p>
<p>  另一种 <span class="math inline">\(y\)</span> 的表示形式</p>
<p><span class="math display">\[
y = x_2 + \theta (x_1 - x_2)
\]</span></p>
<p>可以解释为：<span class="math inline">\(y\)</span>
是<strong>基点</strong>（<em>base point</em>）<span class="math inline">\(x_2\)</span>（对应 <span class="math inline">\(\theta =
0\)</span>）和<strong>方向</strong>（<em>direction</em>）<span class="math inline">\(x_1 - x_2\)</span>（由 <span class="math inline">\(x_2\)</span> 指向 <span class="math inline">\(x_1\)</span>）乘以参数 <span class="math inline">\(\theta\)</span> 的和。因此，<span class="math inline">\(\theta\)</span> 给出了 <span class="math inline">\(y\)</span> 在由 <span class="math inline">\(x_2\)</span> 通向 <span class="math inline">\(x_1\)</span> 的路上的位置。当 <span class="math inline">\(\theta\)</span> 由 <span class="math inline">\(0\)</span> 增加到 <span class="math inline">\(1\)</span>，点 <span class="math inline">\(y\)</span> 相应地由 <span class="math inline">\(x_2\)</span> 移动到 <span class="math inline">\(x_1\)</span>。如果 <span class="math inline">\(\theta &gt; 1\)</span>，点 <span class="math inline">\(y\)</span> 在超越了 <span class="math inline">\(x_1\)</span> 的直线上。<a href="#图1">图 1</a>
给出了直观的解释。</p>
<p><a id="图1"></a></p>
<figure>
<img data-src="../images/post/2022-03-29-josh-cvx-1-1/2022-03-29-josh-cvx-1-1-010-TheLinePassingThroughX1AndX2.png" width="600" alt="图 1. 通过 x_1 和 x_2 的直线可以参数化描述为 \theta x_1 + (1-\theta)x_2，其中 \theta 在 \mathbf{R} 上变化。x_1 和 x_2 之间的线段由深色所示，对应处于 0 和 1 之间的 \theta。">
<figcaption aria-hidden="true">图 1. 通过 <span class="math inline">\(x_1\)</span> 和 <span class="math inline">\(x_2\)</span> 的直线可以参数化描述为 <span class="math inline">\(\theta x_1 + (1-\theta)x_2\)</span>，其中 <span class="math inline">\(\theta\)</span> 在 <span class="math inline">\(\mathbf{R}\)</span> 上变化。<span class="math inline">\(x_1\)</span> 和 <span class="math inline">\(x_2\)</span> 之间的线段由深色所示，对应处于 <span class="math inline">\(0\)</span> 和 <span class="math inline">\(1\)</span> 之间的 <span class="math inline">\(\theta\)</span>。</figcaption>
</figure>
<span id="more"></span>
<h1 id="仿射集合和凸集">2. 仿射集合和凸集</h1>
<p>  如果通过集合 <span class="math inline">\(C \subseteq
\mathbf{R}^n\)</span> 中任意两个不同点的直线仍然在集合 <span class="math inline">\(C\)</span> 中，那么称集合 <span class="math inline">\(C\)</span>
是<strong>仿射</strong>（<em>affine</em>）的。也就是说，<span class="math inline">\(C \subseteq \mathbf{R}^n\)</span>
是仿射的等价于：对于任意 <span class="math inline">\(x_1, x_2 \in
C\)</span> 及 <span class="math inline">\(\theta \in \mathbf{R}\)</span>
有 <span class="math inline">\(\theta x_1 + (1-\theta)x_2 \in
C\)</span>。换言之，<span class="math inline">\(C\)</span> 包含了 <span class="math inline">\(C\)</span> 中任意两点的系数之和为 <span class="math inline">\(1\)</span> 的线性组合。</p>
<p>  这个概念可以扩展到多个点的情况。若 <span class="math inline">\(\theta_1 + \cdots + \theta_k =
1\)</span>，则称具有 <span class="math inline">\(\theta_1 x_1 + \cdots +
\theta_k x_k\)</span> 形式的点为 <span class="math inline">\(x_1,
\cdots, x_k\)</span> 的<strong>仿射组合</strong>（<em>affine
combination</em>）。利用仿射集合的定义（即仿射集合包含其中任意两点的仿射组合），可以归纳出以下结论：一个仿射集合包含其中任意点的仿射组合，即如果
<span class="math inline">\(C\)</span> 是一个仿射集合，<span class="math inline">\(x_1, \cdots, x_k \in C\)</span>，并且 <span class="math inline">\(\theta_1 + \cdots + \theta_k = 1\)</span>，那么
<span class="math inline">\(\theta_1 x_1 + \cdots + \theta_k
x_k\)</span> 仍然在 <span class="math inline">\(C\)</span> 中。</p>
<p>  如果 <span class="math inline">\(C\)</span> 是一个仿射集合并且
<span class="math inline">\(x_0 \in C\)</span>，则集合</p>
<p><span class="math display">\[
V = C - x_0 = \left\{ x - x_0\mid x \in C \right\}
\]</span></p>
<p>是一个子空间，即关于加法和数乘是封闭的。</p>
<blockquote>
<p><strong>简单说明</strong> 设 <span class="math inline">\(v_1, v_2 \in
V\)</span>，<span class="math inline">\(\alpha, \beta \in
\mathbf{R}\)</span>，则有 <span class="math inline">\(v_1 + x_0 \in
C\)</span>，<span class="math inline">\(v_2 + x_0 \in C\)</span>。因为
<span class="math inline">\(C\)</span> 是仿射的，且 <span class="math inline">\(\alpha + \beta + (1 - \alpha - \beta) =
1\)</span>，所以</p>
<p><span class="math display">\[
\alpha v_1 + \beta v_2 + x_0 = \alpha (v_1 + x_0) + \beta(v_2 + x_0) +
(1 - \alpha - \beta)x_0 \in C
\]</span></p>
<p>由 <span class="math inline">\(\alpha v_1 + \beta v_2 + x_0 \in
C\)</span>，可知 <span class="math inline">\(\alpha v_1 + \beta v_2 \in
V\)</span>。</p>
</blockquote>
<p>  因此，仿射集合 <span class="math inline">\(C\)</span>
可以表示为</p>
<p><span class="math display">\[
C = V + x_0 = \left\{ v + x_0\mid v \in V \right\}
\]</span></p>
<p>即一个子空间加上一个偏移。与仿射集合 <span class="math inline">\(C\)</span> 相关联的子空间 <span class="math inline">\(V\)</span> 与 <span class="math inline">\(x_0\)</span> 的选取无关，所以 <span class="math inline">\(x_0\)</span> 可以是 <span class="math inline">\(C\)</span> 中的任意一点。定义仿射集合 <span class="math inline">\(C\)</span> 的维数为子空间 <span class="math inline">\(V = C - x_0\)</span> 的维数，其中 <span class="math inline">\(x_0\)</span> 是 <span class="math inline">\(C\)</span> 中的任意元素。</p>
<blockquote>
<p><strong>举例</strong> <strong>线性方程组的解集</strong>。线性方程组的解集
<span class="math inline">\(C = \{x\mid Ax= b\}\)</span>
是一个仿射集合，其中 <span class="math inline">\(A\in\mathbf{R}^{m\times
n}\)</span>，<span class="math inline">\(b \in \mathbf{R}^{m}\)</span>
。为说明这点，设 <span class="math inline">\(x_1,x_2\in C\)</span>，即
<span class="math inline">\(Ax_1 = b, Ax_2 = b\)</span>。则对于任意
<span class="math inline">\(\theta\)</span>，有</p>
<p><span class="math display">\[\begin{aligned}
A(\theta x_1 + (1-\theta)x_2) &amp;= \theta Ax_1 + (1-\theta)Ax_2 \\
&amp;= \theta b + (1-\theta)b \\
&amp;= b
\end{aligned}\]</span></p>
<p>这表明任意的仿射组合 <span class="math inline">\(\theta x_1 +
(1-\theta)x_2\)</span> 也在 <span class="math inline">\(C\)</span>
中，并且与仿射集合 <span class="math inline">\(C\)</span>
相关联的子空间就是 <span class="math inline">\(A\)</span> 的零空间。</p>
<p>反之，任意仿射集合可以表示为一个线性方程组的解集。</p>
</blockquote>
<p>  由集合 <span class="math inline">\(C \subseteq
\mathbf{R}^n\)</span> 中的点的所有仿射组合组成的集合称为 <span class="math inline">\(C\)</span> 的<strong>仿射包</strong>（<em>affine
hull</em>），记为 <span class="math inline">\(\mathop{\bf
aff}{C}\)</span>：</p>
<p><span class="math display">\[
\mathop{\bf aff}{C} = \left\{ \theta_1 x_1 + \cdots + \theta_k x_k\mid
x_1, \cdots, x_k \in C, \theta_1 + \cdots + \theta_k = 1 \right\}
\]</span></p>
<p>仿射包是包含 <span class="math inline">\(C\)</span>
的最小的仿射集合，也就是说：如果 <span class="math inline">\(S\)</span>
是满足 <span class="math inline">\(C \subseteq S\)</span>
的仿射集合，那么 <span class="math inline">\(\mathop{\bf aff}{C}
\subseteq S\)</span>。</p>
<h1 id="仿射维数与相对内部">3. 仿射维数与相对内部</h1>
<p>  集合 <span class="math inline">\(C\)</span>
的仿射维数定义为其仿射包的维数。仿射维数在凸分析及凸优化中十分有用，但它与其他维数的定义常常不相容。</p>
<blockquote>
<p><strong>举例</strong> 考虑 <span class="math inline">\(\mathbf{R}^2\)</span> 上的单位圆环 <span class="math inline">\(\left\{x\in\mathbf{R}^2\mid x_1^2 + x_2^2 = 1
\right\}\)</span>。它的仿射包是全空间 <span class="math inline">\(\mathbf{R}^2\)</span>，所以其仿射维数为 <span class="math inline">\(2\)</span>。但是，在其他大多数维数的定义下，<span class="math inline">\(\mathbf{R}^2\)</span> 上的单位圆环的维数为 <span class="math inline">\(1\)</span>。</p>
</blockquote>
<p>  如果集合 <span class="math inline">\(C \subseteq
\mathbf{R}^n\)</span> 的仿射维数小于 <span class="math inline">\(n\)</span>，那么这个集合在仿射集合 <span class="math inline">\(\mathop{\bf aff}C \ne \mathbf{R}^n\)</span>
中。定义集合 <span class="math inline">\(C\)</span>
的<strong>相对内部</strong>（<em>relative interior</em>）为 <span class="math inline">\(\mathop{\bf aff}C\)</span> 的内部，记为 <span class="math inline">\(\mathop{\bf relint}C\)</span>，即</p>
<p><span class="math display">\[
\mathop{\bf relint}C = \left\{ x \in C\mid B(x,r) \cap \mathop{\bf aff}C
\subseteq C\ 对于某些\ r &gt; 0 \right\}
\]</span></p>
<p>其中 <span class="math inline">\(B(x,r) = \left\{ y\mid \left\| y-x
\right\| \leqslant r \right\}\)</span>，即半径为 <span class="math inline">\(r\)</span>，中心为 <span class="math inline">\(x\)</span> 并由范数 <span class="math inline">\(\|
\cdot \|\)</span> 定义的球（这里的 <span class="math inline">\(\| \cdot
\|\)</span>
可以是任意范数，并且所有范数定义了相同的相对内部）。于是可以定义集合
<span class="math inline">\(C\)</span>
的<strong>相对边界</strong>（<em>relative boundary</em>）为 <span class="math inline">\(\mathop{\bf cl}C\ \setminus \mathop{\bf
relint}C\)</span>，此处 <span class="math inline">\(\mathop{\bf
cl}C\)</span> 表示 <span class="math inline">\(C\)</span> 的闭包。</p>
<div class="note info"><p>这里的 “<span class="math inline">\(\setminus\)</span>”
表示“集合减”，也即集合 <span class="math inline">\(C\)</span>
的相对边界为其闭包 <span class="math inline">\(\mathbf{cl}\ C\)</span>
减去其相对内部 <span class="math inline">\(\mathbf{relint}\
C\)</span>。</p>
</div>
<blockquote>
<p><strong>举例</strong> 考虑 <span class="math inline">\(\mathbf{R}^3\)</span> 中处于 <span class="math inline">\((x_1，x_2)\)</span> 平面的一个正方形，定义</p>
<p><span class="math display">\[
C = \{x \in \mathbf{R}\mid -1\leqslant 1, -1\leqslant x_2\leqslant 1,
x_3 = 0\}
\]</span></p>
<p>其仿射包为 <span class="math inline">\((x_1,x_2)\)</span>-平面，即
<span class="math inline">\(\mathop{\bf aff}C = \{x\in\mathbf{R}^3\mid
x_3 = 0 \}\)</span>。<span class="math inline">\(C\)</span>
的内部为空，但其相对内部为</p>
<p><span class="math display">\[
\mathop{\bf relint}C =
\{x\in\mathbf{R}^3\mid  -1&lt;x_1&lt;1,-1&lt;x_2&lt;1,x_3 = 0\}
\]</span></p>
<p><span class="math inline">\(C\)</span>（在 <span class="math inline">\(\mathbf{R}^3\)</span>
中）的边界是其自身，而相对边界是其边框，</p>
<p><span class="math display">\[
\{x \in \mathbf{R}^3\mid \max\{|x_1|,|x_2|\} = 1,x_3 = 0\}
\]</span></p>
</blockquote>
<h1 id="凸集">4. 凸集</h1>
<p>  集合 <span class="math inline">\(C\)</span>
被称为<strong>凸集</strong>（<em>convex set</em>），如果 <span class="math inline">\(C\)</span> 中任意两点间的线段仍然在 <span class="math inline">\(C\)</span> 中，即对于任意 <span class="math inline">\(x_1, x_2 \in C\)</span> 和满足 <span class="math inline">\(0 \leqslant \theta \leqslant 1\)</span> 的 <span class="math inline">\(\theta\)</span> 都有</p>
<p><span class="math display">\[
\theta x_1 + (1-\theta)x_2 \in C
\]</span></p>
<p>粗略地看，如果集合中的每一点都可以被其他点沿着它们之间一条无阻碍的路径看见，那么这个集合就是凸集。所谓无阻碍，是指整条路径都在集合中。由于仿射集包含穿过集合中任意不同两点的整条直线，任意不同两点间的线段自然也在集合中。因而仿射集是凸集。<a href="#图2">图 2</a> 显示了 <span class="math inline">\(\mathbf{R}^2\)</span>
空间中一些简单的凸和非凸集合。</p>
<p><a id="图2"></a></p>
<figure>
<img data-src="../images/post/2022-03-29-josh-cvx-1-1/2022-03-29-josh-cvx-1-1-020-SomeSimpleConvexAndNonconvexSets.png" width="1000" alt="图 2. 一些简单的凸和非凸集合。左：包含其边界的六边形是凸的。中：肾形集合不是凸的，因为图中所示集合中两点间的线段不为集合所包含。右：仅包含部分边界的正方形不是凸的。">
<figcaption aria-hidden="true">图 2.
一些简单的凸和非凸集合。<strong>左</strong>：包含其边界的六边形是凸的。<strong>中</strong>：肾形集合不是凸的，因为图中所示集合中两点间的线段不为集合所包含。<strong>右</strong>：仅包含部分边界的正方形不是凸的。</figcaption>
</figure>
<p>  集合 <span class="math inline">\(C\)</span>
中所有点的凸组合的集合称为集合 <span class="math inline">\(C\)</span>
的<strong>凸包</strong>（<em>convex hull</em>），记为 <span class="math inline">\(\mathop{\bf conv}C\)</span>：</p>
<p><span class="math display">\[
\mathop{\bf conv}C = \left\{ \theta_1 x_1 + \cdots + \theta_k x_k\mid
x_i \in C, \theta_i \geqslant 0, i = 1,\cdots, k, \theta_1 + \cdots +
\theta_k = 1 \right\}
\]</span></p>
<p>顾名思义，凸包 <span class="math inline">\(\mathop{\bf
conv}C\)</span> 总是凸的。它是包含 <span class="math inline">\(C\)</span> 的最小的凸集。也就是说，如果 <span class="math inline">\(B\)</span> 是包含 <span class="math inline">\(C\)</span> 的凸集，那么 <span class="math inline">\(\mathop{\bf conv}C \subseteq B\)</span>。<a href="#图3">图 3</a> 展示了凸包的定义。</p>
<p><a id="图3"></a></p>
<figure>
<img data-src="../images/post/2022-03-29-josh-cvx-1-1/2022-03-29-josh-cvx-1-1-030-TheConvexHullsOfTwoSets.png" width="800" alt="图 3. \mathbf{R}^2 上两个集合的凸包。左：（如图所示的）十五个点的集合的凸包是一个五边形示）。右：图 2 中的肾形集合的凸包是阴影所示的集合。">
<figcaption aria-hidden="true">图 3. <span class="math inline">\(\mathbf{R}^2\)</span>
上两个集合的凸包。<strong>左</strong>：（如图所示的）十五个点的集合的凸包是一个五边形示）。<strong>右</strong>：<a href="#图2">图 2</a> 中的肾形集合的凸包是阴影所示的集合。</figcaption>
</figure>
<div class="note info"><p>集合 <span class="math inline">\(C\)</span> 的仿射包 <span class="math inline">\(\mathbf{aff}\ C\)</span> 和凸包 <span class="math inline">\(\mathbf{Conv}\ C\)</span> 的区别是参数 <span class="math inline">\(\theta\)</span> 的定义域。可以看出，仿射包 <span class="math inline">\(\mathbf{aff}\ C\)</span> 包含凸包 <span class="math inline">\(\mathbf{Conv}\ C\)</span>，因此集合 <span class="math inline">\(C\)</span> 的仿射包是凸集。</p>
</div>
<p>  凸组合的概念可以扩展到无穷级数、积分以及大多数形式的概率分布。假设
<span class="math inline">\(\theta_1,\theta_2,\cdots\)</span> 满足</p>
<p><span class="math display">\[
\theta_i \geqslant 0, \quad i = 1,2,\cdots,\quad \sum_{i=1}^\infty
\theta_i = 1
\]</span></p>
<p>并且 <span class="math inline">\(x_1, x_2, \cdots \in
C\)</span>，其中 <span class="math inline">\(C \subseteq
\mathbf{R}^n\)</span> 为凸集。那么，如果下面的级数收敛，则有</p>
<p><span class="math display">\[
\sum_{i=1}^\infty \theta_i x_i \in C
\]</span></p>
<p>更一般地，假设 <span class="math inline">\(p:\mathbf{R}^n\to\mathbf{R}\)</span> 对所有 <span class="math inline">\(x \in C\)</span> 满足 <span class="math inline">\(p(x) \geqslant 0\)</span>，并且 <span class="math inline">\(\displaystyle \int_C p(x) \mathrm{d}x =
1\)</span>，其中 <span class="math inline">\(C \subseteq
\mathbf{R}^n\)</span> 是凸集。那么，如果下面的积分存在，则有</p>
<p><span class="math display">\[
\int_C p(x)x \mathrm{d}x \in C
\]</span></p>
<p>  最一般的情况，设 <span class="math inline">\(C \subseteq
\mathbf{R}^n\)</span> 是凸集，<span class="math inline">\(x\)</span>
是随机变量，并且 <span class="math inline">\(x \in C\)</span> 的概率为
<span class="math inline">\(1\)</span>，那么 <span class="math inline">\(\mathbb{E}\{x\} \in
C\)</span>。事实上，这一形式包含了前述的特殊情况。例如，假设随机变量
<span class="math inline">\(x\)</span> 只在 <span class="math inline">\(x_1\)</span> 和 <span class="math inline">\(x_2\)</span> 中取值，其概率分别为 <span class="math inline">\(\mathbf{prob}(x=x_1) = \theta\)</span> 和 <span class="math inline">\(\mathbf{prob}(x=x_2) = 1-\theta\)</span>，其中
<span class="math inline">\(0 \leqslant \theta \leqslant
1\)</span>。于是，<span class="math inline">\(\mathbb{E}\{x\} = \theta
x_1 + (1-\theta)x_2\)</span>，即回到了两个点的简单的凸组合。</p>
<h1 id="锥">5. 锥</h1>
<p>  如果对于任意 <span class="math inline">\(x \in C\)</span> 和 <span class="math inline">\(\theta \geqslant 0\)</span> 都有 <span class="math inline">\(\theta x \in C\)</span>，我们称集合 <span class="math inline">\(C\)</span>
是<strong>锥</strong>（<em>cone</em>）或者<strong>非负齐次</strong>（<em>nonnegative
homogeneous</em>）。如果集合 <span class="math inline">\(C\)</span>
是锥，并且是凸的，则称 <span class="math inline">\(C\)</span>
为<strong>凸锥</strong>（<em>convex cone</em>），即对于任意 <span class="math inline">\(x_1, x_2 \in C\)</span> 和 <span class="math inline">\(\theta_1, \theta_2 \geqslant 0\)</span>，都有</p>
<p><span class="math display">\[
\theta_1 x_1 + \theta_2 x_2 \in C
\]</span></p>
<p>在几何上，具有此类形式的点构成了二维的扇形，这个扇形以 <span class="math inline">\(0\)</span> 为顶点，边通过 <span class="math inline">\(x_1\)</span> 和 <span class="math inline">\(x_2\)</span>（如<a href="#图4">图
4</a>所示）。</p>
<p><a id="图4"></a></p>
<figure>
<img data-src="../images/post/2022-03-29-josh-cvx-1-1/2022-03-29-josh-cvx-1-1-040-ThePieSlice.png" width="400" alt="图 4. 扇形展示了所有具有形式 \theta_1 x_1 + \theta_2 x_2 的点，其中 \theta_1, \theta_2 \geqslant 0。扇形的顶点 (\theta_1 = \theta_2 = 0) 在 0；其边界（对应于 $\theta_1 = 0 或 \theta_2 = 0) 穿过点 x_1 和 x_2。">
<figcaption aria-hidden="true">图 4. 扇形展示了所有具有形式 <span class="math inline">\(\theta_1 x_1 + \theta_2 x_2\)</span> 的点，其中
<span class="math inline">\(\theta_1, \theta_2 \geqslant
0\)</span>。扇形的顶点 (<span class="math inline">\(\theta_1 = \theta_2
= 0\)</span>) 在 <span class="math inline">\(0\)</span>；其边界（对应于
$<span class="math inline">\(\theta_1 = 0\)</span> 或 <span class="math inline">\(\theta_2 = 0\)</span>) 穿过点 <span class="math inline">\(x_1\)</span> 和 <span class="math inline">\(x_2\)</span>。</figcaption>
</figure>
<p>  具有 <span class="math inline">\(\theta_1 x_1 + \cdots + \theta_k
x_k, \theta_1,\cdots,\theta_k \geqslant 0\)</span> 形式的点称为 <span class="math inline">\(x_1,\cdots,x_k\)</span>
的<strong>锥组合</strong>（<em>conic
combination</em>）（或<strong>非负线性组合</strong>（<em>nonnegative
linear combination</em>））。如果 <span class="math inline">\(x_i\)</span> 均属于凸锥 <span class="math inline">\(C\)</span>，那么，<span class="math inline">\(x_i\)</span> 的每一个锥组合也在 <span class="math inline">\(C\)</span> 中。反言之，集合 <span class="math inline">\(C\)</span>
是凸锥的充要条件是它包含其元素的所有锥组合。如同凸（或仿射）组合一样，锥组合的概念可以扩展到无穷级数和积分中。</p>
<p>  集合 <span class="math inline">\(C\)</span>
的<strong>锥包</strong>（<em>conic hull</em>）是 <span class="math inline">\(C\)</span> 中元素的所有锥组合的集合，即</p>
<p><span class="math display">\[
\left\{ \theta_1 x_1 + \cdots + \theta_k x_k\mid x_i \in C, \theta_i
\geqslant 0, i = 1,\cdots,k \right\}
\]</span></p>
<p>它是包含 <span class="math inline">\(C\)</span> 的最小的凸锥（如<a href="#图5">图 5</a> 所示）。</p>
<p><a id="图5"></a></p>
<figure>
<img data-src="../images/post/2022-03-29-josh-cvx-1-1/2022-03-29-josh-cvx-1-1-050-TheConicHulls.png" width="600" alt="图 5. 图 3 中两个集合的锥包（阴影所示）。">
<figcaption aria-hidden="true">图 5. <a href="#图3">图 3</a>
中两个集合的锥包（阴影所示）。</figcaption>
</figure>
<div class="note info"><p>类似仿射包，集合 <span class="math inline">\(C\)</span> 的凸包 <span class="math inline">\(\mathbf{Conv}\ C\)</span> 和锥包的区别是参数 <span class="math inline">\(\theta\)</span> 的定义域。可以看出，锥包包含凸包
<span class="math inline">\(\mathbf{Conv}\ C\)</span>，因此集合 <span class="math inline">\(C\)</span> 的锥包是凸集。</p>
</div>
<h1 id="参考文献">参考文献</h1>
<ol type="1">
<li>Stephen P. Boyd and Lieven Vandenberghe, <em>Convex
optimization</em>. Cambridge, UK: Cambridge University Press, 2004.</li>
<li>Stephen P. Boyd and Lieven Vandenberghe, <em>凸优化</em>. 北京:
清华大学出版社, 2013.</li>
</ol>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/css/markmap.css">

<script src="/js/markmap.js"></script>
]]></content>
      <categories>
        <category>Josh 的学习笔记</category>
        <category>凸优化</category>
        <category>凸集</category>
        <category>数学</category>
        <category>凸优化</category>
      </categories>
      <tags>
        <tag>凸优化</tag>
        <tag>凸集</tag>
        <tag>仿射</tag>
        <tag>锥</tag>
      </tags>
  </entry>
  <entry>
    <title>Josh&#39;s Note — SystemVerilog 验证&lt;br&gt;Part 1 验证导论</title>
    <url>/posts/8e17a993.html</url>
    <content><![CDATA[<p>  在开始学习有关 SystemVerilog
语言的细节之前，我们需要了解如何制订计划来验证手中的设计，以及这个验证计划对测试平台（testbench）结构的影响。所有测试平台都有用于产生激励、检验响应的结构。本文对测试平台的构建和设计给出一些引导性的建议和编码风格方面的参考，以满足不同的需要。</p>
<p>  对于验证工程师而言，最重要的原则是“有漏洞是好事（Bugs are
good）”，要勇于寻找程序中的漏洞，每次找到漏洞都应该及时告警并记录下来。任何一个项目中都不可能没有漏洞，所以在流片之前每发现一个漏洞都意味着用户手中的产品少一个漏洞。我们应该尽可能细致深入地去检验设计，找出所有可能存在的漏洞，尽管有时候这些漏洞可能很容易修复。</p>
<p>  本文需要 Verilog 语言基础，面向对 SystemVerilog HVL（Hard­ware
Verification Language，硬件验证语言）感兴趣的读者。与 HDL（Hardware
Description Language，硬件描述语言）相比，HVL 具有一些特别的性质：</p>
<ol type="1">
<li><p><strong>受约束的随机激励生成</strong>（<em>Constrained-random
stimulus generation</em>）。</p></li>
<li><p><strong>功能覆盖率</strong>（<em>Functional
coverage</em>）。</p></li>
<li><p><strong>更高层次的结构</strong>，尤其是面向对象的编程（<em>Higher-level
structures</em>, especially object-oriented programming）。</p></li>
<li><p><strong>多线程</strong>及线程间的通信（<em>Multithreading</em>
and interprocess communication）。</p></li>
<li><p><strong>支持 HDL 数据类型</strong>（<em>Support for HDL
types</em>）。</p></li>
<li><p><strong>集成了事件仿真器</strong>，便于对设计施加控制（<em>Tight
integration with event-simulator</em> for control of the
design）。</p></li>
</ol>
<p>  此外还有其他很多有用的特性，但上述特性使得 HVL
可以创建高度抽象的测试平台，其抽象层次比使用 HDL 或计算机编程语言（如 C
语言）所能达到的还要高。</p>
<span id="more"></span>
<h1 id="验证流程">1. 验证流程</h1>
<p>  验证的目的是什么？如果说是为了“寻找漏洞”，那只答对了一部分。硬件设计的目的是设计一个<strong>基于设计规范并能完成特定任务的设备</strong>，例如
DVD
播放器、路由器或者雷达信号处理器。验证工程师需要<strong>确保这些设备能够成功地完成预定的任务</strong>——也就是说，该设计是<strong>对规范的一种准确表达</strong>；而设计在超出预定目标之外的行为可以不用关心。</p>
<p>  验证和设计是<strong>并行</strong>的流程。对于每个设计模块，设计工程师需要首先了解硬件设计规范/设计输入，理解其中的设计需求，然后使用
RTL
等的机器语言创建相应的逻辑。为了完成这个过程，设计工程师需要知道输入格式、传输函数以及输出格式。在理解设计需求的过程中总会有一定模糊（ambiguity），可能因为是设计输入文档本身的表述不清楚，遗漏了细节或者前后不一致。验证工程师必须阅读硬件规范并拟定验证计划，然后按照计划，创建测试来检查
RTL 代码是否准确地实现了所有的特性。</p>
<p>  如果有多人按照同一规范进行解读，那么设计流程可能会出现冗余。验证工程师的工作是阅读同样的硬件设计规范并对其含义做出独立的判断，然后利用测试来检查对应的
RTL 代码是否与理解相一致。</p>
<h2 id="不同层次的测试">1.1. 不同层次的测试</h2>
<p>  设计中会潜藏着哪些类型的漏洞呢？最容易检测的是在<strong>代码块（<em>block</em>）层次</strong>上，代码块由每个设计工程师在模块（module）内创建。ALU（Arithmetic-Logic
Unit，运算逻辑单元）是否正确地执行了两个数的加法？是否每次总线传输都能够成功完成？是否所有的数据包都经过了网络交换机？为了找出这些漏洞而去编写定向测试是一件十分繁琐的事情，因为这些漏洞都被包含在设计的代码块里。</p>
<p>  除了代码块以外，代码块的<strong>输入输出接口</strong>也是容易出现漏洞的地方，通常是因为多个设计工程师对同一规范产生了不同理解。对于一个给定的协议，什么信号发生了变化？在什么时候变化？第一个设计工程师按照自己对规范的理解建立了一个总线驱动器，第二个设计工程师也按照自己的理解建立了一个总线接收器，但两者对规范的理解略有不同。<strong>验证工程师的工作就是找到两者在硬件逻辑上有冲突的地方，然后将两者进行统一。</strong></p>
<p>  为了对一个代码块进行仿真，我们需要创建测试集来模拟周围代码块产生激励，这是一件困难而繁琐的事情。虽然低层次的仿真运行起来会很快，但是随着代码块数量的增加，可能会在设计和测试平台中同时找到漏洞，因为测试平台为了提供足够的激励，代码量也会很长。当开始对所有的代码块进行合并测试时，它们也会相互激励，测试负担就会相对减少。多个代码块同时仿真可能会发现更多的漏洞，但是运行起来也会慢一些。</p>
<p>  在 DUT（Design under
Test，待测设计）的最高层次中，整个系统都会被测试，但是仿真过程会简单很多。我们的测试应该尽可能让所有的代码块并发活动。所有的输入输出端口都被激活，处理器正在处理数据，而高速缓存也正在载入数据。有了这些行为以后，数据分配和时序上的漏洞肯定会出现。</p>
<p>  在这个层次能够运行更加精细的测试，可以<strong>让 DUT
并发执行多种操作以激活尽可能多的代码块</strong>。如果一个 MP3
播放器正在播放音乐时，用户希望从计算机上下载新的音乐会发生什么？在下载的过程中，用户在播放器上按键又会发生什么？显然，一个实际的设备在被使用时，有些用户会去做这些事情，那为什么不在设备制造之初去做同样的测试呢？这种测试可以把易于使用的产品和经常发生故障的产品区分开来。</p>
<p>  一旦验证了 DUT 能够执行所有预期的功能以后，还需要看一下当出现错误时
DUT
会怎样操作。设计是否能应对只进行了一半的事件，已经受损的数据或控制字段？想要列举出所有可能的问题就很困难，更不用说去判断设计会如何从这些错误中恢复了。所以<strong>错误注入和处理（Error
Injection and Handling）是验证中最具挑战性的部分</strong>。</p>
<p>  随着设计抽象层次的提高，验证的挑战性也会加大。我们可以确定单个信元是否正确通过
ATM（Asynchronous Transfer
Mode，异步传输模式）路由器，但如果是一系列有着不同优先权的数据流呢？在最高的抽象层次中，下一个操作应该选择哪个信元并不是显而易见的，可能不得不统计成千上万的信元，以便确定这种集总的操作是否正确。</p>
<p>  最后，<strong>我们永远也无法证明没有任何遗留的漏洞</strong>，所以需要不停地尝试新的验证策略。</p>
<h2 id="验证计划">1.2. 验证计划</h2>
<p>  验证计划和硬件规范是紧密联系在一起的，它描述了需要验证什么样的特性，以及采用哪些技术。这些步骤可能包含有定向测试（directed
testing）或随机测试（random
testing）、断言（assertion）、软硬件协同验证（HW/SW
co-verification）、硬件仿真（emulation）、形式验证（formal
proof），以及对验证 IP 的使用等等。有关验证更全面的讨论，可参见 Bergeron
的 <em>Verification Methodology Manual for
SystemVerilog</em>（2006）。</p>
<h1 id="测试平台的基本功能">2. 测试平台的基本功能</h1>
<p>  测试平台的用途在于<strong>确定 DUT
的正确性</strong>。包含下列步骤：</p>
<ol type="1">
<li><p>产生激励。</p></li>
<li><p>把激励施加到 DUT 上。</p></li>
<li><p>捕捉响应。</p></li>
<li><p>检验正确性。</p></li>
<li><p>对照整个验证目标测算进展情况。</p></li>
</ol>
<p>  有些步骤是测试平台自动完成的，有些则需要手动操作，所选择的验证方法学（methodology）决定了上述步骤如何展开。</p>
<h1 id="定向测试">3. 定向测试</h1>
<p>  当需要验证一个设计的正确性时，传统的做法可能是使用<strong>定向测试</strong>（<em>directed
testing</em>）。使用这种方式，首先需要阅读硬件规范，然后写下验证计划，计划上列有各种测试，每个测试针对一系列相关的特性。按照这个计划，接着<strong>编写针对
DUT 具体特性的激励向量，然后使用这些向量对 DUT
进行仿真</strong>。仿真结束后，手动查看一下结果文件和波形，确保设计的行为与预期的一致。一旦测试结果正确，就可以开始下一个测试。</p>
<p>  这种渐进的方法比较容易取得稳步的进展，因而很受那些喜欢看到项目持续向前推进的管理者的欢迎。由于创建每个激励向量时并不需要什么基础，所以定向测试的结果也会很快得到。只要给予足够的时间和人力，定向测试对于大部分设计验证来讲都是可以胜任的。</p>
<p>  <a href="#图1">图 1</a>
显示了定向测试如何逐步覆盖验证计划中的每个特性。每个测试都针对一个特别的设计元素集合。<strong>如果有足够的时间</strong>，可以写出
100% 覆盖整个验证计划所需要的全部测试。</p>
<p><a id="图1"></a></p>
<figure>
<img data-src="../images/post/2022-05-30-josh-systemverilog-1/2022-05-30-josh-systemverilog-1-010-DirectedTestProgressOverTime.png" width="500" alt="图 1. 定向测试随时间的进展">
<figcaption aria-hidden="true">图 1. 定向测试随时间的进展</figcaption>
</figure>
<p>  如果没有足够的时间和资源来完成定向测试该怎么办？如<a href="#图1">图
1</a>，当在时间往前推进时，覆盖率（coverage）可能维持不变。如果设计复杂度翻倍，那么测试就需要增加一倍的时间或者人力，而这种情况是我们所不愿意看到的。因此为了达到
100% 覆盖率的目标，需要一种可以更快找出漏洞的方法。</p>
<p>  <a href="#图2">图 2</a>
所示为整个设计空间和各种特性被定向测试案例覆盖的情形。在设计空间里有很多特性（feature），其中有些存在漏洞，需要编写各种测试（test）去覆盖所有的特性并找出漏洞。</p>
<p><a id="图2"></a></p>
<figure>
<img data-src="../images/post/2022-05-30-josh-systemverilog-1/2022-05-30-josh-systemverilog-1-020-DirectedTestCoverage.png" width="800" alt="图 2. 定向测试的覆盖率">
<figcaption aria-hidden="true">图 2. 定向测试的覆盖率</figcaption>
</figure>
<h1 id="方法学基础">4. 方法学基础</h1>
<p>  本文使用如下原则：</p>
<ol type="1">
<li><p>受约束的随机激励。</p></li>
<li><p>功能覆盖率。</p></li>
<li><p>使用事件处理器的分层测试平台。</p></li>
<li><p>对所有测试通用的测试平台。</p></li>
<li><p>独立于测试平台之外的个性化测试代码。</p></li>
</ol>
<p>  些原则是相关联的。随机激励对于测试复杂设计十分关键。<strong>定向测试可以找出设计中预期的漏洞，而随机测试则能够找出预料不到的漏洞</strong>。当使用随机激励时，需要用功能覆盖率来评估验证的进展情况。一旦开始使用自动生成的激励，就需要一种能够<strong>自动预测结果</strong>的方式——通常是记分板（scoreboard）或者参考模型（reference
model）。建立包括自预测在内的测试平台是一件工作量很大的事情。<strong>分层测试平台</strong>（<em>layered
testbench</em>）能够把问题分解为容易处理的小块，这样有助于控制复杂度。<strong>事件处理器</strong>（<em>transactors</em>）能够为构建这些小块提供有用的模式（pattern）。在适当的规划下，可以建立一个测试平台所需的基础设施，它们能在所有测试中通用并且不需要经常修改，只需要在某些地方放置“钩子（hook）”，以便测试能够在这些地方执行调整激励或注入错误等特定操作。相反，针对单一测试的个性化代码必须与测试平台分开，这样可以避免增加基础设施的复杂度。</p>
<p>  建立这种风格的测试平台所需的时间要比传统的定向测试平台多得多，尤其是自检的部分，因此可能需要很长的准备时间才能进行第一次可运行的测试。这会给项目管理带来阵痛，所以需要在测试时间表上把这部分考虑进去。从<a href="#图3">图 3</a>
中可以看到，第一个随机测试运行前有比较长的初始延迟。</p>
<p><a id="图3"></a></p>
<figure>
<img data-src="../images/post/2022-05-30-josh-systemverilog-1/2022-05-30-josh-systemverilog-1-030-ConstraineRandomTestProgressOverTimeVSDirectedTesting.png" width="500" alt="图 3. 受约束的随机测试与定向测试随时间的进度比较">
<figcaption aria-hidden="true">图 3.
受约束的随机测试与定向测试随时间的进度比较</figcaption>
</figure>
<p>  随机测试的前期准备工作看起来似乎令人不满意，但是其回报却很高。每个随机测试都可以共享这个通用的测试平台，不像每个定向测试都要从零开始编写。每个随机测试都会包含一部分代码，将激励约束到特定的方向上并触发期望的异常，比如创建一个协议违例（protocol
violation），受约束的随机测试平台找起漏洞来会比很多定向测试快很多。</p>
<p>  随着漏洞出现率的下降，应该创建新的随机约束去探索新的区域。最后的几个漏洞可能只能通过定向测试来发现，但是绝大部分的漏洞都应该会在随机测试中出现。</p>
<h1 id="受约束的随机激励">5. 受约束的随机激励<a name="05"></a></h1>
<p>  虽然我们希望仿真器能产生随机激励，但同时又<strong>不希望这些激励数值完全随机</strong>。使用
SystemVerilog 语言可以描述激励的格式（例如，地址是 32 位；操作码是 ADD、
SUB 或 STORE；长度 &lt; 32
字节），然后让仿真器产生满足约束的数值。这些数值会被发送到设计中去，同时也会被发送到一个负责预测仿真结果的高层模块中去。设计的实际输出最终需要和预测输出做对比。</p>
<p>  <a href="#图4">图 4</a>
所示为受约束的随机测试在整个设计空间中的覆盖率。</p>
<ul>
<li><p>值得注意的是，<strong>一个随机测试的覆盖范围往往比一个定向测试大</strong>。多出来的覆盖部分可能会与其他测试发生交叠，或者探测到事先没有预料到的新区域（new
area）。</p></li>
<li><p>在这些新区域中发现漏洞是一件幸运的事情。如果这些对新区域的测试不合法，则需要编写更多的约束去阻止随机测试产生非法的功能。</p></li>
<li><p>对于那些受约束的随机测试覆盖不到的地方，可能还需要编写一些定向测试。</p></li>
</ul>
<p><a id="图4"></a></p>
<figure>
<img data-src="../images/post/2022-05-30-josh-systemverilog-1/2022-05-30-josh-systemverilog-1-040-ConstrainedRandomTestCoverage.png" width="800" alt="图 4. 受约束的随机测试覆盖率">
<figcaption aria-hidden="true">图 4. 受约束的随机测试覆盖率</figcaption>
</figure>
<p>  <a href="#图5">图 5</a> 所示为达到完全覆盖的技术路线：</p>
<ol type="1">
<li><p>从左上角的基本的受约束的随机测试（constrained random
test）开始，使用不同的种子（seed）运行。</p></li>
<li><p>当我们查看功能覆盖率（functional
coverage）报告时，注意找出覆盖率中的间隙（hole），即覆盖盲区。</p></li>
<li><p>针对这些盲区进行最小程度代码修改（minimal code
modification），可能是使用新的约束（constraint），也可能是把错误或延迟加入到
DUT
中。这个外部循环会花掉我们大部分的时间，只有对少数使用随机测试达不到的特性才编写定向测试。</p></li>
</ol>
<p><a id="图5"></a></p>
<figure>
<img data-src="../images/post/2022-05-30-josh-systemverilog-1/2022-05-30-josh-systemverilog-1-050-CoverageConvergence.png" width="500" alt="图 5. 覆盖率收敛">
<figcaption aria-hidden="true">图 5. 覆盖率收敛</figcaption>
</figure>
<h1 id="我们的随机化对象是什么">6.
我们的随机化对象是什么<a name="06"></a></h1>
<p>  当考虑对一个设计的激励进行随机化时，首先想到的可能是数据字段。这种激励最容易创建——只需调用
<code>$random()</code>
即可。问题是这种随机数据在找漏洞方面的回报很小。能够使用随机数据找到的漏洞类型基本上都是在数据路径上的，很可能还都是比特级的错误，还需要找出<strong>控制逻辑上的漏洞</strong>。</p>
<p>  此外，需要广泛地考虑所有的设计输入，如下所列：</p>
<ol type="1">
<li><p>设备配置。</p></li>
<li><p>环境配置。</p></li>
<li><p>输入数据。</p></li>
<li><p>协议异常。</p></li>
<li><p>错误和违例。</p></li>
<li><p>时延。</p></li>
</ol>
<h2 id="设备和环境配置">6.1. 设备和环境配置</h2>
<p>  在对 RTL
设计进行测试的过程中，察觉不到漏洞的最常见的原因是什么？是因为<strong>没有尝试足够多的不同配置（<em>configuration</em>）</strong>。很多测试只使用了仅仅经过复位的设计，或者施加固定的初始化向量集把设计引向一个已知的状态。这就好比是在个人电脑上刚刚安装完操作系统，还没有安装任何应用程序的时候，就对操作系统进行测试。测试结果当然会很好，但是并没有挖掘出实际的问题。</p>
<blockquote>
<p>  在一个实际的应用环境中，随着 DUT
使用时间的增加，其配置会变得越来越随机。例如，验证一个分时复用的多路开关，它有
2000 个输入通道和 12
个输出通道。这些通道在另外一边可以映射成各种不同的配置。每个输入可能作为单个通道使用，也可能会被进一步分割成多个通道。棘手的是，虽然大部分时间里使用的是几种标准的通道分割方式，但由于其他分割方式的组合也是合法的，所以存在着大量可能的用户配置。</p>
<p>  为了测试这个设备，对于每个通道的配置，工程师都必须写出好几十行的定向测试代码。显然，验证工程师无力应对如此多的通道配置。后来编写了一个测试平台，对每个通道的参数都采用随机化策略，然后把这部分代码放到一个循环里去完成所有开关通道的配置。现在，找出与配置相关的漏洞变得更加容易，而这些漏洞在以前常常不被察觉。</p>
</blockquote>
<p>  在实际的应用中，我们的设计所在的环境里会包含其他的部件。当对 DUT
进行验证时，实际上就是把测试平台连接起来模仿这个环境，应该对整个环境的配置进行随机化，包括仿真的时长、设备的数量，以及它们的配置方式。当然，需要创建约束以确保配置的合法性。</p>
<blockquote>
<p>  在另外一个 Synopsys 公司的客户案例中，一家公司设计了一个 I/O
交换芯片，用于把多套 PCI
总线连接到一套内部总线上。在仿真一开始，他们就随机地选择了 PCI
总线的数目（1~4）以及总线上设备的数目（1~8），而且对每个设备上的参数也进行了随机化（如主从模式、
CSR
地址等等）。他们使用功能覆盖率对测试过的组合进行跟踪，以确保所有可能的组合都被覆盖。</p>
</blockquote>
<p>  其他环境参数还包括测试长度、错误注入比率，以及时延模式等。Bergeron（2006）在这方面有更多的例子。</p>
<h2 id="输入数据">6.2. 输入数据</h2>
<p>  当看到随机激励时，我们可能会想到<strong>选取一个总线写入的事件或
ATM
信元，然后把随机数值填充到其中的数据字段里</strong>。实际上，这种方式相当直接，需要事先估计好所有的分层协议和错误注入，以及记分板的内容和功能覆盖率。</p>
<h2 id="协议异常错误和违例">6.3. 协议异常、错误和违例</h2>
<p>  最令人沮丧的事情莫过于个人电脑或移动电话之类的设备死机。大多数情况下，唯一的办法就是关机然后重新启动。死机最有可能的原因是，产品内部的一部分逻辑遇到了错误以后无法恢复过来，因此使得设备不能正常工作。</p>
<p>  如何才能阻止这些问题出现在我们创建的硬件上呢？应该尽量尝试去仿真在实际的硬件中可能出现的错误，而且应该针对所有可能出现的错误。如果一个总线事件没有完成会怎么样？如果遇到一个非法的操作呢？设计规范中有没有指出哪两个信号互斥？要对这些情况一一尝试，然后确保设备还能继续正常运作。</p>
<p>  <strong>在尝试使用不当的命令去激励硬件的同时，也应该注意捕捉出现的问题</strong>。例如，重新调用那些互斥的信号。可以增加用于检验的代码来帮忙找出问题所在。这些代码应该至少能够在出错的地方打印一个警告信息，如果能够报告出错误并且使测试停下来则更好。花费大最时间在代码中追溯故障的根源，是一件令人非常不愉快的事情，尤其是在本来如果使用一个简单的断言就可以定位这个错误的情况下。（关于如何在测试平台和设计代码中编写断言，可以参考
Vijayaraghavan 和 Ramanathan 在 2005
出版的著作。）只要确保能够使代码在出错的地方停止仿真，那么就很容易应对测试中的错误。</p>
<h2 id="时延和同步">6.4. 时延和同步</h2>
<p>  测试平台应该以多快的速度发送激励呢？使用<strong>受约束的随机时延</strong>有助于捕捉协议上的漏洞。时延最短的测试运行速度最快，但它产生不了所有可能的激励。可以创建一个测试平台以最快的速度与另一个代码块通信，但那些隐蔽的漏洞往往是在引入间歇性时延之后才被发现的。</p>
<p>  一个代码块对于来自同一接口的所有可能激励也许都能正常工作，但如果同时面对多个输入，隐蔽的漏洞可能就会出现。尝试协调各个驱动器使它们能够在不同的速率下进行通信。如果输入以可能的最快速率到达，而输出却被卡在一个较低的速率上，该怎么办？如何处理来自多个输人的激励同时到达的情况？如果这此激励带有不同的时延又该怎么办？使用功能覆盖率，可以测量随机生成的各种组合。</p>
<h2 id="并行的随机测试">6.5. 并行的随机测试</h2>
<p>  如何运行测试？每个定向测试都带有一个测试平台，能够产生一组特定的激励和响应向量。如果想改变激励，就需要改变测试。随机测试则包含了测试平台代码和随机种子。如果对同一个测试运行
50 次，每次都采用不同的种子，那么将会得到 50
个不同的激励集合。使用多个种子运行同一个测试可以加大覆盖率，同时也能减少工作量。</p>
<p>  我们需要<strong>为每次仿真选定一个独特的种子</strong>。有些人使用自然时间作为种子，但这依然会引起重复。如果半夜里在一个计算机集群系统上开始
10
项任务会怎么样？多项任务可能会于同一时间在不同的计算机上启动，这样还是会得到相同的随机种子并运行相同的激励。因此，应该把处理器的名称加入到种子里去。如果集群系统里面有多核计算机，那还是可能会出现两个相同的种子，所以在这种情况下应该把处理器核的编号也加到种子里去，这样就能得到独一无二的种子了。</p>
<div class="note info"><p>  我们还需要对并行仿真的文件组织进行规划。每次仿真都会有一系列的输出文件，例如日志文件和功能覆盖率文件，可以让每个仿真在不同的目录里运行，或者也可以尝试给每个文件取不同的名字。最简单的办法是在目录名后面加上随机种子的值。</p>
</div>
<h1 id="功能覆盖率">7. 功能覆盖率</h1>
<p>  本文<a href="#05">第 5 节</a>和<a href="#06">第 6
节</a>讲述了如何创建激励并使这些激励遍历整个可能的输入空间。使用这种方法，测试平台会频繁访问部分区域，但需要花费很长的时间来达到所有可能的状态。即使对仿真时间不加限制，无法达到的状态还是永远也不会被访问到，因此需要知道哪些部分已经被验证过，这样才能对验证计划中的项目进行核对。</p>
<p>  对功能覆盖率的测量和使用包含了几个步骤。首先，需要在测试平台中加入代码，用于监控进入设备中的激励，以及设备对激励的反应，并据此确定哪些功能已经被验证过。运行几次仿真，每次使用不同的种子。接下来，把这些仿真的结果合并到一个报告中。然后需要对结果进行分析，最后决定如何采用新的激励来达到那些尚未被测试到的条件和逻辑。</p>
<h2 id="从功能覆盖率到激励的反馈">7.1. 从功能覆盖率到激励的反馈</h2>
<p>  随机测试需要使用反馈（feedback）。最初的测试会被运行很多次，使用不同的种子，创建很多互异的输入序列。但是到了最后，即使使用新的种子，所产生的激励也很可能无法在设计空间中探测到新区域。<strong>随着功能覆盖率逐渐接近极限，需要改变测试，以期能找出新的方法去达到那些尚未被覆盖的区域</strong>。这被称为“覆盖率驱动的验证”，如<a href="#图6">图 6</a> 所示。</p>
<p><a id="图6"></a></p>
<figure>
<img data-src="../images/post/2022-05-30-josh-systemverilog-1/2022-05-30-josh-systemverilog-1-060-TestProgressWithAndWithoutFeedback.png" width="500" alt="图 6. 带反馈和不带反馈的测试进展">
<figcaption aria-hidden="true">图 6.
带反馈和不带反馈的测试进展</figcaption>
</figure>
<p>  测试平台有没有可能为我们做到这一点呢？假设现在需要使用测试平台在每个周期为处理器产生一个总线事件，并为总线事件做出终止判断（成功、校验错误、重试）。在没有使用
HVL
的时候，通常会编写一个很长的定向测试集，然后花费了很多天的工夫编排终止判断代码，并让它们在合适的周期里给出判断。经过了大量的手动分析以后才得出成功的结论达到
100
％的覆盖率。但之后可能由于处理器的时序有了一点微小的改变，不得不重新分析测试并改变激励。</p>
<p>  更加有效的测试策略是<strong>使用随机总线事件和终止判断</strong>。运行的时间越长，覆盖率就会越高。另外的一个好处是，这种测试在创建激励时灵活性很高，足以应对设计时序有改变的情形。为了做到这一点，可以在测试代码中加入一个反馈循环，用于监测己生成的激励（是否已经产生所有写周期？）并根据情况调整约束的权重（把写的权重降到零)。这种改进能大大缩减达到完全覆盖的时间，而且只需要很少量的人工干预。</p>
<p>  其实，这并不是一种典型的情况，因为从功能覆盖率到激励的反馈往往是微不足道的。在实际的设计中，应该如何改变激励以使它达到一个期望的设计状态呢？这不仅要求对设计有深入的了解，而且还需要高超的形式验证技术。总之答案并不简单，所以<strong>在受约束的随机激励中很少采用动态反馈</strong>。相反地，<strong>需要手动分析覆盖率报告，然后调整随机约束</strong>。</p>
<p>  有些形式分析工具如 Magellan（Synopsys,
2003）用到了反馈。它首先对设计进行分析并找出所有可以达到的互异状态。然后运行一小段仿真看有多少状态被访问到。最后，在状态机和设计输入之间进行搜索并计算出达到所有遗留状态所需要的激励，然后
Ma­gellan 再把这些激励施加到 DUT 上。</p>
<h1 id="测试平台的构建">8. 测试平台的构建</h1>
<p>  在仿真时，<strong>测试平台会把整个 DUT
包围起来</strong>，就像一个硬件测试器连接到一个物理芯片上一样，如<a href="#图7">图 7</a>
所示。测试平台和测试仪器都会产生激励并捕捉响应。不同的是，测试平台需要工作在一个很宽的抽象层次范围内，同时创建事件和激励序列并最终转换成比特向量。而测试仪器则只工作在比特级上。</p>
<p><a id="图7"></a></p>
<figure>
<img data-src="../images/post/2022-05-30-josh-systemverilog-1/2022-05-30-josh-systemverilog-1-070-TheTestbenchDesignEnvironment.png" width="450" alt="图 7. 测试平台与设计环境">
<figcaption aria-hidden="true">图 7. 测试平台与设计环境</figcaption>
</figure>
<p>  测试平台模块里都包含了什么呢？有很多的 BFM（Bus Functional Models,
总线功能模型），可以把它们看成是测试平台构件（components）——从 DUT
的角度看，它们和真实的构件没什么两样，但它们其实只是测试平台的组成部分，并非
RTL 设计。如果实际应用中设备被连接到 AMBA、USB、PCI 和 SPI
总线上，那么就必须<strong>在测试平台中建立能够产生激励并校验响应的等效构件</strong>，如<a href="#图8">图 8</a>
所示。这些构件并不是带有细节的可综合模型，而是遵循协议并且执行速度更快的高层次事件处理器。如果把设计原型在
FPGA 上实现或者是进行硬件仿真，那么这些 BFM 就需要是可综合的。</p>
<p><a id="图8"></a></p>
<figure>
<img data-src="../images/post/2022-05-30-josh-systemverilog-1/2022-05-30-josh-systemverilog-1-080-TestbenchComponents.png" width="450" alt="图 8. 测试平台构件">
<figcaption aria-hidden="true">图 8. 测试平台构件</figcaption>
</figure>
<h1 id="分层测试平台">9. 分层测试平台</h1>
<p>  对于任何一种新型的验证方法学来讲，分层的测试平台是一个关键的概念。虽然分层似乎会使测试平台变得更复杂，但它能够把代码分而治之，<strong>有助于减轻工作负担</strong>。不要试图去编写一个包含所有功能（随机产生所有合法和非法的激励，并使用多层协议进行错误注入）的子程序，因为这样的子程序很快就会变得很复杂，并且难以维护。</p>
<h2 id="不分层的测试平台">9.1. 不分层的测试平台</h2>
<p>  在刚开始学习 Verilog
并尝试写测试程序的时候，这些程序看起来可能会和<a href="#例1.1">例
1.1</a> 所示的用于执行一个简单 APB（AMBA Peripheral Bus, AMBA
外围总线）写入的低层次代码很相似。</p>
<p><a id="例1.1"></a></p>
<figure class="highlight verilog"><figcaption><span>例 1.1. 驱动 APB 引脚</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> test(PAddr,PWrite,PSel,PWData,PEnable,Rst,clk);</span><br><span class="line"><span class="comment">// 此处省略端口声明</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 驱动复位</span></span><br><span class="line">        Rst &lt;= <span class="number">0</span>;</span><br><span class="line">        # <span class="number">100</span> Rst &lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 驱动控制总线</span></span><br><span class="line">        @(<span class="keyword">posedge</span> clk)</span><br><span class="line">        PAddr  &lt;= <span class="number">16'h50</span>;</span><br><span class="line">        PWData &lt;= <span class="number">32'h50</span>;</span><br><span class="line">        PWrite &lt;= <span class="number">1'b1</span>;</span><br><span class="line">        PSel   &lt;= <span class="number">1'b1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使 PEnable 翻转</span></span><br><span class="line">        @(<span class="keyword">posedge</span> clk)</span><br><span class="line">            PEnable &lt;= <span class="number">1'b1</span>;</span><br><span class="line">        @(<span class="keyword">posedge</span> clk)</span><br><span class="line">            PEnable&lt; = <span class="number">1'b0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 校验结果</span></span><br><span class="line">        <span class="keyword">if</span> (top<span class="variable">.mem</span><span class="variable">.memory</span>[<span class="number">16'h50</span>] == <span class="number">32'h50</span>)</span><br><span class="line">            <span class="built_in">$display</span>(<span class="string">"Success"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">$display</span>(<span class="string">"Error, wrong value in memory"</span>);</span><br><span class="line">        <span class="built_in">$finish</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></tbody></table></figure>
<p>  经过几天连续编写这种代码以后，我们可能会意识到这是一种重复性的劳动，所以会尝试创建可用于总线写入这种普通操作的任务，如<a href="#例1.2">例 1.2</a> 所示。</p>
<p><a id="例1.2"></a></p>
<figure class="highlight verilog"><figcaption><span>例 1.2. 一个用于驱动 APB 引脚的任务</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">task</span> write(<span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>] addr, <span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>] data);</span><br><span class="line">    <span class="comment">// 驱动控制总线</span></span><br><span class="line">    @(<span class="keyword">posedge</span> clk)</span><br><span class="line">    PAddr  &lt;= addr;</span><br><span class="line">    PWData &lt;= data;</span><br><span class="line">    PWrite &lt;= <span class="number">1'b1</span>;</span><br><span class="line">    PSel   &lt;= <span class="number">1'b1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使 PEnable 翻转</span></span><br><span class="line">    @(<span class="keyword">posedge</span> clk)</span><br><span class="line">        PEnable &lt;= <span class="number">1'b1</span>;</span><br><span class="line">    @(<span class="keyword">posedge</span> clk)</span><br><span class="line">        PEnable &lt;= <span class="number">1'b0</span>;</span><br><span class="line"><span class="keyword">endtask</span></span><br></pre></td></tr></tbody></table></figure>
<p>  这样，测试平台就会变得简单一些，如<a href="#例1.3">例 1.3</a>。</p>
<p><a id="例1.3"></a></p>
<figure class="highlight verilog"><figcaption><span>例 1.3. 低层次的 Verilog 测试</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> test(PAddr,PWrite,PSel,PWData,PEnable,Rst,clk);</span><br><span class="line">    <span class="comment">// 此处省略端口声明</span></span><br><span class="line">    <span class="comment">// 此处省略如例 1.2 给出的任务函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        reset();                  <span class="comment">// 设备复位</span></span><br><span class="line">        write(<span class="number">16'h50</span>, <span class="number">32'h50</span>);    <span class="comment">// 把数据写入到存储器中</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 校验结果</span></span><br><span class="line">        <span class="keyword">if</span>(top<span class="variable">.mem</span><span class="variable">.memory</span>[<span class="number">16'h50</span>] == <span class="number">32'h50</span>)</span><br><span class="line">            <span class="built_in">$display</span>(<span class="string">"Success"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">$display</span>(<span class="string">"Error, wrong value in memory"</span>);</span><br><span class="line">        <span class="built_in">$finish</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></tbody></table></figure>
<p>  通过把一些通用的操作（如复位、总线读出和总线写入）放到一个子程序中，可以提高工作效率并减少错误。这里，物理和命令层的建立只是通往分层测试平台的第一步。</p>
<h2 id="信号和命令层">9.2. 信号和命令层</h2>
<p>  <a href="#图9">图 9</a> 所示为一个测试平台中最低的几个层次。</p>
<p><a id="图9"></a></p>
<figure>
<img data-src="../images/post/2022-05-30-josh-systemverilog-1/2022-05-30-josh-systemverilog-1-090-SignalAndCommandLlayers.png" width="500" alt="图 9. 信号和命令层">
<figcaption aria-hidden="true">图 9. 信号和命令层</figcaption>
</figure>
<p>  在底部的<strong>信号层</strong>（<em>signal</em>），包含 DUT 和把
DUT 连接到测试平台的信号。</p>
<p>  再往上一层是<strong>命令层</strong>（<em>command</em>）。执行总线读写命令的驱动器驱动
DUT 的输入。DUT
的输出与监视器（monitor）相连，监视器负责检测信号的变化，并把这些变化按照命令分组。断言（assertion）也穿过命令层和信号层，它们负责监视独立的信号以寻找穿越整个命令的信号变化。</p>
<h2 id="功能层">9.3. 功能层</h2>
<p>  <a href="#图10">图 10</a>
给出了为加上<strong>功能层</strong>（<em>functional</em>）的测试平台，功能层向下面对的是命令层。代理（agent,
在 VMM 中称为事件处理器）接收到来自上层的事件，例如，DMA
读或写，把它们分解成独立的命令。这些命令也被送往用于预测事件结果的记分板（scoreboard）。检验器（checker）则负责比较来自监视器和记分板的命令。</p>
<p><a id="图10"></a></p>
<figure>
<img data-src="../images/post/2022-05-30-josh-systemverilog-1/2022-05-30-josh-systemverilog-1-100-TestbenchWithFunctionalLlayerAdded.png" width="500" alt="图 10. 加上功能层的测试平台">
<figcaption aria-hidden="true">图 10. 加上功能层的测试平台</figcaption>
</figure>
<h2 id="场景层">9.4. 场景层</h2>
<p>  <a href="#图11">图 11</a>
所示，功能层被位于<strong>场景层</strong>（<em>scenario</em>）中的发生器（generator）所驱动。什么是场景呢？记住一点，验证工程师的工作是确保
DUT 能够完成预期的任务。比如 MP3
播放器，它能一边播放事先存储好的音乐，一边从一台主机上下载新的音乐，并且同时对用户输入如音量调整或音轨控制等操作保持响应。这中间的每一个操作都能称为一个场景。下载一个音乐文件需要若于步骤，例如前期准备时的控制寄存器的读写操作，歌曲传送过程中多次
DMA
写操作，以及之后的很多读写操作。场景层就是负责组织协调这些步骤的，操作的参数如音轨大小和寄存器位置等都采用受约束的随机值。</p>
<p><a id="图11"></a></p>
<figure>
<img data-src="../images/post/2022-05-30-josh-systemverilog-1/2022-05-30-josh-systemverilog-1-110-TestbenchWithScenarioLayerAdded.png" width="500" alt="图 11. 加上场景层的测试平台">
<figcaption aria-hidden="true">图 11. 加上场景层的测试平台</figcaption>
</figure>
<p>  在测试平台<strong>环境</strong>（<em>environment</em>）中的这些块（[图
11](#图11）虚线框内）是在刚开始开发的时候画出来的。随着项目的进展，它们可能会有一些变化，也可能会加入一些功能，但是这些块对于每个独立的测试都是不应改变的。可以通过在代码中留下“钩子”来做到这一点，这样即使这些块的行为需要在测试时改变，也不必重新编写代码。“钩子”可以使用工厂模式（factory
patterns）和回调函数（callbacks）来创建。</p>
<h2 id="测试的层次和功能覆盖率">9.5. 测试的层次和功能覆盖率</h2>
<p>  现在到了测试平台的最顶层——测试层，如<a href="#图12">图 12</a>。DUT
模块间的漏洞是比较难以发现的，因为这些模块可能是不同的人按照不同的规范设计出来的。</p>
<p><a id="图12"></a></p>
<figure>
<img data-src="../images/post/2022-05-30-josh-systemverilog-1/2022-05-30-josh-systemverilog-1-120-FullTestbenchWithAllLayers.png" width="500" alt="图 12. 带着所有层次的完整测试平台">
<figcaption aria-hidden="true">图 12.
带着所有层次的完整测试平台</figcaption>
</figure>
<p>  这个顶层的测试（test）就像一个指挥官：他不演奏任何乐器，但引领着其他人的表演。测试包含了用于创建激励的约束。</p>
<p>  功能覆盖率（functional
coverage）可以衡量所有测试在满足验证计划要求方面的进展。随着各项测量标准的完成，功能覆盖率代码在整个项目过程中会经常变化。由于代码经常被修改，所以它不作为测试环境的组成部分。</p>
<p>  我们可以在受约束的随机环境中创建“定向测试”。只需在随机序列中间插入定向测试的代码，或者把两部分代码并列。定向代码执行期望的任务，而随机的“背景噪声”可能会使漏洞暴露出来，而且漏洞还有可能来自从未被关注过的模块。</p>
<p>  测试平台中是否需要所有的层次呢？答案要视 DUT
而定。设计越复杂，所需的测试平台就要越完备。测试层则是必须的。对于一个简单的设计来说，场景层可能过于简单以至于可以把它合并到代理中。</p>
<p>  当然，可能还需要更多的层次。如果 DUT
有多个协议层，那么每个层都应该在测试平台环境中有对应的层。例如使用 IP
封装了 TCP
流量，然后通过以太网数据包的形式发送，对这种情况的测试应该考虑使用三个独立的层来产生和校验数据，如
果能够使用已有的验证构件则更好。</p>
<p>  <a href="#图12">图 12</a>
中需要注意的最后一点是，它只给出了各块之间一些可能的连接方式，测试平台模块间的连接可能会与之不同。比如测试层可能需要连接到驱动器层以迫使物理漏洞出现。这里给出的只是一些引导——实际当中应该是，需要什么就创建什么。</p>
<h1 id="建立一个分层的测试平台">10. 建立一个分层的测试平台</h1>
<p>  现在是学习如何把前面图示的那些构件映射成 SystemVerilog
结构时候了。</p>
<h2 id="创建一个简单的驱动器">10.1. 创建一个简单的驱动器</h2>
<p>  首先，来仔细看看其中的一个模块——驱动器。<a href="#图13">图 13</a>
所示的驱动器接收来自代理的命令。驱动器可能会注入错误或者增加时延，然后再把命令分解成一些信号的变化，例如总线请求或握手。这样一个测试平台模块通常被称为“事件处理器（transactor)”，它的核心部分是一个循环：有关事件处理器的示范代码如[例
1.4](#例1.4）所示。</p>
<p><a id="图13"></a></p>
<figure>
<img data-src="../images/post/2022-05-30-josh-systemverilog-1/2022-05-30-josh-systemverilog-1-130-ConnectionsForTheDriver.png" width="120" alt="图 13. 带着所有层次的完整测试平台">
<figcaption aria-hidden="true">图 13.
带着所有层次的完整测试平台</figcaption>
</figure>
<p><a id="例1.4"></a></p>
<figure class="highlight verilog"><figcaption><span>例 1.4. 基本的事件处理器代码</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">task</span> run();</span><br><span class="line">  done = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (!done) <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">// 获取下一个事件</span></span><br><span class="line">    <span class="comment">// 进行变换</span></span><br><span class="line">    <span class="comment">// 发送事件</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endtask</span></span><br></pre></td></tr></tbody></table></figure>
<p>  后序的文章给出了：</p>
<ul>
<li><p>基本的 OOP
以及如何创建一个对象并使对象里面包含事件处理器所需要的子程序和数据，事件处理器的另一个例子是代理，它可能会把一个复杂的事件如
DMA 读分解成多个总线命令；</p></li>
<li><p>如何创建一个对象并使对象里面包含构成一个命令所需要的数据和子程序。使用
SystemVerilog 信箱可以实现这些对象在不同的事件处理器之间传递；</p></li>
<li><p>还将介绍很多方法，用于在不同层之间交换数据并使事件处理器实现同步。</p></li>
</ul>
<h1 id="仿真环境的阶段">11. 仿真环境的阶段</h1>
<p>  到目前为止，已经学习了环境的构成部分。这些部分在什么时候执行呢？我们希望把各个阶段清楚地定义好，以便协调测试平台，使项目中的所有代码能在一起工作。三个基本的阶段是建立（build）、运行（run）和收尾（wrap-up）。每个阶段都可以再细分为更小的步骤。</p>
<p>  <strong>建立阶段</strong>可以分为如下步骤。</p>
<ol type="1">
<li><p><strong>生成配置</strong>（<em>Generate configuration</em>）：把
DUT 的配置和周围的环境随机化。</p></li>
<li><p><strong>建立环境</strong>（<em>Build
environment</em>）：基于配置来分配和连接测试平台构件。测试平台构件指的是存在于测试平台中的部分，注意与设计中的物理构件区分开，后者是采用
RTL
代码描述的。例如，如果配置选择了三个总线驱动器，那么测试平台应该在这个阶段对它们进行分配和初始化。</p></li>
<li><p><strong>对 DUT 进行复位</strong>（<em>Reset the
DUT.</em>）。</p></li>
<li><p><strong>配置 DUT</strong>（<em>Configure the
DUT</em>）：基于第一步中生成的配置，载入 DUT 的命令寄存器。</p></li>
</ol>
<p>  <strong>运行阶段</strong>是指测试实际运行的阶段，可分为以下步骤。</p>
<ol type="1">
<li><p><strong>启动环境</strong>（<em>Start
environment</em>）：运行测试平台构件，例如各种 BFM
和激励发生器。</p></li>
<li><p><strong>运行测试</strong>（<em>Run the
test</em>）：启动测试然后等待测试完成。定向测试的完成很容易判断，但随机测试却比较困难。可以使用测试平台的层作为引导。从顶层启动，等待一个层接收完来自上一层（如果有的话）的所有输入，接着等待当前层空闲下来，然后再等待下一层。应该同时使用超时检测以确保
DUT 或测试平台不出现死锁（lock up）。</p></li>
</ol>
<p>  收尾阶段包含如下两个步骤。</p>
<ol type="1">
<li><strong>清空</strong>（<em>Sweep</em>）：在最下层完成以后，需要等待
DUT 清空最后的事务。</li>
<li><strong>报告</strong>（<em>Report</em>）：一旦 DUT
空闲下来，就可以清空遗留在测试平台中的数据了。有时候保存在记分板里面的数据从来就没有送出来过，这些数据可能是被
DUT
丢弃掉的。可以根据这些信息创建最终报告，说明测试通过或者失败。如果测试失败，务必把相应的功能覆盖率结果删除，因为它们可能是不正确的。</li>
</ol>
<p>  如<a href="#图12">图 12</a>
所示，测试启动环境以后，环境就会按上述步骤运行。</p>
<h1 id="最大限度的代码重用">12. 最大限度的代码重用</h1>
<p>  为了验证一个带有数百个特性的复杂设备，必须编写数百个定向测试。如果使用受约束的随机激励，需要编写的测试就会少很多。与定向测试相比，随机测试的主要工作是构建测试平台，使它包含所有较低的层：场景、功能、命令以及信号。这个测试平台代码要能够被所有的测试使用，所以它需要有很好的<strong>通用性</strong>。</p>
<p>  这些建议似乎是在推荐一个极度复杂的测试平台，但需要记住的是，在测试平台中每输入一行，就等于给每个单独的测试都减少了一行，相当于在同时创建很多个测试，而这也正是建立一个复杂测试平台所能获得的巨额回报。</p>
<h1 id="测试平台的性能">13. 测试平台的性能</h1>
<p>  如果你是第一次接触这种方法学的话，可能还是会怀疑它工作起来是否会优于定向测试？一个普遍的质疑便是测试平台
的性能。一个定向测试通常可以在一秒之内运行完，但<strong>受约束的随机测试却要花费数分钟甚至数小时去搜索整个状态空间</strong>。这种论点的问题在于，它忽略了一个在验证上真实存在的瓶颈：创建一个测试所需要的时间。你可以在一天之内手动编写完一个定向测试，然后再花一两天的时间调试并手动验证结果。测试的实际运行时间比起你在其他方面花费的时间其实要少得多。</p>
<p>  创建受约束的随机测试需要几个步骤。</p>
<ol type="1">
<li><p>最重要的一步是建立分层的测试平台，包括自检的部分。这项工作能给所有的测试带来好处，所以是非常值得的。</p></li>
<li><p>按照验证计划中列举的目标创建激励。可以使用随机约束，也可以采用注入错误或协议违例等迂回的方式。以这其中的任何一种方式创建激励所花费的时间可能可以用于创建好儿个定向测试，但是它的回报也要高很多。一个受约束的随机测试能够尝试成千上万种不同的协议违例，而在同样的时间里创建的几个定向测试却只能尝试几种情形，显然前者要比后者好得多。</p></li>
<li><p>功能覆盖率（受约束的随机测试）。这项任务的开始是创建一个强有力的验证计划，这个计划必须带有清晰而且便于测植的目标。接下来你需要创建
System­Verilog
代码，在环境中添加工具用于收集数据。最后很重要的一点，你需要对结果进行分析，并据此判断是否满足目标要求，如果不满足，应如何修改测试。</p></li>
</ol>
<h1 id="结束语">14. 结束语</h1>
<p>  电子设计复杂度的持续增长要求以一种新颖的、系统的且自动化的方法来创建测试平台。从硬件规范到
RTL
编码、门级综合、芯片制造，以及最后到用户手里，项目每向前推进一步，修复单个漏洞所需要的代价就会增加数倍甚至数十倍。定向测试每次只能测试一个特性，而无法模拟设备在实际应用环境中所面对的复杂的激励和配置。为了得到稳健的设计，<strong>必须使用受约束的随机激励加上功能覆盖率</strong>，才能在可能的限度内创建出最广泛的激励。</p>
<h1 id="参考文献">参考文献</h1>
<ol type="1">
<li>C. Spear. <em>SystemVerilog 验证: 测试平台编写指南 原书第二版</em>.
北京: 科学出版社, 2009.</li>
<li>C. Spear. <em>SystemVerilog for verification: a guide to learning
the testbench language features</em>, 2nd ed.&nbsp;New York: Springer,
2008.</li>
</ol>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/css/markmap.css">

<script src="/js/markmap.js"></script>
]]></content>
      <categories>
        <category>Josh 的学习笔记</category>
        <category>SystemVerilog</category>
      </categories>
      <tags>
        <tag>SystemVerilog</tag>
        <tag>Testbench</tag>
        <tag>测试平台</tag>
        <tag>验证</tag>
      </tags>
  </entry>
  <entry>
    <title>Josh&#39;s Note — SystemVerilog 验证&lt;br&gt;Part 3 过程语句和子程序</title>
    <url>/posts/43879201.html</url>
    <content><![CDATA[<p>在做设计验证时，需要写很多代码，其中大部分在任务和函数里面。SystemVerilog
在这方面增加了许多改进使得它更接近 C
语言，从而使代码的编写变得更加容易，尤其是在处理参数传递上。</p>
<span id="more"></span>
<h1 id="过程语句">1. 过程语句</h1>
<p>SystemVerilog 从 C 和 C++ 中引入了很多操作符和语句：</p>
<ul>
<li>可以在 <code>for</code>
循环中定义循环变量，它的作用范围仅限于循环内部，从而有助于避免一些
bug。</li>
<li>自动递增符 <code>++</code> 和自动递减符 <code>--</code>
既可以作为前缀，也可以作为后缀。</li>
<li>如果在 <code>begin</code> 或 <code>fork</code>
语句中使用标识符，那么在相对应的 <code>end</code> 或 <code>join</code>
语句中可以放置相同的标号，这使得程序块的首尾匹配更加容易。</li>
<li>也可以把标识符放在 SystemVerilog 的其他结束语句里，例如
<code>endmodule</code>、<code>endtask</code>、<code>endfunction</code>
以及本文将介绍的其他语句。</li>
</ul>
<p><a href="#例3.1">例 3.1</a> 展示了一些新的语法结构。</p>
<p><span id="例3.1"></span></p>
<figure class="highlight verilog"><figcaption><span>例 3.1 新的过程语句和操作符</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">initial</span></span><br><span class="line">    <span class="keyword">begin</span> : example</span><br><span class="line">    <span class="keyword">integer</span> array[<span class="number">10</span>], sum, j;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 for 语句中声明 i</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)       <span class="comment">// i 递增</span></span><br><span class="line">        array[i] = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add up values in the array</span></span><br><span class="line">    sum = array[<span class="number">9</span>];</span><br><span class="line">    j=<span class="number">8</span>;</span><br><span class="line">    <span class="keyword">do</span>                            <span class="comment">// do...while 循环</span></span><br><span class="line">        sum += array[j];          <span class="comment">// 累加</span></span><br><span class="line">    <span class="keyword">while</span> (j--);                  <span class="comment">// 判断 j=0 是否成立</span></span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">"Sum=%4d"</span>, sum);     <span class="comment">// %4d，指定宽度</span></span><br><span class="line"><span class="keyword">end</span> : example                     <span class="comment">// 结束标识符</span></span><br></pre></td></tr></tbody></table></figure>
<p>SystemVerilog 为循环功能增加了两个新语句：</p>
<ul>
<li>第一个是
<code>continue</code>，用于在循环中跳过本轮循环剩下的语句而直接进入下一轮循环。</li>
<li>第二个是 <code>break</code>，用于终止并跳出循环。</li>
</ul>
<p><a href="#例3.2">例 3.2</a> 中的循环使用 Verilog-2001
中的文件输入输出系统任务从一个文件中读取命令。如果读到的命令只是一个空行，则执行
<code>continue</code>
语句，跳过对这个命令的任何进一步处理。如果读到的命令是
“done”，代码将会执行 <code>break</code> 终止循环。</p>
<p><span id="例3.2"></span></p>
<figure class="highlight verilog"><figcaption><span>例 3.2 在读取文件时使用 <code>break</code> 和 <code>continue</code></span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">127</span>:<span class="number">0</span>] cmd;</span><br><span class="line">    <span class="keyword">int</span> file, c;</span><br><span class="line"></span><br><span class="line">    file = <span class="built_in">$fopen</span>(<span class="string">"commands.txt"</span>, <span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">$feof</span>(file)) <span class="keyword">begin</span></span><br><span class="line">        c = <span class="built_in">$fscanf</span>(file, <span class="string">"%s"</span>, cmd);</span><br><span class="line">        <span class="keyword">case</span> (cmd)</span><br><span class="line">            <span class="string">""</span>:     <span class="keyword">continue</span>;    <span class="comment">// 空行——跳到本轮循环的末尾</span></span><br><span class="line">            <span class="string">"done"</span>: <span class="keyword">break</span>;       <span class="comment">// Done——终止并跳出循环</span></span><br><span class="line">            ...                  <span class="comment">// 处理其他命令</span></span><br><span class="line">        <span class="keyword">endcase</span> <span class="comment">// case(cmd)</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">$fclose</span>(file);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="任务函数以及-void-函数">2. 任务、函数以及 <code>void</code>
函数</h1>
<p>在 Verilog 中，任务 (task) 和函数 (function)
之间有很明显的区别，其中最重要的一点是，<strong>任务可以消耗时间而函数不能</strong>。函数里面不能带有诸如
<code>#100</code> 的时延语句或诸如
<code>@(posedge clock)</code>、<code>wait(ready)</code>
的阻塞语句，也不能调用任务。另外，Verilog
中的函数必须有返回值，并且返回值必须被使用，例如用到赋值语句中。</p>
<p>SystemVerilog 对这条限制稍有放宽，允许函数调用任务，但只能在由
<code>fork... join_none</code> 语句生成的线程中调用。</p>
<blockquote>
<p>不消耗时间的 SystemVerilog 任务应该被定义成 <code>void</code>
函数，这种函数没有返回值，这样它就能被任何任务或函数所调用了。从最大灵活性的角度考虑，所有用于调试的子程序都应该定义成
<code>void</code> 函数而非任务，以便于被任何其他任务或函数所调用。<a href="#例3.3">例 3.3</a> 可以输出状态机的当前状态值。</p>
</blockquote>
<p><span id="例3.3"></span></p>
<figure class="highlight verilog"><figcaption><span>例 3.3 用于调试的 <code>void</code> 函数</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> print_state(...);</span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">"@%0t: state = %s"</span>, <span class="built_in">$time</span>, cur_state<span class="variable">.name</span>());</span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></tbody></table></figure>
<p>在 SystemVerilog 中，如果想调用函数并且忽略它的返回值，可以使用
<code>void</code> 进行结果转换，如<a href="#例3.4">例 3.4</a>
所示。有些仿真器，如 VCS，允许在不使用上述 void
语法的情况下忽略返回值。</p>
<p><span id="例3.4"></span></p>
<figure class="highlight verilog"><figcaption><span>例 3.4 忽略函数的返回值</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">void</span>'(<span class="built_in">$fscanf</span>(file, <span class="string">"%d"</span>, i));</span><br></pre></td></tr></tbody></table></figure>
<h1 id="任务和函数概述">3. 任务和函数概述</h1>
<p>SystemVerilog 在任务和函数上做了一些小改进，使得它们看起来更像 C 或
C++ 的程序。一般情况下，不带参数的子程序在定义或调用时并不需要带空括号
<code>()</code>。为清楚起见，本文对此种情形的子程序将全部带括号。</p>
<h2 id="在子程序中移除-begin...end">3.1. 在子程序中移除
<code>begin...end</code></h2>
<p>在 SystemVerilog
中，你可能会注意到的第一个改进就是，<code>begin...end</code>
块变成可选了，而在 Verilog-1995 中则对单行以外的子程序都是必须的。如<a href="#例3.5">例 3.5</a> 所示，<code>task/end­task</code> 和
<code>function/endfunction</code>
的关键词已经足以定义这些子程序的边界了。</p>
<p><span id="例3.5"></span></p>
<figure class="highlight verilog"><figcaption><span>例 3.5 不带 <code>begin...end</code> 的简单任务</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">task</span> multiple_lines;</span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">"First line"</span>);</span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">"Second line"</span>);</span><br><span class="line"><span class="keyword">endtask</span> : multiple_lines</span><br></pre></td></tr></tbody></table></figure>
<h1 id="子程序参数">4. 子程序参数</h1>
<p>SystemVerilog
对子程序的很多改进使参数的声明变得更加方便，同时也扩展了参数的传递方式。</p>
<h2 id="c-语言风格的子程序参数">4.1. C 语言风格的子程序参数</h2>
<p>System Verilog 和 Verilog-2001
在任务和函数参数的声明上更加简洁，更少重复。<a href="#例3.6">例 3.6</a>
中的 Verilog
任务要求对一些参数进行两次声明，一次是方向声明，另一次是类型声明。</p>
<p><span id="例3.6"></span></p>
<figure class="highlight verilog"><figcaption><span>例 3.6 Verilog-1995 的子程序参数</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">task</span> mytask2;</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] x;</span><br><span class="line">    <span class="keyword">reg</span>    [<span class="number">31</span>:<span class="number">0</span>] x;</span><br><span class="line">    <span class="keyword">input</span>         y;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">endtask</span></span><br></pre></td></tr></tbody></table></figure>
<p>而在 System Verilog 中，可以采用简明的 C 语言风格，如<a href="#例3.7">例 3.7</a> 所示。但注意<strong>必须使用通用的输入类型
<code>logic</code></strong>。</p>
<p><span id="例3.7"></span></p>
<figure class="highlight verilog"><figcaption><span>例 3.7 C 语言风格的子程序参数</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">task</span> mytask1 (<span class="keyword">output</span> <span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] x,</span><br><span class="line">              <span class="keyword">input</span>  <span class="keyword">logic</span> y);</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">endtask</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="参数的方向">4.2. 参数的方向</h2>
<p>在声明子程序参数方面还可以有更多的便捷。因为默认的类型和方向是 “logic
输入”，所以在声明类似参数时可不必重复。<a href="#例3.8">例 3.8</a>
所示为采用 SystemVerilog 的数据类型，但以 Verilog-1995
的风格编写的一个子程序头。</p>
<p><span id="例3.8"></span></p>
<figure class="highlight verilog"><figcaption><span>例 3.8 带 Verilog 风格的繁冗的子程序参数</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">task</span> T3;</span><br><span class="line">    <span class="keyword">input</span> a, b;</span><br><span class="line">    <span class="keyword">logic</span> a, b;</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">15</span>:<span class="number">0</span>] u, v;</span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">15</span>:<span class="number">0</span>] u, v;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">endtask</span></span><br></pre></td></tr></tbody></table></figure>
<p>可以把它重写成<a href="#例3.9">例 3.9</a> 的形式。</p>
<p><span id="例3.9"></span></p>
<figure class="highlight verilog"><figcaption><span>例 3.9 使用默认类型的子程序参数</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">task</span> T3(a, b, <span class="keyword">output</span> <span class="keyword">bit</span> [<span class="number">15</span>:<span class="number">0</span>] u, v);</span><br></pre></td></tr></tbody></table></figure>
<p>参数 <code>a</code> 和 <code>b</code> 是 1 比特宽度的 logic
输入。参数 <code>u</code> 和 <code>v</code> 是 16 比特宽度的 bit
类型输出。尽管有这种简洁的编程方式，但不建议使用这种方式，因为这种方式将容易引入一些细小而难以发现的
bug。所以<strong>建议对所有子程序参数的声明都带上类型和方向</strong>。</p>
<h2 id="高级的参数类型">4.3. 高级的参数类型</h2>
<p>Verilog 对参数的处理方式很简单：在子程序的开头把 <code>input</code>
和 <code>inout</code> 的值复制给本地变量，在子程序退出时则复制
<code>output</code> 和 <code>inout</code>
的值。除了标量以外，没有任何把存储器传递给 Verilog 子程序的办法。</p>
<p>在 SystemVerilog 中，参数的传递方式可以指定为引用而不是复制。这种
<code>ref</code> 参数类型比 <code>input</code>、<code>output</code> 或
<code>inout</code> 更好用。首先，把数组传递给子程序。</p>
<p><span id="例3.10"></span></p>
<figure class="highlight verilog"><figcaption><span>例 3.10 使用 <code>ref</code> 和 <code>const</code> 传递数组</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> print_checksum (<span class="keyword">const</span> <span class="keyword">ref</span> <span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] a[]);</span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] checksum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;a<span class="variable">.size</span>(); i++)</span><br><span class="line">        checksum ^= a[i];</span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">"The array checksum is %0d"</span>, checksum);</span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></tbody></table></figure>
<p>SystemVerilog 允许不带 <code>ref</code>
进行数组参数的传递，这时数组会被复制到堆栈区里。这种操作的代价很高，除非是对特别小的数组。</p>
<p>SystemVerilog 的语言参考手册 (LRM) 规定了 <code>ref</code>
参数只能被用于带自动存储的子程序中。如果对程序或模块指明了
<code>automatic</code> 属性，则整个子程序内部都是自动存储的。</p>
<p><a href="#例3.10">例 3.10</a> 也用到了 <code>const</code>
修饰符，其结果是，<strong>虽然数组变量 <code>a</code>
指向了调用程序中的数组，但子程序不能修改数组的值</strong>。如果试图改变数组的值，编译器将报错。</p>
<blockquote>
<p>向子程序传递数组时应尽量使用 <code>ref</code>
以获取最佳性能。如果不希望子程序改变数组的值，可以使用
<code>const ref</code>
类型。这种情况下，编译器会进行检查以确保数组不被子程序修改。</p>
</blockquote>
<p><code>ref</code>
参数的第二个好处是<strong>可以在任务里修改变量，并且修改结果对调用它的函数随时可见</strong>。当有若干并发执行的线程时，这样操作可以提供一种简单的信息传递方式。</p>
<p>在<a href="#例3.11">例 3.11</a> 中，一旦 <code>bus.enable</code>
有效，初始化块中的 <code>thread2</code>
块马上就可以获取来自存储器的数据，而不用等到 <code>bus_read</code>
任务完成总线上的数据处理后返回，这可能需要若干个时钟周期。由于参数
<code>data</code> 是以 <code>ref</code> 方式传递的，所以只要任务里的
<code>data</code> 一有变化，<code>@data</code> 语句就会触发。如果你把
<code>data</code> 声明为 <code>output</code>，则 <code>@data</code>
语句就要等到总线处理完成后才能触发。</p>
<p><span id="例3.11"></span></p>
<figure class="highlight verilog"><figcaption><span>例 3.11 在多线程间使用 <code>ref</code></span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">task</span> bus_read(<span class="keyword">input</span> <span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] addr,</span><br><span class="line">              <span class="keyword">ref</span>   <span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求总线并驱动地址</span></span><br><span class="line">    bus<span class="variable">.request</span> = <span class="number">1'b1</span>;</span><br><span class="line">    @(<span class="keyword">posedge</span> bus<span class="variable">.grant</span>) bus<span class="variable">.addr</span> = addr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待来自存储器的数据</span></span><br><span class="line">    @(<span class="keyword">posedge</span> bus<span class="variable">.enable</span>) data = bus<span class="variable">.data</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放总线并等待许可</span></span><br><span class="line">    bus<span class="variable">.request</span> = <span class="number">1'b0</span>;</span><br><span class="line">    @(<span class="keyword">negedge</span> bus<span class="variable">.grant</span>);</span><br><span class="line"><span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] addr, data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span></span><br><span class="line">    <span class="keyword">fork</span></span><br><span class="line">        bus_read(addr, data);</span><br><span class="line">        thread2: <span class="keyword">begin</span></span><br><span class="line">            @data;  <span class="comment">// 在数据变化时触发</span></span><br><span class="line">            <span class="built_in">$display</span>(<span class="string">"Read %h from bus"</span>, data);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">join</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="参数的默认值">4.4. 参数的默认值</h2>
<p>当测试程序越来越复杂时，会希望在不破坏已有代码的情况下增加额外的控制。在<a href="#例3.10">例 3.10</a>
的函数里，可能想把数组中间部分元素的校验和打印出来，但是又不希望改写代码，为每次函数调用增加额外的参数。在
SystemVerilog
中，可以为参数指定一个默认值，如果在调用时不指明参数，则使用默认值。<a href="#例3.12">例 3.12</a> 为 <code>print_checksum</code> 函数增加了
<code>low</code> 和 <code>high</code>
两个参数，这样就能够打印出指定范围内的数组内容的校验和。</p>
<p><span id="例3.12"></span></p>
<figure class="highlight verilog"><figcaption><span>例 3.12 带默认参数值的函数</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> print_checksum(<span class="keyword">ref</span> <span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] a[],</span><br><span class="line">                             <span class="keyword">input</span> <span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] low = <span class="number">0</span>,</span><br><span class="line">                             <span class="keyword">input</span> <span class="keyword">int</span> high = -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] checksum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (high == -<span class="number">1</span> || high &gt;= a<span class="variable">.size</span>())</span><br><span class="line">        high = a<span class="variable">.size</span>()-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=low; i&lt;=high; i++)</span><br><span class="line">        checksum += a[i];</span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">"The array checksum is %0d"</span>, sum);</span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></tbody></table></figure>
<p>可以使用如<a href="#例3.13">例 3.13</a>
所示的方式调用这个函数。注意，第一个调用对两种形式的
<code>print_checksum</code> 子程序都是可行的。</p>
<p><span id="例3.13"></span></p>
<figure class="highlight verilog"><figcaption><span>例 3.13 使用参数的默认值</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">print_checksum(a);       <span class="comment">// a[0:size()-1]中所有元素的校验和——默认情况</span></span><br><span class="line">print_checksum(a, <span class="number">2</span>, <span class="number">4</span>); <span class="comment">// a[2:4]中所有元素的校验和</span></span><br><span class="line">print_checksum(a, <span class="number">1</span>);    <span class="comment">// 从 1 开始</span></span><br><span class="line">print_checksum(a,, <span class="number">2</span>);   <span class="comment">// a[0:2]中所有元素的校验和</span></span><br><span class="line">print_checksum();        <span class="comment">// 编译错误：a 没有默认值</span></span><br></pre></td></tr></tbody></table></figure>
<p>使用 -1 (或其他任何越界值)
作为默认值，对于获知调用时是否有指定值，不失为一个好方法。</p>
<p>Verilog 中的 <code>for</code> 循环总是在执行初始化
(<code>int i=low</code>) 和条件测试 (<code>i&lt;=high</code>)
之后再开始循环。所以，如果不小心把一个大于 <code>high</code>
或数组宽度的数值传递给 <code>low</code>，那么 <code>for</code>
循环的循环体将不会被执行。</p>
<h2 id="采用名字进行参数传递">4.5. 采用名字进行参数传递</h2>
<p>在 SystemVerilog 的语言参考手册 (LRM)
中，任务或函数的参数有时被称为端口
(port)，就跟模块的接口一样。如果有一个带着许多参数的任务或函数，其中一些参数有缺省值，而又只想对它们中的部分参数进行设置，那么可以通过采用类似
<code>port</code> 的语法指定子程序参数名字的方式来指定一个子集，如<a href="#例3.14">例 3.14</a> 所示。</p>
<p><span id="例3.14"></span></p>
<figure class="highlight verilog"><figcaption><span>例 3.14 采用名字进行参数传递</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">task</span> many (<span class="keyword">input</span> <span class="keyword">int</span> a=<span class="number">1</span>, b=<span class="number">2</span>, c=<span class="number">3</span>, d=<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">"%0d %0d %0d %0d"</span>, a, b, c, d);</span><br><span class="line"><span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span>           <span class="comment">// a  b  c  d</span></span><br><span class="line">    many(<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>);   <span class="comment">// 6  7  8  9  指定所有值</span></span><br><span class="line">    many();             <span class="comment">// 1  2  3  4  使用默认值</span></span><br><span class="line">    many(<span class="variable">.c</span>(<span class="number">5</span>));        <span class="comment">// 1  2  5  4  只指定 c</span></span><br><span class="line">    many(, <span class="number">6</span>, <span class="variable">.d</span>(<span class="number">8</span>));   <span class="comment">// 1  6  3  8  混合方式</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="常见的代码错误">4.6. 常见的代码错误</h2>
<blockquote>
<p>在编写子程序代码时最容易犯的错误就是，往往会忘记，在默认情况下，参数的类型是与其前一个参数相同的，而第一个参数的默认类型是单比特输入。先看看<a href="#例3.15">例 3.15</a> 所示的简单的任务头。</p>
</blockquote>
<p><span id="例3.15"></span></p>
<figure class="highlight verilog"><figcaption><span>例 3.15 原始的任务头</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">task</span> sticky(<span class="keyword">int</span> a, b);</span><br></pre></td></tr></tbody></table></figure>
<p>这两个参数都是整型输入。在编写这个任务时，由于需要访问一个数组，因此又加入了一个新的数组参数，并且使用
<code>ref</code> 类型以便让数组值不被复制。修改后的子程序头如<a href="#例3.16">例 3.16</a> 所示。</p>
<p><span id="例3.16"></span></p>
<figure class="highlight verilog"><figcaption><span>例 3.16 加入额外数组参数的任务头</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">task</span> sticky(<span class="keyword">ref</span> <span class="keyword">int</span> array[<span class="number">50</span>],</span><br><span class="line">            <span class="keyword">int</span> a, b);      <span class="comment">// 这些变量的方向是什么？</span></span><br></pre></td></tr></tbody></table></figure>
<p><code>a</code> 和 <code>b</code>
的参数类型是什么呢？它们在方向上实际采用的是与前一个参数一致的
<code>ref</code> 类型。对简单的 <code>int</code> 变量使用
<code>ref</code>
通常并无必要，但编译器不会对此做出任何反应，连警告都没有，所以你不会意识到正在使用一个错误的方向类型。</p>
<p>如果在子程序中使用了非默认输入类型的参数，应该明确指明所有参数的方向，如<a href="#例3.17">例 3.17</a> 所示。</p>
<p><span id="例3.17"></span></p>
<figure class="highlight verilog"><figcaption><span>例 3.17 加入额外数组参数的任务头</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">task</span> sticky(<span class="keyword">ref</span>   <span class="keyword">int</span> array[<span class="number">50</span>],</span><br><span class="line">            <span class="keyword">input</span> <span class="keyword">int</span> a, b);  <span class="comment">// 明确指定方向</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="子程序的返回">5. 子程序的返回</h1>
<p>Verilog
中子程序的结束方式比较简单；当执行完子程序的最后一条语句，程序就会返回到调用子程序的代码上。此外，函数还会返回一个值，该值被赋给与函数同名的变量。</p>
<h2 id="返回-return-语句">5.1. 返回 (<code>return</code>) 语句</h2>
<p>SystemVerilog 增加了 <code>return</code>
语句，使子程序中的流程控制变得更方便。<a href="#例3.18">例 3.18</a>
中的任务由于发现错误而需要提前返回。如果不这样做，那么任务中剩下的部分就必须被放到一个
<code>else</code>
条件语句中，从而使得代码变得不规整，可读性也降低了。</p>
<p><span id="例3.18"></span></p>
<figure class="highlight verilog"><figcaption><span>例 3.18 在任务中用 <code>return</code> 返回</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">task</span> load_array(<span class="keyword">int</span> len, <span class="keyword">ref</span> <span class="keyword">int</span> array[]);</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">0</span>) <span class="keyword">begin</span></span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">"Bad len"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 任务中其余的代码</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">endtask</span></span><br></pre></td></tr></tbody></table></figure>
<p><code>return</code> 语句也可以简化函数，如<a href="#例3.19">例
3.19</a> 所示。</p>
<p><span id="例3.19"></span></p>
<figure class="highlight verilog"><figcaption><span>例 3.19 在函数中用 <code>return</code> 返回</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">bit</span> transmit(...);</span><br><span class="line">    <span class="comment">// Send transaction</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> ~ifc<span class="variable">.cb</span><span class="variable">.error</span>; <span class="comment">// 返回状态：0=error</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="从函数中返回一个数组">5.2. 从函数中返回一个数组</h2>
<p>Verilog
的子程序只能返回一个简单值，如比特、整数或是向量。如果想计算并返回一个数组，那就不是一件容易的事情了。在
SystemVerilog 中，函数可以采用多种方式返回一个数组。</p>
<p><strong>第一种方式是定义一个数组类型，然后在函数的声明中使用该类型</strong>。<a href="#例3.20">例 3.20</a> 使用了<a href="https://josh-gao.top/posts/2a5db13d.html#%E4%BE%8B2.35">例
2.35</a> 的数组类型，并创建了一个函数来初始化数组。</p>
<p><span id="例3.20"></span></p>
<figure class="highlight verilog"><figcaption><span>例 3.20 使用 <code>typedef</code> 从函数中返回一个数组</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> fixed_array5[<span class="number">5</span>];</span><br><span class="line">fixed_array5 f5;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> fixed_array5 init(<span class="keyword">int</span> start);</span><br><span class="line">    <span class="keyword">foreach</span> (init[i])</span><br><span class="line">        init[i] = i + start;</span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    f5 = init(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">foreach</span> (f5[i])</span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">"f5[%0d] = %0d"</span>, i, f5[i]);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<p>使用上述代码的一个问题是，函数 <code>init</code>
创建了一个数组，该数组的值被拷贝到数组 <code>f5</code>
中。如果数组很大，那么可能会引起性能上的问题。</p>
<p><strong>另一种方式是通过引用来进行数组参数的传递</strong>。最简单的办法是以
ref 参数的形式将数组传递到函数里，如<a href="#例3.21">例 3.21</a>
所示。</p>
<p><span id="例3.21"></span></p>
<figure class="highlight verilog"><figcaption><span>例 3.21 把数组作为 <code>ref</code> 参数传递给函数</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> init(<span class="keyword">ref</span> <span class="keyword">int</span> f[<span class="number">5</span>], <span class="keyword">input</span> <span class="keyword">int</span> start);</span><br><span class="line">    <span class="keyword">foreach</span> (f[i])</span><br><span class="line">        f[i] = i + start;</span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    init(fa, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">foreach</span> (fa[i])</span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">"fa[%0d] = %0d"</span>, i, fa[i]);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<p>从函数中返回数组的最后一种方式是将数组包装到一个类中，然后返回对象的句柄。</p>
<h1 id="局部数据存储">6. 局部数据存储</h1>
<p>Verilog 在 20 世纪 80
年代被创建时，最初的目的是用来描述硬件。因此，语言中的所有对象都是静态分配的。特别是，子程序参数和局部变量是被存放在固定位置的，而不像其他编程语言那样存放在堆栈区里。诸如递归子程序一类的动态代码没有对应的芯片实现方式，那还有什么必要为它们建模呢？对于那些做验证的软件工程师来说，使用
Verilog 可能会有些困难，他们已经习惯了像 C 一类的基于堆栈区
(stack-based) 的语言，因而在使用子程序库创建复杂 testbench
方面可能会显得力不从心。</p>
<h2 id="自动存储">6.1. 自动存储</h2>
<p>在 Verilog-1995
里，如果试图在测试程序里的多个地方调用同一个任务，由于任务里的局部变量会使用共享的静态存储区，所以不同的线程之间会窜用这些局部变量。在Verilog-2001
里，可以指定任务、函数和模块使用自动存储，从而迫使仿真器使用堆栈区存储局部变量。</p>
<blockquote>
<p>在 SystemVerilog 中，模块 (<code>module</code>) 和
<code>program</code>
块中的子程序默认情况下仍然使用静态存储。如果要使用自动存储，则必须在程序语句中加入
<code>automatic</code> 关键词。后续会详细讲解用于编写 testbench 代码的
<code>program</code> 块，以及如何在创建多线程时使用动态存储。</p>
</blockquote>
<p><a href="#例3.22">例 3.22</a>
所示的是一个用于监测数据何时被写人存储器的任务。</p>
<p><span id="例3.22"></span></p>
<figure class="highlight verilog"><figcaption><span>例 3.22 在 <code>program</code> 块中指定自动存储方式</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">program</span> <span class="keyword">automatic</span> test;</span><br><span class="line">    <span class="keyword">task</span> wait_for_mem(<span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] addr, expect_data,</span><br><span class="line">                      <span class="keyword">output</span> success);</span><br><span class="line">        <span class="keyword">while</span> (bus<span class="variable">.addr</span> !== addr)</span><br><span class="line">            @(bus<span class="variable">.addr</span>);</span><br><span class="line">        success = (bus<span class="variable">.data</span> == expect_data);</span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">endprogram</span></span><br></pre></td></tr></tbody></table></figure>
<p>因为参数 <code>addr</code> 和 <code>expect_data</code>
在每次调用时都使用不同的存储空间，所以对这个任务同时进行多次调用是没有问题的。但如果没有修饰符
<code>automatic</code>，由于第一次调用的任务处于等待状态，所以对
<code>wait_for_mem</code> 的第二次调用会覆盖它的两个参数。</p>
<h2 id="变量的初始化">6.2. 变量的初始化</h2>
<blockquote>
<p>当试图在声明中初始化局部变量时，类似的问题也会出现，因为局部变量实际上在仿真开始前就被赋了初值。常规的解决方法是<strong>避免在变量声明中赋予除常数以外的任何值</strong>。对局部变量使用单独的赋值语句也会使控制变得更方便。</p>
</blockquote>
<p><a href="#例3.23">例 3.23</a>
中的任务在检测总线五个周期以后，创建了一个局部变量并试图把当前地址总线的值作为初值赋给它。</p>
<p><span id="例3.23"></span></p>
<figure class="highlight verilog"><figcaption><span>例 3.23 静态初始化的 bug</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">program</span> initialization; <span class="comment">// 有 bug 的版本</span></span><br><span class="line">    <span class="keyword">task</span> check_bus;</span><br><span class="line">        <span class="keyword">repeat</span> (<span class="number">5</span>) @(<span class="keyword">posedge</span> clock);</span><br><span class="line">        <span class="keyword">if</span> (bus_cmd == 'READ) <span class="keyword">begin</span></span><br><span class="line">            <span class="comment">// 何时对 local_addr 赋初值？</span></span><br><span class="line">            <span class="keyword">logic</span> [<span class="number">7</span>:<span class="number">0</span>] local_addr = addr&lt;&lt;<span class="number">2</span>;  <span class="comment">// Bug</span></span><br><span class="line">            <span class="built_in">$display</span>(<span class="string">"Local Addr = %h"</span>, local_addr);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endprogram</span></span><br></pre></td></tr></tbody></table></figure>
<p>存在的 bug 是，变量 <code>local_addr</code>
是静态分配的，所以实际上在仿真的一开始它就有了初值，而不是等到进入
<code>begin ... end</code>
块中才进行初始化。同样，解决的办法是把程序块声明为
<code>automatic</code>，如同<a href="#例3.24">例 3.24</a> 所示。</p>
<p><span id="例3.24"></span></p>
<figure class="highlight verilog"><figcaption><span>例 3.24 修复静态初始化的 bug：使用 <code>automatic</code></span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">program</span> <span class="keyword">automatic</span> initialization; <span class="comment">// Bug 被修复</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">endprogram</span></span><br></pre></td></tr></tbody></table></figure>
<p>此外，如果不在声明中初始化变量，那这个 bug
也可以避免，只是这种方式不太好记住，尤其是对习惯了 C 语言的程序员。<a href="#例3.25">例 3.25</a>
给出了一种较为可取的编码风格，用于分离声明和初始化。</p>
<p><span id="例3.25"></span></p>
<figure class="highlight verilog"><figcaption><span>例 3.25 修复静态初始化的 bug：把声明和初始化拆开</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">logic</span> [<span class="number">7</span>:<span class="number">0</span>] local_addr</span><br><span class="line">local_addr = addr &lt;&lt; <span class="number">2</span>;  <span class="comment">// Bug</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="时间值">7. 时间值</h1>
<p>SystemVerilog 有几种新结构使你可以非常明确地在系统中指明时间值。</p>
<h2 id="时间单位和精度">7.1. 时间单位和精度</h2>
<p>当使用编译指示语句 <code>'timescale</code>
时，在编译文件时就必须按照适当的顺序以确保所有的时延都采用适宜的量程和精度。<code>timeunit</code>
和 <code>timeprecision</code>
声明语句可以明确地为每个模块指明时间值，从而避免歧义。<a href="#例3.26">例 3.26</a>
展示了这些声明语句。注意，如果使用这些语句替代
<code>`timescale</code>，则必须把它们放到每个带有时延的模块里。</p>
<h2 id="时间参数">7.2. 时间参数</h2>
<p>SystemVerilog
允许使用数值和单位来明确指定一个时间值。代码里可以使用类似
<code>0.1ns</code> 和 <code>20ps</code> 的时延。只要记得使用
<code>timeunit</code> 和 <code>timeprecision</code>、或者
<code>`timescale</code> 即可。还可以通过使用经典的 Verilog 时间函数
<code>$timeformat</code>，<code>$time</code> 和 <code>$realtime</code>
来使代码在时间标度上更清楚。<code>$timeformat</code>
的四个参数分别是时间标度 (-9 代表纳秒，-12
代表皮秒)，小数点后的数据精度，时间值之后的后缀字符串，以及显示数值的最小宽度。</p>
<p>例 3.26 所示的是使用 <code>$tmeformat()</code> 和 <code>%t</code>
指定符进行格式化后的多种时延以及打印结果。</p>
<p><span id="例3.26"></span></p>
<figure class="highlight verilog"><figcaption><span>例 3.26 时间参数和 <code>$timeformat</code></span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> timing;</span><br><span class="line">    <span class="keyword">timeunit</span> <span class="number">1</span>ns;</span><br><span class="line">    <span class="keyword">timeprecision</span> <span class="number">1</span>ps;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="built_in">$timeformat</span>(-<span class="number">9</span>, <span class="number">3</span>, <span class="string">"ns"</span>, <span class="number">8</span>);</span><br><span class="line">        #<span class="number">1</span>     <span class="built_in">$display</span>(<span class="string">"%t"</span>, <span class="built_in">$realtime</span>); <span class="comment">// 1.000ns</span></span><br><span class="line">        #<span class="number">2</span>ns   <span class="built_in">$display</span>(<span class="string">"%t"</span>, <span class="built_in">$realtime</span>); <span class="comment">// 3.000ns</span></span><br><span class="line">        #<span class="number">0</span><span class="variable">.1ns</span> <span class="built_in">$display</span>(<span class="string">"%t"</span>, <span class="built_in">$realtime</span>); <span class="comment">// 3.100ns</span></span><br><span class="line">        #<span class="number">41</span>ps  <span class="built_in">$display</span>(<span class="string">"%t"</span>, <span class="built_in">$realtime</span>); <span class="comment">// 3.141ns</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="时间和变量">7.3. 时间和变量</h2>
<p>可以把时间值存放到变量里，并在计算和延时中使用它们。根据当前的时间量程和精度，时间值会被缩放或舍入。<code>time</code>
类型的变量不能保存小数时延，因为它们是 64
比特的整数，所以时延的小数部分会被舍入。如果不希望这样，那应该采用
<code>real</code> 变量。</p>
<p><a href="#例3.27">例 3.27</a> 使用实 (real)
变量保存精确的数值，它们只在用作时延量的时候才被舍入。</p>
<p><span id="例3.27"></span></p>
<figure class="highlight verilog"><figcaption><span>例 3.27 时间变量及舍入</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ps/1ps</span></span><br><span class="line"><span class="keyword">module</span> ps;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">real</span> rdelay = <span class="number">800</span>fs;    <span class="comment">// 以 0.800 存储</span></span><br><span class="line">        <span class="keyword">time</span> tdelay = <span class="number">800</span>fs;    <span class="comment">// 舍入后得到 1</span></span><br><span class="line">        <span class="built_in">$timeformat</span>(-<span class="number">15</span>, <span class="number">0</span>, <span class="string">"fs"</span>, <span class="number">5</span>);</span><br><span class="line">        #rdelay;                <span class="comment">// 时延舍入后得到 1ps</span></span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">"%t"</span>, rdelay); <span class="comment">// "800fs"</span></span><br><span class="line">        #tdelay;                <span class="comment">// 再次延时 1ps</span></span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">"%t"</span>, tdelay); <span class="comment">// "1000fs"</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="time-与-realtime-的对比">7.4. <code>$time</code> 与
<code>$realtime</code> 的对比</h2>
<p>系统任务 <code>$time</code>
的返回值是一个根据所在模块的时间精度要求进行舍入的整数，不带小数部分，而
<code>$realtime</code>
的返回值则是一个带小数部分的完整实数。本文为简洁起见，所举例子中全部使用
<code>$time</code>，但请不要忘记，testbench 可能需要使用
<code>$realtime</code>。</p>
<h1 id="结束语">8. 结束语</h1>
<p>SystemVerilog 的程序化结构和任务、函数中的新特点使得它与诸如 C/C++
一类的编程语言更加接近，从而也更便于编写 testbench。和 C/C++
相比，SystemVerilog 还拥有额外的 HDL
结构，例如，时序控制、简单的线程控制和四态逻辑等。</p>
<h1 id="参考文献">参考文献</h1>
<ol type="1">
<li>克里斯·斯皮尔, 斯皮尔, 张春,等.
SystemVerilog验证:测试平台编写指南[M]. 科学出版社, 2009.</li>
<li>Spear C. SystemVerilog for verification: a guide to learning the
testbench language features[M]. Springer Science &amp; Business Media,
2008.</li>
</ol>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/css/markmap.css">

<script src="/js/markmap.js"></script>
]]></content>
      <categories>
        <category>Josh 的学习笔记</category>
        <category>SystemVerilog</category>
      </categories>
  </entry>
  <entry>
    <title>Josh&#39;s Note — SystemVerilog 验证&lt;br&gt;Part 2 数据类型</title>
    <url>/posts/2a5db13d.html</url>
    <content><![CDATA[<p>和 Verilog 相比，SystemVerilog
提供了很多改进了的数据结构。虽然其中的部分结构最初是为设计人员创建的，但对测试人员也同样有用。本文将介绍这些对验证很有用的数据结构。</p>
<p>SystemVerilog 引进了一些新的数据类型，它们具有如下优点：</p>
<ol type="1">
<li><strong>双状态数据类型</strong>
(<em>Two-state</em>)：性能更好，内存消耗更低。</li>
<li><strong>队列、动态数组和关联数组</strong> (<em>Queues, dynamic and
associative arrays</em>)：内存消耗减少，自带搜索和分类功能。</li>
<li><strong>类和结构</strong> (<em>Classes and
structures:</em>)：支持抽象数据结构。</li>
<li><strong>联合和合并结构</strong> (<em>Unions and packed
structures</em>)：允许对同一数据有多种视图 (view)。</li>
<li><strong>字符串</strong>
(<em>Strings</em>)：支持内建的字符序列。</li>
<li><strong>枚举类型</strong> (<em>Enumerated
types</em>)：方便代码编写、增加可读性。</li>
</ol>
<span id="more"></span>
<h1 id="内建数据类型">1. 内建数据类型</h1>
<p>Verilog-1995 有两种基本的数据类型：变量 (variable) 和线网
(net)。它们各自都可以有四种取值：<code>0</code>，<code>1</code>，<code>Z</code>
和 <code>X</code>。RTL 代码使用变量来存放组合和时序值。变量可以是：</p>
<ul>
<li>单比特或多比特的无符号数 (unsigned single or multi-bit,
<code>reg [7:0] m</code>)；</li>
<li>32 比特的有符号数 (signed 32-bit variable,
<code>integer</code>)；</li>
<li>64 比特的无符号数 (unsigned 64-bit variable,
<code>time</code>)；</li>
<li>浮点数 (floating point number, <code>real</code>)。</li>
</ul>
<p>若干变量可以被一起存放到定宽数组 (fixed-size array)
里。所有的存储都是静态 (static)
的，意味着所有的变量在整个仿真过程当中都是存活 (alive) 的，子程序
(routine)
不能通过堆栈来保存参数和局部变量。线网可以用来连接设计当中的不同部分，例如门原语和模块实例。尽管线网有很多种用法，但是大多数设计者还是使用标量或矢量
<code>wire</code> 来连接各个设计模块的端口。</p>
<p>SystemVerilog
增加了很多新的数据类型，对设计和验证工程师都很有帮助。</p>
<h2 id="逻辑-logic-类型">1.1. 逻辑 (<code>logic</code>) 类型</h2>
<p>在 Verilog 中，初学者经常分不清 <code>reg</code> 和 <code>wire</code>
两者的区别。应该使用哪一个来驱动端口？连接不同模块时又该怎么做？SystemVerilog
对经典的 <code>reg</code>
数据类型进行了改进，使得它除了作为一个变量以外，还<strong>可以被连续赋值、门单元和模块所驱动</strong>。为了与寄存器类型相区别，这种改进的数据类型称为
<code>logic</code>。任何使用线网的地方均可使用
<code>logic</code>，但<strong>要求 <code>logic</code>
不能有多个结构性的驱动</strong>，例如在对双向总线建模的时候。此时，需要使用线网类型，例如
<code>wire</code>，SystemVerilog
会对多个数据来源进行解析以后确定最终值。</p>
<p><a href="#例1">例 1</a> 给出在 SystemVerilog 中使用
<code>logic</code> 类型的例子。</p>
<p><a id="例1"></a></p>
<figure class="highlight verilog"><figcaption><span>例 1 <code>logic</code> 类型的使用</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> logic_data_type(<span class="keyword">input</span> <span class="keyword">logic</span> rst_h);</span><br><span class="line">  <span class="keyword">parameter</span> CYCLE = <span class="number">20</span>;</span><br><span class="line">  <span class="keyword">logic</span> q, q_l, d, clk, rst_l;</span><br><span class="line">  <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    clk = <span class="number">0</span>;                    <span class="comment">// 过程赋值</span></span><br><span class="line">    <span class="keyword">forever</span> <span class="variable">#(CYCLE/2)</span> clk = ~clk;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">assign</span> rst_l = ~rst_h;        <span class="comment">// 连续赋值</span></span><br><span class="line">  <span class="keyword">not</span> n1(q_l, q);               <span class="comment">// q_l 被门驱动</span></span><br><span class="line">  my_dff d1(q, d, clk, rst_l);  <span class="comment">// q 被模块驱动</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></tbody></table></figure>
<p>由于 <code>logic</code> 类型只能有一个驱动，所以可以使用它对网表
(netlist) 进行 debug。</p>
<ul>
<li>可以把所有的信号都声明为
<code>logic</code>，如果存在多个驱动，编译时就会出现错误。</li>
<li>然而有些信号本来就有多个驱动，例如双向总线，这些信号就需要被定义成线网类型，例如
<code>wire</code>。</li>
</ul>
<h2 id="双状态数据类型">1.2. 双状态数据类型</h2>
<p>相比四状态数据类型，SystemVerilog
引入的双状态数据类型有利于提高仿真器的性能并减少内存的使用量。最简单的双状态数据类型是
<code>bit</code>，它是无符号的。另四种带符号的双状态数据类型是
<code>byte</code>，<code>shortint</code>，<code>int</code> 和
<code>longint</code>，如<a href="#例2">例 2</a> 所示。</p>
<p><a id="例2"></a></p>
<figure class="highlight verilog"><figcaption><span>例 2 带符号的数据类型</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">bit</span> b;           <span class="comment">// 双状态，单比特</span></span><br><span class="line"><span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] b32;  <span class="comment">// 双状态，32 比特无符号整数</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">unsigned</span> ui; <span class="comment">// 双状态，32 比特无符号整数</span></span><br><span class="line"><span class="keyword">int</span> i;           <span class="comment">// 双状态，32 比特有符号整数</span></span><br><span class="line"><span class="keyword">byte</span> b8;         <span class="comment">// 双状态，8 比特有符号整数</span></span><br><span class="line"><span class="keyword">shortint</span> s;      <span class="comment">// 双状态，16 比特有符号整数</span></span><br><span class="line"><span class="keyword">longint</span> l;       <span class="comment">// 双状态，64 比特有符号整数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">integer</span> i4;      <span class="comment">// 四状态，32 比特有符号整数</span></span><br><span class="line"><span class="keyword">time</span> t;          <span class="comment">// 四状态，64 比特无符号整数</span></span><br><span class="line"><span class="keyword">real</span> r;          <span class="comment">// 双状态，双精度浮点数</span></span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>虽然使用 <code>byte</code> 等数据类型来替代类似
<code>logic[7:0]</code>
进行声明可以让程序更简洁，但需要注意，这些新的数据类型都是<strong>带符号</strong>的，所以
<code>byte</code> 变量的最大值只有 127，而不是 255 (它的范围是
-128~127)。可以使用 <code>byte unsigned</code>，但这其实比使用
<code>byte [7:0]</code>
还要麻烦。在进行随机化时，带符号变量可能会造成意想不到的结果，这一点在后面会讨论到。</p>
</blockquote>
<blockquote>
<p>在把双状态变量连接到 DUT 务必要小心，尤其是连接到 DUT 的输出时，因为
DUT 产生的 <code>X</code> 或 <code>Z</code>
会被转换成双状态值，而测试代码可能永远也察觉不了。这些值被转换成了
<code>0</code> 还是 <code>1</code>
并不重要，重要的是要<strong>随时检查未知值的传播</strong>。使用
<code>$isunknown()</code> 操作符，可以在表达式的任意位出现
<code>X</code> 或 <code>Z</code> 时返回 <code>1</code>，如<a href="#例3">例 3</a>。</p>
</blockquote>
<p><a id="例3"></a></p>
<figure class="highlight verilog"><figcaption><span>例 3 对四状态值的检查</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">$isunknown</span>(iport) == <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">"@%0t: 4-state value detected on iport %b"</span>,</span><br><span class="line">            <span class="built_in">$time</span>, iport);</span><br></pre></td></tr></tbody></table></figure>
<p>使用格式符 <code>%0t</code> 和参数 <code>$time</code>
可以打印出当前的仿真时间，打印的格式在 <code>$timeformat()</code>
子程序中指定。</p>
<h1 id="定宽数组">2. 定宽数组</h1>
<p>相比于 Verilog-1995 中的一维定宽数组，SystemVerilog
提供了更加多样的数组类型，功能上也大大增强。</p>
<h2 id="定宽数组的声明和初始化">2.1. 定宽数组的声明和初始化</h2>
<p>Verilog 要求在声明中必须给出数组的上下界。因为几乎所有数组都使用
<code>0</code> 作为索引下界，所以 SystemVerilog
<strong>允许只给出数组宽度的便捷声明方式</strong>，跟 C 语言类似。</p>
<p><a id="例4"></a></p>
<figure class="highlight verilog"><figcaption><span>例 4 定宽数组的声明</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> lo_hi[<span class="number">0</span>:<span class="number">15</span>];        <span class="comment">// 16 个整数 [0]..[15]</span></span><br><span class="line"><span class="keyword">int</span> c_style[<span class="number">16</span>];        <span class="comment">// 16 个整数 [0]..[15]</span></span><br></pre></td></tr></tbody></table></figure>
<p>可以通过在变量名后面指定维度的方式来创建<strong>多维定宽数组</strong>
(<em>multidimensional fixed-size array</em>)。<a href="#例5">例 5</a>
创建了几个二维的整数数组，大小都是 8 行 4 列，最后一个元素的值被设置为
1。多维数组在 Verilog-2001
中已经引入，但这种紧凑型声明方式却是新的。</p>
<p><a id="例5"></a></p>
<figure class="highlight verilog"><figcaption><span>例 5 声明并使用多维数组</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> array2 [<span class="number">0</span>:<span class="number">7</span>][<span class="number">0</span>:<span class="number">3</span>];  <span class="comment">// 完整的声明</span></span><br><span class="line"><span class="keyword">int</span> array3 [<span class="number">8</span>][<span class="number">4</span>];      <span class="comment">// 紧凑的声明</span></span><br><span class="line"></span><br><span class="line">array2[<span class="number">7</span>][<span class="number">3</span>] = <span class="number">1</span>;       <span class="comment">// 设置最后一个元素</span></span><br></pre></td></tr></tbody></table></figure>
<p>如果从一个越界的地址中读取数据，SystemVerilog
将返回数组元素类型的默认值：</p>
<ul>
<li>对于元素为四状态类型的数组，如 <code>logic</code>，返回
<code>X</code>；</li>
<li>对于元素为双状态类型的数组，如 <code>int</code> 或
<code>bit</code>，返回 <code>0</code>。</li>
</ul>
<p>这适用于所有数组类型，包括定宽数组、动态数组、关联数组和队列，也同时适用于地址中含有
<code>X</code> 或 <code>Z</code> 的情况。线网在没有驱动的时候输出是
<code>Z</code>。</p>
<p>很多 SystemVerilog 仿真器<strong>在存放数组元素时使用 32 比特的字
(word) 边界</strong>，所以 <code>byte</code>，<code>shortint</code> 和
<code>int</code> 都是存放在一个字中，<code>longint</code>
存放到两个字中。如<a href="#例6">例 6</a>
所示，<strong>在非合并数组中，字的低位用来存放数据，高位不使用</strong>。<a href="#图1">图 1</a> 所示的字节数组 <code>b_unpack</code>
被存放到三个字的空间里。</p>
<p><a id="例6"></a></p>
<figure class="highlight verilog"><figcaption><span>例 6 非合并数组的声明</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] b_unpack[<span class="number">3</span>];   <span class="comment">// 非合并数组</span></span><br></pre></td></tr></tbody></table></figure>
<p><a id="图1"></a></p>
<figure>
<img data-src="../images/post/2022-05-31-josh-systemverilog-2/2022-05-31-josh-systemverilog-2-010-UnpackedArrayStorage.png" width="600" alt="图 1 非合并数组的存放">
<figcaption aria-hidden="true">图 1 非合并数组的存放</figcaption>
</figure>
<p>仿真器通常使用两个或两个以上连续的字来存放 <code>logic</code> 和
<code>integer</code>
等四状态类型，这<strong>比存放双状态变量多占用一倍的空间</strong>。</p>
<h2 id="常量数组">2.2. 常量数组</h2>
<p><a href="#例7">例 7</a>
示范了如何使用常量数组，即<strong>用一个单引号加大括号来初始化数组</strong>
(注意这里的单引号并不同于编译器指引或宏定义中的单引号)，可以一次性地为数组的部分或所有元素赋值。在大括号前标上重复次数可以对多个元素重复赋值，还可以为没有显式赋值的元素指定一个默认值。</p>
<p><a id="例7"></a></p>
<figure class="highlight verilog"><figcaption><span>例 7 初始化一个数组</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ascend[<span class="number">4</span>] = '{<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>};    <span class="comment">// 对 4 个元素进行初始化</span></span><br><span class="line"><span class="keyword">int</span> descend[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">descend = '{<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>};        <span class="comment">// 为 5 个元素赋值</span></span><br><span class="line">descend[<span class="number">0</span>:<span class="number">2</span>] = '{<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>};       <span class="comment">// 为前 3 个元素赋值</span></span><br><span class="line">ascend = '{<span class="number">4</span>{<span class="number">8</span>}};              <span class="comment">// 四个值全部为 8</span></span><br><span class="line">descend = '{<span class="number">9</span>, <span class="number">8</span>, <span class="keyword">default</span>:<span class="number">1</span>};  <span class="comment">// {9,8,1,1,1}</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="基本的数组操作-for-和-foreach">2.3. 基本的数组操作——
<code>for</code> 和 <code>foreach</code></h2>
<p>操作数组的最常见的方式是使用 <code>for</code> 或 <code>foreach</code>
循环。在<a href="#例8">例 8</a> 中，<code>i</code> 被声明为
<code>for</code> 循环内的局部变量。SystemVerilog 的 <code>$size</code>
函数返回数组的宽度。在 <code>foreach</code>
循环中，只需要给出数组名并在后面的方括号中给出索引变量，SystemVerilog
便会自动遍历数组中的元素。索引变量将自动声明，并只在循环内有效。</p>
<p><a id="例8"></a></p>
<figure class="highlight verilog"><figcaption><span>例 8 在数组操作中使用 <code>for</code> 和 <code>foreach</code> 循环</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] src[<span class="number">5</span>], dst[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="built_in">$size</span>(src); i++)</span><br><span class="line">        src[i] = i;</span><br><span class="line">    <span class="keyword">foreach</span> (dst[j])</span><br><span class="line">        dst[j] = src[j] * <span class="number">2</span>;  <span class="comment">// dst 的值是 src 的两倍</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<p>注意在<a href="#例9">例 9</a> 中，对多维数组使用 <code>foreach</code>
的语法可能会与设想的有所不同。使用时并不是像 <code>[i][j]</code>
这样把每个下标分别列在不同的方括号里，而是用逗号隔开后放在同一个方括号里，像
<code>[i,j]</code>。</p>
<p><a id="例9"></a></p>
<figure class="highlight verilog"><figcaption><span>例 9 初始化并遍历多维数组</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> md[<span class="number">2</span>][<span class="number">3</span>] = '{'{<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>}, '{<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>}};</span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">"Initial value:"</span>);</span><br><span class="line">    <span class="keyword">foreach</span> (md[i,j])   <span class="comment">// 这是正确的语法格式</span></span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">"md[%0d][%0d] = %0d"</span>, i, j, md[i][j]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">"New value:"</span>);</span><br><span class="line">    <span class="comment">// Replicate last 3 values of 5</span></span><br><span class="line">    md = '{'{<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>}, '{<span class="number">3</span>{'<span class="number">5</span>}}};</span><br><span class="line">    <span class="keyword">foreach</span> (md[i,j])   <span class="comment">// 这是正确的语法格式</span></span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">"md[%0d][%0d] = %0d"</span>, i, j, md[i][j]);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<p><a href="#例9">例 9</a> 的输出结果如<a href="#例10">例 10</a>
所示。</p>
<p><a id="例10"></a></p>
<figure class="highlight plaintext"><figcaption><span>例 10 多维数组元素值的打印输出结果</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">Initial value:</span><br><span class="line">md[0][0] = 0</span><br><span class="line">md[0][1] = 1</span><br><span class="line">md[0][2] = 2</span><br><span class="line">md[1][0] = 3</span><br><span class="line">md[1][1] = 4</span><br><span class="line">md[1][2] = 5</span><br><span class="line">New value:</span><br><span class="line">md[0][0] = 9</span><br><span class="line">md[0][1] = 8</span><br><span class="line">md[0][2] = 7</span><br><span class="line">md[1][0] = 5</span><br><span class="line">md[1][1] = 5</span><br><span class="line">md[1][2] = 5</span><br></pre></td></tr></tbody></table></figure>
<p><strong>如果不需要遍历数组中的所有维度，可以在 <code>foreach</code>
循环里忽略不需要的维度</strong>。<a href="#例11">例 11</a>
把一个二维数组打印成一个方形的阵列。它在外层循环中遍历第一个维度，然后在内层循环中遍历第二个维度。</p>
<p><a id="例11"></a></p>
<figure class="highlight verilog"><figcaption><span>例 11 打印一个多维数组</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">byte</span> twoD[<span class="number">4</span>][<span class="number">6</span>];</span><br><span class="line">    <span class="keyword">foreach</span>(twoD[i,j])</span><br><span class="line">        twoD[i][j] = i*<span class="number">10</span>+j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (twoD[i]) <span class="keyword">begin</span>      <span class="comment">// 遍历第一个维度</span></span><br><span class="line">        <span class="built_in">$write</span>(<span class="string">"%2d:"</span>, i);</span><br><span class="line">        <span class="keyword">foreach</span>(twoD[,j])        <span class="comment">// 遍历第二个维度</span></span><br><span class="line">            <span class="built_in">$write</span>(<span class="string">"%3d"</span>, twoD[i][j]);</span><br><span class="line">        <span class="built_in">$display</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<p><a href="#例11">例 11</a> 的输出结果如<a href="#例12">例 12</a>
所示。</p>
<p><a id="例12"></a></p>
<figure class="highlight plaintext"><figcaption><span>例 12  打印多维数组的输出结果</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">Initial value:</span><br><span class="line">0: 0 1 2 3 4 5</span><br><span class="line">1: 10 11 12 13 14 15</span><br><span class="line">2: 20 21 22 23 24 25</span><br><span class="line">3: 30 31 32 33 34 35</span><br></pre></td></tr></tbody></table></figure>
<p>最后要补充的是，<code>foreach</code>
循环会<strong>按照数组范围的声明方法进行遍历</strong>：</p>
<ul>
<li>数组 <code>f[5]</code> 等同于
<code>f[0:4]</code>，<code>foreach(f[i])</code> 等同于
<code>for(int i=0; i&lt;=4; i++)</code>。</li>
<li>数组 <code>rev[6:2]</code>，<code>foreach(rev[i])</code> 等同于
<code>for(int i=6; i&gt;=2; i--)</code>。</li>
</ul>
<h2 id="基本的数组操作复制和比较">2.4. 基本的数组操作——复制和比较</h2>
<p>可以在不使用循环的情况下对数组进行聚合比较和复制 (aggregate compare
and copy,
聚合操作适用于整个数组而不是单个元素)，其中比较<strong>只限于等于比较或不等于比较</strong>。<a href="#例13">例 13</a> 列出了几个比较的例子。操作符 <code>? :</code>
是一个迷你型的 <code>if</code> 语句，在<a href="#例13">例 13</a>
中用来对两个字符串进行选择。例子最后的比较语句使用了数组的一部分，<code>src[1:4]</code>，它实际上产生了一个有四个元素的临时数组。</p>
<p><a id="例13"></a></p>
<figure class="highlight verilog"><figcaption><span>例 13 数组的复制和比较操作</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] src[<span class="number">5</span>] = '{<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>},</span><br><span class="line">               dst[<span class="number">5</span>] = '{<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>};</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 两个数组的聚合比较</span></span><br><span class="line">    <span class="keyword">if</span> (src==dst)</span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">"src == dst"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">"src != dst"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把 src 所有元素值复制给 dst</span></span><br><span class="line">    dst = src;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只改变一个元素的值</span></span><br><span class="line">    src[<span class="number">0</span>] = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有元素的值是否相等 (否)</span></span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">"src %s dst"</span>, (src == dst) ? <span class="string">"=="</span> : <span class="string">"!="</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用数组片段对第 1-4 个元素进行比较</span></span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">"src[1:4] %s dst [1:4]"</span>,</span><br><span class="line">        src[<span class="number">1</span>:<span class="number">4</span>] == dst[<span class="number">1</span>:<span class="number">4</span>]) ? <span class="string">"=="</span> : <span class="string">"!="</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<p>对数组的算术运算不能使用聚合操作，而应该使用循环，例如加法等运算。对于逻辑运算，例如异或等运算，只能使用循环或合并数组
(packed array)。</p>
<h2 id="同时使用位下标和数组下标">2.5. 同时使用位下标和数组下标</h2>
<p>在 Verilog-1995 中一个很不方便的地方就是数组下标 (array subscript)
和位下标 (bit subscript) 不能同时使用。Verilog-2001
对定宽数组取消了这个限制。<a href="#例14">例 14</a>
打印出数组的第一个元素 (二进制 101 )、它的最低位 (1) 以及紧接的高两位
(二进制 10)。</p>
<p><a id="例14"></a></p>
<figure class="highlight verilog"><figcaption><span>例 14 同时使用数组下标和位下标</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] src[<span class="number">5</span>] = '{<span class="number">5</span>{<span class="number">5</span>}};</span><br><span class="line">    <span class="built_in">$displayb</span>(src[<span class="number">0</span>],,          <span class="comment">// 'b101 或 'd5</span></span><br><span class="line">              src[<span class="number">0</span>][<span class="number">0</span>],,       <span class="comment">// 'b1</span></span><br><span class="line">              src[<span class="number">0</span>][<span class="number">2</span>:<span class="number">1</span>]);     <span class="comment">// 'b10</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<p>虽然这个变化并不是 SystemVerilog 新增加的，但可能有很多人并不知道
Verilog-2001 中的这个有用的改进。</p>
<h2 id="合井数组">2.6. 合井数组</h2>
<p>对某些数据类型，我们可能希望既可以把它作为一个整体来访问，也可以把它分解成更小的单元。例如，有一个
32 比特的寄存器，有时候希望把它看成四个 8
比特的数据，有时候则希望把它看成单个的无符号数据。SystemVerilog
的合并数组就可以实现这个功能，它既可以用作数组，也可以当成单独的数据。与非合并数组不同的是，它的存放方式是连续的比特集合，中间没有任何闲置的空间。</p>
<h2 id="合并数组的例子">2.7. 合并数组的例子</h2>
<p>声明合并数组时，<strong>合并的位和数组大小是数据类型的一部分，必须在变量名前面指定</strong>。数组大小定义的格式必须是
<code>[msb:lsb]</code>，而不是 <code>[size]</code>。<a href="#例15">例
15</a> 中的变量 <code>bytes</code> 是一个有 4
个字节的合并数组，使用单独的 32 比特的字来存放，如图 2 所示。</p>
<p><a id="例15"></a></p>
<figure class="highlight verilog"><figcaption><span>例 15 合并数组的声明和用法</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">bit</span> [<span class="number">3</span>:<span class="number">0</span>] [<span class="number">7</span>:<span class="number">0</span>] bytes;   <span class="comment">// 4 个 字节 组装成 32 比特</span></span><br><span class="line">bytes = <span class="number">32'hCafe_Dada</span>;</span><br><span class="line"><span class="built_in">$displayh</span>(bytes,,        <span class="comment">// 显示所有的 32 比特</span></span><br><span class="line">          bytes[<span class="number">3</span>],,     <span class="comment">// 显示最高字节 “CA”</span></span><br><span class="line">          bytes[<span class="number">3</span>][<span class="number">7</span>]);  <span class="comment">// 显示 MSB “1”</span></span><br></pre></td></tr></tbody></table></figure>
<p><a id="图2"></a></p>
<figure>
<img data-src="../images/post/2022-05-31-josh-systemverilog-2/2022-05-31-josh-systemverilog-2-020-PackedArrayLayout.png" width="600" alt="图 2 合井数组存放示意图">
<figcaption aria-hidden="true">图 2 合井数组存放示意图</figcaption>
</figure>
<p>合并和非合并数组可以混合使用。可以使用数组来表示存储单元，这些单元可以按比特、字节或长字的方式进行存取。在<a href="#例16">例 16</a> 中，<code>barray</code> 是一个具有 3
个合并元素的非合并数组。</p>
<p><a id="例16"></a></p>
<figure class="highlight verilog"><figcaption><span>例 16 合并数组的声明和用法</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">bit</span> [<span class="number">3</span>:<span class="number">0</span>] [<span class="number">7</span>:<span class="number">0</span>] barray [<span class="number">3</span>];    <span class="comment">// 合并，3×32 比特</span></span><br><span class="line"><span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] lw = <span class="number">32'h0123_4567</span>; <span class="comment">// 字</span></span><br><span class="line"><span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] [<span class="number">3</span>:<span class="number">0</span>] nibbles;       <span class="comment">// 合并数组</span></span><br><span class="line">barray[<span class="number">0</span>] = lw;</span><br><span class="line">barray[<span class="number">0</span>][<span class="number">3</span>] = <span class="number">8'h01</span>;</span><br><span class="line">barray[<span class="number">0</span>][<span class="number">1</span>][<span class="number">6</span>] = <span class="number">1'b1</span>;</span><br><span class="line">nibbles = barray[<span class="number">0</span>];           <span class="comment">// 复制合并数组的元素值</span></span><br></pre></td></tr></tbody></table></figure>
<p><a href="#例15">例 15</a> 中的变量 <code>bytes</code> 是一个具有 4
个字节的合并数组，以单字形式存放。<code>barray</code> 则是一个具有 3
个类似 <code>bytes</code> 元素的数组，其存放形式如图 3。</p>
<p><a id="图3"></a></p>
<figure>
<img data-src="../images/post/2022-05-31-josh-systemverilog-2/2022-05-31-josh-systemverilog-2-030-PackedArrayBitLayout.png" width="600" alt="图 3 合并数组存放示意图">
<figcaption aria-hidden="true">图 3 合并数组存放示意图</figcaption>
</figure>
<ul>
<li>使用一个下标，可以得到一个字的数据，如 <code>barray[2]</code>；</li>
<li>使用两个下标，可以得到一个字节的数据，如
<code>barray[0][3]</code>；</li>
<li>使用三个下标，可以访问到单个比特位，如
<code>barray[0][1][6]</code>。</li>
</ul>
<p>注意数组声明中在变量名后面指定了数组的大小，<code>barray[3]</code>，这个维度是非合并的，所以在使用该数组时至少要有一个下标。</p>
<p><a href="#例16">例 16</a>
中的最后一行在两个合并数组间实现复制。由于操作是以比特为单位进行的，所以即使数组维度不同也可以进行复制。</p>
<h2 id="合井数组和非合并数组的选择">2.8. 合井数组和非合并数组的选择</h2>
<p>应该选择合并数组还是非合并数组呢？当需要和标量进行相互转换时，使用合并数组会非常方便。例如，以字节或字为单位对存储单元进行操作。<a href="#图3">图 3</a> 中所示的 <code>barray</code>
可以满足这一要求。任何数组类型都可以合并，包括动态数组、队列和关联数组。</p>
<p><strong>如果需要等待数组中的变化，则必须使用合并数组</strong>。当
testbench 需要通过存储器数据的变化来唤醒时，需要使用 <code>@</code>
操作符，但 <strong><code>@</code>
操作符只能用于标量或者合并数组</strong>。在<a href="#例16">例 16</a>
中，可以把 <code>lw</code> 和 <code>barray[0]</code>
用作敏感信号，但却不能用整个的 <code>barray</code>
数组，除非把它扩展成：<code>@(barray[0] or barray[1] or barray[2])</code>。</p>
<h1 id="动态数组">3. 动态数组</h1>
<p>前面介绍的基本的 Verilog
数组类型都是定宽数组，其宽度在编译时就确定了。但如果直到程序运行之前都还不知道数组的宽度呢？例如，在仿真开始的时候生成一批事件，事件的总量是随机的。如果把这些事件存放到一个定宽数组里，那这个数组的宽度需要大到可以容纳最大的事件量，但实际的事件量可能会远远小于最大值，这就造成了存储空间的浪费。</p>
<p>SystemVerilog
提供了动态数组类型，可以<strong>在仿真时分配空间或调整宽度</strong>，这样在仿真中就可以使用最小的存储星。</p>
<p>动态数组在声明时使用空的下标
<code>[]</code>，表示数组的宽度不在编译时给出，在程序运行时再指定。数组在最开始时是空的，所以必须调用
<code>new[]</code>
操作符来分配空间，同时在方括号中传递数组宽度。可以把数组名传给
<code>new[]</code> 构造符，并把已有数组的值复制到新数组里，如<a href="#例17">例 17</a> 所示。</p>
<p><a id="例17"></a></p>
<figure class="highlight verilog"><figcaption><span>例 17 使用动态数组</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> dyn[], d2[];                <span class="comment">// 声明动态数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">  dyn = <span class="keyword">new</span>[<span class="number">5</span>];                 <span class="comment">// A: 分配 5 个元素</span></span><br><span class="line">  <span class="keyword">foreach</span> (dyn[j]) dyn[j] = j;  <span class="comment">// B: 对元素进行初始化</span></span><br><span class="line">  d2 = dyn;                     <span class="comment">// C: 复制一个动态数组</span></span><br><span class="line">  d2[<span class="number">0</span>] = <span class="number">5</span>;                    <span class="comment">// D: 修改复制值</span></span><br><span class="line">  <span class="built_in">$display</span>(dyn[<span class="number">0</span>],d2[<span class="number">0</span>]);       <span class="comment">// E: 显示数值 (0 和 5)</span></span><br><span class="line">  dyn = <span class="keyword">new</span>[<span class="number">20</span>](dyn);           <span class="comment">// F: 分配 20 个整数值并进行复制</span></span><br><span class="line">  dyn = <span class="keyword">new</span>[<span class="number">100</span>];               <span class="comment">// G: 分配 100 个新的整数值</span></span><br><span class="line">                                <span class="comment">//    旧值不复存在</span></span><br><span class="line">  dyn<span class="variable">.delete</span>();                 <span class="comment">// H: 删除所有元素</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<p>在<a href="#例17">例 17</a> 中：</p>
<ul>
<li>A：调用 <code>new[5]</code> 为动态数组 <code>dyn</code> 分配了 5
个整型元素。</li>
<li>B：把数组的索引值赋给相应的元素。</li>
<li>C：把 <code>dyn</code> 数组的元素值复制给了另一个数组。</li>
<li>D：和 E 行显示了数组 <code>dyn</code> 和 <code>d2</code>
是相互独立的。</li>
<li>F：首先分配了 20 个新元素并把原来的 <code>dyn</code>
数组复制给开始的 5 个元素，然后释放 dyn 数组原有的 5
个元素所占用的空间，最终 <code>dyn</code> 指向了一个具有 20
个元素的数组。</li>
<li>G：调用 <code>new[]</code> 分配了 100
个元素，但并不复制原有的值，原有的 20 个元素随即被释放。</li>
<li>H：删除了 <code>dyn</code> 数组。</li>
</ul>
<p>调用系统函数 <code>$size</code>
可以返回数组的宽度。动态数组有一些内建的子程序 (rou­tines)，例如
<code>delete</code> 和 <code>size</code>。</p>
<p>如果想声明一个常数数组但又不想统计元素的个数，可以使用动态数组并使用常量数组进行赋值。在<a href="#例18">例 18</a> 中声明的 <code>mask</code> 数组具有 9 个 8
比特元素，SystemVerilog
会自动统计元素的个数，这比声明一个定宽数组然后不小心把宽度错指为 8
要好。</p>
<p><a id="例18"></a></p>
<figure class="highlight verilog"><figcaption><span>例 18 使用动态数组来保存元素数量不定的列表</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] mask[] = '{<span class="number">8'b0000_0000</span>, <span class="number">8'b0000_0001</span>,</span><br><span class="line">                     <span class="number">8'b0000_0011</span>, <span class="number">8'b0000_0111</span>,</span><br><span class="line">                     <span class="number">8'b0000_1111</span>, <span class="number">8'b0001_1111</span>,</span><br><span class="line">                     <span class="number">8'b0011_1111</span>, <span class="number">8'b0111_1111</span>,</span><br><span class="line">                     <span class="number">8'b1111_1111</span>};</span><br></pre></td></tr></tbody></table></figure>
<p><strong>基本数据类型相同的定宽数组和动态数组之间可以相互赋值</strong>，例如都是
<code>int</code>
时。在元素数目相同的情况下，可以把动态数组的值复制到定宽数组。</p>
<p>当把一个定宽数组复制给一个动态数组时，SystemVerilog 会调用构造函数
<code>new[]</code> 来分配空间并复制数值。</p>
<h1 id="队列">4. 队列</h1>
<p>SystemVerilog 引进了一种新的数据类型——队列
(queue)，它结合了链表和数组的优点。队列与链表相似，<strong>可以在一个队列中的任何地方增加或删除元素</strong>，这类操作在性能上的损失比动态数组小得多，因为动态数组需要分配新的数组并复制所有元素的值。队列与数组相似，可以通过索引实现对任一元素的访问，而不需要像链表那样去遍历目标元素之前的所有元素。</p>
<p>队列的声明是使用带有美元符号的下标：<code>[$]</code>。队列元素的编号从
<code>0</code> 到 <code>$</code>。<a href="#例19">例 19</a>
示范了如何使用方法 (method) 在队列中增加和删除元素。注意队列的常量
(literal) 只有大括号而没有数组常量中开头的单引号。</p>
<p>SystemVerilog 的队列类似于标准模板库 (standard template library)
中的双端队列。通过增加元素来创建队列，SystemVerilog
会分配额外的空间以便新元素能够被快速插入。当元素增加到超过原有空间的容量时，SystemVerilog
会自动分配更多的空间。因此队列可以扩大或缩小，但不用像动态数组那样在性能上付出很大代价，System­Verilog
会随时记录闲置的空间。注意不要对队列使用构造函数
<code>new[]</code>。</p>
<p><a id="例19"></a></p>
<figure class="highlight verilog"><figcaption><span>例 19 队列的操作</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> j = <span class="number">1</span>,</span><br><span class="line">    q2[$] = {<span class="number">3</span>,<span class="number">4</span>},            <span class="comment">// 队列的常量不需要使用 “'”</span></span><br><span class="line">    q[$] = {<span class="number">0</span>,<span class="number">2</span>,<span class="number">5</span>};           <span class="comment">// {0,2,5}</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    q<span class="variable">.insert</span>(<span class="number">1</span>, j);           <span class="comment">// {0,1,2,5}     在 2 之前插入 1</span></span><br><span class="line">    q<span class="variable">.insert</span>(<span class="number">3</span>, q2);          <span class="comment">// {0,1,2,3,4,5} 在 q 中插入一个队列</span></span><br><span class="line">    q<span class="variable">.delete</span>(<span class="number">1</span>);              <span class="comment">// {0,2,3,4,5}   删除第 1 个元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面的操作执行速度很快</span></span><br><span class="line">    q<span class="variable">.push_front</span>(<span class="number">6</span>);          <span class="comment">// {6,0,2,3,4,5} 在队列前面插入</span></span><br><span class="line">    j = q<span class="variable">.pop_back</span>;           <span class="comment">// {6,0,2,3,4}   j = 5</span></span><br><span class="line">    q<span class="variable">.push_back</span>(<span class="number">8</span>);           <span class="comment">// {6,0,2,3,4,8} 在队列末尾插入</span></span><br><span class="line">    j = q<span class="variable">.pop_front</span>;          <span class="comment">// {0,2,3,4,8}   j = 6</span></span><br><span class="line">    <span class="keyword">foreach</span> (q[i])</span><br><span class="line">        <span class="built_in">$display</span>(q[i]);       <span class="comment">//               打印整个队列</span></span><br><span class="line">    q<span class="variable">.delete</span>();               <span class="comment">// {}            删除整个队列</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<p>还可以使用字下标串联来替代方法。如果把 <code>$</code>
放在一个范围表达式的左边，那么 <code>$</code> 将代表最小值，例如
<code>[$:2]</code> 就代表 <code>[0:2]</code>。如果 <code>$</code>
放在表达式的右边，则代表最大值，如<a href="#例20">例 20</a>
中初始化块的第一行里的 <code>[1:$]</code> 就表示
<code>[1:2]</code>。</p>
<p><a id="例20"></a></p>
<figure class="highlight verilog"><figcaption><span>例 20 队列的操作</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> j = <span class="number">1</span>,</span><br><span class="line">    q2[$] = {<span class="number">3</span>,<span class="number">4</span>},            <span class="comment">// 队列的常量不需要使用 “'”</span></span><br><span class="line">    q[$] = {<span class="number">0</span>,<span class="number">2</span>,<span class="number">5</span>};           <span class="comment">// {0,2,5}</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span>                 <span class="comment">// 结果</span></span><br><span class="line">    q = {q[<span class="number">0</span>], j, q[<span class="number">1</span>:$]};    <span class="comment">// {0,1,2,5}     在 2 之前插入 1</span></span><br><span class="line">    q = {q[<span class="number">0</span>:<span class="number">2</span>], q2, q[<span class="number">3</span>:$]}; <span class="comment">// {0,1,2,3,4,5} 在 q 中插入一个队列</span></span><br><span class="line">    q = {q[<span class="number">0</span>], q[<span class="number">2</span>:$]};       <span class="comment">// {0,2,3,4,5}   删除第 1 个元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面的操作执行速度很快</span></span><br><span class="line">    q = {<span class="number">6</span>, q};               <span class="comment">// {6,0,2,3,4,5} 在队列前面插入</span></span><br><span class="line">    j = q[$];                 <span class="comment">//               等同于 j = 5</span></span><br><span class="line">    q = q[<span class="number">0</span>:$-<span class="number">1</span>];             <span class="comment">// {6,0,2,3,4}   从队列末尾取出数据</span></span><br><span class="line">    q = {q, <span class="number">8</span>};               <span class="comment">// {6,0,2,3,4,8} 在队列末尾插入</span></span><br><span class="line">    j = q[<span class="number">0</span>];                 <span class="comment">//               等同于 j = 6</span></span><br><span class="line">    q = q[<span class="number">1</span>:$];               <span class="comment">// {0,2,3,4,8}   从队列前面取出数据</span></span><br><span class="line"></span><br><span class="line">    q = {};                   <span class="comment">// {}            删除整个队列</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<p>队列中的元素是连续存放的，所以在队列的前面或后面存取数据非常方便。无论队列有多大，这种操作所耗费的时间都是一样的。在队列中间增加或删除元素需要对已经存在的数据进行搬移以便腾出空间。相应操作所耗费的时间会随着队列的大小线性增加。</p>
<p>可以把定宽或动态数组的值复制给队列。</p>
<h1 id="关联数组">5. 关联数组</h1>
<p>如果只是偶尔需要创建一个大容量的数组，那么动态数组已经足够好用了，但是如果需要超大容量的呢？假设正在对一个有着几个
G
字节寻址范围的处理器进行建模。在典型的测试中，这个处理器可能只访问了用来存放可执行代码和数据的几百或几千个字节，这种情况下对几
G 字节的存储空间进行分配和初始化显然是浪费的。</p>
<p>SystemVerilog 提供了关联数组 (associative array)
类型，用来保存稀疏矩阵 (sparse matrix)
的元素。这意味着当对一个非常大的地址空间进行寻址时，SystemVerilog
只为实际写入的元素分配空间。在<a href="#图4">图 4</a> 中，关联数组只保留
0…3、42、1000、4521 和 200,000
等位置上的值。这样，用来存放这些值的空间比有 200,000
个条目的定宽或动态数组所占用的空间要小得多。</p>
<p><a id="图4"></a></p>
<figure>
<img data-src="../images/post/2022-05-31-josh-systemverilog-2/2022-05-31-josh-systemverilog-2-040-AssociativeArray.png" width="600" alt="图 4 关联数组">
<figcaption aria-hidden="true">图 4 关联数组</figcaption>
</figure>
<p>仿真器可以采用树或哈希表的形式来存放关联数组，但有一定的额外开销。当保存索引值比较分散的数组时，例如使用
32 位地址或 64
位数据作为索引的数据包，这种额外开销显然是可以接受的。</p>
<p>关联数组采用<strong>在方括号中放置数据类型<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></strong>的形式来进行声明，例如
<code>[int]</code> 或 <code>[Packet]</code>。<a href="#例21">例 21</a>
示范了关联数组的声明、初始化和遍历过程。</p>
<p><a id="例21"></a></p>
<figure class="highlight verilog"><figcaption><span>例 21 关联数组的声明、初始化和使用</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">63</span>:<span class="number">0</span>] assoc[<span class="keyword">int</span>], idx = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对稀疏分布的元素进行初始化</span></span><br><span class="line">    <span class="keyword">repeat</span> (<span class="number">64</span>) <span class="keyword">begin</span></span><br><span class="line">        assoc[idx] = idx;</span><br><span class="line">        idx = idx &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 foreach 遍历数组</span></span><br><span class="line">    <span class="keyword">foreach</span> (assoc[i])</span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">"assoc[%h] = %h"</span>, i, assoc[i]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用函数遍历数组</span></span><br><span class="line">    <span class="keyword">if</span> (assoc<span class="variable">.first</span>(idx))</span><br><span class="line">    <span class="keyword">begin</span>                         <span class="comment">// 得到第一个索引</span></span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">            <span class="built_in">$display</span>(<span class="string">"assoc[%h]=%h"</span>, idx, assoc[idx]);</span><br><span class="line">        <span class="keyword">while</span> (assoc<span class="variable">.next</span>(idx));  <span class="comment">// 得到下一个索引</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到并删除第一个元素</span></span><br><span class="line">    assoc<span class="variable">.first</span>(idx);</span><br><span class="line">    assoc<span class="variable">.delete</span>(idx);</span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">"The array now has %0d elements"</span>, assoc<span class="variable">.num</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<p><a href="#例21">例 21</a> 中的关联数组 <code>assoc</code>
具有稀疏分布的元素：1、2、4、8、16 等等。简单的 <code>for</code>
循环并不能遍历该数组，需要使用 <code>foreach</code>
循环来完成。如果想控制得更好，可以在 <code>do ... while</code>
循环中使用 <code>first</code> 和 <code>next</code>
函数。这些函数可以修改索引参数的值，然后根据数组是否为空返回 0 或
1。</p>
<p>和 Perl
语言中的哈希数组类似，关联数组也可以使用字符串索引进行寻址。<a href="#例22">例 22</a> 使用字符串索引读取文件，并建立关联数组
<code>switch</code>，以实现从字符串到数字的映射。如<a href="#例22">例
22</a> 所示，可以使用函数 <code>exists()</code>
来检查元素是否存在。如果试图读取尚未被写入的元素，SystemVerilog
会返回数组类型的默认值，例如对于双状态类型是
<code>0</code>，对于四状态类型是 <code>X</code>。</p>
<p><a id="例22"></a></p>
<figure class="highlight verilog"><figcaption><span>例 22 使用带字符串索引的关联数组</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输入文件的内容如下：</span></span><br><span class="line"><span class="comment">    42   min_address</span></span><br><span class="line"><span class="comment">    1492 max_address</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> switch[<span class="keyword">string</span>], min_address, max_address;</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">int</span> i, r, file;</span><br><span class="line">    <span class="keyword">string</span> s;</span><br><span class="line">    file = <span class="built_in">$fopen</span>(<span class="string">"switch.txt"</span>, <span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">while</span> (! <span class="built_in">$feof</span>(file)) <span class="keyword">begin</span></span><br><span class="line">        r = <span class="built_in">$fscanf</span>(file, <span class="string">"%d %s"</span>, i, s);</span><br><span class="line">        switch[s] = i;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">$fclose</span>(file);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最小地址值，默认为 0</span></span><br><span class="line">    min_address = switch[<span class="string">"min_address"</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最大地址值，默认为 1000</span></span><br><span class="line">    <span class="keyword">if</span> (switch<span class="variable">.exists</span>(<span class="string">"max_address"</span>))</span><br><span class="line">        max_address = switch[<span class="string">"max_address"</span>];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        max_address = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印数组的所有元素</span></span><br><span class="line">    <span class="keyword">foreach</span> (switch[s])</span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">"switch['%s']=%0d"</span>, s, switch[s]);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="链表">6. 链表</h1>
<p>System Verilog 提供了链表数据结构，类似于标准模板库 (STL)
的列表容器。这个容器被定义为一个参数化的类，可以根据用户需要存放各种类型的数据。</p>
<p>虽然 SystemVerilog 提供了链表，但应该避免使用它。C++ 程序员也许很熟悉
STL，但是 SystemVerilog 的队列更加高效易用。</p>
<h1 id="数组的方法">7. 数组的方法</h1>
<p>SystemVerilog
提供了很多数组的方法，可用于任何一种非合并的数组类型，包括定宽数组、动态数组、队列和关联数组。这些方法有简有繁，简单的如求当前数组的大小，复杂的如对数组进行排序。如果不带参数，则方法中的圆括号可以省略。</p>
<h2 id="数组缩减方法">7.1. 数组缩减方法</h2>
<p>基本的数组缩减方法是把一个数组缩减成一个值，如<a href="例23">例
23</a> 所示。最常用的缩减方法是
<code>sum</code>，它对数组中的所有元素求和。这里必须对 SystemVerilog
处理操作<strong>位宽</strong>的规则十分小心。默认情况下，如果把一个单比特数组的所有元素相加，其和也是单比特的。但如果使用
32 比特的表达式，把结果保存在 32 比特的变量里，与一个 32
比特的变量进行比较，或者使用适当的 <code>with</code>
表达式，SystemVerilog 都会在数组求和的过程中使用 32 比特位宽。</p>
<p><a id="例23"></a></p>
<figure class="highlight verilog"><figcaption><span>例 23 数组求和</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">bit</span> on[<span class="number">10</span>];                                   <span class="comment">// 单比特数组</span></span><br><span class="line"><span class="keyword">int</span> total;</span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">foreach</span> (on[i])</span><br><span class="line">        on[i] = i;                            <span class="comment">// on[i] 的值为 0 或 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印出单比特和</span></span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">"on.sum = %0d"</span>, on<span class="variable">.sum</span>);         <span class="comment">// on.sum = 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印出 32 比特和</span></span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">"on.sum = %0d"</span>, on<span class="variable">.sum</span> + <span class="number">32'd0</span>); <span class="comment">// on.sum = 5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于 total 是 32 比特变量，所以数组和也是 32 比特</span></span><br><span class="line">    total = on<span class="variable">.sum</span>;</span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">"total = %0d"</span>, total);           <span class="comment">// total = 5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将数组和与一个 32 比特数进行比较</span></span><br><span class="line">    <span class="keyword">if</span> (on<span class="variable">.sum</span> &gt;=<span class="number">32'd5</span>)                       <span class="comment">// 条件成立</span></span><br><span class="line">      <span class="built_in">$display</span>(<span class="string">"sum has 5 or more 1's"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用带 32 比特有符号运算的 with 表达式</span></span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">"int sum=%0d"</span>, on<span class="variable">.sum</span> <span class="keyword">with</span> (<span class="keyword">int</span>'(item)));</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<p>其他的数组缩减方法还有 <code>product</code> (积)，<code>and</code>
(与)，<code>or</code> (或) 和 <code>xor</code> (异或)。SystemVerilog
没有提供专门从数组里随机选取一个元素的方法。所以对于定宽数组队列、动态数组和关联数组可以使用
<code>$urandom_range($size (array)-1)</code>，而对于队列和动态数组还可以使用
<code>$urandom_ range(array.size()-1)</code>。</p>
<p>如果想从一个关联数组中随机选取一个元素，则需要逐个访问它之前的元素，因为无法直接访问到第
<span class="math inline">\(N\)</span> 个元素。<a href="#例24">例 24</a>
示范了如何从一个以整数值作为索引的关联数组中随机选取一个元素。如果数组是以字符串作为索引，只需要将
<code>idx</code> 的类型改为 <code>string</code> 即可。</p>
<p><a id="例24"></a></p>
<figure class="highlight verilog"><figcaption><span>例 24 从一个关联数组中随机选取一个元素</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> aa[<span class="keyword">int</span>], rand_idx, element, count;</span><br><span class="line"></span><br><span class="line">element = $urandom_range(aa<span class="variable">.size</span>()-<span class="number">1</span>);</span><br><span class="line"><span class="keyword">foreach</span>(aa[i])</span><br><span class="line">    <span class="keyword">if</span> (count++ == element) <span class="keyword">begin</span></span><br><span class="line">        rand_idx = i;   <span class="comment">// 保存关联数组的索引</span></span><br><span class="line">        <span class="keyword">break</span>;          <span class="comment">// 并退出</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">$display</span>(<span class="string">"%0d element aa[%0d] = %0d"</span>,</span><br><span class="line">         element, rand_idx, aa[rand_idx]);</span><br></pre></td></tr></tbody></table></figure>
<h2 id="数组定位方法">7.2. 数组定位方法</h2>
<p>数组中的最大值是什么？数组中有没有包含某个特定值？要想在非合并数组中查找数据，可以使用数组定位方法。<strong>这些方法的返回值通常是一个队列</strong>。</p>
<p><a href="#例25">例 25</a> 使用一个定宽数组
<code>f[6]</code>，一个动态数组 <code>d[]</code> 和一个队列
<code>q[$]</code>。<code>min</code> 和 <code>max</code>
函数能够找出数组中的最小值和最大值。注意，它们返回的是一个队列而非标量。这些方法也适用于关联数组。方法
<code>unique</code>
返回的是在数组中具有唯一值的队列，即排除掉重复的数值。</p>
<p><a id="例25"></a></p>
<figure class="highlight verilog"><figcaption><span>例 25 数组定位方法：<code>min</code>、<code>max</code>、<code>unique</code></span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> aa[<span class="keyword">int</span>], rand_idx, element, count;</span><br><span class="line"></span><br><span class="line">element = $urandom_range(aa<span class="variable">.size</span>()-<span class="number">1</span>);</span><br><span class="line"><span class="keyword">foreach</span>(aa[i])</span><br><span class="line">    <span class="keyword">if</span> (count++ == element) <span class="keyword">begin</span></span><br><span class="line">        rand_idx = i;   <span class="comment">// 保存关联数组的索引</span></span><br><span class="line">        <span class="keyword">break</span>;          <span class="comment">// 并退出</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">$display</span>(<span class="string">"%0d element aa[%0d] = %0d"</span>,</span><br><span class="line">         element, rand_idx, aa[rand_idx]);</span><br></pre></td></tr></tbody></table></figure>
<p>使用 <code>foreach</code>
循环固然可以实现数组的完全搜索，但是如果使用 SystemVerilog
的定位方法，则只需一个操作便可完成。表达式 <code>with</code> 可以指示
SystemVerilog 如何进行搜索，如<a href="#例26">例 26</a> 所示。</p>
<p><a id="例26"></a></p>
<figure class="highlight verilog"><figcaption><span>例 26 数组定位方法：<code>find</code></span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> d[] = '{<span class="number">9</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>}, tq[$];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找出所有大于 3 的元素</span></span><br><span class="line">tq = d<span class="variable">.find</span> <span class="keyword">with</span> (item &gt; <span class="number">3</span>);             <span class="comment">// {9,8,4,4}</span></span><br><span class="line"><span class="comment">// 等效代码</span></span><br><span class="line">tq<span class="variable">.delete</span>();</span><br><span class="line"><span class="keyword">foreach</span> (d[i])</span><br><span class="line">    <span class="keyword">if</span> (d[i] &gt; <span class="number">3</span>)</span><br><span class="line">        tq<span class="variable">.push_back</span>(d[i]);</span><br><span class="line"></span><br><span class="line">tq = d<span class="variable">.find_index</span> <span class="keyword">with</span> (item &gt; <span class="number">3</span>);       <span class="comment">// {0,2,4,5}</span></span><br><span class="line">tq = d<span class="variable">.find_first</span> <span class="keyword">with</span> (item &gt; <span class="number">99</span>);      <span class="comment">// {}-没有找到</span></span><br><span class="line">tq = d<span class="variable">.find_first_index</span> <span class="keyword">with</span> (item==<span class="number">8</span>);  <span class="comment">// {2} d[2]=8</span></span><br><span class="line">tq = d<span class="variable">.find_last</span> <span class="keyword">with</span> (item==<span class="number">4</span>);         <span class="comment">// {4}</span></span><br><span class="line">tq = d<span class="variable">.find_last_index</span> <span class="keyword">with</span> (item==<span class="number">4</span>);   <span class="comment">// {5} d[5]=4</span></span><br></pre></td></tr></tbody></table></figure>
<p>在条件语句 <code>with</code> 中，<code>item</code>
被称为重复参数，它代表了数组中一个单独的元素。<code>item</code>
是默认的名字，也可以指定别的名字，只要在数组方法的参数列表中列出来就可以了，如<a href="#例27">例 27</a> 所示。</p>
<p><a id="例27"></a></p>
<figure class="highlight verilog"><figcaption><span>例 27 重复参数的声明</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">tq = d<span class="variable">.find_first</span> <span class="keyword">with</span> (item==<span class="number">4</span>);        <span class="comment">// 本例的四个语句都是等价的</span></span><br><span class="line">tq = d<span class="variable">.find_first</span>() <span class="keyword">with</span> (item==<span class="number">4</span>);</span><br><span class="line">tq = d<span class="variable">.find_first</span>(item) <span class="keyword">with</span> (item==<span class="number">4</span>);</span><br><span class="line">tq = d<span class="variable">.find_first</span>(x) <span class="keyword">with</span> (x==<span class="number">4</span>);</span><br></pre></td></tr></tbody></table></figure>
<p><a href="#例28">例 28</a>
示范了几种对数组子集进行求和的方式。第一次求和 (<code>total</code>)
是先把元素值与 7 进行比较，比较表达式返回 1 (为真) 或 0
(为假)，然后再把返回结果与对应元素相乘，所以
<code>{9, 0, 8, 0, 0, 0}</code> 的元素和是 17。第二次求和
(<code>total</code>) 则使用条件操作符 <code>? :</code> 进行计算。</p>
<p><a id="例28"></a></p>
<figure class="highlight verilog"><figcaption><span>例 28 数组定位方法</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> count, total, d[] = '{<span class="number">9</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>};</span><br><span class="line"></span><br><span class="line">count = d<span class="variable">.sum</span> <span class="keyword">with</span> (item &gt;  <span class="number">7</span>);           <span class="comment">// 2: {9, 8}</span></span><br><span class="line">total = d<span class="variable">.sum</span> <span class="keyword">with</span> ((item &gt; <span class="number">7</span>) * item);   <span class="comment">// 17= 9+8</span></span><br><span class="line">count = d<span class="variable">.sum</span> <span class="keyword">with</span> (item &lt;  <span class="number">8</span>);           <span class="comment">// 4: {1, 3, 4, 4}</span></span><br><span class="line">total = d<span class="variable">.sum</span> <span class="keyword">with</span> (item &lt; <span class="number">8</span> ? item : <span class="number">0</span>); <span class="comment">// 12=1+3+4+4</span></span><br><span class="line">count = d<span class="variable">.sum</span> <span class="keyword">with</span> (item == <span class="number">4</span>);           <span class="comment">// 2: {4, 4}</span></span><br></pre></td></tr></tbody></table></figure>
<p>当把数组缩减方法与条件语句 <code>with</code>
结合使用时，会产生令人惊讶的结果，例如 <code>sum</code> 方法。在<a href="#例28">例 28</a> 中，<code>sum</code>
操作符的结果是条件表达式为真的次数。对于<a href="#例28">例 28</a>
的第一个运算语句来说，总共有两个数组元素大于 7 (9 和 8)，所以
<code>count</code> 最后得 2。</p>
<blockquote>
<p>返回值为索引的数组定位方法，其返回的队列类型是 <code>int</code> 而非
<code>integer</code>，例如 <code>find_index</code>
方法。如果在这些语句中不小心用错了数据类型，那么代码有可能通不过编译。</p>
</blockquote>
<h2 id="数组的排序">7.3. 数组的排序</h2>
<p>SystemVerilog
有几个可以改变数组中元素顺序的方法。可以对元素进行正排序、逆排序，或是打乱它们的顺序，如<a href="#例29">例 29</a>
所示。注意，与前述数组定位方法不同的是，<strong>排序方法改变了原始数组</strong>，而<strong>数组定位方法新建了一个队列来保存结果</strong>。</p>
<p><a id="例29"></a></p>
<figure class="highlight verilog"><figcaption><span>例 29 对数组排序</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> d[] =        '{<span class="number">9</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>};</span><br><span class="line">d<span class="variable">.reverse</span>();  <span class="comment">// '{4,4,3,8,1,9}</span></span><br><span class="line">d<span class="variable">.sort</span>();     <span class="comment">// '{1,3,4,4,8,9}</span></span><br><span class="line">d<span class="variable">.rsort</span>();    <span class="comment">// '{9,8,4,4,3,1}</span></span><br><span class="line">d<span class="variable">.shuffle</span>();  <span class="comment">// '{9,4,3,8,1,4}</span></span><br></pre></td></tr></tbody></table></figure>
<p><code>reverse</code> 和 <code>shuffle</code> 方法不能带
<code>with</code>
条件语句，<strong>它们的作用范围是整个数组</strong>。<a href="#例30">例
30</a>
示范了如何使用子域对一个结构进行排序。结构和合并结构后面会有解释。</p>
<p><a id="例30"></a></p>
<figure class="highlight verilog"><figcaption><span>例 30 对结构数组进行排序</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="keyword">packed</span> { <span class="keyword">byte</span> red, green, blue; } c[];</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    c = <span class="keyword">new</span>[<span class="number">100</span>];           <span class="comment">// 分配 100 个像素</span></span><br><span class="line">    <span class="keyword">foreach</span>(c[i])</span><br><span class="line">        c[i] = $urandom;    <span class="comment">// 填上随机数</span></span><br><span class="line"></span><br><span class="line">    c<span class="variable">.sort</span> <span class="keyword">with</span> (item<span class="variable">.red</span>); <span class="comment">// 只对红色 (red) 像素进行排序</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先对绿色 (green) 像素后对蓝色 (blue) 像素进行排序</span></span><br><span class="line">    c<span class="variable">.sort</span>(x) <span class="keyword">with</span> ({x<span class="variable">.green</span>, x<span class="variable">.blue</span>});</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="使用数组定位方法建立记分板">7.4. 使用数组定位方法建立记分板</h2>
<p>数组定位方法可以用来建立记分板。<a href="#例31">例 31</a>
定义了包结构
(<code>Packet</code>)，然后建立了一个由包结构队列组成的记分板。后面会解释如何使用
<code>typedef</code> 创建结构。</p>
<p><a id="例31"></a></p>
<figure class="highlight verilog"><figcaption><span>例 31 带数组方法的记分板</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="keyword">packed</span></span><br><span class="line">    {<span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] addr;</span><br><span class="line">     <span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] pr;</span><br><span class="line">     <span class="keyword">bit</span> [<span class="number">15</span>:<span class="number">0</span>] data; } Packet;</span><br><span class="line"></span><br><span class="line">Packet scb[$];</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> check_addr(<span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] addr);</span><br><span class="line">    <span class="keyword">int</span> intq[$];</span><br><span class="line"></span><br><span class="line">    intq = scb<span class="variable">.find_index</span>() <span class="keyword">with</span> (item<span class="variable">.addr</span> == addr);</span><br><span class="line">    <span class="keyword">case</span> (intq<span class="variable">.size</span>())</span><br><span class="line">    <span class="number">0</span>: <span class="built_in">$display</span>(<span class="string">"Addr %h not found in scoreboard"</span>, addr);</span><br><span class="line">    <span class="number">1</span>: scb<span class="variable">.delete</span>(intq[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">"ERROR: Multiple hits for addr %h"</span>, addr);</span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">endfunction</span> : check_addr</span><br></pre></td></tr></tbody></table></figure>
<p><a href="#例31">例 31</a> 中的 <code>check_addr()</code>
函数在记分板里寻找和参数匹配的地址。<code>find_index()</code>
方法返回一个 <code>int</code> 队列。如果该队列为空
(<code>size==0</code>)，则说明没有匹配值。如果该队列有一个成员
(<code>size==1</code>)，则说明有一个匹配，该匹配元素随后被
<code>check_addr()</code> 函数删除掉。如果该队列有多个成员
(<code>size&gt;1</code>)，则说明记分板里有多个包地址和目标值匹配。</p>
<p>对于包信息的存储，更好的方式是采用类 (class)，后续会有相关介绍。</p>
<h1 id="选择存储类型">8. 选择存储类型</h1>
<p>下面介绍基于灵活性、存储器用量、速度和排序要求正确选择存储类型的一些准则。这些准则只是一些经验法则，其结果可能会随着仿真器的不同而不同。</p>
<h2 id="灵活性">8.1. 灵活性</h2>
<ul>
<li><p>如果<strong>数组的索引是连续的非负整数</strong> 0、1、2、3
等，则应该使用定宽或动态数组。当数组的宽度在编译时已经确定时选择定宽数组，如果要等到程序运行时才知道数组宽度的话则选择动态数组。例如，长度可变的数据包使用动态数组存储会很方便。当编写处理数组的子程序时，最好使用动态数组，因为只要在元素类型
(如 <code>int</code>、<code>string</code> 等)
匹配的情况下，同一个子程序可以处理不同宽度的数组。同样地，只要元素类型匹配，任意长度的队列都可以传递给子程序。关联数组也可以作为参数传递，而不用考虑数组宽度的问题。相比之下，带定宽数组参数的子程序则只能接受指定宽度的数组。</p></li>
<li><p>当<strong>数组索引不规则时</strong>，例如对于由随机数值或地址产生的稀疏分布索引，则应选择关联数组。关联数组也可以用来对基于内容寻址
(content-addressable) 的存储器建模。</p></li>
<li><p>对于那些<strong>在仿真过程中元素数目变化很大的数组</strong>，例如保存预期值的记分板，队列是一个很好的选择。</p></li>
</ul>
<h2 id="存储器用量">8.2. 存储器用量</h2>
<p><strong>使用双状态类型可以减少仿真时的存储器用量</strong>。为了避免浪费空间，应尽量选择
32 比特的整数倍作为数据位宽。仿真器通常会把位宽小于 32 比特的数据存放到
32 比特的字里。例如，对于一个大小为 1024
的字节数组，如果仿真器把每个元素都存成一个 32 比特字，则会浪费 3/4
的存储空间。使用合并数组就有助于节省存储空间。</p>
<ul>
<li>对于具有一千个元素的数组，数组类型的选择对存储器用量的影响不大（除非这种数组的量非常大）</li>
<li>对于具有一千到一百万个活动元素的数组，定宽和动态数组具有最高的存储器使用效率。</li>
<li>如果需要用到大于一百万个活动元素的数组，那就有必要重新检查一下算法是否有问题。</li>
</ul>
<p>因为需要额外的指针，队列的存取效率比定宽或动态数组稍差。但是，如果把长度经常变化的数据集存放到动态存储空间里，那么需要手动调用
<code>new[]</code>
来分配和复制内存。这个操作的代价会很高，可能会抵消使用动态存储空间所带来的全部好处。</p>
<p>对兆字节量级的存储器建模应该使用关联数组。注意，因为指针带来的额外开销，关联数组里每个元素所占用的空间可能会比定宽或动态数组占用的空间大好几倍。</p>
<h2 id="速度">8.3. 速度</h2>
<p>还应根据<strong>每个时钟周期内的存取次数</strong>来选择数组类型。对于少量的读写，任何类型都可以使用，因为即使有额外开销，相比整个
DUT
也会显得很小。但是如果数组的操作很频繁，则数组的宽度和类型就会变得很关键。</p>
<ul>
<li><p>因为定宽和动态数组都是被存放在连续的存储器空间里，所以访问其中的任何元素耗时都相同，而与数组的大小无关。</p></li>
<li><p>队列的读写速度与定宽或动态数组基本相当。队列首尾元素的存取几乎没有任何额外开销，而在队列中间插入或删除元素则需要对很多其他元素进行搬移以便腾出空间。当需要在一个很长的队列里插入新元素时，测试程序可能会变得很慢，这时最好考虑改变新元素的存储方式。</p></li>
<li><p>对关联数组进行读写时，仿真器必须在存储器里进行搜索。SystemVerilog
的语言参考手册里并没有阐明这个过程是如何完成的，但最常用的方法是使用哈希表和树型结构。相比其他类型的数组，这要求更多的运算量，所以关联数组的存取速度是最慢的。</p></li>
</ul>
<h2 id="排序">8.4. 排序</h2>
<p>由于 SystemVerilog 能够对任何类型的一维数组
(定宽、动态、关联数组以及队列)
进行排序，因此应该<strong>根据数组中元素增加的频繁程度来选择数组的类型</strong>。</p>
<ul>
<li>如果元素是一次性全部加入的话，则选择定宽或动态数组，这样只需对数组进行一次分配。</li>
<li>如果元素是逐个加入的话，则选择队列，因为在队列首尾加入元素的效率很高。</li>
<li>如果数组的值不连续且彼此互异，例如 {1, 10, 11,
50}，那么可以使用关联数组并把元素值本身作为索引。</li>
</ul>
<p>使用子程序 <code>first</code>、 <code>next</code> 和
<code>prev</code>
可以从数组中查找某个特定值并进而找到它的相邻值。因为链表的是双重链接的，所以可以很容易地同时找到比当前值大的值和小的值。关联数组和链表也都支持对元素的删除操作。相比之下，关联数组通过给定索引的方式来存取元素还是比链表要快得多。</p>
<p>例如，可以使用一个关联数组来存放预期的 32
比特数值。数值生成后便直接写入索引的位优。如果想知道某个数值是否已被写入，可以使用
<code>exists</code> 函数来检查。如果不需要某个元素时，可以使用
<code>delete</code> 把它从关联数组删除。</p>
<h2 id="选择最优的数据结构">8.5. 选择最优的数据结构</h2>
<p>以下是针对数据结构选择的一些建议：</p>
<ol type="1">
<li><p><strong>网络数据包</strong> (<em>Network
packets</em>)。特点：长度固定，顺序存取。针对长度固定或可变的数据包可分别采用定宽或动态数组。</p></li>
<li><p><strong>保存期望值的记分板</strong> (<em>Scoreboard of expected
values</em>)。特点：仿真前长度未知，按值存取，长度经常变化。一般情况下可使用队列，这样方便在仿真期间连续增加和删除元素。如果能够为每个事件给出一个固定的编号，例如
1、2、3……，那么可以把这个编号作为队列的索引。如果事件涉及的全都是随机数值，那么只能把它们压入队列中并从中搜索特定的值。如果记分板有数百个元素，而且需要经常在元素之间进行增删操作，则使用关联数组在速度上可能会快一些。</p></li>
<li><p><strong>有序结构</strong> (<em>Sorted
structures</em>)。如果数据按照可预见的顺序输出，那么可以使用队列；如果输出顺序不确定，则使用关联数组。如果不用对记分板进行搜索，那么只需要把预期的数值存入信箱
(mailbox)。</p></li>
<li><p><strong>对超过百万个条目的特大容量存储器进行建模</strong>
(<em>Modeling very large memories, greater than a million
entries</em>)。如果不需要用到所有的存储空间，可以使用关联数组实现稀疏存储。如果确实需要用到所有的存储空间，试试有没有其他办法可以减少数据的使用量。如果还有问题，请确保使用的是双状态的
32 比特合并数据。</p></li>
<li><p><strong>文件中的命令名或操作码</strong> (<em>Command names or
opcodes from a
file</em>)。特点：把字符串转换成固定值。从文件中读出字符串，然后使用命令名作为字符串索引在关联数组中查找命令名或操作码。</p></li>
</ol>
<h1 id="使用-typedef-创建新的类型">9. 使用 <code>typedef</code>
创建新的类型</h1>
<p>typedef 语句可以用来创建新的类型。例如，要求一个算术逻辑单元 (ALU)
在编译时可配置，以适应 8 比特、 16 比特、 24 比特或 32
比特等不同位宽的操作数。在 Verilog
中，可以为操作数的位宽和类型分别定义一个宏 (macro)，如<a href="#例32">例
32</a> 所示。</p>
<p><a id="例32"></a></p>
<figure class="highlight verilog"><figcaption><span>例 32  Verilog 中用户自定义的类型宏</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 旧的 Verilog 风格</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> OPSIZE 8</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> OPREG reg [`OPSIZE-1:0]</span></span><br><span class="line"></span><br><span class="line">`OPREG op_a, op_b;</span><br></pre></td></tr></tbody></table></figure>
<p>这种情况并没有创建新的类型，而只是在进行文本替换。在 SystemVerilog
中，采用下面的代码可以创建新的类型。本文约定，所有用户自定义类型都带后缀
“<code>_t</code>”。</p>
<p><a id="例33"></a></p>
<figure class="highlight verilog"><figcaption><span>例 33 SystemVerilog 中用户自定义类型</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 新的 SystemVerilog 风格</span></span><br><span class="line"><span class="keyword">parameter</span> OPSIZE = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">reg</span> [OPSIZE-<span class="number">1</span>:<span class="number">0</span>] opreg_t;</span><br><span class="line"></span><br><span class="line">opreg_t op_a, op_b;</span><br></pre></td></tr></tbody></table></figure>
<p>一般来说，即使数据位宽不匹配，例如值被扩展或截断，SystemVerilog
都允许在这些基本类型之间进行复制而不会给出警告。</p>
<p>注意，可以把 <code>parameter</code> 和 <code>typedef</code>
语句放到一个程序包 (package) 里以使它们能被整个设计和 testbench
所共用。</p>
<blockquote>
<p>用户自定义的最有用的类型是双状态的 32 比特的无符号整数。在 testbench
中，很多数值都是正整数，例如字段长度或事件次数，这种情况下如果定义有符号整数就会出问题。把对
<code>uint</code>
的定义放到通用定义程序包中，这样就可以在仿真程序的任何地方使用它。</p>
</blockquote>
<p><a id="例34"></a></p>
<figure class="highlight verilog"><figcaption><span>例 34 <code>uint</code> 的定义</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] uint;    <span class="comment">// 32 比特双状态无符号数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="keyword">unsigned</span> uint;  <span class="comment">// 等效定义</span></span><br></pre></td></tr></tbody></table></figure>
<p>对新的数组类型的定义并不是很明显，需要把数组的下标放在新的数组名称中。<a href="#例35">例 35</a>
创建了一种新的类型，<code>fixed_array5</code>，它是一个有着 5
个元素的定宽数组。<a href="#例35">例 35</a>
接着声明了一个这种类型的数组并进行了初始化。</p>
<p><a id="例35"></a></p>
<figure class="highlight verilog"><figcaption><span>例 35 用户自定义数组类型</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> fixed_array5[<span class="number">5</span>];</span><br><span class="line">fixed_array5 f5;</span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">foreach</span> (f5[i])</span><br><span class="line">        f5[i] = i;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="创建用户自定义结构">10. 创建用户自定义结构</h1>
<p>Verilog 的最大缺陷之一是没有数据结构。在 SystemVerilog 中可以使用
<code>struct</code> 语句创建结构，跟 C 语言类似。但 <code>struct</code>
的功能比类少，所以还不如直接在 testbench 中使用类。就像 Verilog 的模块
(module) 中同时包括数据 (信号) 和代码 (always/initial 代码块及子程序)
一样，类里面也包含数据和程序，以便于调试和重用。<code>struct</code>
只是把数据组织到一起。如果缺少可以操作数据的程序，那么也只是解决了一半的问题。</p>
<p>由于 <code>struct</code>
只是一个数据的集合，所以它是可综合的。如果想在设计代码中对一个复杂的数据类型进行建模，例如像素，可以把它放到
<code>struct</code>
里。结构可以通过模块端口进行传递。而如果想生成带约束的随机数据，那就应该使用类了。</p>
<h2 id="使用-struct-创建新类型">10.1. 使用 <code>struct</code>
创建新类型</h2>
<p>可以把若干变量组合到一个结构中。<a href="#例36">例 36</a>
创建了一个名为 <code>pixel</code>
的结构，它有三个无符号的字节变量，分别代表红、绿和蓝。</p>
<p><a id="例36"></a></p>
<figure class="highlight verilog"><figcaption><span>例 36 创建一个 <code>pixel</code> 类型</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> {<span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] r, g, b;} pixel;</span><br></pre></td></tr></tbody></table></figure>
<p><a href="#例36">例 36</a> 中的声明只是创建了一个 <code>pixel</code>
变量。要想在端口和程序中共享它，则必须创建一个新的类型，如<a href="#例37">例 37</a> 所示。</p>
<p><a id="例37"></a></p>
<figure class="highlight verilog"><figcaption><span>例 37 <code>pixel</code> 结构</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> {<span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] r, g, b;} pixel_s;</span><br><span class="line">pixel_s my_pixel;</span><br></pre></td></tr></tbody></table></figure>
<p>在 <code>struct</code> 的声明中使用后缀 “<code>_s</code>”
可以方便用户识别自定义类型，简化代码的共享和重用过程。</p>
<h2 id="对结构进行初始化">10.2. 对结构进行初始化</h2>
<p>可以在声明或者过程赋值语句中把多个值赋给一个结构体，就像数组那样。如<a href="#例38">例 38</a> 所示，赋值时要把数值放到带单引号的大括号中。</p>
<p><a id="例38"></a></p>
<figure class="highlight verilog"><figcaption><span>例 38 对 <code>struct</code> 类型进行初始化</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">struct</span> {<span class="keyword">int</span> a;</span><br><span class="line">                    <span class="keyword">byte</span> b;</span><br><span class="line">                    <span class="keyword">shortint</span> c;</span><br><span class="line">                    <span class="keyword">int</span> d;} my_struct_s;</span><br><span class="line">    my_struct_s st = '{<span class="number">32'haaaa_aaaad</span>,</span><br><span class="line">                      <span class="number">8'hbb</span>,</span><br><span class="line">                      <span class="number">16'hcccc</span>,</span><br><span class="line">                      <span class="number">32'hdddd_dddd</span>};</span><br><span class="line"></span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">"str = %x %x %x %x "</span>, st<span class="variable">.a</span>, st<span class="variable">.b</span>, st<span class="variable">.c</span>, st<span class="variable">.d</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="创建可容纳不同类型的联合">10.3. 创建可容纳不同类型的联合</h2>
<p>在硬件中，寄存器里的某些位的含义可能与其他位的值有关。例如，不同的操作码对应的处理器指令格式也不同。带立即操作数的指令，它在操作数位置上存放的是一个常量。整数指令对这个立即数的译码结果会与浮点指令大不相同。<a href="#例39">例 39</a> 把整数 <code>i</code> 和实数 <code>f</code>
存放在同一位置上。</p>
<p><a id="例39"></a></p>
<figure class="highlight verilog"><figcaption><span>例 39 使用一个下标 <code>typedef</code> 创建联合</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> { <span class="keyword">int</span> i; <span class="keyword">real</span> f; } num_u;</span><br><span class="line">num_u un;</span><br><span class="line">un<span class="variable">.f</span> = <span class="number">0</span><span class="variable">.0</span>; <span class="comment">// 把数值设为浮点形式</span></span><br></pre></td></tr></tbody></table></figure>
<p>这里使用后缀 “<code>_u</code>” 来表示联合类型。</p>
<blockquote>
<p>如果需要以若干不同的格式对同一寄存器进行频繁读写时，联合体相当有用。但是，不要滥用，尤其不要仅仅因为想节约存储空间就使用联合。与结构相比，联合可能可以节省几个字节，但是付出的代价却是必须创建并维护一个更加复杂的数据结构，使用一个带判别变量的简单类可以达到同样的效果。这个判别变量的好处在于它标明了需要处理的数据类型，据此可以对相应字段实施读、写和随机化等操作。假如只需要一个数组，并想使用所有的比特来提高存储效率，那使用合并数组是很合适的。</p>
</blockquote>
<h2 id="合并结构">10.4. 合并结构</h2>
<p>SystemVerilog
提供的合并结构允许对数据在存储器中的排布方式有更多的控制。合并结构是以连续比特集的方式存放的，中间没有闲置的空间。<a href="#例37">例 37</a> 中的 <code>pixel</code>
结构使用了三个数值，所以它占用了三个长字的存储空间，即使它实际只需要三个字节。可以指定把它合并到尽可能小的空间里。</p>
<p><a id="例40"></a></p>
<figure class="highlight verilog"><figcaption><span>例 40 合并结构</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="keyword">packed</span> {<span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] r, g, b;} pixel_p_s;</span><br><span class="line">pixel_p_s my_pixel;</span><br></pre></td></tr></tbody></table></figure>
<p>当希望减少存储器的使用量或存储器的部分位代表了数值时，可以使用合并结构。例如，可以把若干个比特域合并成一个寄存器，也可以把操作码和操作数合并在一起来包含整个处理器指令。</p>
<h2 id="在合井结构和非合并结构之间进行选择">10.5.
在合井结构和非合并结构之间进行选择</h2>
<p>当在合并和非合并结构体间选择时，必须考虑结构通常的使用方式和元素的对齐方式。如果对结构的操作很频繁，例如需要经常对整个结构体进行复制，那么使用合并结构的效率会比较高。但是，如果操作经常是针对结构内的个体成员而非整体，那就应该使用非合并结构。当结构的元素不按字节对齐，或者元素位宽与字节不匹配，又或者元素是处理器的指令字时，使用合并和非合并结构在性能上的差别会更大。对合并结构中尺寸不规则的元素进行读写，需要移位和屏蔽操作，代价很高。</p>
<h1 id="类型转换">11. 类型转换</h1>
<p>SystemVerilog
数据类型的多样性意味着可能需要在它们之间进行转换。如果源变量和目标变量的比特位分布完全相同，例如整数和枚举类型，那它们之间可以直接相互赋值。如果比特位分布不同，例如字节数组和字数组，则需要使用流操作符对比特分布重新安排。</p>
<h2 id="静态转换">11.1. 静态转换</h2>
<p>静态转换操作不对转换值进行检查。如<a href="#例41">例 41</a>
所示，转换时指定目标类型，并在需要转换的表达式前加上单引号即可。注意，Verilog
对整数和实数类型，或者不同位宽的向量之间进行隐式转换。</p>
<p><a id="例41"></a></p>
<figure class="highlight verilog"><figcaption><span>例 41 在整型和实划之间进行静态转换</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">real</span> r;</span><br><span class="line"></span><br><span class="line">i = <span class="keyword">int</span> '(<span class="number">10</span><span class="variable">.0</span> - <span class="number">0</span><span class="variable">.1</span>); <span class="comment">// 转换是非强制的</span></span><br><span class="line">r = <span class="keyword">real</span>'(<span class="number">42</span>);         <span class="comment">// 转换是非强制的</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="动态转换">11.2. 动态转换</h2>
<p>动态转换函数 <code>$cast</code>
允许对越界的数值进行检查。相关内容后续对于枚举类型的解释和示例。</p>
<h2 id="流操作符">11.3. 流操作符</h2>
<p>流操作符 <code>&lt;&lt;</code> 和 <code>&gt;&gt;</code>
用在赋值表达式的右边，后面带表达式、结构或数组。流操作符用于把其后的数据打包成一个比特流。操作符
<code>&gt;&gt;</code> 把数据从左至右变成流，而 <code>&lt;&lt;</code>
则把数据从右至左变成流，如<a href="#例42">例 42</a>
所示。也可以指定一个片段宽度，把源数据按照这个宽度分段以后再转变成流。不能将比特流结果直接赋给非合并数组，而应该在赋值表达式的左边使用流操作符把比特流拆分到非合并数组中。</p>
<p><a id="例42"></a></p>
<figure class="highlight verilog"><figcaption><span>例 42 基本的流操作</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] b, g[<span class="number">4</span>], j[<span class="number">4</span>] = '{<span class="number">8'ha</span>, <span class="number">8'hb</span>, <span class="number">8'hc</span>, <span class="number">8'hd</span>};</span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] q, r, s, t;</span><br><span class="line"></span><br><span class="line">    h = { &gt;&gt; {j}};              <span class="comment">// 0a0b0c0d - 把数组打包成整型</span></span><br><span class="line">    h = { &lt;&lt; {j}};              <span class="comment">// b030d050 位倒序</span></span><br><span class="line">    h = { &lt;&lt; <span class="keyword">byte</span> {j}};         <span class="comment">// 0d0c0b0a 字节倒序</span></span><br><span class="line">    g = { &lt;&lt; <span class="keyword">byte</span> {j}};         <span class="comment">// 0d, 0c, 0b, 0a 拆分成数组</span></span><br><span class="line">    b = { &lt;&lt; {<span class="number">8'b0011_0101</span>}};   <span class="comment">// 1010_1100 位倒序</span></span><br><span class="line">    b = { &lt;&lt; <span class="number">4</span> {<span class="number">8'b0011_0101</span>}}; <span class="comment">// 0101_0011 半字节倒序</span></span><br><span class="line">    {&gt;&gt; {q, r, s, t}} = j;      <span class="comment">// 把 j 分散到四个字节变最里</span></span><br><span class="line">    h = {&gt;&gt;{t, s, r, q}};       <span class="comment">// 把字节集中到 h 里</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<p>也可以使用很多连接符 <code>{}</code>
来完成同样的操作，但是流操作符用起来会更简洁并且易于阅读。</p>
<p>如果需要打包或拆分数组，可以使用流操作符来完成具有不同尺寸元素的数组间的转换。例如，可以将字节数组转换成字数组。对于定宽数组、动态数组和队列都可以这样。<a href="#例43">例 43</a>
示范了队列之间的转换，这种转换同时也适用于动态数组。数组元素会根据需要自动分配。</p>
<p><a id="例43"></a></p>
<figure class="highlight verilog"><figcaption><span>例 43 使用流操作符进行队列间的转换</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">15</span>:<span class="number">0</span>] wq[$] = {<span class="number">16'h1234</span>, <span class="number">16'h5678</span>};</span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>]  bq[$];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把字数组转换成字节数组</span></span><br><span class="line">    bq = { &gt;&gt; {wq}};  <span class="comment">// 12 34 56 78</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把字节数组转换成字数组</span></span><br><span class="line">    bq = {<span class="number">8'h98</span>, <span class="number">8'h76</span>, <span class="number">8'h54</span>, <span class="number">8'h32</span>};</span><br><span class="line">    wq = { &gt;&gt; {bq}};  <span class="comment">// 9876 5432</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>数组下标失配是在数组间进行流操作时常见的错误。数组声明中的下标
<code>[256]</code> 等同于 <code>[0:255]</code> 而非
<code>[255:0]</code>。由于很多数组使用 <code>[high:low]</code>
(由高到低) 的下标形式进行声明，使用流操作把它们的值赋给带
<code>[size]</code>
下标形式的数组，会造成元素倒序。同样，如果把声明形式为
<code>bit [7:0] src [255:0]</code>
的非合并数组使用流操作赋值给声明形式为
<code>bit [7:0] [255:0] dst</code>
的合并数组，则数值的顺序会被打乱。对于合并的字节数组，正确的声明形式应该是
<code>bit [255:0] [7:0] dst</code>。</p>
</blockquote>
<p>流操作符也可用来将结构 (例如，ATM 信元) 打包或拆分到字节数组中。在<a href="#例44">例 44</a>
中使用流操作把结构转换成动态的字节数组，然后字节数组又被反过来转换成结构。</p>
<p><a id="例44"></a></p>
<figure class="highlight verilog"><figcaption><span>例 44 使用流操作符在结构和数组间进行转换</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">struct</span> {<span class="keyword">int</span> a;</span><br><span class="line">                    <span class="keyword">byte</span> b;</span><br><span class="line">                    <span class="keyword">shortint</span> c;</span><br><span class="line">                    <span class="keyword">int</span> d;} my_struct_s;</span><br><span class="line">    my_struct_s st = '{<span class="number">32'haaaa_aaaa</span>,</span><br><span class="line">                      <span class="number">8'hbb</span>,</span><br><span class="line">                      <span class="number">16'hcccc</span>,</span><br><span class="line">                      <span class="number">32'hdddd_dddd</span>};</span><br><span class="line">    <span class="keyword">byte</span> b[];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将结构转换成字节数组</span></span><br><span class="line">    b = { &gt;&gt; {st}};      <span class="comment">// {aa aa aa aa bb cc cc dd dd dd dd}</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将字节数组转换成结构</span></span><br><span class="line">    b = '{<span class="number">8'h11</span>, <span class="number">8'h22</span>, <span class="number">8'h33</span>, <span class="number">8'h44</span>, <span class="number">8'h55</span>, <span class="number">8'h66</span>, <span class="number">8'h77</span>,</span><br><span class="line">          <span class="number">8'h88</span>, <span class="number">8'h99</span>, <span class="number">8'haa</span>, <span class="number">8'hbb</span>};</span><br><span class="line">    st = { &gt;&gt; {b}};      <span class="comment">// st = 11223344, 55, 6677, 8899aabb</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="枚举类型">12. 枚举类型</h1>
<p>在学会使用枚举类型之前，只能使用文本宏。宏的作用范围太大，而且大多数情况下对于调试者是可见的。枚举创建了一种强大的变量类型，它仅限于一些特定名称的集合，例如指令中的操作码或者状态机中的状态名。例如，使用
ADD、MOVE 或 ROTW 这些名称有利于编写和维护代码，它比直接使用
<code>8'h01</code>
这样的常量或者宏要好得多。定义常量的另一种方法是使用参数。但参数需要对每个数值进行单独的定义，而枚举类型却能够自动为列表中的每个名称分配不同的数值。</p>
<p>最简单的枚举类型声明包含了一个常量名称列表以及一个或多个变量，如<a href="#例45">例 45</a>
所示。通过这种方式创建的是一个匿名的枚举类型，它只能用于这个例子中声明的变量。</p>
<p><a id="例45"></a></p>
<figure class="highlight verilog"><figcaption><span>例 45 一个简单的枚举类型</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> {RED, BLUE, GREEN} color;</span><br></pre></td></tr></tbody></table></figure>
<p>创建一个署名的枚举类型有利于声明更多新变量，尤其是当这些变量被用作子程序参数或模块端口时。首先需要创建枚举类型，然后再创建相应的变量。使用内建的
<code>name()</code> 函数，可以得到枚举变量值对应的字符串，如<a href="#例46">例 46</a> 所示。</p>
<p><a id="例46"></a></p>
<figure class="highlight verilog"><figcaption><span>例 46 枚举类型</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 创建代表 0,1,2 的数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> {INIT, DECODE, IDLE} fsmstate_e;</span><br><span class="line">fsmstate_e pstate, nstate;          <span class="comment">// 声明自定义类型变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">case</span> (pstate)</span><br><span class="line">        IDLE:    nstate = INIT;     <span class="comment">// 数据赋值</span></span><br><span class="line">        INIT:    nstate = DECODE;</span><br><span class="line">        <span class="keyword">default</span>: nstate = IDLE;</span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">"Next state is %s"</span>,</span><br><span class="line">            nstate<span class="variable">.name</span>());         <span class="comment">// 显示状态的符号名</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<p>这里，使用后缀 “<code>_e</code>” 来表示枚举类型。</p>
<h2 id="定义枚举值">12.1. 定义枚举值</h2>
<p>枚举值默认为从 0 开始递增的整数。可以定义自己的枚举值。<a href="#例47">例 47</a> 中使用 <code>INIT</code> 代表默认值
0，<code>DECODE</code> 代表 2，<code>IDLE</code> 代表 3。</p>
<p><a id="例47"></a></p>
<figure class="highlight verilog"><figcaption><span>例 47 指定枚举值</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> {INIT, DECODE=<span class="number">2</span>, IDLE} fsmtype_e;</span><br></pre></td></tr></tbody></table></figure>
<p>枚举常量，如<a href="#例47">例 47</a> 中的
<code>INIT</code>，它们的作用范围规则和变量是一样的。因此，如果在不同的枚举类型中用到了同一个枚举常量名，例如把
<code>INIT</code>
用于不同的状态机中，那么必须在不同的作用域里声明它们，例如模块、程序块、函数和类。</p>
<blockquote>
<p>如果没有特别指出，枚举类型会被当成 <code>int</code> 类型存储。由于
<code>int</code> 类型的默认值是 0，所以在给枚举常量赋值时务必小心。在<a href="#例48">例 48</a> 中 <code>position</code> 会被初始化为
0，这并不是一个合法的 <code>ordinal_e</code>
变量。这种情况是语言本身所规定的，而非工具上的缺陷。因此把 0
指定给一个枚举常量可以避免这个错误，如<a href="#例49">例 49</a>
所示。</p>
</blockquote>
<p><a id="例48"></a></p>
<figure class="highlight verilog"><figcaption><span>例 48 指定枚举值：不正确</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> {FIRST=<span class="number">1</span>, SECOND, THIRD} ordinal_e;</span><br><span class="line">ordinal_e position;</span><br></pre></td></tr></tbody></table></figure>
<p><a id="例49"></a></p>
<figure class="highlight verilog"><figcaption><span>例 49 指定枚举值：正确</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> {BAD_O=<span class="number">0</span>, FIRST=<span class="number">1</span>, SECOND, THIRD} ordinal_e;</span><br><span class="line">ordinal_e position;</span><br></pre></td></tr></tbody></table></figure>
<h2 id="枚举类型的子程序">12.2. 枚举类型的子程序</h2>
<p>SystemVerilog 提供了一些可以遍历枚举类型的函数：</p>
<ol type="1">
<li><code>first()</code> 返回第一个枚举常赋。</li>
<li><code>last()</code> 返回最后一个枚举常量。</li>
<li><code>next()</code> 返回下一个枚举常量。</li>
<li><code>next(N)</code> 返回以后第 N 个枚举常量。</li>
<li><code>prev()</code> 返回前一个枚举变量。</li>
<li><code>prev(N)</code> 返回以前第 N 个枚举变量。</li>
</ol>
<p>当到达枚举常量列表的头或尾时，函数 <code>next</code> 和
<code>prev</code> 会自动以环形方式绕回。</p>
<p>注意，要在 <code>for</code>
循环中使用变量来遍历枚举类型中的所有成员并非易事。可以使用
<code>first</code> 访问第一个成员，使用 <code>next</code>
访问后面的成员。间题在于如何为循环设置终止条 件。如果使用
<code>current! =current.last</code>，则循环会在到达最后一个成员之前终止。如果
使用 <code>current&lt;=current.last</code>，则会造成死循环，因为
<code>next</code> 给出的值永远也不会大于最后一个值。这类似于
<code>for</code> 循环的步长为 0.3，而循环变量定义为
<code>bit [1:0]</code>，所以循环永远不会退出。</p>
<p>实际上，可以使用 <code>do ... while</code> 循环来遍历所有值，如<a href="#例50">例 50</a> 所示。</p>
<p><a id="例50"></a></p>
<figure class="highlight verilog"><figcaption><span>例 50 遍历所有枚举成员</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> {RED, BLUE, GREEN} color_e;</span><br><span class="line">color_e color;</span><br><span class="line">color = color<span class="variable">.first</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">"Color = %0d/%s"</span>, color, color<span class="variable">.name</span>);</span><br><span class="line">    color = color<span class="variable">.next</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">while</span> (color != color<span class="variable">.first</span>);  <span class="comment">// 环形绕回时即完成</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="枚举类型的转换">12.3. 枚举类型的转换</h2>
<p>枚举类型的默认类型为双状态
<code>int</code>。可以使用简单的赋值表达式把枚举变量的值直接赋给非枚举变量如
<code>int</code>。但 SystemVerilog
不允许在没有进行显式类型转换的情况下把整型变量赋给枚举变量。SystemVerilog
要求显式类型转换的原因是<strong>可能存在的数值越界情况</strong>。</p>
<p><a id="例51"></a></p>
<figure class="highlight verilog"><figcaption><span>例 51 整型和枚举类型之间的相互赋值</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> {RED, BLUE, GREEN} COLOR_E;</span><br><span class="line">COLOR_E color, c2;</span><br><span class="line"><span class="keyword">int</span> c;</span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    color = BLUE;         <span class="comment">// 赋一个已知的合法值</span></span><br><span class="line">    c = color;            <span class="comment">// 将枚举类型转换成整型 (1)</span></span><br><span class="line">    c++;                  <span class="comment">// 整型递增 (2)</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">$cast</span>(color, c)) <span class="comment">// 将整型显式转换回枚举类型</span></span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">"Cast failed for c=%0d"</span>, c);</span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">"Color is %0d / %s"</span>, color, color<span class="variable">.name</span>);</span><br><span class="line">    c++;                  <span class="comment">// 3 对于枚举类型已经越界</span></span><br><span class="line">    c2 = COLOR_E'(c);     <span class="comment">// 不做类型检查</span></span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">"Color is %0d / %s"</span>, color, color<span class="variable">.name</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<p>在<a href="#例51">例 51</a> 中，<code>$cast</code>
被当成函数进行调用，目的在于把右边的值赋给左边的量。如果赋值成功，<code>$cast()</code>
返回 1。如果因为数值越界而导致赋值失败，则不进行任何赋值，函数返回
0。如果把 <code>cast</code> 当成任务使用并且操作失败，则 SystemVerilog
会打印错误信息。</p>
<p>也可以像<a href="#例51">例 51</a> 所示的那样使用
<code>type'(val)</code>
进行类型转换，但这种方式并不进行任何类型检查，所以转换结果可能会越界。例如，在<a href="#例51">例 51</a> 中进行静态类型转换以后，赋给 <code>c2</code>
的值实际上已经越界，所以应该尽量避免使用这种方式。</p>
<h1 id="常量">13. 常量</h1>
<p>SystemVerilog 中有好几种类型的常量。Verilog
中创建常量的最典型的方法是使用文本宏 (text
macro)。它的好处是：宏具有全局作用范围并且可以用于位段和类型定义。它的缺点同样是因为宏具有全局作用范围，在只需要一个局部常量时可能会引发冲突。此外，宏定义需要使用“<code>`</code>”符号，这样它才能被编译器识别和扩展。</p>
<p>在 SystemVerilog
中，参数可以在程序包里声明，因此可以在多个模块中共同使用。这种方式可以替换掉
Verilog 中很多用来表示常量的宏。可以用 <code>typedef</code>
来替换掉那些单调乏味的宏。其次还可以选择 <code>parameter</code>。Verilog
中的 <code>parameter</code>
并没有严格的类型界定，而且其作用范围仅限于单个模块里。Verilog-2001
增加了带类型的
<code>parameter</code>，但其有限的作用范围仍然使得它无法获得广泛应用。</p>
<p>SystemVerilog 也支持 <code>const</code>
修饰符，允许在变量声明时对其进行初始化，但不能在过程代码中改变其值。</p>
<p><a id="例52"></a></p>
<figure class="highlight verilog"><figcaption><span>例 52 <code>const</code> 变量的声明</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">byte</span> colon = <span class="string">":"</span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<p>在<a href="#例52">例 52</a> 中，<code>colon</code> 的值在
<code>initial</code> 块开头就被初始化。<code>const</code>
还可以作为子程序参数。</p>
<h1 id="字符串">14. 字符串</h1>
<p>Verilog 中使用 <code>reg</code>
变量来保存字符串，这一表达很不方便。SystemVerilog 中的
<code>string</code> 类型可以用来保存长度可变的字符串。单个字符是
<code>byte</code> 类型。长度为 <span class="math inline">\(N\)</span>
的字符串中，元素编号从 0 到 <span class="math inline">\(N —
1\)</span>。注意，跟 C 语言 不一样的是，字符串的结尾并不带标识符
null，所有尝试使用字符 “\0”
的操作都会被忽略。字符串使用动态的存储方式，所以不用担心存储空间会全部用完。</p>
<p><a href="#例53">例 53</a> 示范了与字符串相关的几种操作。函数
<code>getc(N)</code> 返回位置 <code>N</code>
上的字节，<code>toup­per</code>
返回一个所有字符大写的字符串，<code>tolower</code>
返回一个小写的字符串。大括号 <code>{}</code> 用于串接字符串。任务
<code>putc(M,C)</code> 把字节 <code>c</code> 写到字符串的 <code>M</code>
位上。<code>M</code> 必须介于 0 和 <code>len</code>
所给出的长度之间。函数 <code>substr(start,end)</code> 提取出从位置
<code>start</code> 到 <code>end</code> 之间的所有字符。</p>
<p><a id="例53"></a></p>
<figure class="highlight verilog"><figcaption><span>例 53 字符串方法</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">string</span> s;</span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    s = <span class="string">"IEEE "</span>;</span><br><span class="line">    <span class="built_in">$display</span>(s<span class="variable">.getc</span>(<span class="number">0</span>));      <span class="comment">// 显示: 73 ('I')</span></span><br><span class="line">    <span class="built_in">$display</span>(s<span class="variable">.tolower</span>());    <span class="comment">// 显示: ieee</span></span><br><span class="line"></span><br><span class="line">    s<span class="variable">.putc</span>(s<span class="variable">.len</span>()-<span class="number">1</span>, <span class="string">"-"</span>);   <span class="comment">// 将空格变为 '-'</span></span><br><span class="line">    s = {s, <span class="string">"P1800"</span>};         <span class="comment">// "IEEE-P1800"</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">$display</span>(s<span class="variable">.substr</span>(<span class="number">2</span>, <span class="number">5</span>)); <span class="comment">// 显示: EE-P</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建临时字符串，注意格式</span></span><br><span class="line">    my_log_rtn(<span class="built_in">$psprintf</span>(<span class="string">"%s %5d"</span>, s, <span class="number">42</span>));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">task</span> my_log(<span class="keyword">string</span> message);</span><br><span class="line">    <span class="comment">// 把信息打印到日志里</span></span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">"@%0t: %s"</span>, <span class="built_in">$time</span>, message);</span><br><span class="line"><span class="keyword">endtask</span></span><br></pre></td></tr></tbody></table></figure>
<p>稍加留意便可发现动态字符串的用处有多大。在别的语言如 C
里，必须不停地创建临时字符串来接收函数返回的结果。在<a href="#例53">例
53</a> 中，函数 <code>psprintf()</code> 替代了 Verilog-2001 中的函数
<code>sformat()</code>。这个新函数返回一个格式化的临时字符串，并且可以直接传递给其他子程序。这样就可以不用定义新的临时字符串并在格式化语句与函数调用过程中传递这个字符串。</p>
<h1 id="表达式的位宽">15. 表达式的位宽</h1>
<p>在 Verilog 中，表达式的位宽是造成行为不可预知的主要原因之一。<a href="#例54">例 54</a> 使用四种不同方式实现 <code>1+1</code>：</p>
<ul>
<li>方式 A 使用两个单比特变量，在这种精度下得到
<code>1+1=0</code>。</li>
<li>方式 B 由于赋值表达式的左边有一个 8 比特的变量，所以其精度是 8
比特，得到的结果是 <code>1+1=2</code>。</li>
<li>方式 C 采用一个哑元常数强迫 SystemVerilog 使用 2 比特精度。</li>
<li>方式 D 中，第一个值在转换符的作用下被指定为 2 比特的值，所以结果是
<code>1+1=2</code>。</li>
</ul>
<p><a id="例54"></a></p>
<figure class="highlight verilog"><figcaption><span>例 54 表达式位宽依赖于上下文</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] b8;</span><br><span class="line"><span class="keyword">bit</span> one = <span class="number">1'b1</span>;               <span class="comment">// 单比特</span></span><br><span class="line"><span class="built_in">$displayb</span>(one + one);         <span class="comment">// A: 1+1 = 0</span></span><br><span class="line"></span><br><span class="line">b8 = one + one;               <span class="comment">// B: 1+1 = 2</span></span><br><span class="line"><span class="built_in">$displayb</span>(b8);</span><br><span class="line"></span><br><span class="line"><span class="built_in">$displayb</span>(one + one + <span class="number">2'b0</span>);  <span class="comment">// C: 1+1 = 2, 使用了常量</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">$displayb</span>(<span class="number">2</span>'(one) + one);     <span class="comment">// D: 1+1 = 2, 采用强制类型转换</span></span><br></pre></td></tr></tbody></table></figure>
<p>有一些技巧可以避免这个问题。首先，避免像上例中方式 A
那样由于溢出造成精度受损的情况。也可以使用临时变量，像上例中的
<code>b8</code>
那样，以得到期望的位宽。或者，可以另外加入其他的值去强制获取最小精度，就像上例中的
<code>2'b0</code>。最后，在 SystemVerilog
中，还可以通过对变量进行强制转换以达到期望的精度。</p>
<h1 id="结束语">16. 结束语</h1>
<p>SystemVerilog
提供了很多新的数据类型和结构，让我们可以在较高的抽象层次上编写testbench，而不用担心比特层次的表示问题。队列很适合用于创建记分板，可以在上面频繁地增加或删除数据。动态数组允许在程序运行时再指定数组宽度，为
testbench
提供了极大的灵活性。关联数组可用于稀疏存储和一些只有单一索引的记分板。枚举类型通过创建具名常量列表，增强代码的可读写性。</p>
<p>但不应该满足于使用这些数据结构来写测试程序。后续讲述的 SystemVerilog
的 OOP
特性将帮我们在更高抽象层次上设计代码，进而提高代码的稳健性和可重用性。</p>
<h1 id="参考文献">参考文献</h1>
<ol type="1">
<li>克里斯·斯皮尔, 斯皮尔, 张春,等.
SystemVerilog验证:测试平台编写指南[M]. 科学出版社, 2009.</li>
<li>Spear C. SystemVerilog for verification: a guide to learning the
testbench language features[M]. Springer Science &amp; Business Media,
2008.</li>
</ol>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr>
<ol>
<li id="fn1"><p>也可以采用通配符作为下标进行关联数组的声明，例如
<code>wild[*]</code>。但是不推荐使用这种风格，因为不明确指明数据类型会导致很多问题。一个典型的问题是在
<code>foreach</code> 循环中——在 <code>foreach(wild[j])</code> 中的变量
<code>j</code> 究竟是什么类型？<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/css/markmap.css">

<script src="/js/markmap.js"></script>
]]></content>
      <categories>
        <category>Josh 的学习笔记</category>
        <category>SystemVerilog</category>
      </categories>
      <tags>
        <tag>SystemVerilog</tag>
        <tag>数据类型</tag>
        <tag>双状态</tag>
        <tag>队列</tag>
        <tag>动态数组</tag>
        <tag>关联数组</tag>
        <tag>类型转换</tag>
      </tags>
  </entry>
  <entry>
    <title>牛津 5000 词汇表（The Oxford 5000）</title>
    <url>/posts/4d8c1385.html</url>
    <content><![CDATA[<h1 id="the-oxford-5000">The Oxford 5000™</h1>
<p>The Oxford 5000 is an expanded core word list for advanced learners
of English. As well as the Oxford 3000, it includes an additional 2000
words for learners at B2-C1 level, which are listed here.</p>
<blockquote>
<p>The PDF version can be found at <a href="https://www.oxfordlearnersdictionaries.com/external/pdf/wordlists/oxford-3000-5000/The_Oxford_5000.pdf">The_Oxford_5000.pdf</a>.</p>
</blockquote>
<span id="more"></span>
<h2 id="a">A</h2>
<table>
<colgroup>
<col style="width: 32%">
<col style="width: 36%">
<col style="width: 31%">
</colgroup>
<tbody>
<tr>
<td style="text-align: left;">abolish <em>v.</em> C1</td>
<td style="text-align: left;">adverse <em>adj.</em> C1</td>
<td style="text-align: left;">applicant <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">abortion <em>n.</em> C1</td>
<td style="text-align: left;">advocate <em>n.</em>, <em>v.</em> C1</td>
<td style="text-align: left;">appoint <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">absence <em>n.</em> C1</td>
<td style="text-align: left;">aesthetic <em>adj.</em> C1</td>
<td style="text-align: left;">appreciation <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">absent <em>adj.</em> C1</td>
<td style="text-align: left;">affection <em>n.</em> C1</td>
<td style="text-align: left;">appropriately <em>adv.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">absorb <em>v.</em> B2</td>
<td style="text-align: left;">affordable <em>adj.</em> B2</td>
<td style="text-align: left;">arbitrary <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">abstract <em>adj.</em> B2</td>
<td style="text-align: left;">aftermath <em>n.</em> C1</td>
<td style="text-align: left;">architectural <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">absurd <em>adj.</em> C1</td>
<td style="text-align: left;">aggression <em>n.</em> C1</td>
<td style="text-align: left;">archive <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">abundance <em>n.</em> C1</td>
<td style="text-align: left;">agricultural <em>adj.</em> C1</td>
<td style="text-align: left;">arena <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">abuse <em>n.</em>, <em>v.</em> C1</td>
<td style="text-align: left;">agriculture <em>n.</em> B2</td>
<td style="text-align: left;">arguably <em>adv.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">academy <em>n.</em> C1</td>
<td style="text-align: left;">aide <em>n.</em> C1</td>
<td style="text-align: left;">arm <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">accelerate <em>v.</em> C1</td>
<td style="text-align: left;">AIDS <em>n.</em> B2</td>
<td style="text-align: left;">array <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">accent <em>n.</em> B2</td>
<td style="text-align: left;">albeit conj. C1</td>
<td style="text-align: left;">arrow <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">acceptance <em>n.</em> C1</td>
<td style="text-align: left;">alert <em>v.</em>, <em>n.</em>,
<em>adj.</em> C1</td>
<td style="text-align: left;">articulate <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">accessible <em>adj.</em> C1</td>
<td style="text-align: left;">alien <em>n.</em> B2, <em>adj.</em>
C1</td>
<td style="text-align: left;">artwork <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">accidentally <em>adv.</em> B2</td>
<td style="text-align: left;">align <em>v.</em> C1</td>
<td style="text-align: left;">ash <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">accommodate <em>v.</em> B2</td>
<td style="text-align: left;">alignment <em>n.</em> C1</td>
<td style="text-align: left;">aside <em>adv.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">accomplish <em>v.</em> B2</td>
<td style="text-align: left;">alike <em>adv.</em>, <em>adj.</em> C1</td>
<td style="text-align: left;">aspiration <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">accomplishment <em>n.</em> C1</td>
<td style="text-align: left;">allegation <em>n.</em> C1</td>
<td style="text-align: left;">aspire <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">accordance <em>n.</em> C1</td>
<td style="text-align: left;">allege <em>v.</em> C1</td>
<td style="text-align: left;">assassination <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">accordingly <em>adv.</em> C1</td>
<td style="text-align: left;">allegedly <em>adv.</em> C1</td>
<td style="text-align: left;">assault <em>n.</em>, <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">accountability <em>n.</em> C1</td>
<td style="text-align: left;">alliance <em>n.</em> C1</td>
<td style="text-align: left;">assemble <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">accountable <em>adj.</em> C1</td>
<td style="text-align: left;">allocate <em>v.</em> C1</td>
<td style="text-align: left;">assembly <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">accountant <em>n.</em> B2</td>
<td style="text-align: left;">allocation <em>n.</em> C1</td>
<td style="text-align: left;">assert <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">accumulate <em>v.</em> C1</td>
<td style="text-align: left;">allowance <em>n.</em> C1</td>
<td style="text-align: left;">assertion <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">accumulation <em>n.</em> C1</td>
<td style="text-align: left;">ally <em>n.</em> C1</td>
<td style="text-align: left;">asset <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">accuracy <em>n.</em> B2</td>
<td style="text-align: left;">alongside <em>prep.</em> B2</td>
<td style="text-align: left;">assign <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">accurately <em>adv.</em> B2</td>
<td style="text-align: left;">altogether <em>adv.</em> B2</td>
<td style="text-align: left;">assistance <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">accusation <em>n.</em> C1</td>
<td style="text-align: left;">aluminium <em>n.</em> C1</td>
<td style="text-align: left;">assumption <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">accused <em>n.</em> C1</td>
<td style="text-align: left;">amateur <em>adj.</em>, <em>n.</em> C1</td>
<td style="text-align: left;">assurance <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">acid <em>n.</em> B2, <em>adj.</em> C1</td>
<td style="text-align: left;">ambassador <em>n.</em> C1</td>
<td style="text-align: left;">assure <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">acquisition <em>n.</em> C1</td>
<td style="text-align: left;">ambulance <em>n.</em> B2</td>
<td style="text-align: left;">astonishing <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">acre <em>n.</em> C1</td>
<td style="text-align: left;">amend <em>v.</em> C1</td>
<td style="text-align: left;">asylum <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">activate <em>v.</em> B2</td>
<td style="text-align: left;">amendment <em>n.</em> C1</td>
<td style="text-align: left;">atrocity <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">activation <em>n.</em> C1</td>
<td style="text-align: left;">amid <em>prep.</em> C1</td>
<td style="text-align: left;">attachment <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">activist <em>n.</em> C1</td>
<td style="text-align: left;">amusing <em>adj.</em> B2</td>
<td style="text-align: left;">attain <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">acute <em>adj.</em> C1</td>
<td style="text-align: left;">analogy <em>n.</em> C1</td>
<td style="text-align: left;">attendance <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">adaptation <em>n.</em> C1</td>
<td style="text-align: left;">analyst <em>n.</em> B2</td>
<td style="text-align: left;">attorney <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">addiction <em>n.</em> B2</td>
<td style="text-align: left;">ancestor <em>n.</em> B2</td>
<td style="text-align: left;">attribute <em>v.</em>, <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">additionally <em>adv.</em> B2</td>
<td style="text-align: left;">anchor <em>n.</em> C1</td>
<td style="text-align: left;">auction <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">adequate <em>adj.</em> B2</td>
<td style="text-align: left;">angel <em>n.</em> C1</td>
<td style="text-align: left;">audio <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">adequately <em>adv.</em> B2</td>
<td style="text-align: left;">animation <em>n.</em> B2</td>
<td style="text-align: left;">audit <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">adhere <em>v.</em> C1</td>
<td style="text-align: left;">annually <em>adv.</em> B2</td>
<td style="text-align: left;">authentic <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">adjacent <em>adj.</em> C1</td>
<td style="text-align: left;">anonymous <em>adj.</em> C1</td>
<td style="text-align: left;">authorize <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">adjust <em>v.</em> B2</td>
<td style="text-align: left;">anticipate <em>v.</em> B2</td>
<td style="text-align: left;">auto <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">adjustment <em>n.</em> C1</td>
<td style="text-align: left;">anxiety <em>n.</em> B2</td>
<td style="text-align: left;">automatic <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">administer <em>v.</em> C1</td>
<td style="text-align: left;">apology <em>n.</em> B2</td>
<td style="text-align: left;">automatically <em>adv.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">administrative <em>adj.</em> C1</td>
<td style="text-align: left;">apparatus <em>n.</em> C1</td>
<td style="text-align: left;">autonomy <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">administrator <em>n.</em> C1</td>
<td style="text-align: left;">appealing <em>adj.</em> C1</td>
<td style="text-align: left;">availability <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">admission <em>n.</em> C1</td>
<td style="text-align: left;">appetite <em>n.</em> C1</td>
<td style="text-align: left;">await <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">adolescent <em>n.</em> C1</td>
<td style="text-align: left;">applaud <em>v.</em> C1</td>
<td style="text-align: left;">awareness <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">adoption <em>n.</em> C1</td>
<td style="text-align: left;">applicable <em>adj.</em> C1</td>
<td style="text-align: left;">awkward <em>adj.</em> B2</td>
</tr>
</tbody>
</table>
<h2 id="b">B</h2>
<table>
<colgroup>
<col style="width: 30%">
<col style="width: 39%">
<col style="width: 30%">
</colgroup>
<tbody>
<tr>
<td style="text-align: left;">backdrop <em>n.</em> C1</td>
<td style="text-align: left;">beneath <em>prep.</em> C1</td>
<td style="text-align: left;">boom <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">backing <em>n.</em> C1</td>
<td style="text-align: left;">beneficial <em>adj.</em> B2</td>
<td style="text-align: left;">boost <em>v.</em>, <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">backup <em>n.</em> C1</td>
<td style="text-align: left;">beneficiary <em>n.</em> C1</td>
<td style="text-align: left;">bounce <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">badge <em>n.</em> B2</td>
<td style="text-align: left;">beside <em>prep.</em> B2</td>
<td style="text-align: left;">bound <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">bail <em>n.</em> C1</td>
<td style="text-align: left;">besides <em>prep.</em>, <em>adv.</em>
B2</td>
<td style="text-align: left;">boundary <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">balanced <em>adj.</em> B2</td>
<td style="text-align: left;">betray <em>v.</em> C1</td>
<td style="text-align: left;">bow1 <em>v.</em>, <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">ballet <em>n.</em> B2</td>
<td style="text-align: left;">bias <em>n.</em> B2</td>
<td style="text-align: left;">breach <em>n.</em>, <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">balloon <em>n.</em> B2</td>
<td style="text-align: left;">bid <em>n.</em>, <em>v.</em> B2</td>
<td style="text-align: left;">breakdown <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">ballot <em>n.</em> C1</td>
<td style="text-align: left;">bind <em>v.</em> C1</td>
<td style="text-align: left;">breakthrough <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">banner <em>n.</em> C1</td>
<td style="text-align: left;">biography <em>n.</em> C1</td>
<td style="text-align: left;">breed <em>v.</em>, <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">bare <em>adj.</em> C1</td>
<td style="text-align: left;">biological <em>adj.</em> B2</td>
<td style="text-align: left;">brick <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">barely <em>adv.</em> B2</td>
<td style="text-align: left;">bishop <em>n.</em> C1</td>
<td style="text-align: left;">briefly <em>adv.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">bargain <em>n.</em> B2</td>
<td style="text-align: left;">bizarre <em>adj.</em> C1</td>
<td style="text-align: left;">broadband <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">barrel <em>n.</em> C1</td>
<td style="text-align: left;">blade <em>n.</em> C1</td>
<td style="text-align: left;">broadcaster <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">basement <em>n.</em> B2</td>
<td style="text-align: left;">blanket <em>n.</em> B2</td>
<td style="text-align: left;">broadly <em>adv.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">basket <em>n.</em> B2</td>
<td style="text-align: left;">blast <em>n.</em>, <em>v.</em> C1</td>
<td style="text-align: left;">browser <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">bass1 <em>n.</em> C1</td>
<td style="text-align: left;">bleed <em>v.</em> C1</td>
<td style="text-align: left;">brutal <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">bat <em>n.</em> B2, <em>v.</em> C1</td>
<td style="text-align: left;">blend <em>v.</em>, <em>n.</em> C1</td>
<td style="text-align: left;">buck <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">battlefield <em>n.</em> C1</td>
<td style="text-align: left;">bless <em>v.</em> C1</td>
<td style="text-align: left;">buddy <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">bay <em>n.</em> C1</td>
<td style="text-align: left;">blessing <em>n.</em> C1</td>
<td style="text-align: left;">buffer <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">beam <em>n.</em> C1</td>
<td style="text-align: left;">blow <em>n.</em> B2</td>
<td style="text-align: left;">bug <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">beast <em>n.</em> C1</td>
<td style="text-align: left;">boast <em>v.</em> C1</td>
<td style="text-align: left;">bulk <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">behalf <em>n.</em> C1</td>
<td style="text-align: left;">bold <em>adj.</em> B2</td>
<td style="text-align: left;">burden <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">beloved <em>adj.</em> C1</td>
<td style="text-align: left;">bombing <em>n.</em> B2</td>
<td style="text-align: left;">bureaucracy <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">bench <em>n.</em> C1</td>
<td style="text-align: left;">bonus <em>n.</em> C1</td>
<td style="text-align: left;">burial <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">benchmark <em>n.</em> C1</td>
<td style="text-align: left;">booking <em>n.</em> B2</td>
<td style="text-align: left;">burst <em>v.</em> C1</td>
</tr>
</tbody>
</table>
<h2 id="c">C</h2>
<table>
<colgroup>
<col style="width: 28%">
<col style="width: 28%">
<col style="width: 42%">
</colgroup>
<tbody>
<tr>
<td style="text-align: left;">cabin <em>n.</em> B2</td>
<td style="text-align: left;">commander <em>n.</em> B2</td>
<td style="text-align: left;">contempt <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">cabinet <em>n.</em> C1</td>
<td style="text-align: left;">commence <em>v.</em> C1</td>
<td style="text-align: left;">contend <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">calculation <em>n.</em> C1</td>
<td style="text-align: left;">commentary <em>n.</em> C1</td>
<td style="text-align: left;">contender <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">canal <em>n.</em> B2</td>
<td style="text-align: left;">commentator <em>n.</em> C1</td>
<td style="text-align: left;">content2 <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">candle <em>n.</em> B2</td>
<td style="text-align: left;">commerce <em>n.</em> C1</td>
<td style="text-align: left;">contention <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">canvas <em>n.</em> C1</td>
<td style="text-align: left;">commissioner <em>n.</em> C1</td>
<td style="text-align: left;">continually <em>adv.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">capability <em>n.</em> C1</td>
<td style="text-align: left;">commodity <em>n.</em> C1</td>
<td style="text-align: left;">contractor <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">capitalism <em>n.</em> C1</td>
<td style="text-align: left;">communist <em>adj.</em> C1</td>
<td style="text-align: left;">contradiction <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">capitalist <em>adj.</em> C1</td>
<td style="text-align: left;">companion <em>n.</em> C1</td>
<td style="text-align: left;">contrary <em>adj.</em>, <em>n.</em>
C1</td>
</tr>
<tr>
<td style="text-align: left;">carbon <em>n.</em> B2</td>
<td style="text-align: left;">comparable <em>adj.</em> C1</td>
<td style="text-align: left;">contributor <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">cargo <em>n.</em> C1</td>
<td style="text-align: left;">comparative <em>adj.</em> B2</td>
<td style="text-align: left;">controversial <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">carriage <em>n.</em> C1</td>
<td style="text-align: left;">compassion <em>n.</em> C1</td>
<td style="text-align: left;">controversy <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">carve <em>v.</em> C1</td>
<td style="text-align: left;">compel <em>v.</em> C1</td>
<td style="text-align: left;">convenience <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">casino <em>n.</em> C1</td>
<td style="text-align: left;">compelling <em>adj.</em> C1</td>
<td style="text-align: left;">convention <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">casual <em>adj.</em> B2</td>
<td style="text-align: left;">compensate <em>v.</em> C1</td>
<td style="text-align: left;">conventional <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">casualty <em>n.</em> C1</td>
<td style="text-align: left;">compensation <em>n.</em> C1</td>
<td style="text-align: left;">conversion <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">catalogue <em>n.</em> C1</td>
<td style="text-align: left;">competence <em>n.</em> C1</td>
<td style="text-align: left;">convey <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">cater <em>v.</em> C1</td>
<td style="text-align: left;">competent <em>adj.</em> C1</td>
<td style="text-align: left;">convict <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">cattle <em>n.</em> C1</td>
<td style="text-align: left;">compile <em>v.</em> C1</td>
<td style="text-align: left;">conviction <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">caution <em>n.</em> C1</td>
<td style="text-align: left;">complement <em>v.</em> C1</td>
<td style="text-align: left;">convincing <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">cautious <em>adj.</em> C1</td>
<td style="text-align: left;">completion <em>n.</em> B2</td>
<td style="text-align: left;">cooperate <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">cave <em>n.</em> B2</td>
<td style="text-align: left;">complexity <em>n.</em> C1</td>
<td style="text-align: left;">cooperative <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">cease <em>v.</em> C1</td>
<td style="text-align: left;">compliance <em>n.</em> C1</td>
<td style="text-align: left;">coordinate <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">cemetery <em>n.</em> C1</td>
<td style="text-align: left;">complication <em>n.</em> C1</td>
<td style="text-align: left;">coordination <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">certainty <em>n.</em> B2</td>
<td style="text-align: left;">comply <em>v.</em> C1</td>
<td style="text-align: left;">coordinator <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">certificate <em>n.</em> B2</td>
<td style="text-align: left;">compose <em>v.</em> B2</td>
<td style="text-align: left;">cop <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">challenging <em>adj.</em> B2</td>
<td style="text-align: left;">composer <em>n.</em> B2</td>
<td style="text-align: left;">cope <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">chamber <em>n.</em> C1</td>
<td style="text-align: left;">composition <em>n.</em> C1</td>
<td style="text-align: left;">copper <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">championship <em>n.</em> B2</td>
<td style="text-align: left;">compound <em>n.</em> B2</td>
<td style="text-align: left;">copyright <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">chaos <em>n.</em> C1</td>
<td style="text-align: left;">comprehensive <em>adj.</em> B2</td>
<td style="text-align: left;">corporation <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">characterize <em>v.</em> C1</td>
<td style="text-align: left;">comprise <em>v.</em> B2</td>
<td style="text-align: left;">correction <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">charm <em>n.</em> C1</td>
<td style="text-align: left;">compromise <em>n.</em>, <em>v.</em>
C1</td>
<td style="text-align: left;">correlate <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">charming <em>adj.</em> B2</td>
<td style="text-align: left;">compulsory <em>adj.</em> B2</td>
<td style="text-align: left;">correlation <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">charter <em>n.</em> C1</td>
<td style="text-align: left;">compute <em>v.</em> C1</td>
<td style="text-align: left;">correspond <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">chase <em>v.</em>, <em>n.</em> B2</td>
<td style="text-align: left;">conceal <em>v.</em> C1</td>
<td style="text-align: left;">correspondence <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">cheek <em>n.</em> B2</td>
<td style="text-align: left;">concede <em>v.</em> C1</td>
<td style="text-align: left;">correspondent <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">cheer <em>v.</em>, <em>n.</em> B2</td>
<td style="text-align: left;">conceive <em>v.</em> C1</td>
<td style="text-align: left;">corresponding <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">choir <em>n.</em> B2</td>
<td style="text-align: left;">conception <em>n.</em> C1</td>
<td style="text-align: left;">corridor <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">chop <em>v.</em> B2</td>
<td style="text-align: left;">concession <em>n.</em> C1</td>
<td style="text-align: left;">corrupt <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">chronic <em>adj.</em> C1</td>
<td style="text-align: left;">concrete <em>adj.</em>, <em>n.</em>
B2</td>
<td style="text-align: left;">corruption <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">chunk <em>n.</em> C1</td>
<td style="text-align: left;">condemn <em>v.</em> C1</td>
<td style="text-align: left;">costly <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">circuit <em>n.</em> B2</td>
<td style="text-align: left;">confer <em>v.</em> C1</td>
<td style="text-align: left;">councillor <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">circulate <em>v.</em> C1</td>
<td style="text-align: left;">confess <em>v.</em> B2</td>
<td style="text-align: left;">counselling <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">circulation <em>n.</em> C1</td>
<td style="text-align: left;">confession <em>n.</em> C1</td>
<td style="text-align: left;">counsellor <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">citizenship <em>n.</em> C1</td>
<td style="text-align: left;">configuration <em>n.</em> C1</td>
<td style="text-align: left;">counter (long flat surface) <em>n.</em>
B2</td>
</tr>
<tr>
<td style="text-align: left;">civic <em>adj.</em> C1</td>
<td style="text-align: left;">confine <em>v.</em> C1</td>
<td style="text-align: left;">counter (argue against) <em>v.</em>
C1</td>
</tr>
<tr>
<td style="text-align: left;">civilian <em>n.</em>, <em>adj.</em>
C1</td>
<td style="text-align: left;">confirmation <em>n.</em> C1</td>
<td style="text-align: left;">counterpart <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">civilization <em>n.</em> B2</td>
<td style="text-align: left;">confront <em>v.</em> C1</td>
<td style="text-align: left;">countless <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">clarify <em>v.</em> B2</td>
<td style="text-align: left;">confrontation <em>n.</em> C1</td>
<td style="text-align: left;">coup <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">clarity <em>n.</em> C1</td>
<td style="text-align: left;">confusion <em>n.</em> B2</td>
<td style="text-align: left;">courtesy <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">clash <em>n.</em> C1</td>
<td style="text-align: left;">congratulate <em>v.</em> C1</td>
<td style="text-align: left;">coverage <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">classification <em>n.</em> C1</td>
<td style="text-align: left;">congregation <em>n.</em> C1</td>
<td style="text-align: left;">crack <em>v.</em>, <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">classify <em>v.</em> B2</td>
<td style="text-align: left;">congressional <em>adj.</em> C1</td>
<td style="text-align: left;">craft <em>n.</em> B2, <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">clerk <em>n.</em> B2</td>
<td style="text-align: left;">conquer <em>v.</em> C1</td>
<td style="text-align: left;">crawl <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">cliff <em>n.</em> B2</td>
<td style="text-align: left;">conscience <em>n.</em> C1</td>
<td style="text-align: left;">creativity <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">cling <em>v.</em> C1</td>
<td style="text-align: left;">consciousness <em>n.</em> C1</td>
<td style="text-align: left;">creator <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">clinic <em>n.</em> B2</td>
<td style="text-align: left;">consecutive <em>adj.</em> C1</td>
<td style="text-align: left;">credibility <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">clinical <em>adj.</em> C1</td>
<td style="text-align: left;">consensus <em>n.</em> C1</td>
<td style="text-align: left;">credible <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">clip <em>n.</em> B2</td>
<td style="text-align: left;">consent <em>n.</em>, <em>v.</em> C1</td>
<td style="text-align: left;">creep <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">closure <em>n.</em> C1</td>
<td style="text-align: left;">consequently <em>adv.</em> B2</td>
<td style="text-align: left;">critically <em>adv.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">cluster <em>n.</em> C1</td>
<td style="text-align: left;">conservation <em>n.</em> B2</td>
<td style="text-align: left;">critique <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">coalition <em>n.</em> C1</td>
<td style="text-align: left;">conserve <em>v.</em> C1</td>
<td style="text-align: left;">crown <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">coastal <em>adj.</em> C1</td>
<td style="text-align: left;">considerable <em>adj.</em> B2</td>
<td style="text-align: left;">crude <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">cocktail <em>n.</em> C1</td>
<td style="text-align: left;">considerably <em>adv.</em> B2</td>
<td style="text-align: left;">cruise <em>n.</em>, <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">cognitive <em>adj.</em> C1</td>
<td style="text-align: left;">consistency <em>n.</em> C1</td>
<td style="text-align: left;">crush <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">coincide <em>v.</em> C1</td>
<td style="text-align: left;">consistently <em>adv.</em> B2</td>
<td style="text-align: left;">crystal <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">coincidence <em>n.</em> B2</td>
<td style="text-align: left;">consolidate <em>v.</em> C1</td>
<td style="text-align: left;">cue <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">collaborate <em>v.</em> C1</td>
<td style="text-align: left;">conspiracy <em>n.</em> B2</td>
<td style="text-align: left;">cult <em>n.</em>, <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">collaboration <em>n.</em> C1</td>
<td style="text-align: left;">constituency <em>n.</em> C1</td>
<td style="text-align: left;">cultivate <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">collective <em>adj.</em> C1</td>
<td style="text-align: left;">constitute <em>v.</em> C1</td>
<td style="text-align: left;">curiosity <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">collector <em>n.</em> B2</td>
<td style="text-align: left;">constitution <em>n.</em> C1</td>
<td style="text-align: left;">curious <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">collision <em>n.</em> C1</td>
<td style="text-align: left;">constitutional <em>adj.</em> C1</td>
<td style="text-align: left;">curriculum <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">colonial <em>adj.</em> C1</td>
<td style="text-align: left;">constraint <em>n.</em> C1</td>
<td style="text-align: left;">custody <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">colony <em>n.</em> B2</td>
<td style="text-align: left;">consult <em>v.</em> B2</td>
<td style="text-align: left;">cute <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">colourful <em>adj.</em> B2</td>
<td style="text-align: left;">consultant <em>n.</em> B2</td>
<td style="text-align: left;">cutting <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">columnist <em>n.</em> C1</td>
<td style="text-align: left;">consultation <em>n.</em> C1</td>
<td style="text-align: left;">cynical <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">combat <em>n.</em>, <em>v.</em> C1</td>
<td style="text-align: left;">consumption <em>n.</em> B2</td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">comic <em>adj.</em>, <em>n.</em> B2</td>
<td style="text-align: left;">contemplate <em>v.</em> C1</td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<h2 id="d">D</h2>
<table>
<colgroup>
<col style="width: 30%">
<col style="width: 28%">
<col style="width: 41%">
</colgroup>
<tbody>
<tr>
<td style="text-align: left;">dairy <em>n.</em>, <em>adj.</em> B2</td>
<td style="text-align: left;">deputy <em>n.</em> C1</td>
<td style="text-align: left;">disorder <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">dam <em>n.</em> C1</td>
<td style="text-align: left;">derive <em>v.</em> B2</td>
<td style="text-align: left;">displace <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">damaging <em>adj.</em> C1</td>
<td style="text-align: left;">descend <em>v.</em> C1</td>
<td style="text-align: left;">disposal <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">dare <em>v.</em> B2</td>
<td style="text-align: left;">descent <em>n.</em> C1</td>
<td style="text-align: left;">dispose <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">darkness <em>n.</em> B2</td>
<td style="text-align: left;">designate <em>v.</em> C1</td>
<td style="text-align: left;">dispute <em>n.</em>, <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">database <em>n.</em> B2</td>
<td style="text-align: left;">desirable <em>adj.</em> C1</td>
<td style="text-align: left;">disrupt <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">dawn <em>n.</em> C1</td>
<td style="text-align: left;">desktop <em>n.</em> C1</td>
<td style="text-align: left;">disruption <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">deadline <em>n.</em> B2</td>
<td style="text-align: left;">desperately <em>adv.</em> B2</td>
<td style="text-align: left;">dissolve <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">deadly <em>adj.</em> B2</td>
<td style="text-align: left;">destruction <em>n.</em> B2</td>
<td style="text-align: left;">distant <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">dealer <em>n.</em> B2</td>
<td style="text-align: left;">destructive <em>adj.</em> C1</td>
<td style="text-align: left;">distinct <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">debris <em>n.</em> C1</td>
<td style="text-align: left;">detain <em>v.</em> C1</td>
<td style="text-align: left;">distinction <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">debut <em>n.</em> C1</td>
<td style="text-align: left;">detection <em>n.</em> C1</td>
<td style="text-align: left;">distinctive <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">decision-making <em>n.</em> C1</td>
<td style="text-align: left;">detention <em>n.</em> C1</td>
<td style="text-align: left;">distinguish <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">decisive <em>adj.</em> C1</td>
<td style="text-align: left;">deteriorate <em>v.</em> C1</td>
<td style="text-align: left;">distort <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">deck <em>n.</em> B2</td>
<td style="text-align: left;">determination <em>n.</em> B2</td>
<td style="text-align: left;">distract <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">declaration <em>n.</em> C1</td>
<td style="text-align: left;">devastate <em>v.</em> C1</td>
<td style="text-align: left;">distress <em>n.</em>, <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">dedicated <em>adj.</em> C1</td>
<td style="text-align: left;">devil <em>n.</em> C1</td>
<td style="text-align: left;">disturb <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">dedication <em>n.</em> C1</td>
<td style="text-align: left;">devise <em>v.</em> C1</td>
<td style="text-align: left;">disturbing <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">deed <em>n.</em> C1</td>
<td style="text-align: left;">devote <em>v.</em> B2</td>
<td style="text-align: left;">dive <em>v.</em>, <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">deem <em>v.</em> C1</td>
<td style="text-align: left;">diagnose <em>v.</em> C1</td>
<td style="text-align: left;">diverse <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">default <em>n.</em> C1</td>
<td style="text-align: left;">diagnosis <em>n.</em> C1</td>
<td style="text-align: left;">diversity <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">defect <em>n.</em> C1</td>
<td style="text-align: left;">dictate <em>v.</em> C1</td>
<td style="text-align: left;">divert <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">defender <em>n.</em> B2</td>
<td style="text-align: left;">dictator <em>n.</em> C1</td>
<td style="text-align: left;">divine <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">defensive <em>adj.</em> C1</td>
<td style="text-align: left;">differ <em>v.</em> B2</td>
<td style="text-align: left;">divorce <em>n.</em>, <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">deficiency <em>n.</em> C1</td>
<td style="text-align: left;">differentiate <em>v.</em> C1</td>
<td style="text-align: left;">doctrine <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">deficit <em>n.</em> C1</td>
<td style="text-align: left;">dignity <em>n.</em> C1</td>
<td style="text-align: left;">documentation <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">defy <em>v.</em> C1</td>
<td style="text-align: left;">dilemma <em>n.</em> C1</td>
<td style="text-align: left;">domain <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">delegate <em>n.</em> C1</td>
<td style="text-align: left;">dimension <em>n.</em> C1</td>
<td style="text-align: left;">dominance <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">delegation <em>n.</em> C1</td>
<td style="text-align: left;">diminish <em>v.</em> C1</td>
<td style="text-align: left;">dominant <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">delete <em>v.</em> B2</td>
<td style="text-align: left;">dip <em>v.</em> C1</td>
<td style="text-align: left;">donation <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">delicate <em>adj.</em> C1</td>
<td style="text-align: left;">diplomat <em>n.</em> C1</td>
<td style="text-align: left;">donor <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">democracy <em>n.</em> B2</td>
<td style="text-align: left;">diplomatic <em>n.</em> C1</td>
<td style="text-align: left;">dose <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">democratic <em>adj.</em> B2</td>
<td style="text-align: left;">directory <em>n.</em> C1</td>
<td style="text-align: left;">dot <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">demon <em>n.</em> C1</td>
<td style="text-align: left;">disability <em>n.</em> B2</td>
<td style="text-align: left;">downtown <em>n.</em>, <em>adj.</em>,
<em>adv.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">demonstration <em>n.</em> B2</td>
<td style="text-align: left;">disabled <em>adj.</em> B2</td>
<td style="text-align: left;">drain <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">denial <em>n.</em> C1</td>
<td style="text-align: left;">disagreement <em>n.</em> B2</td>
<td style="text-align: left;">dramatically <em>adv.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">denounce <em>v.</em> C1</td>
<td style="text-align: left;">disappoint <em>v.</em> B2</td>
<td style="text-align: left;">drift <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">dense <em>adj.</em> C1</td>
<td style="text-align: left;">disappointment <em>n.</em> B2</td>
<td style="text-align: left;">driving <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">density <em>n.</em> C1</td>
<td style="text-align: left;">disastrous <em>adj.</em> C1</td>
<td style="text-align: left;">drought <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">depart <em>v.</em> B2</td>
<td style="text-align: left;">discard <em>v.</em> C1</td>
<td style="text-align: left;">drown <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">dependence <em>n.</em> C1</td>
<td style="text-align: left;">discharge <em>v.</em> C1</td>
<td style="text-align: left;">dual <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">dependent <em>adj.</em> B2</td>
<td style="text-align: left;">disclose <em>v.</em> C1</td>
<td style="text-align: left;">dub <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">depict <em>v.</em> C1</td>
<td style="text-align: left;">disclosure <em>n.</em> C1</td>
<td style="text-align: left;">dull <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">deploy <em>v.</em> C1</td>
<td style="text-align: left;">discourage <em>v.</em> B2</td>
<td style="text-align: left;">dumb <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">deployment <em>n.</em> C1</td>
<td style="text-align: left;">discourse <em>n.</em> C1</td>
<td style="text-align: left;">dump <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">deposit <em>n.</em> B2, <em>v.</em>
C1</td>
<td style="text-align: left;">discretion <em>n.</em> C1</td>
<td style="text-align: left;">duo <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">depression <em>n.</em> B2</td>
<td style="text-align: left;">discrimination <em>n.</em> C1</td>
<td style="text-align: left;">duration <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">deprive <em>v.</em> C1</td>
<td style="text-align: left;">dismissal <em>n.</em> C1</td>
<td style="text-align: left;">dynamic <em>adj.</em> B2, <em>n.</em>
C1</td>
</tr>
</tbody>
</table>
<h2 id="e">E</h2>
<table>
<colgroup>
<col style="width: 29%">
<col style="width: 36%">
<col style="width: 34%">
</colgroup>
<tbody>
<tr>
<td style="text-align: left;">eager <em>adj.</em> C1</td>
<td style="text-align: left;">endeavour <em>n.</em> C1</td>
<td style="text-align: left;">evoke <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">earnings <em>n.</em> C1</td>
<td style="text-align: left;">endless <em>adj.</em> C1</td>
<td style="text-align: left;">evolution <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">ease <em>n.</em>, <em>v.</em> C1</td>
<td style="text-align: left;">endorse <em>v.</em> C1</td>
<td style="text-align: left;">evolutionary <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">echo <em>v.</em>, <em>n.</em> C1</td>
<td style="text-align: left;">endorsement <em>n.</em> C1</td>
<td style="text-align: left;">evolve <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">ecological <em>adj.</em> C1</td>
<td style="text-align: left;">endure <em>v.</em> C1</td>
<td style="text-align: left;">exaggerate <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">economics <em>n.</em> B2</td>
<td style="text-align: left;">enforce <em>v.</em> C1</td>
<td style="text-align: left;">exceed <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">economist <em>n.</em> B2</td>
<td style="text-align: left;">enforcement <em>n.</em> C1</td>
<td style="text-align: left;">excellence <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">editorial <em>adj.</em> B2</td>
<td style="text-align: left;">engagement <em>n.</em> C1</td>
<td style="text-align: left;">exception <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">educator <em>n.</em> C1</td>
<td style="text-align: left;">engaging <em>adj.</em> C1</td>
<td style="text-align: left;">exceptional <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">effectiveness <em>n.</em> C1</td>
<td style="text-align: left;">enjoyable <em>adj.</em> B2</td>
<td style="text-align: left;">excess <em>n.</em>, <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">efficiency <em>n.</em> C1</td>
<td style="text-align: left;">enquire <em>v.</em> C1</td>
<td style="text-align: left;">excessive <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">efficiently <em>adv.</em> B2</td>
<td style="text-align: left;">enrich <em>v.</em> C1</td>
<td style="text-align: left;">exclude <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">ego <em>n.</em> C1</td>
<td style="text-align: left;">enrol <em>v.</em> C1</td>
<td style="text-align: left;">exclusion <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">elaborate <em>adj.</em> C1</td>
<td style="text-align: left;">ensue <em>v.</em> C1</td>
<td style="text-align: left;">exclusive <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">elbow <em>n.</em> B2</td>
<td style="text-align: left;">enterprise <em>n.</em> C1</td>
<td style="text-align: left;">exclusively <em>adv.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">electoral <em>adj.</em> C1</td>
<td style="text-align: left;">entertaining <em>adj.</em> B2</td>
<td style="text-align: left;">execute <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">electronics <em>n.</em> B2</td>
<td style="text-align: left;">enthusiast <em>n.</em> C1</td>
<td style="text-align: left;">execution <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">elegant <em>adj.</em> B2</td>
<td style="text-align: left;">entitle <em>v.</em> C1</td>
<td style="text-align: left;">exert <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">elementary <em>adj.</em> B2</td>
<td style="text-align: left;">entity <em>n.</em> C1</td>
<td style="text-align: left;">exhibit <em>v.</em>, <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">elevate <em>v.</em> C1</td>
<td style="text-align: left;">entrepreneur <em>n.</em> B2</td>
<td style="text-align: left;">exile <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">eligible <em>adj.</em> C1</td>
<td style="text-align: left;">envelope <em>n.</em> B2</td>
<td style="text-align: left;">exit <em>n.</em> B2, <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">eliminate <em>v.</em> B2</td>
<td style="text-align: left;">epidemic <em>n.</em> C1</td>
<td style="text-align: left;">exotic <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">elite <em>n.</em> C1</td>
<td style="text-align: left;">equality <em>n.</em> C1</td>
<td style="text-align: left;">expansion <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">embark <em>v.</em> C1</td>
<td style="text-align: left;">equation <em>n.</em> C1</td>
<td style="text-align: left;">expenditure <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">embarrassment <em>n.</em> C1</td>
<td style="text-align: left;">equip <em>v.</em> B2</td>
<td style="text-align: left;">experimental <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">embassy <em>n.</em> C1</td>
<td style="text-align: left;">equivalent <em>n.</em>, <em>adj.</em>
B2</td>
<td style="text-align: left;">expertise <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">embed <em>v.</em> C1</td>
<td style="text-align: left;">era <em>n.</em> B2</td>
<td style="text-align: left;">expire <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">embody <em>v.</em> C1</td>
<td style="text-align: left;">erect <em>v.</em> C1</td>
<td style="text-align: left;">explicit <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">embrace <em>v.</em> B2</td>
<td style="text-align: left;">erupt <em>v.</em> B2</td>
<td style="text-align: left;">explicitly <em>adv.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">emergence <em>n.</em> C1</td>
<td style="text-align: left;">escalate <em>v.</em> C1</td>
<td style="text-align: left;">exploit <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">emission <em>n.</em> B2</td>
<td style="text-align: left;">essence <em>n.</em> C1</td>
<td style="text-align: left;">exploitation <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">emotionally <em>adv.</em> B2</td>
<td style="text-align: left;">essentially <em>adv.</em> B2</td>
<td style="text-align: left;">explosive <em>adj.</em>, <em>n.</em>
C1</td>
</tr>
<tr>
<td style="text-align: left;">empire <em>n.</em> B2</td>
<td style="text-align: left;">establishment <em>n.</em> C1</td>
<td style="text-align: left;">exposure <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">empirical <em>adj.</em> C1</td>
<td style="text-align: left;">eternal <em>adj.</em> C1</td>
<td style="text-align: left;">extension <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">empower <em>v.</em> C1</td>
<td style="text-align: left;">ethic <em>n.</em> B2</td>
<td style="text-align: left;">extensive <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">enact <em>v.</em> C1</td>
<td style="text-align: left;">ethnic <em>adj.</em> B2</td>
<td style="text-align: left;">extensively <em>adv.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">encompass <em>v.</em> C1</td>
<td style="text-align: left;">evacuate <em>v.</em> C1</td>
<td style="text-align: left;">extract <em>n.</em> B2, <em>v.</em>
C1</td>
</tr>
<tr>
<td style="text-align: left;">encouragement <em>n.</em> C1</td>
<td style="text-align: left;">evaluation <em>n.</em> B2</td>
<td style="text-align: left;">extremist <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">encouraging <em>adj.</em> C1</td>
<td style="text-align: left;">evident <em>adj.</em> B2</td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<h2 id="f">F</h2>
<table>
<colgroup>
<col style="width: 33%">
<col style="width: 30%">
<col style="width: 36%">
</colgroup>
<tbody>
<tr>
<td style="text-align: left;">fabric <em>n.</em> B2</td>
<td style="text-align: left;">firm <em>adj.</em> B2</td>
<td style="text-align: left;">fortunate <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">fabulous <em>adj.</em> B2</td>
<td style="text-align: left;">firmly <em>adv.</em> B2</td>
<td style="text-align: left;">forum <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">facilitate <em>v.</em> C1</td>
<td style="text-align: left;">fit <em>n.</em>C1</td>
<td style="text-align: left;">fossil <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">faction <em>n.</em> C1</td>
<td style="text-align: left;">fixture <em>n.</em> C1</td>
<td style="text-align: left;">foster <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">faculty <em>n.</em> C1</td>
<td style="text-align: left;">flavour <em>n.</em> B2</td>
<td style="text-align: left;">foundation <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">fade <em>v.</em> C1</td>
<td style="text-align: left;">flaw <em>n.</em> C1</td>
<td style="text-align: left;">founder <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">failed <em>adj.</em> B2</td>
<td style="text-align: left;">flawed <em>adj.</em> C1</td>
<td style="text-align: left;">fraction <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">fairness <em>n.</em> C1</td>
<td style="text-align: left;">flee <em>v.</em> C1</td>
<td style="text-align: left;">fragile <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">fake <em>adj.</em> B2</td>
<td style="text-align: left;">fleet <em>n.</em> C1</td>
<td style="text-align: left;">fragment <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">fame <em>n.</em> B2</td>
<td style="text-align: left;">flesh <em>n.</em> C1</td>
<td style="text-align: left;">framework <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">fantasy <em>n.</em> B2</td>
<td style="text-align: left;">flexibility <em>n.</em> C1</td>
<td style="text-align: left;">franchise <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">fare <em>n.</em> B2</td>
<td style="text-align: left;">flourish <em>v.</em> C1</td>
<td style="text-align: left;">frankly <em>adv.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">fatal <em>adj.</em> C1</td>
<td style="text-align: left;">fluid <em>n.</em> C1</td>
<td style="text-align: left;">fraud <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">fate <em>n.</em> C1</td>
<td style="text-align: left;">fond <em>adj.</em> B2</td>
<td style="text-align: left;">freely <em>adv.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">favourable <em>adj.</em> C1</td>
<td style="text-align: left;">fool <em>n.</em> B2</td>
<td style="text-align: left;">frequent <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">feat <em>n.</em> C1</td>
<td style="text-align: left;">footage <em>n.</em> C1</td>
<td style="text-align: left;">frustrated <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">federal <em>adj.</em> B2</td>
<td style="text-align: left;">forbid <em>v.</em> B2</td>
<td style="text-align: left;">frustrating <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">feminist <em>adj.</em>, <em>n.</em>
C1</td>
<td style="text-align: left;">forecast <em>n.</em>, <em>v.</em> B2</td>
<td style="text-align: left;">frustration <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">fever <em>n.</em> B2</td>
<td style="text-align: left;">foreigner <em>n.</em> C1</td>
<td style="text-align: left;">fulfil <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">fibre <em>n.</em> C1</td>
<td style="text-align: left;">forge <em>v.</em> C1</td>
<td style="text-align: left;">full-time <em>adj.</em>/<em>adv.</em>
B2</td>
</tr>
<tr>
<td style="text-align: left;">fierce <em>adj.</em> C1</td>
<td style="text-align: left;">format <em>n.</em> B2</td>
<td style="text-align: left;">functional <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">film-maker <em>n.</em> C1</td>
<td style="text-align: left;">formation <em>n.</em> B2</td>
<td style="text-align: left;">fundamentally <em>adv.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">filter <em>n.</em>, <em>v.</em> C1</td>
<td style="text-align: left;">formerly <em>adv.</em> B2</td>
<td style="text-align: left;">fundraising <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">fine <em>n.</em>, <em>v.</em> C1</td>
<td style="text-align: left;">formula <em>n.</em> C1</td>
<td style="text-align: left;">funeral <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">firearm <em>n.</em> C1</td>
<td style="text-align: left;">formulate <em>v.</em> C1</td>
<td style="text-align: left;">furious <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">firefighter <em>n.</em> B2</td>
<td style="text-align: left;">forth <em>adv.</em> C1</td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">firework <em>n.</em> B2</td>
<td style="text-align: left;">forthcoming <em>adj.</em> C1</td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<h2 id="g">G</h2>
<table>
<colgroup>
<col style="width: 27%">
<col style="width: 45%">
<col style="width: 26%">
</colgroup>
<tbody>
<tr>
<td style="text-align: left;">gallon <em>n.</em> C1</td>
<td style="text-align: left;">glance <em>n.</em>, <em>v.</em> C1</td>
<td style="text-align: left;">gravity <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">gambling <em>n.</em> C1</td>
<td style="text-align: left;">glimpse <em>n.</em> C1</td>
<td style="text-align: left;">greatly <em>adv.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">gaming <em>n.</em> B2</td>
<td style="text-align: left;">globalization <em>n.</em> B2</td>
<td style="text-align: left;">greenhouse <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">gathering <em>n.</em> C1</td>
<td style="text-align: left;">globe <em>n.</em> B2</td>
<td style="text-align: left;">grid <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">gay <em>adj.</em> B2</td>
<td style="text-align: left;">glorious <em>adj.</em> C1</td>
<td style="text-align: left;">grief <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">gaze <em>n.</em>, <em>v.</em> C1</td>
<td style="text-align: left;">glory <em>n.</em> C1</td>
<td style="text-align: left;">grin <em>v.</em>, <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">gear <em>n.</em> C1</td>
<td style="text-align: left;">golden <em>adj.</em> B2</td>
<td style="text-align: left;">grind <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">gender <em>n.</em> B2</td>
<td style="text-align: left;">goodness <em>n.</em> B2</td>
<td style="text-align: left;">grip <em>n.</em>, <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">gene <em>n.</em> B2</td>
<td style="text-align: left;">gorgeous <em>adj.</em> B2</td>
<td style="text-align: left;">grocery <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">generic <em>adj.</em> C1</td>
<td style="text-align: left;">governance <em>n.</em> C1</td>
<td style="text-align: left;">gross <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">genetic <em>adj.</em> B2</td>
<td style="text-align: left;">governor <em>n.</em> B2</td>
<td style="text-align: left;">guerrilla <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">genius <em>n.</em> B2</td>
<td style="text-align: left;">grace <em>n.</em> C1</td>
<td style="text-align: left;">guidance <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">genocide <em>n.</em> C1</td>
<td style="text-align: left;">graphic <em>adj.</em> B2</td>
<td style="text-align: left;">guideline <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">genuine <em>adj.</em> B2</td>
<td style="text-align: left;">graphics <em>n.</em> B2</td>
<td style="text-align: left;">guilt <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">genuinely <em>adv.</em> B2</td>
<td style="text-align: left;">grasp <em>v.</em>, <em>n.</em> C1</td>
<td style="text-align: left;">gut <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">gesture <em>n.</em> B2</td>
<td style="text-align: left;">grave (for dead person) <em>n.</em>
C1</td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">gig <em>n.</em> B2</td>
<td style="text-align: left;">grave (serious) <em>adj.</em> C1</td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<h2 id="h">H</h2>
<table>
<colgroup>
<col style="width: 32%">
<col style="width: 33%">
<col style="width: 33%">
</colgroup>
<tbody>
<tr>
<td style="text-align: left;">habitat <em>n.</em> B2</td>
<td style="text-align: left;">heal <em>v.</em> B2</td>
<td style="text-align: left;">honesty <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">hail <em>v.</em> C1</td>
<td style="text-align: left;">healthcare <em>n.</em> B2</td>
<td style="text-align: left;">hook <em>v.</em> B2, <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">halfway <em>adv.</em> C1</td>
<td style="text-align: left;">heighten <em>v.</em> C1</td>
<td style="text-align: left;">hopeful <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">halt <em>v.</em>, <em>n.</em> C1</td>
<td style="text-align: left;">helmet <em>n.</em> B2</td>
<td style="text-align: left;">hopefully <em>adv.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">handful <em>n.</em> C1</td>
<td style="text-align: left;">hence <em>adv.</em> B2</td>
<td style="text-align: left;">horizon <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">handling <em>n.</em> C1</td>
<td style="text-align: left;">herb <em>n.</em> B2</td>
<td style="text-align: left;">horn <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">handy <em>adj.</em> C1</td>
<td style="text-align: left;">heritage <em>n.</em> C1</td>
<td style="text-align: left;">hostage <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">harassment <em>n.</em> C1</td>
<td style="text-align: left;">hidden <em>adj.</em> B2</td>
<td style="text-align: left;">hostile <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">harbour <em>n.</em> B2</td>
<td style="text-align: left;">hierarchy <em>n.</em> C1</td>
<td style="text-align: left;">hostility <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">hardware <em>n.</em> C1</td>
<td style="text-align: left;">high-profile <em>adj.</em> C1</td>
<td style="text-align: left;">humanitarian <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">harmony <em>n.</em> C1</td>
<td style="text-align: left;">highway <em>n.</em> B2</td>
<td style="text-align: left;">humanity <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">harsh <em>adj.</em> C1</td>
<td style="text-align: left;">hilarious <em>adj.</em> B2</td>
<td style="text-align: left;">humble <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">harvest <em>n.</em>, <em>v.</em> C1</td>
<td style="text-align: left;">hint <em>n.</em>, <em>v.</em> C1</td>
<td style="text-align: left;">hunger <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">hatred n, C1</td>
<td style="text-align: left;">hip <em>n.</em> B2</td>
<td style="text-align: left;">hydrogen <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">haunt <em>v.</em> C1</td>
<td style="text-align: left;">historian <em>n.</em> B2</td>
<td style="text-align: left;">hypothesis <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">hazard <em>n.</em> C1</td>
<td style="text-align: left;">homeland <em>n.</em> C1</td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">headquarters <em>n.</em> B2</td>
<td style="text-align: left;">homeless <em>adj.</em> B2</td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<h2 id="i">I</h2>
<table>
<colgroup>
<col style="width: 29%">
<col style="width: 29%">
<col style="width: 40%">
</colgroup>
<tbody>
<tr>
<td style="text-align: left;">icon <em>n.</em> B2</td>
<td style="text-align: left;">infamous <em>adj.</em> C1</td>
<td style="text-align: left;">integral <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">ID <em>n.</em> B2</td>
<td style="text-align: left;">infant <em>n.</em> C1</td>
<td style="text-align: left;">integrate <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">identical <em>adj.</em> B2</td>
<td style="text-align: left;">infect <em>v.</em> C1</td>
<td style="text-align: left;">integrated <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">identification <em>n.</em> C1</td>
<td style="text-align: left;">infer <em>v.</em> B2</td>
<td style="text-align: left;">integration <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">ideological <em>adj.</em> C1</td>
<td style="text-align: left;">inflation <em>n.</em> B2</td>
<td style="text-align: left;">integrity <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">ideology <em>n.</em> C1</td>
<td style="text-align: left;">inflict <em>v.</em> C1</td>
<td style="text-align: left;">intellectual <em>adj.</em> B2, <em>n.</em>
C1</td>
</tr>
<tr>
<td style="text-align: left;">idiot <em>n.</em> C1</td>
<td style="text-align: left;">influential <em>adj.</em> C1</td>
<td style="text-align: left;">intensify <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">ignorance <em>n.</em> C1</td>
<td style="text-align: left;">info <em>n.</em> B2</td>
<td style="text-align: left;">intensity <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">illusion <em>n.</em> B2</td>
<td style="text-align: left;">infrastructure <em>n.</em> B2</td>
<td style="text-align: left;">intensive <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">imagery <em>n.</em> C1</td>
<td style="text-align: left;">inhabitant <em>n.</em> B2</td>
<td style="text-align: left;">intent <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">immense <em>adj.</em> C1</td>
<td style="text-align: left;">inherent <em>adj.</em> C1</td>
<td style="text-align: left;">interact <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">immigration <em>n.</em> B2</td>
<td style="text-align: left;">inherit <em>v.</em> B2</td>
<td style="text-align: left;">interaction <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">imminent <em>adj.</em> C1</td>
<td style="text-align: left;">inhibit <em>v.</em> C1</td>
<td style="text-align: left;">interactive <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">immune <em>adj.</em> B2</td>
<td style="text-align: left;">initiate <em>v.</em> C1</td>
<td style="text-align: left;">interface <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">implement <em>v.</em> B2</td>
<td style="text-align: left;">inject <em>v.</em> C1</td>
<td style="text-align: left;">interfere <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">implementation <em>n.</em> C1</td>
<td style="text-align: left;">injection <em>n.</em> C1</td>
<td style="text-align: left;">interference <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">implication <em>n.</em> B2</td>
<td style="text-align: left;">injustice <em>n.</em> C1</td>
<td style="text-align: left;">interim <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">imprison <em>v.</em> C1</td>
<td style="text-align: left;">ink <em>n.</em> B2</td>
<td style="text-align: left;">interior <em>adj.</em>, <em>n.</em>
C1</td>
</tr>
<tr>
<td style="text-align: left;">imprisonment <em>n.</em> C1</td>
<td style="text-align: left;">inmate <em>n.</em> C1</td>
<td style="text-align: left;">intermediate <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">inability <em>n.</em> C1</td>
<td style="text-align: left;">innovation <em>n.</em> B2</td>
<td style="text-align: left;">interpretation <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">inadequate <em>adj.</em> C1</td>
<td style="text-align: left;">innovative <em>adj.</em> B2</td>
<td style="text-align: left;">interval <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">inappropriate <em>adj.</em> C1</td>
<td style="text-align: left;">input <em>n.</em> B2</td>
<td style="text-align: left;">intervene <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">incentive <em>n.</em> B2</td>
<td style="text-align: left;">insert <em>v.</em> B2</td>
<td style="text-align: left;">intervention <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">incidence <em>n.</em> C1</td>
<td style="text-align: left;">insertion <em>n.</em> C1</td>
<td style="text-align: left;">intimate <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">inclined <em>adj.</em> C1</td>
<td style="text-align: left;">insider <em>n.</em> C1</td>
<td style="text-align: left;">intriguing <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">inclusion <em>n.</em> C1</td>
<td style="text-align: left;">inspect <em>v.</em> C1</td>
<td style="text-align: left;">invade <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">incorporate <em>v.</em> B2</td>
<td style="text-align: left;">inspection <em>n.</em> C1</td>
<td style="text-align: left;">invasion <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">incorrect <em>adj.</em> B2</td>
<td style="text-align: left;">inspector <em>n.</em> B2</td>
<td style="text-align: left;">investigator <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">incur <em>v.</em> C1</td>
<td style="text-align: left;">inspiration <em>n.</em> C1</td>
<td style="text-align: left;">investor <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">independence <em>n.</em> B2</td>
<td style="text-align: left;">installation <em>n.</em> B2</td>
<td style="text-align: left;">invisible <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">index <em>n.</em> B2</td>
<td style="text-align: left;">instant <em>adj.</em> B2</td>
<td style="text-align: left;">invoke <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">indication <em>n.</em> B2</td>
<td style="text-align: left;">instantly <em>adv.</em> B2</td>
<td style="text-align: left;">involvement <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">indicator <em>n.</em> C1</td>
<td style="text-align: left;">instinct <em>n.</em> C1</td>
<td style="text-align: left;">ironic <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">indictment <em>n.</em> C1</td>
<td style="text-align: left;">institutional <em>adj.</em> C1</td>
<td style="text-align: left;">ironically <em>adv.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">indigenous <em>adj.</em> C1</td>
<td style="text-align: left;">instruct <em>v.</em> C1</td>
<td style="text-align: left;">irony <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">induce <em>v.</em> C1</td>
<td style="text-align: left;">instrumental <em>adj.</em> C1</td>
<td style="text-align: left;">irrelevant <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">indulge <em>v.</em> C1</td>
<td style="text-align: left;">insufficient <em>adj.</em> C1</td>
<td style="text-align: left;">isolate <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">inequality <em>n.</em> C1</td>
<td style="text-align: left;">insult <em>n.</em>, <em>v.</em> C1</td>
<td style="text-align: left;">isolated <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">inevitable <em>adj.</em> B2</td>
<td style="text-align: left;">intact <em>adj.</em> C1</td>
<td style="text-align: left;">isolation <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">inevitably <em>adv.</em> B2</td>
<td style="text-align: left;">intake <em>n.</em> C1</td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<h2 id="j">J</h2>
<table>
<tbody>
<tr>
<td style="text-align: left;">jail <em>n.</em>, <em>v.</em> B2</td>
<td style="text-align: left;">judicial <em>adj.</em> C1</td>
<td style="text-align: left;">just <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">jet <em>n.</em> B2</td>
<td style="text-align: left;">junction <em>n.</em> C1</td>
<td style="text-align: left;">justification <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">joint <em>adj.</em>, <em>n.</em> B2</td>
<td style="text-align: left;">jurisdiction <em>n.</em> C1</td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">journalism <em>n.</em> B2</td>
<td style="text-align: left;">jury <em>n.</em> B2</td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<h2 id="k">K</h2>
<table>
<tbody>
<tr>
<td style="text-align: left;">kidnap <em>v.</em> C1</td>
<td style="text-align: left;">kingdom <em>n.</em> C1</td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">kidney <em>n.</em> C1</td>
<td style="text-align: left;">kit <em>n.</em> B2</td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<h2 id="l">L</h2>
<table>
<colgroup>
<col style="width: 32%">
<col style="width: 33%">
<col style="width: 33%">
</colgroup>
<tbody>
<tr>
<td style="text-align: left;">lad <em>n.</em> C1</td>
<td style="text-align: left;">legislative <em>adj.</em> C1</td>
<td style="text-align: left;">line-up <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">ladder <em>n.</em> B2</td>
<td style="text-align: left;">legislature <em>n.</em> C1</td>
<td style="text-align: left;">linger <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">landing <em>n.</em> B2</td>
<td style="text-align: left;">legitimate <em>adj.</em> C1</td>
<td style="text-align: left;">listing <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">landlord <em>n.</em> C1</td>
<td style="text-align: left;">lengthy <em>adj.</em> C1</td>
<td style="text-align: left;">literacy <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">landmark <em>n.</em> C1</td>
<td style="text-align: left;">lens <em>n.</em> B2</td>
<td style="text-align: left;">literally <em>adv.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">lane <em>n.</em> B2</td>
<td style="text-align: left;">lesbian <em>adj.</em> C1</td>
<td style="text-align: left;">literary <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">lap <em>n.</em> C1</td>
<td style="text-align: left;">lesser <em>adj.</em> C1</td>
<td style="text-align: left;">litre <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">large-scale <em>adj.</em> C1</td>
<td style="text-align: left;">lethal <em>adj.</em> C1</td>
<td style="text-align: left;">litter <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">laser <em>n.</em> C1</td>
<td style="text-align: left;">liable <em>adj.</em> C1</td>
<td style="text-align: left;">liver <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">lately <em>adv.</em> B2</td>
<td style="text-align: left;">liberal <em>adj.</em>, <em>n.</em> C1</td>
<td style="text-align: left;">lobby <em>n.</em>, <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">latter <em>adj.</em>, <em>n.</em> C1</td>
<td style="text-align: left;">liberation <em>n.</em> C1</td>
<td style="text-align: left;">log <em>n.</em>, <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">lawn <em>n.</em> C1</td>
<td style="text-align: left;">liberty <em>n.</em> C1</td>
<td style="text-align: left;">logic <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">lawsuit <em>n.</em> C1</td>
<td style="text-align: left;">license <em>v.</em> C1</td>
<td style="text-align: left;">logo <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">layout <em>n.</em> C1</td>
<td style="text-align: left;">lifelong <em>adj.</em> C1</td>
<td style="text-align: left;">long-standing <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">leaflet <em>n.</em> B2</td>
<td style="text-align: left;">lifetime <em>n.</em> B2</td>
<td style="text-align: left;">long-time <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">leak <em>v.</em>, <em>n.</em> C1</td>
<td style="text-align: left;">lighting <em>n.</em> B2</td>
<td style="text-align: left;">loom <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">leap <em>v.</em>, <em>n.</em> C1</td>
<td style="text-align: left;">likelihood <em>n.</em> C1</td>
<td style="text-align: left;">loop <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">legacy <em>n.</em> C1</td>
<td style="text-align: left;">likewise <em>adv.</em> B2</td>
<td style="text-align: left;">lottery <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">legend <em>n.</em> B2</td>
<td style="text-align: left;">limb <em>n.</em> C1</td>
<td style="text-align: left;">loyal <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">legendary <em>adj.</em> C1</td>
<td style="text-align: left;">limitation <em>n.</em> B2</td>
<td style="text-align: left;">loyalty <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">legislation <em>n.</em> C1</td>
<td style="text-align: left;">linear <em>adj.</em> C1</td>
<td style="text-align: left;">lyric <em>n.</em> B2</td>
</tr>
</tbody>
</table>
<h2 id="m">M</h2>
<table>
<colgroup>
<col style="width: 37%">
<col style="width: 34%">
<col style="width: 28%">
</colgroup>
<tbody>
<tr>
<td style="text-align: left;">machinery <em>n.</em> C1</td>
<td style="text-align: left;">meaningful <em>adj.</em> C1</td>
<td style="text-align: left;">ministry <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">magical <em>adj.</em> C1</td>
<td style="text-align: left;">meantime <em>n.</em> C1</td>
<td style="text-align: left;">minute2 <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">magistrate <em>n.</em> C1</td>
<td style="text-align: left;">mechanic <em>n.</em> B2</td>
<td style="text-align: left;">miracle <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">magnetic <em>adj.</em> C1</td>
<td style="text-align: left;">mechanical <em>adj.</em> B2</td>
<td style="text-align: left;">miserable <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">magnificent <em>adj.</em> B2</td>
<td style="text-align: left;">mechanism <em>n.</em> B2</td>
<td style="text-align: left;">misery <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">magnitude <em>n.</em> C1</td>
<td style="text-align: left;">medal <em>n.</em> B2</td>
<td style="text-align: left;">misleading <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">mainland <em>n.</em> C1</td>
<td style="text-align: left;">medication <em>n.</em> B2</td>
<td style="text-align: left;">missile <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">mainstream <em>n.</em>, <em>adj.</em>
C1</td>
<td style="text-align: left;">medieval <em>adj.</em> C1</td>
<td style="text-align: left;">mob <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">maintenance <em>n.</em> C1</td>
<td style="text-align: left;">meditation <em>n.</em> C1</td>
<td style="text-align: left;">mobility <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">make-up <em>n.</em> B2</td>
<td style="text-align: left;">melody <em>n.</em> C1</td>
<td style="text-align: left;">mobilize <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">making <em>n.</em> B2</td>
<td style="text-align: left;">membership <em>n.</em> B2</td>
<td style="text-align: left;">mode <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">mandate <em>n.</em> C1</td>
<td style="text-align: left;">memo <em>n.</em> C1</td>
<td style="text-align: left;">moderate <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">mandatory <em>adj.</em> C1</td>
<td style="text-align: left;">memoir <em>n.</em> C1</td>
<td style="text-align: left;">modest <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">manifest <em>v.</em> C1</td>
<td style="text-align: left;">memorable <em>adj.</em> B2</td>
<td style="text-align: left;">modification <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">manipulate <em>v.</em> C1</td>
<td style="text-align: left;">memorial <em>n.</em> C1</td>
<td style="text-align: left;">momentum <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">manipulation <em>n.</em> C1</td>
<td style="text-align: left;">mentor <em>n.</em> C1</td>
<td style="text-align: left;">monk <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">manufacture <em>v.</em> B2</td>
<td style="text-align: left;">merchant <em>n.</em> C1</td>
<td style="text-align: left;">monopoly <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">manufacturing <em>n.</em> B2</td>
<td style="text-align: left;">mercy <em>n.</em> C1</td>
<td style="text-align: left;">monster <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">manuscript <em>n.</em> C1</td>
<td style="text-align: left;">mere <em>adj.</em> C1</td>
<td style="text-align: left;">monthly <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">marathon <em>n.</em> B2</td>
<td style="text-align: left;">merely <em>adv.</em> C1</td>
<td style="text-align: left;">monument <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">march <em>n.</em>, <em>v.</em> C1</td>
<td style="text-align: left;">merge <em>v.</em> C1</td>
<td style="text-align: left;">morality <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">margin <em>n.</em> B2</td>
<td style="text-align: left;">merger <em>n.</em> C1</td>
<td style="text-align: left;">moreover <em>adv.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">marginal <em>adj.</em> C1</td>
<td style="text-align: left;">merit <em>n.</em> C1</td>
<td style="text-align: left;">mortgage <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">marine <em>adj.</em> C1</td>
<td style="text-align: left;">metaphor <em>n.</em> B2</td>
<td style="text-align: left;">mosque <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">marker <em>n.</em> B2</td>
<td style="text-align: left;">methodology <em>n.</em> C1</td>
<td style="text-align: left;">motion <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">marketplace <em>n.</em> C1</td>
<td style="text-align: left;">midst <em>n.</em> C1</td>
<td style="text-align: left;">motivate <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">martial <em>adj.</em> B2</td>
<td style="text-align: left;">migration <em>n.</em> C1</td>
<td style="text-align: left;">motivation <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">mask <em>n.</em> C1</td>
<td style="text-align: left;">militant <em>n.</em>, <em>adj.</em>
C1</td>
<td style="text-align: left;">motive <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">massacre <em>n.</em> C1</td>
<td style="text-align: left;">militia <em>n.</em> C1</td>
<td style="text-align: left;">motorist <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">mate <em>n.</em>, <em>v.</em> B2</td>
<td style="text-align: left;">mill <em>n.</em> C1</td>
<td style="text-align: left;">moving <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">mathematical <em>adj.</em> C1</td>
<td style="text-align: left;">miner <em>n.</em> B2</td>
<td style="text-align: left;">municipal <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">mature <em>adj.</em>, <em>v.</em> C1</td>
<td style="text-align: left;">minimal <em>adj.</em> C1</td>
<td style="text-align: left;">mutual <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">maximize <em>v.</em> C1</td>
<td style="text-align: left;">minimize <em>v.</em> C1</td>
<td style="text-align: left;">myth <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">mayor <em>n.</em> B2</td>
<td style="text-align: left;">mining <em>n.</em> C1</td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<h2 id="n">N</h2>
<table>
<colgroup>
<col style="width: 37%">
<col style="width: 32%">
<col style="width: 29%">
</colgroup>
<tbody>
<tr>
<td style="text-align: left;">naked <em>adj.</em> B2</td>
<td style="text-align: left;">net <em>adj.</em> C1</td>
<td style="text-align: left;">noon <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">namely <em>adv.</em> C1</td>
<td style="text-align: left;">neutral <em>adj.</em> B2</td>
<td style="text-align: left;">norm <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">nasty <em>adj.</em> B2</td>
<td style="text-align: left;">newly <em>adv.</em> B2</td>
<td style="text-align: left;">notable <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">nationwide <em>adj.</em> C1</td>
<td style="text-align: left;">newsletter <em>n.</em> C1</td>
<td style="text-align: left;">notably <em>adv.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">naval <em>adj.</em> C1</td>
<td style="text-align: left;">niche <em>n.</em> C1</td>
<td style="text-align: left;">notebook <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">navigation <em>n.</em> B2</td>
<td style="text-align: left;">noble <em>adj.</em> C1</td>
<td style="text-align: left;">notify <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">nearby <em>adj.</em>, <em>adv.</em>
B2</td>
<td style="text-align: left;">nod <em>v.</em> C1</td>
<td style="text-align: left;">notorious <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">necessity <em>n.</em> B2</td>
<td style="text-align: left;">nominate <em>v.</em> C1</td>
<td style="text-align: left;">novel <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">neglect <em>v.</em>, <em>n.</em> C1</td>
<td style="text-align: left;">nomination <em>n.</em> C1</td>
<td style="text-align: left;">novelist <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">negotiate <em>v.</em> B2</td>
<td style="text-align: left;">nominee <em>n.</em> C1</td>
<td style="text-align: left;">nowadays <em>adv.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">negotiation <em>n.</em> B2</td>
<td style="text-align: left;">nonetheless <em>adv.</em> C1</td>
<td style="text-align: left;">nursery <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">neighbouring <em>adj.</em> C1</td>
<td style="text-align: left;">non-profit <em>adj.</em> C1</td>
<td style="text-align: left;">nursing <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">nest <em>n.</em> C1</td>
<td style="text-align: left;">nonsense <em>n.</em> C1</td>
<td style="text-align: left;">nutrition <em>n.</em> B2</td>
</tr>
</tbody>
</table>
<h2 id="o">O</h2>
<table>
<colgroup>
<col style="width: 28%">
<col style="width: 34%">
<col style="width: 37%">
</colgroup>
<tbody>
<tr>
<td style="text-align: left;">obesity <em>n.</em> B2</td>
<td style="text-align: left;">opera <em>n.</em> B2</td>
<td style="text-align: left;">outlook <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">objection <em>n.</em> C1</td>
<td style="text-align: left;">operational <em>adj.</em> C1</td>
<td style="text-align: left;">output <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">oblige <em>v.</em> C1</td>
<td style="text-align: left;">operator <em>n.</em> B2</td>
<td style="text-align: left;">outrage <em>n.</em>, <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">observer <em>n.</em> B2</td>
<td style="text-align: left;">opt <em>v.</em> C1</td>
<td style="text-align: left;">outsider <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">obsess <em>v.</em> C1</td>
<td style="text-align: left;">optical <em>adj.</em> C1</td>
<td style="text-align: left;">outstanding <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">obsession <em>n.</em> C1</td>
<td style="text-align: left;">optimism <em>n.</em> C1</td>
<td style="text-align: left;">overcome <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">obstacle <em>n.</em> B2</td>
<td style="text-align: left;">optimistic <em>adj.</em> B2</td>
<td style="text-align: left;">overlook <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">occasional <em>adj.</em> C1</td>
<td style="text-align: left;">oral <em>adj.</em> C1</td>
<td style="text-align: left;">overly <em>adv.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">occupation <em>n.</em> B2</td>
<td style="text-align: left;">orchestra <em>n.</em> B2</td>
<td style="text-align: left;">overnight <em>adv.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">occupy <em>v.</em> B2</td>
<td style="text-align: left;">organic <em>adj.</em> B2</td>
<td style="text-align: left;">overseas <em>adv.</em>, <em>adj.</em>
B2</td>
</tr>
<tr>
<td style="text-align: left;">occurrence <em>n.</em> C1</td>
<td style="text-align: left;">organizational <em>adj.</em> C1</td>
<td style="text-align: left;">oversee <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">odds <em>n.</em> C1</td>
<td style="text-align: left;">orientation <em>n.</em> C1</td>
<td style="text-align: left;">overturn <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">offender <em>n.</em> B2</td>
<td style="text-align: left;">originate <em>v.</em> C1</td>
<td style="text-align: left;">overwhelm <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">offering <em>n.</em> C1</td>
<td style="text-align: left;">outbreak <em>n.</em> C1</td>
<td style="text-align: left;">overwhelming <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">offspring <em>n.</em> C1</td>
<td style="text-align: left;">outfit <em>n.</em> B2</td>
<td style="text-align: left;">ownership <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">ongoing <em>adj.</em> B2</td>
<td style="text-align: left;">outing <em>n.</em> C1</td>
<td style="text-align: left;">oxygen <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">openly <em>adv.</em> B2</td>
<td style="text-align: left;">outlet <em>n.</em> C1</td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<h2 id="p">P</h2>
<table>
<colgroup>
<col style="width: 33%">
<col style="width: 36%">
<col style="width: 29%">
</colgroup>
<tbody>
<tr>
<td style="text-align: left;">packet <em>n.</em> B2</td>
<td style="text-align: left;">pledge <em>v.</em>, <em>n.</em> C1</td>
<td style="text-align: left;">privilege <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">pad <em>n.</em> C1</td>
<td style="text-align: left;">plug <em>v.</em>, <em>n.</em> C1</td>
<td style="text-align: left;">probability <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">palm <em>n.</em> B2</td>
<td style="text-align: left;">plunge <em>v.</em> C1</td>
<td style="text-align: left;">probable <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">panic <em>n.</em> B2</td>
<td style="text-align: left;">pole <em>n.</em> C1</td>
<td style="text-align: left;">probe <em>n.</em>, <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">parade <em>n.</em> B2</td>
<td style="text-align: left;">poll <em>n.</em> C1</td>
<td style="text-align: left;">problematic <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">parallel <em>adj.</em>, <em>n.</em>
B2</td>
<td style="text-align: left;">pond <em>n.</em> C1</td>
<td style="text-align: left;">proceed <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">parameter <em>n.</em> C1</td>
<td style="text-align: left;">pop <em>v.</em> C1</td>
<td style="text-align: left;">proceedings <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">parental <em>adj.</em> C1</td>
<td style="text-align: left;">portfolio <em>n.</em> C1</td>
<td style="text-align: left;">proceeds <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">parish <em>n.</em> C1</td>
<td style="text-align: left;">portion <em>n.</em> B2</td>
<td style="text-align: left;">processing <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">parliamentary <em>adj.</em> C1</td>
<td style="text-align: left;">portray <em>v.</em> C1</td>
<td style="text-align: left;">processor <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">partial <em>adj.</em> C1</td>
<td style="text-align: left;">postpone <em>v.</em> C1</td>
<td style="text-align: left;">proclaim <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">partially <em>adv.</em> C1</td>
<td style="text-align: left;">post-war <em>adj.</em> C1</td>
<td style="text-align: left;">productive <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">participation <em>n.</em> B2</td>
<td style="text-align: left;">potentially <em>adv.</em> B2</td>
<td style="text-align: left;">productivity <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">partnership <em>n.</em> B2</td>
<td style="text-align: left;">practitioner <em>n.</em> C1</td>
<td style="text-align: left;">profitable <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">part-time <em>adj.</em>/<em>adv.</em>
B2</td>
<td style="text-align: left;">preach <em>v.</em> C1</td>
<td style="text-align: left;">profound <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">passing <em>n.</em> C1</td>
<td style="text-align: left;">precede <em>v.</em> B2</td>
<td style="text-align: left;">programming <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">passionate <em>adj.</em> B2</td>
<td style="text-align: left;">precedent <em>n.</em> C1</td>
<td style="text-align: left;">progressive <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">passive <em>adj.</em> C1</td>
<td style="text-align: left;">precious <em>adj.</em> B2</td>
<td style="text-align: left;">prohibit <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">password <em>n.</em> B2</td>
<td style="text-align: left;">precise <em>adj.</em> B2</td>
<td style="text-align: left;">projection <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">pastor <em>n.</em> C1</td>
<td style="text-align: left;">precisely <em>adv.</em> B2</td>
<td style="text-align: left;">prominent <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">patch <em>n.</em> C1</td>
<td style="text-align: left;">precision <em>n.</em> C1</td>
<td style="text-align: left;">promising <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">patent <em>n.</em> C1</td>
<td style="text-align: left;">predator <em>n.</em> C1</td>
<td style="text-align: left;">promotion <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">pathway <em>n.</em> C1</td>
<td style="text-align: left;">predecessor <em>n.</em> C1</td>
<td style="text-align: left;">prompt <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">patience <em>n.</em> B2</td>
<td style="text-align: left;">predictable <em>adj.</em> B2</td>
<td style="text-align: left;">pronounced <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">patrol <em>n.</em>, <em>v.</em> C1</td>
<td style="text-align: left;">predominantly <em>adv.</em> C1</td>
<td style="text-align: left;">propaganda <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">patron <em>n.</em> C1</td>
<td style="text-align: left;">preference <em>n.</em> B2</td>
<td style="text-align: left;">proportion <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">pause <em>v.</em>, <em>n.</em> B2</td>
<td style="text-align: left;">pregnancy <em>n.</em> C1</td>
<td style="text-align: left;">proposition <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">peak <em>n.</em> C1</td>
<td style="text-align: left;">prejudice <em>n.</em> C1</td>
<td style="text-align: left;">prosecute <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">peasant <em>n.</em> C1</td>
<td style="text-align: left;">preliminary <em>adj.</em> C1</td>
<td style="text-align: left;">prosecution <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">peculiar <em>adj.</em> C1</td>
<td style="text-align: left;">premier <em>n.</em> C1</td>
<td style="text-align: left;">prosecutor <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">peer <em>n.</em> B2</td>
<td style="text-align: left;">premise <em>n.</em> C1</td>
<td style="text-align: left;">prospective <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">penalty <em>n.</em> B2</td>
<td style="text-align: left;">premium <em>n.</em> C1</td>
<td style="text-align: left;">prosperity <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">perceive <em>v.</em> B2</td>
<td style="text-align: left;">prescribe <em>v.</em> C1</td>
<td style="text-align: left;">protective <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">perception <em>n.</em> B2</td>
<td style="text-align: left;">prescription <em>n.</em> C1</td>
<td style="text-align: left;">protein <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">permanently <em>adv.</em> B2</td>
<td style="text-align: left;">presently <em>adv.</em> C1</td>
<td style="text-align: left;">protester <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">persist <em>v.</em> C1</td>
<td style="text-align: left;">preservation <em>n.</em> C1</td>
<td style="text-align: left;">protocol <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">persistent <em>adj.</em> C1</td>
<td style="text-align: left;">preside <em>v.</em> C1</td>
<td style="text-align: left;">province <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">personnel <em>n.</em> C1</td>
<td style="text-align: left;">presidency <em>n.</em> C1</td>
<td style="text-align: left;">provincial <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">petition <em>n.</em> C1</td>
<td style="text-align: left;">presidential <em>adj.</em> C1</td>
<td style="text-align: left;">provision <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">philosopher <em>n.</em> C1</td>
<td style="text-align: left;">prestigious <em>adj.</em> C1</td>
<td style="text-align: left;">provoke <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">philosophical <em>adj.</em> C1</td>
<td style="text-align: left;">presumably <em>adv.</em> C1</td>
<td style="text-align: left;">psychiatric <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">physician <em>n.</em> C1</td>
<td style="text-align: left;">presume <em>v.</em> C1</td>
<td style="text-align: left;">psychological <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">pill <em>n.</em> B2</td>
<td style="text-align: left;">prevail <em>v.</em> C1</td>
<td style="text-align: left;">publicity <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">pioneer <em>n.</em>, <em>v.</em> C1</td>
<td style="text-align: left;">prevalence <em>n.</em> C1</td>
<td style="text-align: left;">publishing <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">pipeline <em>n.</em> C1</td>
<td style="text-align: left;">prevention <em>n.</em> C1</td>
<td style="text-align: left;">pulse <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">pirate <em>n.</em> C1</td>
<td style="text-align: left;">prey <em>n.</em> C1</td>
<td style="text-align: left;">pump <em>v.</em>, <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">pit <em>n.</em> C1</td>
<td style="text-align: left;">pride <em>n.</em> B2</td>
<td style="text-align: left;">punch <em>n.</em>, <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">pity <em>n.</em> B2</td>
<td style="text-align: left;">primarily <em>adv.</em> B2</td>
<td style="text-align: left;">punk <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">placement <em>n.</em> B2</td>
<td style="text-align: left;">principal <em>adj.</em> B2, <em>n.</em>
C1</td>
<td style="text-align: left;">purely <em>adv.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">plea <em>n.</em> C1</td>
<td style="text-align: left;">prior <em>adj.</em> B2</td>
<td style="text-align: left;">pursuit <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">plead <em>v.</em> C1</td>
<td style="text-align: left;">privatization <em>n.</em> C1</td>
<td style="text-align: left;">puzzle <em>n.</em> B2</td>
</tr>
</tbody>
</table>
<h2 id="q">Q</h2>
<table>
<tbody>
<tr>
<td style="text-align: left;">query <em>n.</em> C1</td>
<td style="text-align: left;">questionnaire <em>n.</em> B2</td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">quest <em>n.</em> C1</td>
<td style="text-align: left;">quota <em>n.</em> C1</td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<h2 id="r">R</h2>
<table>
<colgroup>
<col style="width: 30%">
<col style="width: 30%">
<col style="width: 39%">
</colgroup>
<tbody>
<tr>
<td style="text-align: left;">racial <em>adj.</em> B2</td>
<td style="text-align: left;">refusal <em>n.</em> C1</td>
<td style="text-align: left;">respective <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">racism <em>n.</em> B2</td>
<td style="text-align: left;">regain <em>v.</em> C1</td>
<td style="text-align: left;">respectively <em>adv.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">racist <em>adj.</em>, <em>n.</em> B2</td>
<td style="text-align: left;">regardless <em>adv.</em> C1</td>
<td style="text-align: left;">restoration <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">radar <em>n.</em> C1</td>
<td style="text-align: left;">regime <em>n.</em> C1</td>
<td style="text-align: left;">restore <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">radiation <em>n.</em> B2</td>
<td style="text-align: left;">registration <em>n.</em> B2</td>
<td style="text-align: left;">restraint <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">radical <em>adj.</em> C1</td>
<td style="text-align: left;">regulate <em>v.</em> B2</td>
<td style="text-align: left;">restrict <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">rage <em>n.</em> C1</td>
<td style="text-align: left;">regulator <em>n.</em> C1</td>
<td style="text-align: left;">restriction <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">raid <em>n.</em>, <em>v.</em> C1</td>
<td style="text-align: left;">regulatory <em>adj.</em> C1</td>
<td style="text-align: left;">resume <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">rail <em>n.</em> B2</td>
<td style="text-align: left;">rehabilitation <em>n.</em> C1</td>
<td style="text-align: left;">retail <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">rally <em>n.</em>, <em>v.</em> C1</td>
<td style="text-align: left;">reign <em>n.</em>, <em>v.</em> C1</td>
<td style="text-align: left;">retirement <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">random <em>adj.</em> B2</td>
<td style="text-align: left;">reinforce <em>v.</em> B2</td>
<td style="text-align: left;">retreat <em>n.</em>, <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">ranking <em>n.</em> C1</td>
<td style="text-align: left;">rejection <em>n.</em> C1</td>
<td style="text-align: left;">retrieve <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">rape <em>n.</em>, <em>v.</em> C1</td>
<td style="text-align: left;">relevance <em>n.</em> C1</td>
<td style="text-align: left;">revelation <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">rat <em>n.</em> B2</td>
<td style="text-align: left;">reliability <em>n.</em> C1</td>
<td style="text-align: left;">revenge <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">rating <em>n.</em> B2</td>
<td style="text-align: left;">relieve <em>v.</em> B2</td>
<td style="text-align: left;">revenue <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">ratio <em>n.</em> C1</td>
<td style="text-align: left;">relieved <em>adj.</em> B2</td>
<td style="text-align: left;">reverse <em>v.</em>, <em>n.</em>,
<em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">rational <em>adj.</em> C1</td>
<td style="text-align: left;">reluctant <em>adj.</em> C1</td>
<td style="text-align: left;">revision <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">ray <em>n.</em> C1</td>
<td style="text-align: left;">remainder <em>n.</em> C1</td>
<td style="text-align: left;">revival <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">readily <em>adv.</em> C1</td>
<td style="text-align: left;">remains <em>n.</em> C1</td>
<td style="text-align: left;">revive <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">realization <em>n.</em> C1</td>
<td style="text-align: left;">remarkable <em>adj.</em> B2</td>
<td style="text-align: left;">revolutionary <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">realm <em>n.</em> C1</td>
<td style="text-align: left;">remarkably <em>adv.</em> B2</td>
<td style="text-align: left;">rhetoric <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">rear <em>adj.</em>, <em>n.</em> C1</td>
<td style="text-align: left;">remedy <em>n.</em> C1</td>
<td style="text-align: left;">ridiculous <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">reasonably <em>adv.</em> B2</td>
<td style="text-align: left;">reminder <em>n.</em> C1</td>
<td style="text-align: left;">rifle <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">reasoning <em>n.</em> C1</td>
<td style="text-align: left;">removal <em>n.</em> C1</td>
<td style="text-align: left;">riot <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">reassure <em>v.</em> C1</td>
<td style="text-align: left;">render <em>v.</em> C1</td>
<td style="text-align: left;">rip <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">rebel <em>n.</em> C1</td>
<td style="text-align: left;">renew <em>v.</em> C1</td>
<td style="text-align: left;">risky <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">rebellion <em>n.</em> C1</td>
<td style="text-align: left;">renowned <em>adj.</em> C1</td>
<td style="text-align: left;">ritual <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">rebuild <em>v.</em> B2</td>
<td style="text-align: left;">rental <em>n.</em> C1</td>
<td style="text-align: left;">rival <em>n.</em>, <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">receiver <em>n.</em> B2</td>
<td style="text-align: left;">replacement <em>n.</em> C1</td>
<td style="text-align: left;">rob <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">recession <em>n.</em> B2</td>
<td style="text-align: left;">reportedly <em>adv.</em> C1</td>
<td style="text-align: left;">robbery <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">recipient <em>n.</em> C1</td>
<td style="text-align: left;">reporting <em>n.</em> B2</td>
<td style="text-align: left;">robust <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">reckon <em>v.</em> B2</td>
<td style="text-align: left;">representation <em>n.</em> C1</td>
<td style="text-align: left;">rock <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">recognition <em>n.</em> B2</td>
<td style="text-align: left;">reproduce <em>v.</em> C1</td>
<td style="text-align: left;">rocket <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">reconstruction <em>n.</em> C1</td>
<td style="text-align: left;">reproduction <em>n.</em> C1</td>
<td style="text-align: left;">rod <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">recount1 <em>v.</em> C1</td>
<td style="text-align: left;">republic <em>n.</em> C1</td>
<td style="text-align: left;">romance <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">recovery <em>n.</em> B2</td>
<td style="text-align: left;">resemble <em>v.</em> C1</td>
<td style="text-align: left;">rose <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">recruit <em>v.</em>, <em>n.</em> B2</td>
<td style="text-align: left;">reside <em>v.</em> C1</td>
<td style="text-align: left;">rotate <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">recruitment <em>n.</em> B2</td>
<td style="text-align: left;">residence <em>n.</em> C1</td>
<td style="text-align: left;">rotation <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">referee <em>n.</em> B2</td>
<td style="text-align: left;">residential <em>adj.</em> C1</td>
<td style="text-align: left;">roughly <em>adv.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">referendum <em>n.</em> C1</td>
<td style="text-align: left;">residue <em>n.</em> C1</td>
<td style="text-align: left;">ruin <em>v.</em>, <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">reflection <em>n.</em> C1</td>
<td style="text-align: left;">resign <em>v.</em> B2</td>
<td style="text-align: left;">ruling <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">reform <em>n.</em>, <em>v.</em> C1</td>
<td style="text-align: left;">resignation <em>n.</em> C1</td>
<td style="text-align: left;">rumour <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">refuge <em>n.</em> C1</td>
<td style="text-align: left;">resistance <em>n.</em> C1</td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">refugee <em>n.</em> B2</td>
<td style="text-align: left;">resolution <em>n.</em> B2</td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<h2 id="s">S</h2>
<table>
<colgroup>
<col style="width: 27%">
<col style="width: 28%">
<col style="width: 43%">
</colgroup>
<tbody>
<tr>
<td style="text-align: left;">sack <em>v.</em> C1</td>
<td style="text-align: left;">slogan <em>n.</em> B2</td>
<td style="text-align: left;">strand <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">sacred <em>adj.</em> C1</td>
<td style="text-align: left;">slot <em>n.</em> C1</td>
<td style="text-align: left;">strategic <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">sacrifice <em>n.</em>, <em>v.</em> C1</td>
<td style="text-align: left;">smash <em>v.</em> C1</td>
<td style="text-align: left;">strengthen <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">saint <em>n.</em> C1</td>
<td style="text-align: left;">snap <em>v.</em> C1</td>
<td style="text-align: left;">strictly <em>adv.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">sake <em>n.</em> C1</td>
<td style="text-align: left;">soak <em>v.</em> C1</td>
<td style="text-align: left;">striking <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">sanction <em>n.</em> C1</td>
<td style="text-align: left;">soar <em>v.</em> C1</td>
<td style="text-align: left;">strip (long narrow piece) <em>n.</em>
C1</td>
</tr>
<tr>
<td style="text-align: left;">satisfaction <em>n.</em> B2</td>
<td style="text-align: left;">so-called <em>adj.</em> B2</td>
<td style="text-align: left;">strip (remove clothes/a layer) <em>v.</em>
C1</td>
</tr>
<tr>
<td style="text-align: left;">say <em>n.</em> C1</td>
<td style="text-align: left;">socialist <em>adj.</em> C1</td>
<td style="text-align: left;">strive <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">scandal <em>n.</em> B2</td>
<td style="text-align: left;">sole <em>adj.</em> C1</td>
<td style="text-align: left;">stroke <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">scare <em>v.</em>, <em>n.</em> B2</td>
<td style="text-align: left;">solely <em>adv.</em> C1</td>
<td style="text-align: left;">structural <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">scattered <em>adj.</em> C1</td>
<td style="text-align: left;">solicitor <em>n.</em> C1</td>
<td style="text-align: left;">stumble <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">scenario <em>n.</em> B2</td>
<td style="text-align: left;">solidarity <em>n.</em> C1</td>
<td style="text-align: left;">stun <em>v.</em>C1</td>
</tr>
<tr>
<td style="text-align: left;">sceptical <em>adj.</em> C1</td>
<td style="text-align: left;">solo <em>adj.</em>, <em>n.</em> C1</td>
<td style="text-align: left;">stunning <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">scholar <em>n.</em> B2</td>
<td style="text-align: left;">somehow <em>adv.</em> B2</td>
<td style="text-align: left;">submission <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">scholarship <em>n.</em> B2</td>
<td style="text-align: left;">sometime <em>adv.</em> B2</td>
<td style="text-align: left;">subscriber <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">scope <em>n.</em> C1</td>
<td style="text-align: left;">sophisticated <em>adj.</em> B2</td>
<td style="text-align: left;">subscription <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">scratch <em>v.</em>, <em>n.</em> B2</td>
<td style="text-align: left;">sound <em>adj.</em> C1</td>
<td style="text-align: left;">subsequent <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">screening <em>n.</em> B2</td>
<td style="text-align: left;">sovereignty <em>n.</em> C1</td>
<td style="text-align: left;">subsequently <em>adv.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">screw <em>v.</em>, <em>n.</em> C1</td>
<td style="text-align: left;">spam <em>n.</em> C1</td>
<td style="text-align: left;">subsidy <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">scrutiny <em>n.</em> C1</td>
<td style="text-align: left;">span <em>v.</em>, <em>n.</em> C1</td>
<td style="text-align: left;">substantial <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">seal <em>v.</em>, <em>n.</em> C1</td>
<td style="text-align: left;">spare <em>adj.</em> B2, <em>v.</em>
C1</td>
<td style="text-align: left;">substantially <em>adv.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">secular <em>adj.</em> C1</td>
<td style="text-align: left;">spark <em>v.</em> C1</td>
<td style="text-align: left;">substitute <em>n.</em>, <em>v.</em>
C1</td>
</tr>
<tr>
<td style="text-align: left;">seeker <em>n.</em> B2</td>
<td style="text-align: left;">specialize <em>v.</em> B1</td>
<td style="text-align: left;">substitution <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">seemingly <em>adv.</em> C1</td>
<td style="text-align: left;">specialized <em>adj.</em> C1</td>
<td style="text-align: left;">subtle <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">segment <em>n.</em> C1</td>
<td style="text-align: left;">specification <em>n.</em> C1</td>
<td style="text-align: left;">suburb <em>n.</em>B2</td>
</tr>
<tr>
<td style="text-align: left;">seize <em>v.</em> C1</td>
<td style="text-align: left;">specify <em>v.</em> B2</td>
<td style="text-align: left;">suburban <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">seldom <em>adv.</em> C1</td>
<td style="text-align: left;">specimen <em>n.</em> C1</td>
<td style="text-align: left;">succession <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">selective <em>adj.</em> C1</td>
<td style="text-align: left;">spectacle <em>n.</em> C1</td>
<td style="text-align: left;">successive <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">seminar <em>n.</em> B2</td>
<td style="text-align: left;">spectacular <em>adj.</em> B2</td>
<td style="text-align: left;">successor <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">senator <em>n.</em> C1</td>
<td style="text-align: left;">spectator <em>n.</em> B2</td>
<td style="text-align: left;">suck <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">sensation <em>n.</em> C1</td>
<td style="text-align: left;">spectrum <em>n.</em> C1</td>
<td style="text-align: left;">sue <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">sensitivity <em>n.</em> C1</td>
<td style="text-align: left;">speculate <em>v.</em> B2</td>
<td style="text-align: left;">suffering <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">sentiment <em>n.</em> C1</td>
<td style="text-align: left;">speculation <em>n.</em> B2</td>
<td style="text-align: left;">sufficient <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">separation <em>n.</em> C1</td>
<td style="text-align: left;">spell <em>n.</em> C1</td>
<td style="text-align: left;">sufficiently <em>adv.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">serial <em>adj.</em> C1</td>
<td style="text-align: left;">sphere <em>n.</em> C1</td>
<td style="text-align: left;">suicide <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">settlement <em>n.</em> C1</td>
<td style="text-align: left;">spice <em>n.</em> B2</td>
<td style="text-align: left;">suite <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">settler <em>n.</em> B2</td>
<td style="text-align: left;">spill <em>v.</em> B2</td>
<td style="text-align: left;">summit <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">set-up <em>n.</em> C1</td>
<td style="text-align: left;">spin <em>v.</em>, <em>n.</em> C1</td>
<td style="text-align: left;">super <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">severely <em>adv.</em> B2</td>
<td style="text-align: left;">spine <em>n.</em> C1</td>
<td style="text-align: left;">superb <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">sexuality <em>n.</em> C1</td>
<td style="text-align: left;">spite <em>n.</em> B2</td>
<td style="text-align: left;">superior <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">sexy <em>adj.</em> B2</td>
<td style="text-align: left;">spoil <em>v.</em> B2</td>
<td style="text-align: left;">supervise <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">shaped <em>adj.</em> B2</td>
<td style="text-align: left;">spokesman <em>n.</em> B2</td>
<td style="text-align: left;">supervision <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">shareholder <em>n.</em> C1</td>
<td style="text-align: left;">spokesperson <em>n.</em> B2</td>
<td style="text-align: left;">supervisor <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">shatter <em>v.</em> C1</td>
<td style="text-align: left;">spokeswoman <em>n.</em> B2</td>
<td style="text-align: left;">supplement <em>n.</em>, <em>v.</em>
C1</td>
</tr>
<tr>
<td style="text-align: left;">shed <em>v.</em> C1</td>
<td style="text-align: left;">sponsorship <em>n.</em> B2</td>
<td style="text-align: left;">supportive <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">sheer <em>adj.</em> C1</td>
<td style="text-align: left;">sporting <em>adj.</em> B2</td>
<td style="text-align: left;">supposedly <em>adv.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">shipping <em>n.</em> C1</td>
<td style="text-align: left;">spotlight <em>n.</em> C1</td>
<td style="text-align: left;">suppress <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">shocking <em>adj.</em> B2</td>
<td style="text-align: left;">spouse <em>n.</em> C1</td>
<td style="text-align: left;">supreme <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">shoot <em>n.</em> C1</td>
<td style="text-align: left;">spy <em>n.</em>, <em>v.</em> C1</td>
<td style="text-align: left;">surge <em>n.</em>, <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">shore <em>n.</em> B2</td>
<td style="text-align: left;">squad <em>n.</em> C1</td>
<td style="text-align: left;">surgeon <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">shortage <em>n.</em> B2</td>
<td style="text-align: left;">squeeze <em>v.</em> C1</td>
<td style="text-align: left;">surgical <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">shortly <em>adv.</em> B2</td>
<td style="text-align: left;">stab <em>v.</em> C1</td>
<td style="text-align: left;">surplus <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">short-term <em>adj.</em> B2</td>
<td style="text-align: left;">stability <em>n.</em> C1</td>
<td style="text-align: left;">surrender <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">shrink <em>v.</em> C1</td>
<td style="text-align: left;">stabilize <em>v.</em> C1</td>
<td style="text-align: left;">surveillance <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">shrug <em>v.</em> C1</td>
<td style="text-align: left;">stake <em>n.</em> C1</td>
<td style="text-align: left;">survival <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">sibling <em>n.</em> B2</td>
<td style="text-align: left;">stall <em>n.</em> B2</td>
<td style="text-align: left;">survivor <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">sigh <em>v.</em>, <em>n.</em> C1</td>
<td style="text-align: left;">stance <em>n.</em> B2</td>
<td style="text-align: left;">suspend <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">signature <em>n.</em> B2</td>
<td style="text-align: left;">standing <em>adj.</em> C1</td>
<td style="text-align: left;">suspension <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">significance <em>n.</em> B2</td>
<td style="text-align: left;">stark <em>adj.</em> C1</td>
<td style="text-align: left;">suspicion <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">simulate <em>v.</em> C1</td>
<td style="text-align: left;">starve <em>v.</em> B2</td>
<td style="text-align: left;">suspicious <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">simulation <em>n.</em> C1</td>
<td style="text-align: left;">statistical <em>adj.</em> C1</td>
<td style="text-align: left;">sustain <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">simultaneously <em>adv.</em> C1</td>
<td style="text-align: left;">steadily <em>adv.</em> B2</td>
<td style="text-align: left;">sustainable <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">sin <em>n.</em> C1</td>
<td style="text-align: left;">steam <em>n.</em> B2</td>
<td style="text-align: left;">swallow <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">situated <em>adj.</em> C1</td>
<td style="text-align: left;">steer <em>v.</em> C1</td>
<td style="text-align: left;">swing <em>v.</em>, <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">sketch <em>n.</em> C1</td>
<td style="text-align: left;">stem <em>n.</em>, <em>v.</em> C1</td>
<td style="text-align: left;">sword <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">skilled <em>adj.</em> B2</td>
<td style="text-align: left;">stereotype <em>n.</em> C1</td>
<td style="text-align: left;">symbolic <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">skip <em>v.</em> C1</td>
<td style="text-align: left;">stimulate <em>v.</em> B2</td>
<td style="text-align: left;">sympathetic <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">skull <em>n.</em> B2</td>
<td style="text-align: left;">stimulus <em>n.</em> C1</td>
<td style="text-align: left;">syndrome <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">slam <em>v.</em> C1</td>
<td style="text-align: left;">stir <em>v.</em> C1</td>
<td style="text-align: left;">synthesis <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">slap <em>v.</em> C1</td>
<td style="text-align: left;">storage <em>n.</em> C1</td>
<td style="text-align: left;">systematic <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">slash <em>v.</em> C1</td>
<td style="text-align: left;">straightforward <em>adj.</em> C1</td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">slavery <em>n.</em> C1</td>
<td style="text-align: left;">strain <em>n.</em> C1</td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<h2 id="t">T</h2>
<table>
<colgroup>
<col style="width: 32%">
<col style="width: 36%">
<col style="width: 32%">
</colgroup>
<tbody>
<tr>
<td style="text-align: left;">tackle <em>v.</em> B2, <em>n.</em> C1</td>
<td style="text-align: left;">theoretical <em>adj.</em> C1</td>
<td style="text-align: left;">tragic <em>adj.</em>, B2</td>
</tr>
<tr>
<td style="text-align: left;">tactic <em>n.</em> C1</td>
<td style="text-align: left;">therapist <em>n.</em> B2</td>
<td style="text-align: left;">trail <em>n.</em>, <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">tactical <em>adj.</em> C1</td>
<td style="text-align: left;">thereafter <em>adv.</em> C1</td>
<td style="text-align: left;">trailer <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">tag <em>n.</em>, <em>v.</em> B2</td>
<td style="text-align: left;">thereby <em>adv.</em> C1</td>
<td style="text-align: left;">trait <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">tap <em>v.</em>, <em>n.</em> B2</td>
<td style="text-align: left;">thesis <em>n.</em> B2</td>
<td style="text-align: left;">transaction <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">taxpayer <em>n.</em> C1</td>
<td style="text-align: left;">thorough <em>adj.</em> B2</td>
<td style="text-align: left;">transcript <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">technological <em>adj.</em> B2</td>
<td style="text-align: left;">thoroughly <em>adv.</em> B2</td>
<td style="text-align: left;">transformation <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">teens <em>n.</em> B2</td>
<td style="text-align: left;">thoughtful <em>adj.</em> C1</td>
<td style="text-align: left;">transit <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">temple <em>n.</em> B2</td>
<td style="text-align: left;">thought-provoking <em>adj.</em> C1</td>
<td style="text-align: left;">transmission <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">temporarily <em>adv.</em> B2</td>
<td style="text-align: left;">thread <em>n.</em> C1</td>
<td style="text-align: left;">transmit <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">tempt <em>v.</em> C1</td>
<td style="text-align: left;">threshold <em>n.</em> C1</td>
<td style="text-align: left;">transparency <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">tenant <em>n.</em> C1</td>
<td style="text-align: left;">thrilled <em>adj.</em> C1</td>
<td style="text-align: left;">transparent <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">tendency <em>n.</em> B2</td>
<td style="text-align: left;">thrive <em>v.</em> C1</td>
<td style="text-align: left;">transportation <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">tender <em>adj.</em> C1</td>
<td style="text-align: left;">thumb <em>n.</em> B2</td>
<td style="text-align: left;">trap <em>v.</em>, <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">tension <em>n.</em> B2</td>
<td style="text-align: left;">tide <em>n.</em> C1</td>
<td style="text-align: left;">trauma <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">tenure <em>n.</em> C1</td>
<td style="text-align: left;">tighten <em>v.</em> C1</td>
<td style="text-align: left;">treasure <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">terminal n B2, <em>adj.</em> C1</td>
<td style="text-align: left;">timber <em>n.</em> C1</td>
<td style="text-align: left;">treaty <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">terminate <em>v.</em> C1</td>
<td style="text-align: left;">timely <em>adj.</em> C1</td>
<td style="text-align: left;">tremendous <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">terms <em>n.</em> B2</td>
<td style="text-align: left;">timing <em>n.</em> B2</td>
<td style="text-align: left;">tribal <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">terrain <em>n.</em> C1</td>
<td style="text-align: left;">tissue <em>n.</em> B2</td>
<td style="text-align: left;">tribe <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">terribly <em>adv.</em> B2</td>
<td style="text-align: left;">tobacco <em>n.</em> C1</td>
<td style="text-align: left;">tribunal <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">terrific <em>adj.</em> C1</td>
<td style="text-align: left;">tolerance <em>n.</em> C1</td>
<td style="text-align: left;">tribute <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">terrify <em>v.</em> B2</td>
<td style="text-align: left;">tolerate <em>v.</em> C1</td>
<td style="text-align: left;">trigger <em>v.</em> B2, <em>n.</em>
C1</td>
</tr>
<tr>
<td style="text-align: left;">territory <em>n.</em> B2</td>
<td style="text-align: left;">toll <em>n.</em> C1</td>
<td style="text-align: left;">trillion number B2</td>
</tr>
<tr>
<td style="text-align: left;">terror <em>n.</em> B2</td>
<td style="text-align: left;">ton <em>n.</em> B2</td>
<td style="text-align: left;">trio <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">terrorism <em>n.</em> B2</td>
<td style="text-align: left;">tonne <em>n.</em> B2</td>
<td style="text-align: left;">triumph <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">terrorist <em>n.</em> B2</td>
<td style="text-align: left;">top <em>v.</em> C1</td>
<td style="text-align: left;">troop <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">testify <em>v.</em> C1</td>
<td style="text-align: left;">torture <em>n.</em>, <em>v.</em> C1</td>
<td style="text-align: left;">trophy <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">testimony <em>n.</em> C1</td>
<td style="text-align: left;">toss <em>v.</em> C1</td>
<td style="text-align: left;">troubled <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">testing <em>n.</em> B2</td>
<td style="text-align: left;">total <em>v.</em> C1</td>
<td style="text-align: left;">trustee <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">textbook <em>n.</em> B2</td>
<td style="text-align: left;">tournament <em>n.</em> B2</td>
<td style="text-align: left;">tsunami <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">texture <em>n.</em> C1</td>
<td style="text-align: left;">toxic <em>adj.</em> C1</td>
<td style="text-align: left;">tuition <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">thankfully <em>adv.</em> C1</td>
<td style="text-align: left;">trace <em>v.</em> B2, <em>n.</em> C1</td>
<td style="text-align: left;">turnout <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">theatrical <em>adj.</em> C1</td>
<td style="text-align: left;">trademark <em>n.</em> C1</td>
<td style="text-align: left;">turnover <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">theft <em>n.</em>B2</td>
<td style="text-align: left;">trading <em>n.</em> B2</td>
<td style="text-align: left;">twist <em>v.</em>, <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">theology <em>n.</em> C1</td>
<td style="text-align: left;">tragedy <em>n.</em> B2</td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<h2 id="u">U</h2>
<table>
<colgroup>
<col style="width: 33%">
<col style="width: 34%">
<col style="width: 31%">
</colgroup>
<tbody>
<tr>
<td style="text-align: left;">ultimate <em>adj.</em> B2</td>
<td style="text-align: left;">unfold <em>v.</em> B2</td>
<td style="text-align: left;">upgrade <em>v.</em>, <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">unacceptable <em>adj.</em> B2</td>
<td style="text-align: left;">unfortunate <em>adj.</em> B2</td>
<td style="text-align: left;">uphold <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">uncertainty <em>n.</em> B2</td>
<td style="text-align: left;">unify <em>v.</em> C1</td>
<td style="text-align: left;">urgent <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">undergo <em>v.</em> B2</td>
<td style="text-align: left;">unite <em>v.</em> B2</td>
<td style="text-align: left;">usage <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">undergraduate <em>n.</em> C1</td>
<td style="text-align: left;">unity <em>n.</em> B2</td>
<td style="text-align: left;">useless <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">underlying <em>adj.</em> C1</td>
<td style="text-align: left;">universal <em>adj.</em> B2</td>
<td style="text-align: left;">utility <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">undermine <em>v.</em> C1</td>
<td style="text-align: left;">unprecedented <em>adj.</em> C1</td>
<td style="text-align: left;">utilize <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">undertake <em>v.</em> B2</td>
<td style="text-align: left;">unveil <em>v.</em> C1</td>
<td style="text-align: left;">utterly <em>adv.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">undoubtedly <em>adv.</em> C1</td>
<td style="text-align: left;">upcoming <em>adj.</em> C1</td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<h2 id="v">V</h2>
<table>
<colgroup>
<col style="width: 38%">
<col style="width: 28%">
<col style="width: 33%">
</colgroup>
<tbody>
<tr>
<td style="text-align: left;">vacuum <em>n.</em> C1</td>
<td style="text-align: left;">verify <em>v.</em> C1</td>
<td style="text-align: left;">violate <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">vague <em>adj.</em> C1</td>
<td style="text-align: left;">verse <em>n.</em> C1</td>
<td style="text-align: left;">violation <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">valid <em>adj.</em> B2</td>
<td style="text-align: left;">versus <em>prep.</em> C1</td>
<td style="text-align: left;">virtue <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">validity <em>n.</em> C1</td>
<td style="text-align: left;">vertical <em>adj.</em> B2</td>
<td style="text-align: left;">visa <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">vanish <em>v.</em> C1</td>
<td style="text-align: left;">vessel <em>n.</em> C1</td>
<td style="text-align: left;">visible <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">variable <em>n.</em>, <em>adj.</em>
C1</td>
<td style="text-align: left;">veteran <em>n.</em> C1</td>
<td style="text-align: left;">vocal <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">variation <em>n.</em> B2</td>
<td style="text-align: left;">viable <em>adj.</em>, C1</td>
<td style="text-align: left;">voluntary <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">varied <em>adj.</em> C1</td>
<td style="text-align: left;">vibrant <em>adj.</em> C1</td>
<td style="text-align: left;">voting <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">vein <em>n.</em> C1</td>
<td style="text-align: left;">vice <em>n.</em> C1</td>
<td style="text-align: left;">vow <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">venture <em>n.</em>, <em>v.</em> C1</td>
<td style="text-align: left;">vicious <em>adj.</em> C1</td>
<td style="text-align: left;">vulnerability <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">verbal <em>adj.</em> C1</td>
<td style="text-align: left;">viewpoint <em>n.</em> B2</td>
<td style="text-align: left;">vulnerable <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">verdict <em>n.</em> C1</td>
<td style="text-align: left;">villager <em>n.</em> C1</td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<h2 id="w">W</h2>
<table>
<tbody>
<tr>
<td style="text-align: left;">wander <em>v.</em> B2</td>
<td style="text-align: left;">well-being <em>n.</em> C1</td>
<td style="text-align: left;">wisdom <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">ward <em>n.</em> C1</td>
<td style="text-align: left;">whatsoever <em>adv.</em> C1</td>
<td style="text-align: left;">wit <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">warehouse <em>n.</em> C1</td>
<td style="text-align: left;">wheat <em>n.</em> B2</td>
<td style="text-align: left;">withdraw <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">warfare <em>n.</em> C1</td>
<td style="text-align: left;">whereby <em>adv.</em> C1</td>
<td style="text-align: left;">withdrawal <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">warming <em>n.</em> B2</td>
<td style="text-align: left;">whilst conj. C1</td>
<td style="text-align: left;">workforce <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">warrant <em>n.</em>, <em>v.</em> C1</td>
<td style="text-align: left;">whip <em>v.</em> C1</td>
<td style="text-align: left;">workout <em>n.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">warrior <em>n.</em> C1</td>
<td style="text-align: left;">whoever pro<em>n.</em> B2</td>
<td style="text-align: left;">workplace <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">weaken <em>v.</em> C1</td>
<td style="text-align: left;">wholly <em>adv.</em> C1</td>
<td style="text-align: left;">workshop <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">weave <em>v.</em> C1</td>
<td style="text-align: left;">widen <em>v.</em> C1</td>
<td style="text-align: left;">worm <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">weed <em>n.</em> C1</td>
<td style="text-align: left;">widespread <em>adj.</em> B2</td>
<td style="text-align: left;">worship <em>n.</em>, <em>v.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">weekly <em>adj.</em> B2</td>
<td style="text-align: left;">widow <em>n.</em> C1</td>
<td style="text-align: left;">worthwhile <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">weird <em>adj.</em> B2</td>
<td style="text-align: left;">width <em>n.</em> C1</td>
<td style="text-align: left;">worthy <em>adj.</em> C1</td>
</tr>
<tr>
<td style="text-align: left;">welfare <em>n.</em> B2</td>
<td style="text-align: left;">willingness <em>n.</em> C1</td>
<td style="text-align: left;">wrist <em>n.</em>B2</td>
</tr>
<tr>
<td style="text-align: left;">well <em>n.</em> C1</td>
<td style="text-align: left;">wipe <em>v.</em> C1</td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<h2 id="y">Y</h2>
<table>
<tbody>
<tr>
<td style="text-align: left;">yell <em>v.</em> C1</td>
<td style="text-align: left;">yield <em>n.</em>, <em>v.</em> C1</td>
<td style="text-align: left;">youngster <em>n.</em> C1</td>
</tr>
</tbody>
</table>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/css/markmap.css">

<script src="/js/markmap.js"></script>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>牛津5000</tag>
        <tag>英语词汇</tag>
      </tags>
  </entry>
  <entry>
    <title>pitch</title>
    <url>/posts/279fbed9.html</url>
    <content><![CDATA[<h1 id="noun">noun</h1>
<h2 id="pronunciation">Pronunciation</h2>
<ul>
<li>BrE: /pɪtʃ/</li>
<li>NAmE: /pɪtʃ/</li>
</ul>
<h2 id="explanation">Explanation</h2>
<h3 id="section"><mark class="label primary">for sport 体育运动</mark></h3>
<ol type="1">
<li><p><strong><mark class="label ">B2</mark></strong> (<em>British English</em>)</p>
<p>(<em>also</em> <strong>field</strong> <em>North American
English</em>, <em>British English</em>)</p>
<p>[countable] an area of ground specially prepared and marked for
playing a sports game</p>
<span id="more"></span>
<ul>
<li><em>a <strong>football pitch</strong></em> 足球场</li>
<li><em>a cricket/rugby/hockey pitch</em> 板球/橄榄球/曲棍球场</li>
<li><em>an artificial pitch</em> 人造沥青</li>
<li><em>After the game fans invaded the pitch.</em>
比赛结束后，球迷们涌入球场。</li>
<li><em>The rugby tour was a disaster both on and off the pitch</em> (=
they lost their matches and the players behaved badly while on tour,
getting bad news reports). 这次橄榄球巡回赛在场上、场下都彻底失败。</li>
</ul>
<details class="note primary"><summary><p>Extra Examples</p>
</summary>
<ul>
<li><em>He was the best player on the pitch today.</em>
他是今天场上表现最好的选手。</li>
<li><em>Negotiations about his transfer are continuing off the
pitch.</em> 关于他转会的谈判仍在球场外继续进行。</li>
<li><em>The pitch was invaded by angry fans.</em>
愤怒的球迷涌入球场。</li>
<li><em>The players have just come off the pitch.</em>
选手们刚从球场下来。</li>
<li><em>The game ended in chaos with fans invading the pitch.</em>
球迷冲进赛场，球赛在一片混乱中结束。</li>
</ul>

</details>
<p><strong>Topics</strong> <a href="https://www.oxfordlearnersdictionaries.com/topic/sports-ball-and-racket-sports?level=b2">Sports:
ball and racket sports</a> <strong><mark class="label ">B2</mark></strong></p>
<details class="note primary"><summary><p>Oxford Collocations Dictionary</p>
</summary>
<ul>
<li><strong>adjective</strong>
<ul>
<li>all-weather</li>
<li>grass</li>
<li>synthetic</li>
<li>…</li>
</ul></li>
<li><strong>verb + pitch</strong>
<ul>
<li>invade</li>
<li>run onto</li>
</ul></li>
<li><strong>pitch + noun</strong>
<ul>
<li>invasion</li>
</ul></li>
<li><strong>preposition</strong>
<ul>
<li>off the pitch</li>
<li>on a/​the pitch</li>
</ul></li>
</ul>

</details></li>
</ol>
<h3 id="section-1"><mark class="label primary">of sound 声音</mark></h3>
<ol start="2" type="1">
<li><p>[singular, uncountable] how high or low a sound is, especially a
musical note（尤指乐音的）音高</p>
<ul>
<li>A basic sense of rhythm and pitch is essential in a music teacher.
基本的韵律感和音高感是音乐教师的必备素质。</li>
</ul>
<details class="note primary"><summary><p><strong>see also</strong> perfect pitch</p>
</summary>
<ul>
<li>BrE: /ˌpɜːfɪkt ˈpɪtʃ/</li>
<li>NAmE: /ˌpɜːrfɪkt ˈpɪtʃ/</li>
</ul>
<p>[uncountable] (music 音乐)</p>
<p>the ability to identify or sing a musical note correctly without the
help of an instrument
绝对音高，绝对音感（指不须借助乐器准确识别或唱出音符的能力）</p>
<ul>
<li><em>Having perfect pitch means that I can hear a note and tell you
that it’s a G, or a B flat or whatever.</em>
拥有完美的音高意味着我能听到一个音符，并告诉你它是 G 音，或者是 B
音，或者别的什么。</li>
</ul>

</details>
<details class="note primary"><summary><p>Extra Examples</p>
</summary>
<ul>
<li><em>The pitch of the drum can be raised by tightening the skin.</em>
可以通过绷紧鼓皮来提高鼓的音高。</li>
<li><em>Her voice fell in pitch as she grew older.</em>
她的音高随年龄的增长而下降。</li>
<li><em>The instrument is not tuned to the correct pitch.</em>
乐器的音高没有调准。</li>
</ul>

</details>
<p><strong>Topics</strong> <a href="https://www.oxfordlearnersdictionaries.com/topic/language?level=c1">Language</a>
<strong><mark class="label ">C1</mark></strong>, <a href="https://www.oxfordlearnersdictionaries.com/topic/music?level=c1">Music</a>
<strong><mark class="label ">C1</mark></strong></p>
<details class="note primary"><summary><p>Oxford Collocations Dictionary</p>
</summary>
<ul>
<li><strong>adjective</strong>
<ul>
<li>high</li>
<li>low</li>
<li>correct</li>
<li>…</li>
</ul></li>
<li><strong>verb + pitch</strong>
<ul>
<li>fall in</li>
<li>rise in</li>
<li>change</li>
<li>…</li>
</ul></li>
<li><strong>phrases</strong>
<ul>
<li>have perfect pitch</li>
</ul></li>
</ul>

</details></li>
</ol>
<h3 id="section-2"><mark class="label primary">degree/strength 程度；强度</mark></h3>
<ol start="3" type="1">
<li><p>[singular, uncountable] the degree or strength of a feeling or
activity; the highest point of
something（感情、活动等的）程度，力度；（事物的）最高点</p>
<ul>
<li><em>a frenetic pitch of activity</em> 活动的狂热极点</li>
<li><em>Speculation has reached such a pitch that a decision will have
to be made immediately.</em>
种种猜测甚嚣尘上，以致必须立即作出决定。</li>
<li><em>to reach a high pitch of excitement</em> 达到极其兴奋的程度</li>
</ul>
<details class="note primary"><summary><p>Oxford Collocations Dictionary</p>
</summary>
<ul>
<li><strong>adjective</strong>
<ul>
<li>fever</li>
<li>high</li>
</ul></li>
<li><strong>verb + pitch</strong>
<ul>
<li>reach</li>
<li>rise to</li>
</ul></li>
<li><strong>preposition</strong>
<ul>
<li>pitch of</li>
</ul></li>
</ul>

</details>
<details class="note primary"><summary><p><strong>see also</strong> fever pitch</p>
</summary>
<ul>
<li>BrE: /ˈfiːvə pɪtʃ/</li>
<li>NAmE: /ˈfiːvər pɪtʃ/</li>
</ul>
<p>[uncountable, singular] a very high level of excitement or activity
高度兴奋；极为激动；狂热</p>
<ul>
<li><em>Speculation about his future had <strong>reached fever
pitch</strong></em>. 关于他的前途的猜测达到了狂想的地步。</li>
<li><em>Excitement rose to fever pitch the day before the game.</em>
比赛的前一天人们兴奋到了极点。</li>
<li><em>The crowd had been roused to fever pitch by the drama of the
game.</em> 这场比赛的戏剧性场面已经把人群激起了狂热。</li>
<li><em>a fever pitch of nervous excitement</em> 极度的焦躁不安。</li>
<li><strong>at fever pitch</strong> <em>Excitement has been at fever
pitch for days</em> 狂热的兴奋持续了好些日子。</li>
</ul>

</details></li>
</ol>
<h3 id="section-3"><mark class="label primary">to sell something 销售</mark></h3>
<ol start="4" type="1">
<li><p>[countable, usually singular] talk or arguments used by a person
trying to sell things or persuade people to do something
推销的话；说教；宣传论点</p>
<ul>
<li><em>an aggressive <strong>sales pitch</strong></em>
强有力的推销行话</li>
<li><em>the candidate’s campaign pitch</em> 候选人的竞选宣传</li>
<li><em>Each company was given ten minutes to <strong>make its
pitch</strong>.</em> 每个公司有十分钟时间做推销宣传。</li>
</ul>
<details class="note primary"><summary><p>Extra Examples</p>
</summary>
<ul>
<li><em>Farley was about to make a pitch to a big client.</em>
法利即将对一个大客户进行推销。</li>
<li><em>His pitch to the business community was based on common
sense.</em> 他对商界的推销是以常识为基础的。</li>
<li><em>Marcelo will be making his pitch to a small number of potential
clients.</em> 马塞洛将向少数的潜在客户进行推销。</li>
<li><em>The executives listened open-mouthed as she seamlessly delivered
a pitch for their business.</em>
她滔滔不绝地推销业务，让高管们听得目瞪口呆。</li>
<li><em>a strong pitch delivered by advertising executives</em>
广告主管发表的强有力的推销言辞</li>
</ul>

</details>
<p><strong>Topics</strong> <a href="https://www.oxfordlearnersdictionaries.com/topic/opinion-and-argument?level=c2">Opinion
and argument</a> <strong><mark class="label ">C2</mark></strong></p>
<details class="note primary"><summary><p>Oxford Collocations Dictionary</p>
</summary>
<ul>
<li><strong>adjective</strong>
<ul>
<li>sales</li>
<li>good</li>
<li>strong</li>
<li>…</li>
</ul></li>
<li><strong>verb + pitch</strong>
<ul>
<li>deliver</li>
<li>do</li>
<li>give</li>
<li>…</li>
</ul></li>
<li><strong>pitch + noun</strong>
<ul>
<li>meeting</li>
</ul></li>
<li><strong>preposition</strong>
<ul>
<li>pitch for</li>
<li>pitch to</li>
</ul></li>
</ul>

</details></li>
</ol>
<h3 id="section-4"><mark class="label primary">in baseball 棒球</mark></h3>
<ol start="5" type="1">
<li><p>[countable] an act of throwing the ball; the way in which it is
thrown 投球；投球方法</p>
<details class="note primary"><summary><p>Synonyms <strong>throw</strong></p>
</summary>
<p>toss | hurl | fling | chuck | lob | bowl | pitch</p>
<p>These words all mean to send something from your hand through the
air.</p>
<ul>
<li><p><strong>throw</strong> to send something from your hand or hands
through the air:</p>
<ul>
<li><em>Some kids were throwing stones at the window.</em>
有些孩子在朝窗户扔石头。</li>
<li><em>She threw the ball and he caught it.</em>
她把球抛出来，他接住了。</li>
</ul></li>
<li><p><strong>toss</strong> to throw something lightly or
carelessly:</p>
<ul>
<li><em>She tossed her jacket onto the bed.</em>
她把她的短上衣丢到床上。</li>
</ul></li>
<li><p><strong>hurl</strong> to throw something violently in a
particular direction:</p>
<ul>
<li><em>Rioters hurled a brick through the car’s windscreen.</em>
暴徒把一块砖猛地扔向汽车，砸破了挡风玻璃。</li>
</ul></li>
<li><p><strong>fling</strong> to throw somebody/​something somewhere with
a lot of force, especially because you are angry or in a hurry:</p>
<ul>
<li><em>She flung the letter down onto the table.</em>
她把信摔在桌子上。</li>
</ul></li>
<li><p><strong>chuck</strong> (<em>especially British English,
informal</em>) to throw something carelessly:</p>
<ul>
<li><em>I chucked him the keys.</em> 我把钥匙扔给了他。</li>
</ul></li>
<li><p><strong>lob</strong> (<em>informal</em>) to throw something so
that it goes high through the air:指往空中高扔、高抛、高掷：</p>
<ul>
<li><em>They were lobbing stones over the wall.</em>
他们在朝墙那边扔石头。</li>
</ul></li>
<li><p><strong>bowl</strong> (<em>in cricket</em>) to throw the ball to
the batsman（板球）指把球投给击球员</p></li>
<li><p><strong>pitch</strong> (<em>in baseball</em>) to throw the ball
to the batter（棒球）指把球投给击球员</p></li>
<li><p>Patterns</p>
<ul>
<li>to throw/​toss/​hurl/​fling/​chuck/​lob/​bowl/​pitch something at/​to
somebody/​something</li>
<li>to throw/​toss/​fling/​chuck something aside/​away</li>
<li>to throw/​toss/​hurl/​fling/​chuck/​lob/​bowl/​pitch a ball</li>
<li>to throw/​toss/​hurl/​fling/​chuck stones/​rocks/​a brick</li>
<li>to throw/​toss/​hurl/​fling something angrily</li>
<li>to throw/​toss something casually/​carelessly</li>
</ul></li>
</ul>

</details>
<details class="note primary"><summary><p>Oxford Collocations Dictionary</p>
</summary>
<ul>
<li><strong>adjective</strong>
<ul>
<li>wild</li>
</ul></li>
<li><strong>verb + pitch</strong>
<ul>
<li>deliver</li>
<li>hit</li>
<li>make</li>
<li>…</li>
</ul></li>
</ul>

</details></li>
</ol>
<h3 id="section-5"><mark class="label primary">black substance 黑色物质</mark></h3>
<ol start="6" type="1">
<li>[uncountable] a black sticky substance made from oil or coal, used
on roofs or the wooden boards of a ship to stop water from coming
through 沥青；柏油</li>
</ol>
<h3 id="section-6"><mark class="label primary">in street/market 街道；市场</mark></h3>
<ol start="7" type="1">
<li>[countable] (<em>British English</em>) a place in a street or market
where somebody sells things, or where somebody performs in order to
entertain people outdoors 街头售货摊点；街头艺人表演地点</li>
</ol>
<h3 id="section-7"><mark class="label primary">camping</mark></h3>
<ol start="8" type="1">
<li><p>(<em>British English</em>)</p>
<p>(<em>North American English</em> <strong>campsite</strong>)</p>
<p>a place in a campsite where you can put up one tent or park one
caravan, etc. 在露营地中可以搭起一个帐篷或停放一个大篷车等的地方。</p>
<ul>
<li><em>Pitches to rent from only £15 per night.</em>
租金从每晚15英镑起。</li>
</ul></li>
</ol>
<h3 id="section-8"><mark class="label primary">of ship/aircraft 船；飞机</mark></h3>
<ol start="9" type="1">
<li><p>[uncountable] (<em>specialist</em>) the movement of a ship up and
down in the water or of an aircraft in the
air（船在水上的）上下颠簸，纵摇；（飞机在空中的）俯仰</p>
<details class="note primary"><summary><p><strong>compare</strong> roll</p>
</summary>
<p><mark class="label primary">of ship/plane 船只；飞机</mark></p>
<p>[uncountable] the act of moving from side to side so that one side is
higher than the other摇晃；摇荡</p>

</details></li>
</ol>
<h3 id="section-9"><mark class="label primary">of roof 屋顶</mark></h3>
<ol start="10" type="1">
<li><p>[singular, uncountable] (<em>specialist</em>) the degree to which
a roof slopes倾斜度</p>
<ul>
<li><em>The pitch of the roof is 45 degrees.</em>
屋顶的倾斜度是45度。</li>
</ul></li>
</ol>
<h2 id="word-origin">Word Origin</h2>
<p><em>noun</em> senses 1 to 5 and <em>noun</em> senses 7 to 9 Middle
English (as a verb in the senses ‘thrust (something pointed) into the
ground’ and ‘fall headlong’): perhaps related to Old English
<em>picung</em> ‘stigmata’, of unknown ultimate origin. The sense
development is obscure. <em>noun</em> sense 6 Old English <em>pic</em>
(noun), <em>pician</em> (verb), of Germanic origin; related to Dutch
<em>pek</em> and German <em>Pech</em>; based on Latin <em>pix</em>,
<em>pic-</em>.</p>
<h2 id="idioms">Idioms</h2>
<ul>
<li><p><strong>make a pitch for somebody/something | make a pitch to
somebody</strong></p>
<p>to make a determined effort to get something or to persuade somebody
of something 决心获得；决心劝服</p>
<ul>
<li><em>He made a pitch to black voters in Alabama.</em>
他向阿拉巴马州的黑人选民游说。</li>
</ul></li>
<li><p><strong>queer somebody’s pitch | queer the pitch (for
somebody)</strong></p>
<p>(<em>British English</em>, <em>informal</em>) to cause somebody’s
plans to fail or to destroy their chances of getting something
破坏…的计划（或机会）</p></li>
</ul>
<h1 id="verb">verb</h1>
<h2 id="pronunciation-1">Pronunciation</h2>
<ul>
<li>BrE: /pɪtʃ/</li>
<li>NAmE: /pɪtʃ/</li>
</ul>
<h3 id="verb-forms">Verb Forms</h3>
<ul>
<li>present simple I / you / we / they <strong>pitch</strong>
<ul>
<li>BrE: /pɪtʃ/</li>
<li>NAmE: /pɪtʃ/</li>
</ul></li>
<li>he / she / it <strong>pitches</strong>
<ul>
<li>BrE: /ˈpɪtʃɪz/</li>
<li>NAmE: /ˈpɪtʃɪz/</li>
</ul></li>
<li>past simple <strong>pitched</strong>
<ul>
<li>BrE: /pɪtʃt/</li>
<li>NAmE: /pɪtʃt/</li>
</ul></li>
<li>past participle <strong>pitched</strong>
<ul>
<li>BrE: /pɪtʃt/</li>
<li>NAmE: /pɪtʃt/</li>
</ul></li>
<li>-ing form <strong>pitching</strong>
<ul>
<li>BrE: /ˈpɪtʃɪŋ/</li>
<li>NAmE: /ˈpɪtʃɪŋ/</li>
</ul></li>
</ul>
<h3 id="explanation-1">Explanation</h3>
<h4 id="section-10"><mark class="label primary">throw 抛</mark></h4>
<ol type="1">
<li><p>[transitive] <strong>pitch somebody/something +
adv./prep.</strong> to throw somebody/something with force
用力扔；投；抛</p>
<ul>
<li><em>The explosion pitched her violently into the air.</em>
爆炸把她猛烈地抛向空中。</li>
<li>(<em>figurative</em>) <em>The new government has already been
pitched into a crisis.</em> 新政府已被抛入危机之中。</li>
</ul>
<details class="note primary"><summary><p>Extra Examples</p>
</summary>
<ul>
<li><em>If they hit any unseen obstacle they would be pitched headlong
into the snow.</em>
如果撞上任何没看见的障碍，他们就会被一头抛进雪里。</li>
<li><em>There was a loud bang and he was pitched from his seat.</em>
一声巨响，他被从座位上抛了起来。</li>
</ul>

</details>
<details class="note primary"><summary><p>Oxford Collocations Dictionary</p>
</summary>
<ul>
<li><strong>adverb</strong>
<ul>
<li>violently</li>
<li>forward</li>
<li>headlong</li>
<li>…</li>
</ul></li>
<li><strong>preposition</strong>
<ul>
<li>from</li>
<li>into</li>
<li>out of</li>
<li>…</li>
</ul></li>
</ul>

</details></li>
</ol>
<h4 id="section-11"><mark class="label primary">in sports 体育运动</mark></h4>
<ol start="2" type="1">
<li><p>[intransitive, transitive] <strong>pitch (something)</strong> (in
baseball 棒球) to throw the ball to the person who is batting
将（球）投给击球员；投球；当投手</p>
<ul>
<li><em>He pitched against UCLA last week.</em>
他上周担任投手，对阵加州大学洛杉矶分校。</li>
<li><em>My dream was to pitch for the Yankees.</em>
我的梦想是成为扬基队的投手。</li>
</ul>
<details class="note primary"><summary><p>Extra Examples</p>
</summary>
<ul>
<li><em>The pitcher pitched the ball right down the middle of the
plate.</em> 那个投手将球正好投到本垒板中间。</li>
<li><em>Perez has pitched effectively this spring.</em>
今年春天佩雷斯投球投得很好。</li>
</ul>

</details>
<p><strong>Topics</strong> <a href="https://www.oxfordlearnersdictionaries.com/topic/sports-ball-and-racket-sports?level=b2">Sports:
ball and racket sports</a> <strong><mark class="label ">B2</mark></strong></p>
<details class="note primary"><summary><p>Oxford Collocations Dictionary</p>
</summary>
<ul>
<li><strong>adverb</strong>
<ul>
<li>effectively</li>
<li>well</li>
<li>poorly</li>
<li>…</li>
</ul></li>
<li><strong>preposition</strong>
<ul>
<li>for</li>
</ul></li>
</ul>

</details></li>
<li><p>[intransitive, transitive] <strong>pitch (something) +
adv./prep.</strong> (of the ball in the games of golf or cricket) to hit
the ground; to make the ball hit the ground 触地；（使球）定点落地</p>
<ul>
<li><em>The ball pitched a yard short of the hole.</em>
球投出了离球洞1码远的地方。</li>
</ul></li>
<li><p>[transitive, intransitive] <strong>pitch (something)</strong> (in
golf 高尔夫球) to hit the ball in a high curve劈高球；击高球</p>
<p><strong>Topics</strong> <a href="https://www.oxfordlearnersdictionaries.com/topic/sports-ball-and-racket-sports?level=b2">Sports:
ball and racket sports</a> <strong><mark class="label ">B2</mark></strong></p></li>
</ol>
<h4 id="section-12"><mark class="label primary">fall 倒下</mark></h4>
<ol start="5" type="1">
<li><p>[intransitive] <strong>+ adv./prep.</strong> to fall heavily in a
particular direction 重跌；踉跄倒下</p>
<ul>
<li><em>With a cry she pitched forward.</em> 她大叫一声向前跌倒了。</li>
</ul>
<details class="note primary"><summary><p>Oxford Collocations Dictionary</p>
</summary>
<ul>
<li><strong>adverb</strong>
<ul>
<li>violently</li>
<li>forward</li>
<li>headlong</li>
<li>…</li>
</ul></li>
<li><strong>preposition</strong>
<ul>
<li>from</li>
<li>into</li>
<li>out of</li>
<li>…</li>
</ul></li>
</ul>

</details></li>
</ol>
<h4 id="section-13"><mark class="label primary">of ship/aircraft 船；飞机</mark></h4>
<ol start="6" type="1">
<li><p>[intransitive] to move up and down on the water or in the air
纵摇；颠簸；上下飘荡</p>
<ul>
<li><em>The sea was rough and the ship pitched and rolled all
night.</em> 大海波涛汹涌，船整夜颠簸摇晃。</li>
<li><em>The boat pitched violently in a heavy swell.</em>
船在汹涌的海浪中剧烈颠簸。</li>
</ul>
<details class="note primary"><summary><p><strong>compare</strong> roll</p>
</summary>
<ul>
<li>BrE: /rəʊl/</li>
<li>NAmE: /rəʊl/</li>
</ul>
<p><mark class="label primary">of ship/plane/walk
船只；飞机；行走</mark></p>
<p>[intransitive, transitive] <strong>roll (something) (+
adv./prep.)</strong> to move or make something move from side to
side（使）摇摆，摇晃</p>
<ul>
<li><em>He walked with a rolling gait.</em> 他摇摇晃晃地走着。</li>
<li><em>The ship was rolling heavily to and fro.</em>
轮船剧烈地颠簸着。</li>
</ul>

</details>
<p><strong>Topics</strong> <a href="https://www.oxfordlearnersdictionaries.com/topic/transport-by-water?level=c2">Transport
by water</a> <strong><mark class="label ">C2</mark></strong></p>
<p></p><details class="note primary"><summary><p>Oxford Collocations Dictionary</p>
</summary>
<ul>
<li><strong>adverb</strong>
<ul>
<li>violently</li>
<li>forward</li>
<li>headlong</li>
<li>…</li>
</ul></li>
<li><strong>preposition</strong>
<ul>
<li>from</li>
<li>into</li>
<li>out of</li>
<li>…</li>
</ul></li>
</ul>

</details><p></p></li>
</ol>
<h4 id="section-14"><mark class="label primary">set level 定标准</mark></h4>
<ol start="7" type="1">
<li><p>[transitive] to set something at a particular level 确定标准</p>
<ul>
<li><strong>pitch something (+ adv./prep./adj.)</strong> <em>They have
pitched their prices too high.</em> 他们把价格定得太高了。</li>
<li><strong>pitch something (at something)</strong> <em>The test was
pitched at too low a level for the students.</em>
这次考试太低估学生的程度了。</li>
</ul>
<details class="note primary"><summary><p>Extra Examples</p>
</summary>
<ul>
<li><em>The test is pitched at a high GCSE standard.</em>
考试是按照普通中等教育证书的较高标准制订的。</li>
<li><em>The price has been pitched quite high.</em>
价格定得相当高。</li>
<li><em>Estimates have been deliberately pitched on the conservative
side.</em> 有意作了保守的估计。</li>
</ul>

</details>
<details class="note primary"><summary><p>Oxford Collocations Dictionary</p>
</summary>
<ul>
<li><strong>adverb</strong>
<ul>
<li>deliberately</li>
</ul></li>
<li><strong>preposition</strong>
<ul>
<li>at</li>
</ul></li>
<li><strong>phrases</strong>
<ul>
<li>pitch something high</li>
<li>pitch something low</li>
</ul></li>
</ul>

</details></li>
</ol>
<h4 id="section-15"><mark class="label primary">try to sell 推销</mark></h4>
<ol start="8" type="1">
<li><p>[transitive] to aim or direct a product or service at a
particular group of
people（使产品或服务）针对，面向；确定销售对象（或目标市场）</p>
<ul>
<li><strong>pitch something (at somebody)</strong> <em>The new software
is being pitched at banks.</em> 这种新软件以银行为目标市场。</li>
<li><em>The product is pitched primarily at telecommunications
companies.</em> 该产品主要面向电信公司。</li>
<li><strong>pitch something (as something)</strong> <em>Orange juice is
to be pitched as an athlete’s drink.</em>
橙汁将作为运动员饮料进行推销。</li>
</ul></li>
<li><p>[transitive, intransitive] to try to persuade somebody to buy
something, to give you something or to make a business deal with you
推销；争取支持（或生意等）</p>
<ul>
<li><strong>pitch something</strong> <em>Representatives went to Japan
to pitch the company’s newest products.</em>
销售代表前往日本推销公司的最新产品。</li>
<li><strong>pitch (for something)</strong> <em>We were pitching against
a much larger company for the contract.</em>
我们在与一家比我们大得多的公司竞争这项合同。</li>
</ul></li>
</ol>
<h4 id="section-16"><mark class="label primary">sound/music 声音；音乐</mark></h4>
<ol start="10" type="1">
<li><p>[transitive] <strong>pitch something + adj.</strong> to produce a
sound or piece of music at a particular level 定音高</p>
<ul>
<li><em>You pitched that note a little flat.</em>
你把那个音符定得有点低了。</li>
<li><em>The song was pitched too low for my voice.</em>
这首歌起调太低，不适合我的嗓音。</li>
<li><em>Her voice was pitched low.</em> 她把声音放低了。</li>
</ul>
<details class="note primary"><summary><p><strong>see also</strong> high-pitched</p>
</summary>
<ul>
<li>BrE: /ˌhaɪ ˈpɪtʃt/</li>
<li>NAmE: /ˌhaɪ ˈpɪtʃt/</li>
</ul>
<p>(of sounds 声音) very high 很高的；尖利的</p>
<ul>
<li><em>a high-pitched voice/whistle</em>尖嗓子；尖锐的口哨声</li>
<li><em>She had a high-pitched giggle which irritated me intensely.</em>
她刺耳的傻笑声让我特别恼火。</li>
<li><em>a high-pitched noise/scream/tone</em>
高声的噪音/尖叫声/音调</li>
</ul>

</details>
<details class="note primary"><summary><p><strong>see also</strong> low-pitched</p>
</summary>
<ul>
<li>BrE: /ˌləʊ ˈpɪtʃt/</li>
<li>NAmE: /ˌləʊ ˈpɪtʃt/</li>
</ul>
<p>(of sounds 声音) deep; low 低沉的；低声的</p>
<ul>
<li><em>a low-pitched voice</em> 低沉的嗓音</li>
</ul>

</details></li>
</ol>
<h4 id="section-17"><mark class="label primary">tent 帐篷</mark></h4>
<ol start="11" type="1">
<li><p>[transitive] pitch something to set up a tent or a camp for a
short time搭（帐篷）；扎（营）</p>
<ul>
<li><em>We could pitch our tent in that field.</em>
我们可以临时把帐篷搭在那块地上。</li>
<li><em>They pitched camp for the night near the river.</em>
他们靠河边扎营过夜。</li>
</ul>
<details class="note primary"><summary><p><strong>see also</strong> pitched</p>
</summary>
<ul>
<li>BrE: /pɪtʃt/</li>
<li>NAmE: /pɪtʃt/</li>
</ul>
<p>(of a roof 屋顶) sloping; not flat 倾斜的</p>
<ul>
<li><em>steeply pitched roofs</em> 陡峭的屋顶</li>
</ul>

</details>
<p><strong>Topics</strong> <a href="https://www.oxfordlearnersdictionaries.com/topic/holidays?level=c2">Holidays</a>
<strong><mark class="label ">C2</mark></strong></p></li>
</ol>
<h3 id="word-origin-1">Word Origin</h3>
<p><em>verb</em> Middle English (as a verb in the senses ‘thrust
(something pointed) into the ground’ and ‘fall headlong’): perhaps
related to Old English <em>picung</em> ‘stigmata’, of unknown ultimate
origin. The sense development is obscure.</p>
<h3 id="idioms-1">Idioms</h3>
<ul>
<li><p><strong>pitch a story/line/yarn (to somebody)</strong></p>
<p>(<em>informal</em>) to tell somebody a story or make an excuse that
is not true（对某人）编谎话</p></li>
</ul>
<h3 id="phrasal-verbs">Phrasal Verbs</h3>
<h4 id="pitch-in">pitch in</h4>
<ul>
<li><p><strong>pitch in (with somebody/something)</strong></p>
<p>(<em>informal</em>) to join in and help with an activity, by doing
some of the work or by giving money, advice, etc. 投入；参与；支援</p>
<ul>
<li><em>Everyone pitched in with the work.</em>
每个人都投入了这项工作。</li>
<li><em>Local companies pitched in with building materials and
labour.</em> 当地的公司支援了建筑材料和劳动力。</li>
</ul></li>
<li><p><strong>pitch something ↔︎ in</strong></p>
<p>to give a particular amount of money in order to help with something
参与；出力；出份子</p>
<ul>
<li>W<em>e all pitched in $10 to buy her a gift.</em> 我们每人出 10
美元，凑钱给她买礼物。</li>
</ul></li>
</ul>
<h4 id="pitch-into">pitch into</h4>
<ul>
<li><p>pitch into somebody</p>
<p>(<em>informal</em>) to attack or criticize
somebody攻击；批判；批评</p>
<ul>
<li><em>She started pitching into me as soon as I arrived.</em>
我刚一到她就劈头盖脸地批评起我来。</li>
</ul></li>
<li><p>pitch into something</p>
<p>(<em>informal</em>) to start an activity with
enthusiasm蓬勃开展；大干</p>
<ul>
<li><strong>pitch into doing something</strong> <em>I rolled up my
sleeves and pitched into cleaning the kitchen.</em>
我卷起袖子，给厨房做大扫除。</li>
</ul></li>
</ul>
<h4 id="pitch-up">pitch up</h4>
<p>(<em>British English</em>, <em>informal</em>) to arrive somewhere,
especially late or without planning 到达（尤指迟到或不约而至）</p>
<details class="note primary"><summary><p><strong>synonym</strong> turn up</p>
</summary>
<p>(of a person 人) to arrive 到达；来到；露面</p>
<ul>
<li><em>We arranged to meet at 7.30, but she never turned up.</em>
我们约好 7:30 碰头，但她根本没露面。</li>
</ul>

</details>
<ul>
<li>You can’t just pitch up and expect to get in without a
ticket.你可不能说来就来，还想无票入场。</li>
</ul>
<h1 id="reference">Reference</h1>
<ol type="1">
<li><p>Diana Lea, Jennifer Bradbery. <em>Oxford Advanced Learner’s
Dictionary, 10th edition.</em> Oxford University Press, 2020.</p></li>
<li><p>Margaret Deuter, Jennifer Bradbery, Joanna Turnbull.
<em>牛津高阶英汉双解词典，第 9 版.</em> 商务印书馆, 2018.</p></li>
</ol>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/css/markmap.css">

<script src="/js/markmap.js"></script>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>牛津5000</tag>
        <tag>英语词汇</tag>
      </tags>
  </entry>
  <entry>
    <title>a, an</title>
    <url>/posts/6635e93f.html</url>
    <content><![CDATA[<h1 id="indefinite-article---a">indefinite article - a</h1>
<h2 id="pronunciation">Pronunciation</h2>
<ul>
<li>BrE: /ə/, strong form /eɪ/</li>
<li>NAmE: /ə/, strong form /eɪ/</li>
</ul>
<blockquote>
<p><em>also</em> <strong>an</strong></p>
<ul>
<li>BrE: /ən/, strong form /æn/</li>
<li>NAmE: /ən/, strong form /æn/</li>
</ul>
<p>The form <strong>a</strong> is used before consonant sounds and the
form <strong>an</strong> before vowel sounds. When saying abbreviations
like ‘FM’ or ‘UN’, use <strong>a</strong> or <strong>an</strong>
according to how the first letter is said. For example,
<strong>F</strong> is a consonant, but begins with the sound /e/ and so
you say: <em>an FM radio</em>. <strong>U</strong> is a vowel but begins
with /j/ and so you say: <em>a UN declaration</em>.</p>
</blockquote>
<h2 id="explanation">Explanation</h2>
<ol type="1">
<li><p><strong><mark class="label ">A1</mark></strong> used before countable or singular
nouns referring to people or things that have not already been
mentioned（用于可数名词或单数名词前，表示未曾提到的）一（人、事、物）</p>
<span id="more"></span>
<ul>
<li><em>a man/horse/unit</em> 一个人；一匹马；一个单位</li>
<li><em>an aunt/egg/hour/X-ray</em> 一位姑母；一枚鸡蛋；一小时；一张 X
光片</li>
<li><em>I can only carry two at a time.</em> 我一次只能带两个。</li>
<li><em>There’s a visitor for you.</em> 有位客人找你。</li>
<li><em>She’s a friend of my father’s</em> (= one of my father’s
friends). 她是我父亲的朋友。</li>
</ul></li>
<li><p><strong><mark class="label ">A1</mark></strong> used to show that
somebody/something is a member of a group or
profession（表示为某一群体或职业中的一员）</p>
<ul>
<li><em>Their new car’s a BMW.</em> 他们的新轿车是辆宝马。</li>
<li><em>She’s a Buddhist.</em> 她是佛教徒。</li>
<li><em>He’s a teacher.</em> 他是教师。</li>
<li><em>Is that a Monet</em> (= a painting by Monet)?
那是莫奈的画吗？</li>
</ul></li>
<li><p><strong><mark class="label ">A1</mark></strong> any; every 任何一；每一</p>
<ul>
<li><em>A lion is a dangerous animal.</em> 狮子是猛兽。</li>
</ul></li>
<li><p><strong><mark class="label ">B1</mark></strong> used before uncountable nouns when
these have an adjective in front of them, or phrase following
them（用于前有形容词或后有短语的不可数名词前）</p>
<ul>
<li><em>a good knowledge of French</em> 精通法语</li>
<li><em>a sadness that won’t go away</em> 挥之不去的悲愁</li>
</ul></li>
<li><p>used in front of two nouns that are seen as a single
unit（用于视为一体的两个名词之前）</p>
<ul>
<li><em>a knife and fork</em> 一副刀叉</li>
</ul></li>
<li><p>used instead of one before some numbers（用于某些数字前，代替
one）</p>
<ul>
<li><em>A thousand people were there.</em> 那里有一千人。</li>
</ul></li>
<li><p>used when talking about prices, quantities and
rates（用于价格、数量、比率等）一，每一</p>
<details class="note primary"><summary><p>Synonyms <strong>per</strong></p>
</summary>
<ul>
<li>BrE: /pə(r)/, strong form /pɜː(r)/</li>
<li>NAmE: /pər/, strong form /pɜːr/</li>
</ul>
<p>used to express the cost or amount of something for each person,
number used, distance travelled, etc. 每；每一</p>
<ul>
<li><em>Rooms cost £50 per person, per night.</em> 房价每人每晚 50
英镑。</li>
<li><em>60 miles per hour</em> 每小时 60 英里</li>
<li><em>France consumes around 200 000 tonnes of cocoa per year.</em>
法国每年消费约20万吨可可。</li>
<li><em>This country has a higher crime rate per 100 000 of the
population than most other European countries.</em>
这个国家的每10万人口犯罪率比大多数其他欧洲国家高。</li>
</ul>

</details>
<ul>
<li>They cost 50p a kilo.这些东西一公斤 50 便士。</li>
<li>I can type 50 words a minute.我每分钟能打 50 个单词。</li>
<li>He was driving at 50 miles an hour.当时他正以每小时 50
英里的速度驾车。</li>
</ul></li>
<li><p>a person like somebody像（某人）的人；…式的人物</p>
<ul>
<li><em>She’s a little Hitler.</em> 她是个小希特勒。</li>
</ul></li>
<li><p>used before somebody’s name to show that the speaker does not
know the person（用于某人姓名前，表示说话者不认识此人）有个</p>
<ul>
<li><em>There’s a Mrs Green to see you.</em> 有位格林太太要见你。</li>
</ul></li>
<li><p>used before the names of days of the week to talk about one
particular day（用于一星期中某天的名称前，表示具体某一天）</p>
<ul>
<li><em>She died on a Tuesday.</em> 她是在某个星期二去世的。</li>
</ul></li>
</ol>
<h2 id="word-origin">Word Origin</h2>
<p>Middle English: weak form of Old English <em>ān</em> ‘one’.</p>
<h1 id="noun---a">noun - A</h1>
<h2 id="pronunciation-1">Pronunciation</h2>
<ul>
<li>BrE: /eɪ/</li>
<li>NAmE: /eɪ/</li>
</ul>
<blockquote>
<p><em>also</em> <strong>a</strong></p>
<p>plural <strong>As</strong>, <strong>A’s</strong>,
<strong>a’s</strong></p>
<ul>
<li>BrE: /eɪz/</li>
<li>NAmE: /eɪz/</li>
</ul>
</blockquote>
<h2 id="explanation-1">Explanation</h2>
<ol type="1">
<li><p>[countable, uncountable] the first letter of the English alphabet
英语字母表的第 1 个字母</p>
<ul>
<li><em>‘Apple’ begins with (an) A/‘A’.</em> apple 一词以字母 a
开头。</li>
</ul></li>
<li><p><strong>A</strong> [countable, uncountable] (music音乐) the 6th
note in the scale of C major A 音（C 大调音阶的第六级音）</p></li>
<li><p>[countable, uncountable] <strong>A (in/for something)</strong> a
grade that a student can get for a piece of work or course of study that
shows that it is excellent（学业成绩）第一等，优，甲</p>
<ul>
<li><em>She got (an) A in biology.</em> 她生物得了A。</li>
<li><em>He had straight A’s</em> (= nothing but A’s) <em>all through
high school.</em> 他读中学时成绩全部是 A。</li>
</ul></li>
<li><p><strong>A</strong> [uncountable] used to represent the first of
two or more possibilities（表示两个或更多可能性中的）第一个</p>
<ul>
<li><em>Shall we go for plan A or plan B?</em>
我们采用第一方案还是第二方案？</li>
</ul></li>
<li><p><strong>A</strong> [uncountable] used to represent a person, for
example in an imagined situation or to hide their
identity（代表一个假设的或不指名的人）甲</p>
<ul>
<li><em>Assume A knows B is guilty.</em> 假定甲知道乙有罪。</li>
</ul></li>
</ol>
<details class="note primary"><summary><p><strong>see also</strong> A-frame</p>
</summary>
<ul>
<li>BrE: /ˈeɪ freɪm/</li>
<li>NAmE: /ˈeɪ freɪm/</li>
</ul>
<p>(<em>also</em> <strong>A-frame house</strong>) (<em>especially North
American English</em>)</p>
<p>a house with very steep sides that meet at the top in the shape of
the letter A A 形房屋</p>

</details>
<details class="note primary"><summary><p><strong>see also</strong> A level</p>
</summary>
<ul>
<li>BrE: /ˈeɪ levl/</li>
<li>NAmE: /ˈeɪ levl/</li>
</ul>
<p>(<em>also</em> <strong>advanced level</strong>)</p>
<p>[countable, uncountable] a British exam taken in a particular
subject, usually in the final year of school at the age of 18
高级证书考试（英国中学单科考试，通常在毕业年级进行）</p>
<ul>
<li><em>You need three A levels to get onto this university course.</em>
你要学习这门大学课程，就需要通过三科高级证书考试。</li>
<li><em>What A levels are you doing?</em>
你在准备哪些科目的高级证书考试？</li>
<li><em>I’m doing maths A level.</em> 我在准备数学高级证书考试。</li>
<li><em>two A level passes/two passes at A level</em>
两门高级证书考试及格</li>
</ul>

</details>
<details class="note primary"><summary><p><strong>see also</strong> A-road</p>
</summary>
<ul>
<li>BrE: /ˈeɪ rəʊd/</li>
<li>NAmE: /ˈeɪ rəʊd/</li>
</ul>
<p>(in the UK) a road that is less important than a motorway, but wider
and straighter than a B-road（英国）干线公路，A
级公路（略次于高速公路，但较 B 级公路宽直）</p>

</details>
<h2 id="idioms">Idioms</h2>
<ul>
<li><p><strong>from A to B</strong></p>
<p>from one place to another从一地到另一地</p>
<ul>
<li><em>For me a car is just a means of getting from A to B.</em>
在我看来，汽车只不过是从一地到另一地的代步工具。</li>
</ul></li>
<li><p><strong>from A to Z</strong></p>
<p>including everything there is to know about something
从头到尾；彻底地；完全</p>
<ul>
<li><em>He knew his subject from A to Z.</em> 他通晓自己的学科。</li>
</ul></li>
</ul>
<h1 id="symbol---a">symbol - A</h1>
<h2 id="pronunciation-2">Pronunciation</h2>
<ul>
<li>BrE: /eɪ/</li>
<li>NAmE: /eɪ/</li>
</ul>
<h2 id="explanation-2">Explanation</h2>
<ol type="1">
<li><p>used in the UK before a number to refer to a particular important
road A 级公路，干线公路（英国公路代号，后接数字）</p>
<ul>
<li><em>the A34 to Newbury</em> 通往纽伯里的 A34 号（干线）公路</li>
</ul></li>
<li><p>used (but not in the US) before numbers that show standard metric
sizes of paper（除美国外，用于数字前表示标准纸张尺寸）A…纸（尺寸）’</p>
<ul>
<li><em>a sheet of <strong>A4</strong> paper</em> (= 297×210mm) 一张 A4
纸（= 297 毫米 × 210 毫米）</li>
<li><strong><em>A3</em></strong> (= 420×297mm) A3 纸（= 420 毫米 × 297
毫米）</li>
<li><strong><em>A5</em></strong> (= 210×148mm) A5 纸（= 210 毫米 × 148
毫米）</li>
</ul></li>
</ol>
<h1 id="abbreviation---a">Abbreviation - A</h1>
<h2 id="pronunciation-3">Pronunciation</h2>
<ul>
<li>BrE: /eɪ/</li>
<li>NAmE: /eɪ/</li>
</ul>
<h2 id="explanation-3">Explanation</h2>
<p>(in writing) amp 安，安培（电流单位）</p>
<h1 id="惯用法">惯用法</h1>
<ol type="1">
<li><p>a 和 an 用法的区别，一般说来，是在以辅音开首的词前面用
a，在以元音开首的词前面用
an。不过要注意，这里说的是辅音和元音，不是辅音字母和元音字母。</p>
<ul>
<li><p>如 hour 以辅音字母 h
开首，但读音作［ˈaʊə］，是以元音开首的，所以前面该用 an，不用 a。又如
one 以元音字母 o 开首，但读音作［wʌn］，是以辅音开首的，所以前面该用
a，不用 an。</p></li>
<li><p>又如 M. A.（=Master of Arts，文科硕士）里的 M
是辅音字母，但读音作［em］（M. A.
读［ˈemˈeɪ］或［emˈeɪ］），所以前面该用 an，不用 a。</p></li>
<li><p>MS（=manuscript，手稿）前面往往用 a 而不用 an，并不因为 M
是辅音字母，却因为读音往往作［ˈmænjʊskrɪpt］。</p></li>
<li><p>又如 8 并不是词，无所谓辅音或元音，但读音作［eɪt］，所以前面该用
an，不用 a。</p></li>
<li><p>&amp; 只是一个符号，因为它的名称是
ampersand，读音作［ˈæmpəsænd］，所以前面该用 an。</p></li>
</ul>
<p>据有些语法书说，以［h］音开首而没有重音的音节前面该用 an，如 <del>an
historian</del>，不作 a
historian。这规则现在可说不成立了（虽然还有人——尤其是英国人——遵守着），现在尽可用
a，用 an 反嫌不自然。例如：</p>
<ul>
<li>a habitual smile, a heroic act, a historian, a hotel, a
hypothesis</li>
</ul>
<p>有些英国人，在以［juː］或［jʊ］音开首的词（如 eulogy, euphonic,
European, university, united 和 usual）前面，用 an 而不用
a，在以［h］音开首的词（如 hero, history, hospital, hundred 和
hymn）前面也用 an 而不用 a，在 one 前面也用 an 而不用
a，这种人似乎现在比以前少了。</p></li>
<li><p>哪个名词前面可以用 a（或 an），哪个名词前面不可用 a（或
an）呢？</p>
<p>一般说来，可数名词前面可以用 a（或 an），不可数名词前面不可用 a（或
an），如可以说 a healthy boy，却不可说 <del>a health</del>，可以说 a
chair，却不可说 <del>a
furniture</del>。但事实并不这样简单。所谓“可数”和“不可数”，要看那个词的正确意思而定，不可根据它的普通汉译。</p>
<ul>
<li><p>如不可说 <del>a fun</del>, <del>an information</del>，却可以说 a
pastime, a knowledge。</p></li>
<li><p>又如 dance, hurry, interest, kiss 等词前面都可以用 a（或
an）。</p></li>
<li><p>又如 with child（有孕的），in class（在教室里），take
horse（上马），send word（通知）等习语里都不可用 a（或 an）。但 at a
loss（不知所措的），with a view to（以……为目的），on an
average（作为平均数），take a fancy to（喜欢）等习语里的 a（或
an）都是少不得的。这些都应该从习惯，不是几条规则所能包括得了的。</p></li>
</ul>
<p>一般说来，有复数形式的名词前面可以用 a（或
an），无复数形式的名词前面不可用 a（或 an）。如 boy 和 laugh 有复数形式
boys 和 laughs，所以可以说 <em>a</em> boy 和 <em>a</em>
laugh，completion 和 laughter 无复数形式，所以不可说 <del><em>a</em>
completion</del> 和 <del><em>a</em>
laughter</del>。但有些在习惯上无复数形式的名词，前面却往往也用 a（或
an）。这大概有下面四种情况：</p>
<ol type="1">
<li><p>多少有些抽象性的。例如：</p>
<ul>
<li>I have <em>a</em> great <em>admiration</em> for Gorky.</li>
<li>He has received <em>a</em> good <em>education</em>.</li>
<li>She has <em>a fondness</em> for roses.</li>
<li>You seem to have <em>a hatred</em> of dogs.</li>
<li>I am in <em>a hurry</em>.</li>
<li>There is <em>a bustle</em> going on in the house.</li>
<li>We need not make <em>a fuss</em> about the matter.</li>
<li>The arrival of the visitors caused <em>a</em> great
<em>stir</em>.</li>
<li>He speaks with <em>a lisp</em>.</li>
<li>She talks with <em>a stammer</em>.</li>
<li>We had <em>a</em> fine <em>catch</em> yesterday.
（我们昨天捉到了许多鱼。）</li>
<li>We had <em>a</em> plentiful <em>kill</em> today.
（我们今天打到了许多猎物。）</li>
<li>I hope you will give me <em>a lead</em>.
（我希望你给我开个头。）</li>
<li>He has <em>a</em> good <em>knowledge</em> of Russian.</li>
<li>You must avoid such <em>a waste</em> of time.</li>
<li>The book has <em>a wealth</em> of pictures.</li>
</ul></li>
<li><p>a（或 an）…指“一个……的泉源”。例如：</p>
<ul>
<li>A good pupil is <em>a credit</em> to his teachers.</li>
<li>A lazy boy is <em>a discredit</em> to his parents.</li>
<li>A lazy boy is <em>a dishonour</em> to his class.</li>
<li>A patriot is <em>an honour</em> to his country.</li>
<li>Such cruelty is <em>a reproach</em> to modern society.</li>
<li>Terrorism is <em>a shame</em> to civilization.</li>
</ul></li>
<li><p>a（或 an）…指“一次……”，那名词本来是动词。例如：</p>
<ul>
<li>After <em>a run</em> (或 <em>a climb</em>，或 <em>a swim</em>) I had
<em>a wash</em> (或 <em>a rest</em>，或 <em>a feed</em>，或 <em>a
smoke</em>，或 <em>a read</em>).</li>
</ul></li>
<li><p>a…ing 指“一次……”。例如：</p>
<ul>
<li>Instead of giving the peasant <em>a hearing</em>, the heartless
landlord gave him <em>a</em> good <em>beating</em> (或 <em>a</em> good
<em>hiding</em>，或 <em>a</em> good <em>licking</em> 或 <em>a</em> good
<em>thrashing</em>) as well as <em>a</em> good <em>scolding</em>.</li>
</ul></li>
</ol></li>
<li><p>a（或 an）在下面几种情况里可以用在复数形式前面：</p>
<ol type="1">
<li><p>在有些习语里。例如：</p>
<ul>
<li>a few (books), a very few (books), a good few (books), a good many
(books), a great many (books), a many (books)</li>
</ul></li>
<li><p>在表示时间或款项的短语前面。例如：</p>
<ul>
<li>a further five minutes, a mere two hours, a very busy six weeks, a
whole three years, a pleasant spring holidays, an additional ¥60</li>
</ul></li>
<li><p>在若干在形式上是复数而在意思上是单数的单词前面。例如：</p>
<ul>
<li>a barracks, a bellows, a gallows, a headquarters, an innings, a
links, a means, a scissors, a shambles, a tongs</li>
</ul></li>
<li><p>在下列美国口语中。例如：</p>
<ul>
<li>a good ways, a great ways, a long ways</li>
</ul></li>
</ol></li>
<li><p>a（或
an）有时有（1）“一个而并不是那所要的一个”或（2）“任何一个”的意思。例如：</p>
<ul>
<li><p>I was expecting to hear from my father. I got <em>a</em> letter
indeed, but it was from a friend. (1)</p></li>
<li><p>I wanted to read <em>a</em> book, I did not care whether it was a
history, a novel, or a biography. (2)</p></li>
</ul>
<p>在这种用法里，a（或 an）该特别重读。</p></li>
<li><p>a（或
an）通常不用在人名、地名或其他专有名词的前面，但有例外：</p>
<ol type="1">
<li><p>指有某姓或某名的某人。例如：</p>
<ul>
<li><em>a</em> Smith（姓 Smith 的某人）</li>
<li><em>a</em> John Smith（名叫 John Smith 的某人）</li>
</ul></li>
<li><p>指在某时的某人、某地等。例如：</p>
<ul>
<li>He is now <em>a</em> different John Smith from what he was three
years ago.</li>
<li>He was met at the door by a contented Mary, not <em>an</em> angry
Mary.</li>
<li>Fifty years ago we little dreamt of such <em>a</em> Shanghai as we
have today.</li>
<li>Our children will find it hard to imagine <em>a</em> semi-feudal,
semi-colonial China.</li>
</ul></li>
<li><p>指跟某人、某地等相仿的人、地等。例如：</p>
<ul>
<li>He talks like <em>a</em> Johnson.（Johnson 指英国 18 世纪的大文豪
Samuel Johnson，很健谈，多妙论。）</li>
<li>The humorist considers himself <em>a</em> (second) Mark Twain.</li>
<li>Do you think it possible for the North Pole ever to have <em>a</em>
Shanghai?</li>
<li>We may look upon the romantic tragedy as <em>a</em> Chinese
<em>Romeo and Juliet</em>.</li>
</ul></li>
<li><p>指某人的作品。例如：</p>
<ul>
<li><em>A</em> new Michael Gold（当代美国作家）has appeared.</li>
<li><em>A</em> new Shakespeare（莎士比亚全集新版）is in
preparation.</li>
<li>I found <em>a</em> Picasso（毕加索画的画）on the wall.</li>
</ul></li>
<li><p>指某人所发明、设计或制造的机器等。例如：</p>
<ul>
<li><em>a</em> Remington（美国人 Philo Remington
所设计制造的打字机）</li>
<li><em>a</em> Merriam-Webster（美国 G. &amp; C. Merriam Company
出版，根据 Webster 原著编的词典）</li>
</ul></li>
<li><p>指“……的图或像”。例如：</p>
<ul>
<li><em>a</em> West Lake（一幅西湖图），<em>a</em>
Cupid（一幅爱神图或一个爱神像）</li>
</ul></li>
<li><p>指“好比……那回事”。例如：</p>
<ul>
<li><em>a</em> Dunkirk（敦刻尔克式撤退：1940 年 5、6
月间英军从法国北部港口城市 Dunkirk 大败撤退）</li>
<li><em>a</em> Munich（慕尼黑事件：1938 年 9 月 30
日德、英、法、意四国在德国南部慕尼黑城达成协议，允许当时的纳粹德国吞并捷克斯洛伐克的领土苏台德区，以图避免战争）</li>
</ul></li>
</ol></li>
<li><p>a（或 an）有时用在表示性质的抽象名词的前面。例如：</p>
<ul>
<li>The room was furnished with <em>a</em> simplicity that is almost
elegance. （这间房子的陈设有一种近似文雅的朴素。）</li>
<li>He answered my questions with <em>an</em> accuracy not to be
expected of an ordinary
schoolboy.（他回答了我的问题，准确得不像出自一个普通小学生之口。）</li>
<li>The bird disappeared with <em>a</em> startling
suddenness.（那只鸟惊人地忽然不见了。）</li>
</ul>
<p>在这种用法里，抽象名词后面通常有一个形容词从句（如第一句）或形容词短语（如第二句），否则它的前面有形容词（如第三句）。</p></li>
<li><p>a（或
an）用在物质名词前面指（1）“一种……”或（2）“一份……”或“一客……”。例如：</p>
<ul>
<li><em>a</em> green tea, <em>an</em> old wine (1)</li>
<li><em>a</em> coffee, <em>a</em> tea, <em>an</em>
ice（英：一客冰淇淋，美：一客冷饮），<em>a</em> whisky and soda (2)</li>
</ul></li>
<li><p>a（或 an）通常不可用在 only
的前面，也不可用在属于最高级的词的前面。</p>
<p>如不可说 <del><em>an only</em> house</del>, <del><em>a best</em>
essay</del>, <del><em>a greatest</em> poet</del>, <del><em>a
longest</em> street</del>，但尽可说 <em>an only</em>
son（一个独生子），<em>a best</em> seller（一本畅销书），<em>a best</em>
man（一个男傧相），<em>a first</em>
night（某剧的第一夜表演）。因为这些已经成为习惯了。</p>
<p>a 用在副词 most 前面是很普通的，如 <em>a most</em> happy life 和
<em>a most</em> learned man。但该注意这里的 most
并不真正属于最高级，它的意思跟 very 相仿。</p></li>
<li><p>在一个名词被用来指它的本身的时候，往往不用 a（或 an）。例如：</p>
<ul>
<li>Apple is a noun.</li>
<li>He is dubbed ‘poet’.（人家给他“诗人”的诨名。）</li>
<li>We should not call every school
‘college’.（我们不该把每个学校都叫作“学院”。）</li>
<li>‘Rogue’ is too mild a term for him, he is an arrant
ruffian.（对他来说，“流氓”这名称是太轻了，他是一个十足的恶棍。）</li>
</ul>
<p>下面第一句里的 a 可有可无，第二句里的 a 不可省：</p>
<ul>
<li>He is dubbed (<em>a</em>) poet.</li>
<li>We should not call every school <em>a</em> college.</li>
</ul>
<p>注意 poet 和 college 都没有引号，跟上面的各句不同。</p></li>
<li><p>许多语法书里说，kind of 和 sort of 后面的名词的前面不该用 a（或
an），但事实上并非绝对不可用。例如：</p>
<ul>
<li>What kind (或 sort) of tree is this?</li>
<li>What kind (或 sort) of（<em>a</em>）man is he?</li>
</ul>
<p>第一句里不用 a，因为 kind 或 sort 明白地作“种类”解。第二句里可以用
a，因为 kind 或 sort 并不明白地作“种类”解。what kind (或 sort) of
(<em>a</em>) man 是“怎么样的一个人”的意思。</p>
<p>其实在指“种类”的场合，不但 kind of 和 sort of 后面的名词的前面不用
a（或 an），其他相似的短语后面也是这样。例如：</p>
<table>
<colgroup>
<col style="width: 26%">
<col style="width: 26%">
<col style="width: 23%">
<col style="width: 23%">
</colgroup>
<tbody>
<tr>
<td style="text-align: center;">a kind of car</td>
<td style="text-align: center;">kinds of car</td>
<td style="text-align: center;">a sort of car</td>
<td style="text-align: center;">sorts of car</td>
</tr>
<tr>
<td style="text-align: center;">a brand of car</td>
<td style="text-align: center;">brands of car</td>
<td style="text-align: center;">a class of car</td>
<td style="text-align: center;">classes of car</td>
</tr>
<tr>
<td style="text-align: center;">a form of car</td>
<td style="text-align: center;">forms of car</td>
<td style="text-align: center;">a make of car</td>
<td style="text-align: center;">makes of car</td>
</tr>
<tr>
<td style="text-align: center;">a style of car</td>
<td style="text-align: center;">styles of car</td>
<td style="text-align: center;">a type of car</td>
<td style="text-align: center;">types of car</td>
</tr>
<tr>
<td style="text-align: center;">a variety of car</td>
<td style="text-align: center;">varieties of car</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table></li>
<li><p>part of 前面用 a 也有，不用 a 也有，但意思略有不同。例如：</p>
<ul>
<li>part of it（它的一部分：不一定一半以下，也不一定一半以上）</li>
<li><em>a</em> part of it（它的一小部分：一半以下）</li>
</ul>
<p>但 great part of it 和 <em>a</em> great part of it
是没有区别的。不一定一半以下，也不一定一半以上。</p></li>
<li><p>a（或 an）不用在 a change of 后面的名词的前面。例如：</p>
<ul>
<li>a change of address, a change of name, a change of scene</li>
</ul></li>
<li><p>a（或 an）不用在临时被用来作为不可数名词的前面。例如：</p>
<ul>
<li>five hundred miles of railway, a stretch of road, an acre of garden,
an expanse of lake</li>
</ul></li>
<li><p>下面各种表达方式里的 no 都是形容词，等于 not a：</p>
<ul>
<li>no small value（很大的价值），no mean city（名城），no such
man（没有这样的人），no other person than…（不是别人，却是……）。</li>
</ul>
<p>所以不可说：</p>
<ul>
<li><del><em>a</em> no small value</del>, <del><em>a</em> no mean
city</del>, <del>no such <em>a</em> man</del>, <del>no other <em>a</em>
person than…</del></li>
</ul>
<p><del>a no mean city</del> 是不可说的，但 a no meaner city
是可以说的，no mean<em>er</em> 里的 no 是副词，修饰 meaner，并不等于 not
a，所以前面用 a。</p>
<p>比较：</p>
<ul>
<li>This is no (形容词) mean city. （这是一个名城。）</li>
<li>This is <em>a</em> no (副词) meaner city (than that).
（这是一个［跟那个］同样有名的城。）</li>
<li>There is no (形容词) meaner city (than that).
（没有［比那个］更无名的城。）</li>
<li>There is <em>a</em> no (副词) meaner city (than that).
（有一个［跟那个］同样有名的城。）</li>
</ul></li>
<li><p>在指职位、头衔、等级等的单词前面大都不用 a（或 an）。例如：</p>
<ul>
<li>They asked me to act as (<em>an</em>) interpreter.</li>
<li>I served them fairly well in the capacity of (<em>an</em>)
interpreter.</li>
<li>I served them fairly well in my capacity as (<em>an</em>)
interpreter.</li>
<li>She has obtained a position as (或 of) (<em>a</em>) typist.</li>
<li>He has left his situation as (或 of) (<em>a</em>) gardener.</li>
<li>He is (<em>a</em>) professor of philosophy at that university.</li>
<li>He has the degree of Doctor of Literature.</li>
<li>He soon rose to the rank of colonel.</li>
<li>The title of model worker has been conferred on the young man.</li>
<li>John Keats, English poet, was born in 1795.</li>
</ul>
<p>注意在 As <em>a</em> physician, he does not deserve much praise
等句子里的 as 等于 considered as，那 a 是不可少的。</p></li>
<li><p>在若干动词后面用作表语的名词的前面习惯不用 a（或 an）。例如：</p>
<ul>
<li>He commenced schoolmaster in 1956.
（commence［d］的这种用法现在不很普通）</li>
<li>He turned soldier at twenty-one.</li>
<li>The boy was bound apprentice to a carpenter.</li>
</ul></li>
<li><p>在若干独立短语里不用 a（或 an）。例如：</p>
<ul>
<li>The old man was sitting in a chair, pipe in mouth.</li>
<li>The huntsman entered the forest, gun in hand.</li>
</ul></li>
<li><p>在下面各短语和类似的短语里都不用 a（或 an）：</p>
<ul>
<li>hard of heart, large of limb, nimble of foot, quick of eye, pale of
face</li>
</ul></li>
<li><p>下面各句里都不用 a（或 an），那是因为多少有些感叹的意味：</p>
<ul>
<li>Lucky dog! （幸运儿！）Lucky beggar! （幸运儿！）You beauty!</li>
<li>You fool! You fool you! You lucky rascal! （你好一个幸运儿！）</li>
<li>‘Keep by me, you lovely thing!’ the girl said to her cat.</li>
<li>The old man got run over, poor fellow.</li>
<li>Poor man, he never knew what love was like.</li>
</ul></li>
<li><p>a（或 an）是“一”，one 也是“一”，在用法上有下面几点该注意：</p>
<ol type="1">
<li><p>固定习语里的 a（或 an）和 one 不可调换。如 once upon <em>a</em>
time（从前有一次）和 <em>one</em> day（有一天）里的 a 和 one
不可互换。<em>an</em> hour or two（一二小时，若干小时）和 <em>one</em>
or two hours 里的 an 和 one 不可互换。to <em>a</em>
man（全体地）不可改作 to <em>one</em> man。<em>one</em> man <em>one</em>
vote（每人投一票）不可改作 <del><em>a</em> man <em>a</em>
vote</del>。但“一个……还是两个”可以说 one…or two。例如：Do you spell
‘traveller’ with <em>one</em> ‘1’ <em>or two</em>?</p>
<p>注意下面每组里的两句意思相同，但用了 <em>a</em> 该有 on，用了
<em>one</em> 没有 on：</p>
<blockquote>
<ul>
<li><em>On a</em> warm day a stranger came to see me.</li>
<li><em>One</em> warm day a stranger came to see me.</li>
</ul>
</blockquote>
<p><br></p>
<blockquote>
<ul>
<li>The ship sank <em>on a</em> stormy night.</li>
<li>The ship sank <em>one</em> stormy night.</li>
</ul>
</blockquote></li>
<li><p>有些习语用 a 或 one 都可以。如 at <em>a</em> blow 和 at
<em>one</em> blow（一下子地），in <em>a</em> word 和 in <em>one</em>
word（简单地说），be of <em>a</em> mind 和 be of <em>one</em>
mind（同意），<em>a</em> hundred per cent…和 <em>one</em> hundred per
cent…（十足地……）。</p></li>
<li><p>有时用 a 和用 one 意思不同。如 as <em>a</em> man
是“就他的性格而论”，as <em>one</em> man 是“大家一致地”，at <em>a</em>
time 是“每次”（如 three at a time），at <em>one</em> time
是“从前有一个时期”（如 At one time we met every day）。</p>
<p>注意下面每组里的两种表达方式意思不同：</p>
<blockquote>
<ul>
<li>more than <em>a</em> year （比一年多些，如一年又三个月）</li>
<li>more than <em>one</em> year （不止一个年头，如两年或三年）</li>
</ul>
</blockquote>
<p><br></p>
<blockquote>
<ul>
<li>more than <em>a</em> decade （比十年多些，如十一年或十二年）</li>
<li>more than <em>one</em> decade
（不止一个十年，如二十年或三十年）</li>
</ul>
</blockquote></li>
<li><p>在姓或名前面，用 a（或 an）或 one 意思相同。如 <em>a</em> Smith
和 <em>one</em> Smith 都是“一个姓 Smith 的人”。就语法讲，one Smith 里的
one 被看作形容词或代词都讲得通。</p></li>
<li><p>在 dozen, hundred, thousand 和 million 前面，用 a 或 one
意思相同，用 a 普通些。如 <em>a</em> dozen（一打），<em>a</em>
hundred（一百），<em>a</em> thousand（一千），<em>a</em>
million（一百万），把 a 改作
one，意思不变，但往往有跟“二打、三打”等，“二百、三百”等，“二千、三千”等，“二百万、三百万”等对比的意味。</p>
<p>注意在下面的习语里都用 a，不可用 one：</p>
<ul>
<li><em>a</em> hundred（许多，如 a hundred things），</li>
<li><em>a</em> thousand（许多，如 a thousand thanks），</li>
<li><em>a</em> hundred and one（许多，如 a hundred and one points of
usage），</li>
<li><em>a</em> thousand and one（许多，如 a thousand and one points of
usage），</li>
<li>not <em>a</em> hundred miles away（不远、近），</li>
<li>one in <em>a</em> thousand（极难得的一个）</li>
</ul></li>
<li><p>a（或 an）只有“一”的意思，却并不跟“二、三、四、五”等相对，one
便可以有这种对比的意味。如 I have <em>a</em> pen 只说“我有一枝笔”，I
have <em>one</em> pen 便可有“我并没有两枝、三枝或更多枝笔”的意思。</p>
<p>比较下面两句：</p>
<ul>
<li>Can <em>a</em> boy do this? （回答可能是 No, but a man can。）</li>
<li>Can <em>one</em> boy do this? （回答可能是 No, but two boys
can。）</li>
</ul>
<p>列宁著的 <em>One Step Forward, Two Steps Backward</em> 里的 One
不可改作 A。下面两句里的 one 也不可改作 a：</p>
<ul>
<li>I have one pen, but my sister has three pens.</li>
<li>I have one pen, but three pencils.</li>
</ul>
<p>注意上面说 a 或 an 不跟“二、三、四、五”等对比，并不说不可跟 two,
three, four, five 等连用。I have a pen, <em>but</em> three pencils 里的
a 该改作 one，但 I have a pen and three pencils 里的 a 却不必改作
one。</p></li>
<li><p>注意下面各句的意思不同：</p>
<ul>
<li>There is <em>a</em> pen on the table.
（桌上有一枝钢笔：不是一枝铅笔或一本书。）</li>
<li>There is <em>one</em> pen on the table.
（桌上有一枝钢笔：不是两枝、三枝或更多枝钢笔。）</li>
<li><em>A</em> pen is on the table. （跟第一句意思相同，很少见。）</li>
<li><em>One</em> pen is on the table.
（一枝钢笔在桌上：也许还有其他笔，但在桌上没有。）</li>
</ul></li>
<li><p>说“每一……”计算价钱、款项、速度等，用 a（或 an），不用
one。例如：</p>
<ul>
<li>¥3.10 <em>a</em> dozen（每打三元一角），¥ 70 <em>a</em>
month（每月七十元），</li>
<li>twice <em>a</em> week（每星期两次），ten miles <em>an</em>
hour（每小时十英里）</li>
</ul>
<p>这种用法里的 a 原来是介词，但现在不妨把它看作冠词。</p></li>
</ol></li>
<li><p>of a（或 an）…表明在时间上经常的行为：</p>
<ul>
<li>We would sit together in the park <em>of a morning</em>.</li>
<li>They often met <em>of an afternoon</em>.</li>
<li>The artist may have frequently been seen strolling along the street
<em>of an evening</em>.</li>
<li>His friends used to go to see him in his cottage <em>of a
Sunday</em>.</li>
</ul>
<p>注意：</p>
<ol type="1">
<li>这种结构现在少用。</li>
<li>只用于经常的事，不用于一次的事，如不可说 <del>The old man died of a
morning</del>。</li>
</ol></li>
<li><p>由 a…of a…构成一种习语。</p>
<p>如 a fool of a man 是“一个呆子般的男子”，a gem of a poem
是“一首宝石般（精致）的诗”，a mountain of a wave
是“一个高山似的浪”。又例如：</p>
<ul>
<li>his angel of a wife, a beast of a place (一个很脏的地方), her brute
of a husband, a devil of a hurry (极度的匆忙), his dome of a forehead, a
great elephant of a woman, a jewel of an assistant, a kitten of a girl,
a lamb of a temper（像羔羊般驯服的脾气）, a love of a ring
(一枚极可爱的戒指), a poem of a hotel (一个像诗一般幽雅的旅馆), that
rascal of a landlord, her tyrant of a father</li>
</ul>
<p>注意 a…of a…里的两个名词不可互调，如 a boy of a girl
是“一个男孩子似的女孩子”，a girl of a boy
是“一个女孩子似的男孩子”，意思各不相同。</p></li>
<li><p>a（或 an）通常用在一般形容词的前面，如 <em>a beautiful</em>
garden，但也有几个例外。a（或 an）该用在 what、such 和 many
三个形容词的后面。</p>
<p>例如：</p>
<ul>
<li><em>What a</em> beautiful garden! <em>such a</em> garden, <em>many
a</em> garden</li>
</ul>
<p>假使形容词前面有 how, however, as, so 或 too，那末 a（或
an）也用在这形容词的后面。例如：</p>
<ul>
<li><em>how beautiful a</em> garden, <em>however beautiful a</em>
garden, <em>as beautiful a</em> garden as I ever saw, <em>so beautiful
a</em> garden, <em>too beautiful a</em> garden</li>
</ul>
<p><em>a so beautiful</em> garden 和 <em>a too beautiful</em> garden
这种结构也有，但不很自然。似乎 a so beautiful garden 比 a too beautiful
garden 更不自然。当代英国作家 William Somerset Maugham 的 <em>On a
Chinese Screen</em> 的 Romance 一篇里有 somewhat Ouidaesque a
fashion，当然极不普通。</p>
<p>假使形容词前面有 no less，那末 a（或 an）用在 no less
的前面或这形容词的后面都可以。例如：</p>
<ul>
<li><em>a no less beautiful</em> garden, <em>no less beautiful</em> a
garden 前者比后者自然。假使后面加上 than yours，than this 等，改作 a
garden no less beautiful than…就更自然些。</li>
</ul>
<p>假使形容词前面有 no more，那末 a（或 an）就用在 no more 的前面，如
<em>a no more beautiful</em> garden。不过 <em>no more beautiful a</em>
garden 这种结构也有。</p>
<p>假使形容词前面有 more 或 less（不是 no more 或 no less），那末 a（或
an）就用在 more 或 less 的前面，如 <em>a more</em>（或
<em>less</em>）<em>beautiful</em> garden。上面所说 no less 里的 less
是副词，no less <em>a</em> person than… 中的 less
是形容词，作“较不重要”解，a 的位置不可改动。</p></li>
<li><p>a（或 an）可以用在 quite 和 rather
的前面，也可以用在它们的后面。例如：</p>
<ul>
<li><em>a quite big</em> dog, <em>quite a big</em> dog,</li>
<li><em>a rather big</em> dog, <em>rather a big</em> dog</li>
</ul>
<p>在口语里 quite a（或 an）…和 rather a（或 an）…比 a quite…和 a
rather…普通。</p>
<p>注意 big 和 dog 总是连在一起，不该说：</p>
<ul>
<li><del><em>quite big</em> a dog</del>, <del><em>rather big</em> a
dog</del></li>
</ul></li>
<li><p>就普通语法讲，<em>a</em> black and <em>a</em> white dog
是“一只黑狗和一只白狗”，<em>a</em> black and white dog
是“一只黑白花狗”，<em>a</em> journalist and <em>an</em> author
是“一个新闻记者和一个作家”，<em>a</em> journalist and author
是“一个新闻记者兼作家”。</p>
<p>但事实上为了加强语气，也有用两个 a（或 an），一个 a 和一个 an，或一个
an 和一个 a 而指一个人的。例如：</p>
<ul>
<li>He has become <em>a</em> sadder and <em>a</em> wiser man.</li>
<li>He is <em>a</em> journalist and <em>an</em> author.</li>
</ul>
<p>也有虽然只用一个 a（或 an）而指两个人的。例如：</p>
<ul>
<li><em>A</em> man and woman are walking arm-in-arm.</li>
<li><em>A</em> boy and girl are playing together.</li>
</ul>
<p>但假使具有相对立的意思，便该用两个 a（或 an），一个 a 和一个
an，或一个 an 和一个 a。例如：</p>
<ul>
<li><em>A</em> man and <em>a</em> woman may not always agree on such a
question.</li>
</ul>
<p>明明两件东西而通常配成一件的，只用一个 a（或 an）。例如：</p>
<ul>
<li><em>a</em> knife and fork, <em>a</em> cup and saucer, <em>a</em>
needle and thread, <em>a</em> coat and tie, <em>a</em> short beard and
moustache, <em>a</em> swimming head and parched throat</li>
</ul></li>
<li><p>在两个或两个以上的名词连用的场合，通常不用 a（或 an）。例如：</p>
<ul>
<li>We are brother and sister.</li>
<li>He was printer, publisher, and editor before 1949.</li>
<li>This room is study, bedroom, and sitting room all in one.</li>
<li>This article is meant to appear in newspaper or magazine.</li>
<li>Like father, like son. （有其父必有其子。——谚语）</li>
<li>Diamond cut diamond. （旗鼓相当。）</li>
<li>Dog eat dog. （同类相残。）</li>
</ul></li>
<li><p>假使把 though he is a child 里的 child 放在开首，a 便该去掉，作
child though he is。child as he is 有同样的意思，也不该有 a。</p></li>
<li><p>下面两句里都有 a：</p>
<ul>
<li><em>A</em> baby never sat so gracefully.</li>
<li>Did <em>a</em> baby ever sit so gracefully?</li>
</ul>
<p>假使把 never 或 ever 放在 baby 的前面，通常把 a 去掉。例如：</p>
<ul>
<li>Never did baby sit so gracefully.</li>
<li>Did ever baby sit so gracefully?</li>
</ul>
<p>never a…作 no…解，不过语气强些，a 决不可省。例如：He found <em>never
a</em> baby there. 这里的 never 并不指时间。</p></li>
<li><p>He is <em>a</em> scholar 等句子里的 a（或
an）当然不可省去，但注意下面各句里都不用 a（或 an）：</p>
<ul>
<li>He is artist enough to appreciate these pictures.</li>
<li>Surely you are scholar enough to read this old book.</li>
<li>I was fool enough to believe him.</li>
</ul>
<p>这里 artist, scholar 和 fool 前面都不用 a（或 an），因为后面加上了
enough，把这些名词抽象化了。</p></li>
<li><p><em>A Tale of Two Cities</em> 里有 A，但说 Dickens’s <em>A Tale
of Two Cities</em> 或 Dickens’s <em>Tale of Two Cities</em> 都可以。the
<em>Tale of Two Cities</em> that I bought yesterday 里不可在 Tale
前面加上 A。</p></li>
<li><p>上面所讲到的 a（或
an）的省略，可说都跟语法有关，都是一般的用法。还有为了节省空间、时间、金钱或精力，或为了引起注意力，而省去
a（或 an）的，主要有下面各种情况：</p>
<ol type="1">
<li>报纸标题：
<ul>
<li>(A) New Book by E. G. Flynn (当代美国进步女作家) Published.</li>
<li>(A) Noted Scientist to Make (a) Report on (an) Important Invention
at (a) Local Technical School.</li>
</ul></li>
<li>工商业文件：
<ul>
<li>(A) Copy of the booklet is enclosed.</li>
<li>(A) Duplicate of this letter will be sent to the management.</li>
</ul></li>
<li>广告：
<ul>
<li>(A) Fully furnished flat to let.</li>
<li>(A) Secondhand typewriter wanted.</li>
</ul></li>
<li>电报：
<ul>
<li>(A) Girl born today.</li>
<li>Brother away on (a) visit.</li>
</ul></li>
<li>公告：
<ul>
<li>(A) School Ahead.</li>
<li>(An) Exit.</li>
</ul></li>
<li>日记：
<ul>
<li>Attended (a) lecture on IT technology.</li>
<li>Got (a) long letter from James.</li>
</ul></li>
<li>非正式信札：
<ul>
<li>Hope to send you (a) picture of the Lake soon.</li>
<li>Could you let me have (a) summary of the story?</li>
</ul></li>
<li>注释和定义：
<ul>
<li>Fleet Street: (A) Famous old London street, now the location of many
newspaper offices, often used allusively for the English press.</li>
<li>landscape: (A) Piece of land scenery.</li>
</ul></li>
</ol></li>
<li><p>few 和 <em>a</em> few 不同。few
是“很少”，有“几乎没有”的意思。<em>a</em> few
是“若干”，有“颇有几个”的意思。但两种表达方式的不同，不在于实际数目的大小，却在于说话者的语意。如一篇作文里有三个错误，要是你说
There are <em>few</em> mistakes in
it，你在说它“错误很少”，便是说它好。要是你说 There are <em>a few</em>
mistakes in it，你在说它“有若干错误”，便是说它不好。可以说 few, or
perhaps none 和 a few, or perhaps many。注意 only a few 却等于
few，也是“很少”的意思。</p>
<p>little 和 <em>a</em> little 的不同，相当于 few 和 <em>a</em> few
的不同。如 <em>little</em> trouble 是“很少麻烦”或“几乎没有麻烦”，<em>a
little</em> trouble 是“若干麻烦”或“颇有些麻烦”。</p></li>
<li><p>下面各种表达方式里都有 half a（或 half an）：</p>
<ul>
<li>half a mile, half a month, half an inch, half an hour, half a
bottle, half a cup, half a dozen, half a million</li>
</ul>
<p>在这种用法里，把 half 看作形容词或看作名词后面省去 of 都可以。但不论
half 是形容词还是名词，a 总是冠词，所以下面各种表达方式里的 a 或 an
照理都该去掉：</p>
<ul>
<li>that half <em>a</em> mile, this half <em>a</em> month, another half
<em>an</em> inch, the next half <em>an</em> hour, my half <em>a</em>
dozen</li>
</ul>
<p>不过这个多余的 a（或 an）事实上很常见，因为 half a…或 half
an…用得很多，好似成为一个单位了。甚至有人说 a half an hour。 上面所举的
half a mile, half a month 等表达方式里的 half a（或 half
an）英美通用。但在美国也往往用 a half。例如：</p>
<ul>
<li><em>a half</em> mile, <em>a half</em> month, <em>a half</em> inch,
<em>a half</em> hour</li>
</ul>
<p>a half 在英国也用，但不用在表示距离、时间、数量等的词的前面。如不说 a
half mile, a half month 等，却说 a half length, a half share, a half
conviction 等。</p>
<p>…and a half 和…and a half…两种表达方式意思相同，如 two miles and a
half 和 two and a half miles
都是“两英里半”。这两种表达方式是英美通用的。即使在英国也并没有 two miles
and <em>half a</em> mile, two and <em>half a</em> mile 或 two and
<em>half a</em> miles 的结构。</p>
<p>把 two miles and a half 跟 two and a half miles
比较起来，前者好些，因为 a half miles
读起来似乎很不自然。就时间讲，先有前者，后有后者，后者是从miles
这种写法产生出来的。同样地，a foot and a quarter 比 one and a quarter
feet 好些。</p>
<p>上面说过，that half <em>a</em> mile 等表达方式里的 a
照理该去掉。下面各种表达方式里的 a 照理也该去掉：</p>
<ul>
<li>those two miles and <em>a</em> half,</li>
<li>those two and <em>a</em> half miles,</li>
<li>the foot and <em>a</em> quarter,</li>
<li>the one and <em>a</em> quarter feet</li>
</ul>
<p>但习惯上这种多用的 a 可说是不可少的，省去了反而觉得不自然。</p></li>
</ol>
<h1 id="reference">Reference</h1>
<ol type="1">
<li><p>Diana Lea, Jennifer Bradbery. <em>Oxford Advanced Learner’s
Dictionary, 10th edition.</em> Oxford University Press, 2020.</p></li>
<li><p>Margaret Deuter, Jennifer Bradbery, Joanna Turnbull.
<em>牛津高阶英汉双解词典，第 9 版.</em> 商务印书馆, 2018.</p></li>
<li><p>葛传槼. <em>葛传槼英语惯用法词典.</em> 上海译文出版社,
2012.</p></li>
</ol>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/css/markmap.css">

<script src="/js/markmap.js"></script>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>牛津5000</tag>
        <tag>英语词汇</tag>
      </tags>
  </entry>
  <entry>
    <title>牛津 3000 词汇表（The Oxford 3000）</title>
    <url>/posts/e28b5ccc.html</url>
    <content><![CDATA[<h1 id="the-oxford-3000">The Oxford 3000™</h1>
<p>The Oxford 3000 is the list of the 3000 most important words to learn
in English, from A1 to B2 level.</p>
<blockquote>
<p>The PDF version can be found at <a href="https://www.oxfordlearnersdictionaries.com/external/pdf/wordlists/oxford-3000-5000/The_Oxford_3000.pdf">The_Oxford_3000.pdf</a>.</p>
</blockquote>
<span id="more"></span>
<h2 id="a">A</h2>
<table>
<colgroup>
<col style="width: 33%">
<col style="width: 34%">
<col style="width: 31%">
</colgroup>
<tbody>
<tr>
<td style="text-align: left;"><a href="https://josh-gao.top/posts/6635e93f.html">a, an</a> <em>indefinite
article</em> A1</td>
<td style="text-align: left;">agreement <em>n.</em> B1</td>
<td style="text-align: left;">appointment <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">abandon <em>v.</em> B2</td>
<td style="text-align: left;">ah <em>exclam.</em> A2</td>
<td style="text-align: left;">appreciate <em>v.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">ability <em>n.</em> A2</td>
<td style="text-align: left;">ahead <em>adv.</em> B1</td>
<td style="text-align: left;">approach <em>n.</em>, <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">able <em>adj.</em> A2</td>
<td style="text-align: left;">aid <em>n.</em>, <em>v.</em> B2</td>
<td style="text-align: left;">appropriate <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">about <em>prep.</em>, <em>adv.</em>
A1</td>
<td style="text-align: left;">aim <em>v.</em>, <em>n.</em> B1</td>
<td style="text-align: left;">approval <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">above <em>prep.</em>, <em>adv.</em>
A1</td>
<td style="text-align: left;">air <em>n.</em> A1</td>
<td style="text-align: left;">approve <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">abroad <em>adv.</em> A2</td>
<td style="text-align: left;">aircraft <em>n.</em> B2</td>
<td style="text-align: left;">approximately <em>adv.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">absolute <em>adj.</em> B2</td>
<td style="text-align: left;">airline <em>n.</em> A2</td>
<td style="text-align: left;">April <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">absolutely <em>adv.</em> B1</td>
<td style="text-align: left;">airport <em>n.</em> A1</td>
<td style="text-align: left;">architect <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">academic <em>adj.</em>B1, <em>n.</em>
B2</td>
<td style="text-align: left;">alarm <em>n.</em> B1, <em>v.</em> B2</td>
<td style="text-align: left;">architecture <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">accept <em>v.</em> A2</td>
<td style="text-align: left;">album <em>n.</em> B1</td>
<td style="text-align: left;">area <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">acceptable <em>adj.</em> B2</td>
<td style="text-align: left;">alcohol <em>n.</em> B1</td>
<td style="text-align: left;">argue <em>v.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">access <em>n.</em>, <em>v.</em> B1</td>
<td style="text-align: left;">alcoholic <em>adj.</em> B1</td>
<td style="text-align: left;">argument <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">accident <em>n.</em> A2</td>
<td style="text-align: left;">alive <em>adj.</em> A2</td>
<td style="text-align: left;">arise <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">accommodation <em>n.</em> B1</td>
<td style="text-align: left;">all <em>det.</em>, <em>pron.</em> A1,
<em>adv.</em> A2</td>
<td style="text-align: left;">arm <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">accompany <em>v.</em> B2</td>
<td style="text-align: left;">all right <em>adj.</em>/<em>adv.</em>,
<em>exclam.</em> A2</td>
<td style="text-align: left;">armed <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">according to <em>prep.</em> A2</td>
<td style="text-align: left;">allow <em>v.</em> A2</td>
<td style="text-align: left;">arms <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">account <em>n.</em> B1, <em>v.</em>
B2</td>
<td style="text-align: left;">almost <em>adv.</em> A2</td>
<td style="text-align: left;">army <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">accurate <em>adj.</em> B2</td>
<td style="text-align: left;">alone <em>adj.</em>/<em>adv.</em> A2</td>
<td style="text-align: left;">around <em>prep.</em>, <em>adv.</em>
A1</td>
</tr>
<tr>
<td style="text-align: left;">accuse <em>v.</em> B2</td>
<td style="text-align: left;">along <em>prep.</em>, <em>adv.</em>
A2</td>
<td style="text-align: left;">arrange <em>v.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">achieve <em>v.</em> A2</td>
<td style="text-align: left;">already <em>adv.</em> A2</td>
<td style="text-align: left;">arrangement <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">achievement <em>n.</em> B1</td>
<td style="text-align: left;">also <em>adv.</em> A1</td>
<td style="text-align: left;">arrest <em>v.</em>, <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">acknowledge <em>v.</em> B2</td>
<td style="text-align: left;">alter <em>v.</em> B2</td>
<td style="text-align: left;">arrival <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">acquire <em>v.</em> B2</td>
<td style="text-align: left;">alternative <em>n.</em> A2, <em>adj.</em>
B1</td>
<td style="text-align: left;">arrive <em>v.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">across <em>prep.</em>, <em>adv.</em>
A1</td>
<td style="text-align: left;">although <em>conj.</em> A2</td>
<td style="text-align: left;">art <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">act <em>v.</em> A2, <em>n.</em> B1</td>
<td style="text-align: left;">always <em>adv.</em> A1</td>
<td style="text-align: left;">article <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">action <em>n.</em> A1</td>
<td style="text-align: left;">amazed <em>adj.</em> B1</td>
<td style="text-align: left;">artificial <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">active <em>adj.</em> A2</td>
<td style="text-align: left;">amazing <em>adj.</em> A1</td>
<td style="text-align: left;">artist <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">activity <em>n.</em> A1</td>
<td style="text-align: left;">ambition <em>n.</em> B1</td>
<td style="text-align: left;">artistic <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">actor <em>n.</em> A1</td>
<td style="text-align: left;">ambitious <em>adj.</em> B1</td>
<td style="text-align: left;">as <em>prep.</em> A1, <em>adv.</em>,
<em>conj.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">actress <em>n.</em> A1</td>
<td style="text-align: left;">among <em>prep.</em> A2</td>
<td style="text-align: left;">ashamed <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">actual <em>adj.</em> B2</td>
<td style="text-align: left;">amount <em>n.</em> A2, <em>v.</em> B2</td>
<td style="text-align: left;">ask <em>v.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">actually <em>adv.</em> A2</td>
<td style="text-align: left;">analyse <em>v.</em> B1</td>
<td style="text-align: left;">asleep <em>adj.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">ad <em>n.</em> B1</td>
<td style="text-align: left;">analysis <em>n.</em> B1</td>
<td style="text-align: left;">aspect <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">adapt <em>v.</em> B2</td>
<td style="text-align: left;">ancient <em>adj.</em> A2</td>
<td style="text-align: left;">assess <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">add <em>v.</em> A1</td>
<td style="text-align: left;">and <em>conj.</em> A1</td>
<td style="text-align: left;">assessment <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">addition <em>n.</em> B1</td>
<td style="text-align: left;">anger <em>n.</em> B2</td>
<td style="text-align: left;">assignment <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">additional <em>adj.</em> B2</td>
<td style="text-align: left;">angle <em>n.</em> B2</td>
<td style="text-align: left;">assist <em>v.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">address <em>n.</em> A1, <em>v.</em>
B2</td>
<td style="text-align: left;">angry <em>adj.</em> A1</td>
<td style="text-align: left;">assistant <em>n.</em>, <em>adj.</em>
A2</td>
</tr>
<tr>
<td style="text-align: left;">administration <em>n.</em> B2</td>
<td style="text-align: left;">animal <em>n.</em> A1</td>
<td style="text-align: left;">associate <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">admire <em>v.</em> B1</td>
<td style="text-align: left;">ankle <em>n.</em> A2</td>
<td style="text-align: left;">associated <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">admit <em>v.</em> B1</td>
<td style="text-align: left;">anniversary <em>n.</em> B2</td>
<td style="text-align: left;">association <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">adopt <em>v.</em> B2</td>
<td style="text-align: left;">announce <em>v.</em> B1</td>
<td style="text-align: left;">assume <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">adult <em>n.</em> A1, <em>adj.</em>
A2</td>
<td style="text-align: left;">announcement <em>n.</em> B1</td>
<td style="text-align: left;">at <em>prep.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">advance <em>n.</em>, <em>v.</em>,
<em>adj.</em> B2</td>
<td style="text-align: left;">annoy <em>v.</em> B1</td>
<td style="text-align: left;">athlete <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">advanced <em>adj.</em> B1</td>
<td style="text-align: left;">annoyed <em>adj.</em> B1</td>
<td style="text-align: left;">atmosphere <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">advantage <em>n.</em> A2</td>
<td style="text-align: left;">annoying <em>adj.</em> B1</td>
<td style="text-align: left;">attach <em>v.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">adventure <em>n.</em> A2</td>
<td style="text-align: left;">annual <em>adj.</em> B2</td>
<td style="text-align: left;">attack <em>n.</em>, <em>v.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">advertise <em>v.</em> A2</td>
<td style="text-align: left;">another <em>det.</em>/<em>pron.</em>
A1</td>
<td style="text-align: left;">attempt <em>n.</em>, <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">advertisement <em>n.</em> A2</td>
<td style="text-align: left;">answer <em>n.</em>, <em>v.</em> A1</td>
<td style="text-align: left;">attend <em>v.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">advertising <em>n.</em> A2</td>
<td style="text-align: left;">anxious <em>adj.</em> B2</td>
<td style="text-align: left;">attention <em>n.</em>, <em>exclam.</em>
A2</td>
</tr>
<tr>
<td style="text-align: left;">advice <em>n.</em> A1</td>
<td style="text-align: left;">any <em>det.</em>, <em>pron.</em> A1,
<em>adv.</em> A2</td>
<td style="text-align: left;">attitude <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">advise <em>v.</em> B1</td>
<td style="text-align: left;">anybody <em>pron.</em> A2</td>
<td style="text-align: left;">attract <em>v.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">affair <em>n.</em> B2</td>
<td style="text-align: left;">any more <em>adv.</em> A2</td>
<td style="text-align: left;">attraction <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">affect <em>v.</em> A2</td>
<td style="text-align: left;">anyone <em>pron.</em> A1</td>
<td style="text-align: left;">attractive <em>adj.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">afford <em>v.</em> B1</td>
<td style="text-align: left;">anything <em>pron.</em> A1</td>
<td style="text-align: left;">audience <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">afraid <em>adj.</em> A1</td>
<td style="text-align: left;">anyway <em>adv.</em> A2</td>
<td style="text-align: left;">August <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">after <em>prep.</em> A1, <em>conj.</em>,
<em>adv.</em> A2</td>
<td style="text-align: left;">anywhere <em>adv.</em>, <em>pron.</em>
A2</td>
<td style="text-align: left;">aunt <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">afternoon <em>n.</em> A1</td>
<td style="text-align: left;">apart <em>adv.</em> B1</td>
<td style="text-align: left;">author <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">afterwards <em>adv.</em> B2</td>
<td style="text-align: left;">apartment <em>n.</em> A1</td>
<td style="text-align: left;">authority <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">again <em>adv.</em> A1</td>
<td style="text-align: left;">apologize <em>v.</em> B1</td>
<td style="text-align: left;">autumn <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">against <em>prep.</em> A2</td>
<td style="text-align: left;">app <em>n.</em> A2</td>
<td style="text-align: left;">available <em>adj.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">age <em>n.</em> A1, <em>v.</em> B1</td>
<td style="text-align: left;">apparent <em>adj.</em> B2</td>
<td style="text-align: left;">average <em>adj.</em>, <em>n.</em> A2,
<em>v.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">aged <em>adj.</em> B1</td>
<td style="text-align: left;">apparently <em>adv.</em> B2</td>
<td style="text-align: left;">avoid <em>v.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">agency <em>n.</em> B2</td>
<td style="text-align: left;">appeal <em>n.</em>, <em>v.</em> B2</td>
<td style="text-align: left;">award <em>n.</em> A2, <em>v.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">agenda <em>n.</em> B2</td>
<td style="text-align: left;">appear <em>v.</em> A2</td>
<td style="text-align: left;">aware <em>adj.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">agent <em>n.</em> B1</td>
<td style="text-align: left;">appearance <em>n.</em> A2</td>
<td style="text-align: left;">away <em>adv.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">aggressive <em>adj.</em> B2</td>
<td style="text-align: left;">apple <em>n.</em> A1</td>
<td style="text-align: left;">awful <em>adj.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">ago <em>adv.</em> A1</td>
<td style="text-align: left;">application <em>n.</em> B1</td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">agree <em>v.</em> A1</td>
<td style="text-align: left;">apply <em>v.</em> A2</td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<h2 id="b">B</h2>
<table>
<colgroup>
<col style="width: 39%">
<col style="width: 35%">
<col style="width: 25%">
</colgroup>
<tbody>
<tr>
<td style="text-align: left;">baby <em>n.</em> A1</td>
<td style="text-align: left;">belief <em>n.</em> B1</td>
<td style="text-align: left;">boss <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">back <em>n.</em>, <em>adv.</em> A1,
<em>adj.</em> A2, <em>v.</em> B2</td>
<td style="text-align: left;">believe <em>v.</em> A1</td>
<td style="text-align: left;">both <em>det.</em>/<em>pron.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">background <em>n.</em> A2</td>
<td style="text-align: left;">bell <em>n.</em> B1</td>
<td style="text-align: left;">bother <em>v.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">backwards <em>adv.</em> B1</td>
<td style="text-align: left;">belong <em>v.</em> A2</td>
<td style="text-align: left;">bottle <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">bacteria <em>n.</em> B2</td>
<td style="text-align: left;">below <em>adv.</em>, <em>prep.</em>
A1</td>
<td style="text-align: left;">bottom <em>n.</em>, <em>adj.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">bad <em>adj.</em> A1</td>
<td style="text-align: left;">belt <em>n.</em> A2</td>
<td style="text-align: left;">bowl <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">badly <em>adv.</em> A2</td>
<td style="text-align: left;">bend <em>v.</em>, <em>n.</em> B1</td>
<td style="text-align: left;">box <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">bag <em>n.</em> A1</td>
<td style="text-align: left;">benefit <em>n.</em> A2, <em>v.</em>
B1</td>
<td style="text-align: left;">boy <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">bake <em>v.</em> B1</td>
<td style="text-align: left;">bent <em>adj.</em> B2</td>
<td style="text-align: left;">boyfriend <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">balance <em>n.</em>, <em>v.</em> B1</td>
<td style="text-align: left;">best <em>adj.</em> A1, <em>adv.</em>,
<em>n.</em> A2</td>
<td style="text-align: left;">brain <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">ball <em>n.</em> A1</td>
<td style="text-align: left;">bet <em>v.</em>, <em>n.</em> B2</td>
<td style="text-align: left;">branch <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">ban <em>v.</em>, <em>n.</em> B1</td>
<td style="text-align: left;">better <em>adj.</em> A1, <em>adv.</em> A2,
<em>n.</em> B1</td>
<td style="text-align: left;">brand <em>n.</em>, <em>v.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">banana <em>n.</em> A1</td>
<td style="text-align: left;">between <em>prep.</em> A1, <em>adv.</em>
A2</td>
<td style="text-align: left;">brave <em>adj.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">band <em>n.</em> A1</td>
<td style="text-align: left;">beyond <em>prep.</em>, <em>adv.</em>
B2</td>
<td style="text-align: left;">bread <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">bank (money) <em>n.</em> A1</td>
<td style="text-align: left;">bicycle <em>n.</em> A1</td>
<td style="text-align: left;">break <em>v.</em>, <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">bank (river) <em>n.</em> B1</td>
<td style="text-align: left;">big <em>adj.</em> A1</td>
<td style="text-align: left;">breakfast <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">bar <em>n.</em> A2, <em>v.</em> B2</td>
<td style="text-align: left;">bike <em>n.</em> A1</td>
<td style="text-align: left;">breast <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">barrier <em>n.</em> B2</td>
<td style="text-align: left;">bill <em>n.</em> A1, <em>v.</em> B2</td>
<td style="text-align: left;">breath <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">base <em>n.</em>, <em>v.</em> B1</td>
<td style="text-align: left;">billion <em>number</em> A2</td>
<td style="text-align: left;">breathe <em>v.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">baseball <em>n.</em> A2</td>
<td style="text-align: left;">bin <em>n.</em> A2</td>
<td style="text-align: left;">breathing <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">based <em>adj.</em> A2</td>
<td style="text-align: left;">biology <em>n.</em> A2</td>
<td style="text-align: left;">bride <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">basic <em>adj.</em> B1</td>
<td style="text-align: left;">bird <em>n.</em> A1</td>
<td style="text-align: left;">bridge <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">basically <em>adv.</em> B2</td>
<td style="text-align: left;">birth <em>n.</em> A2</td>
<td style="text-align: left;">brief <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">basis <em>n.</em> B1</td>
<td style="text-align: left;">birthday <em>n.</em> A1</td>
<td style="text-align: left;">bright <em>adj.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">basketball <em>n.</em> A2</td>
<td style="text-align: left;">biscuit <em>n.</em> A2</td>
<td style="text-align: left;">brilliant <em>adj.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">bath <em>n.</em> A1</td>
<td style="text-align: left;">bit <em>n.</em> A2</td>
<td style="text-align: left;">bring <em>v.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">bathroom <em>n.</em> A1</td>
<td style="text-align: left;">bite <em>v.</em>, <em>n.</em> B1</td>
<td style="text-align: left;">broad <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">battery <em>n.</em> B1</td>
<td style="text-align: left;">bitter <em>adj.</em> B2</td>
<td style="text-align: left;">broadcast <em>v.</em>, <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">battle <em>n.</em> B1, <em>v.</em> B2</td>
<td style="text-align: left;">black <em>adj.</em>, <em>n.</em> A1</td>
<td style="text-align: left;">broken <em>adj.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">be <em>v.</em>, auxiliary <em>v.</em>
A1</td>
<td style="text-align: left;">blame <em>v.</em>, <em>n.</em> B2</td>
<td style="text-align: left;">brother <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">beach <em>n.</em> A1</td>
<td style="text-align: left;">blank <em>adj.</em>, <em>n.</em> A2</td>
<td style="text-align: left;">brown <em>adj.</em>, <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">bean <em>n.</em> A2</td>
<td style="text-align: left;">blind <em>adj.</em> B2</td>
<td style="text-align: left;">brush <em>v.</em>, <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">bear (deal with) <em>v.</em> B2</td>
<td style="text-align: left;">block <em>n.</em>, <em>v.</em> B1</td>
<td style="text-align: left;">bubble <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">bear (animal) <em>n.</em> A2</td>
<td style="text-align: left;">blog <em>n.</em> A1</td>
<td style="text-align: left;">budget <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">beat <em>v.</em> A2, <em>n.</em> B2</td>
<td style="text-align: left;">blonde <em>adj.</em> A1</td>
<td style="text-align: left;">build <em>v.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">beautiful <em>adj.</em> A1</td>
<td style="text-align: left;">blood <em>n.</em> A2</td>
<td style="text-align: left;">building <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">beauty <em>n.</em> B1</td>
<td style="text-align: left;">blow <em>v.</em> A2</td>
<td style="text-align: left;">bullet <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">because <em>conj.</em> A1</td>
<td style="text-align: left;">blue <em>adj.</em>, <em>n.</em> A1</td>
<td style="text-align: left;">bunch <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">become <em>v.</em> A1</td>
<td style="text-align: left;">board <em>n.</em> A2, <em>v.</em> B1</td>
<td style="text-align: left;">burn <em>v.</em> A2, <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">bed <em>n.</em> A1</td>
<td style="text-align: left;">boat <em>n.</em> A1</td>
<td style="text-align: left;">bury <em>v.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">bedroom <em>n.</em> A1</td>
<td style="text-align: left;">body <em>n.</em> A1</td>
<td style="text-align: left;">bus <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">bee <em>n.</em> B1</td>
<td style="text-align: left;">boil <em>v.</em> A2</td>
<td style="text-align: left;">bush <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">beef <em>n.</em> A2</td>
<td style="text-align: left;">bomb <em>n.</em>, <em>v.</em> B1</td>
<td style="text-align: left;">business <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">beer <em>n.</em> A1</td>
<td style="text-align: left;">bond <em>n.</em> B2</td>
<td style="text-align: left;">businessman <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">before <em>prep.</em> A1, <em>conj.</em>,
<em>adv.</em> A2</td>
<td style="text-align: left;">bone <em>n.</em> A2</td>
<td style="text-align: left;">busy <em>adj.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">beg <em>v.</em> B2</td>
<td style="text-align: left;">book <em>n.</em> A1, <em>v.</em> A2</td>
<td style="text-align: left;">but <em>conj.</em> A1, <em>prep.</em>
B2</td>
</tr>
<tr>
<td style="text-align: left;">begin <em>v.</em> A1</td>
<td style="text-align: left;">boot <em>n.</em> A1</td>
<td style="text-align: left;">butter <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">beginning <em>n.</em> A1</td>
<td style="text-align: left;">border <em>n.</em> B1, <em>v.</em> B2</td>
<td style="text-align: left;">button <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">behave <em>v.</em> A2</td>
<td style="text-align: left;">bored <em>adj.</em> A1</td>
<td style="text-align: left;">buy <em>v.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">behaviour <em>n.</em> A2</td>
<td style="text-align: left;">boring <em>adj.</em> A1</td>
<td style="text-align: left;">by <em>prep.</em> A1, <em>adv.</em>
B1</td>
</tr>
<tr>
<td style="text-align: left;">behind <em>prep.</em>, <em>adv.</em>
A1</td>
<td style="text-align: left;">born <em>v.</em> A1</td>
<td style="text-align: left;">bye <em>exclam.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">being <em>n.</em> B2</td>
<td style="text-align: left;">borrow <em>v.</em> A2</td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<h2 id="c">C</h2>
<table>
<colgroup>
<col style="width: 35%">
<col style="width: 32%">
<col style="width: 31%">
</colgroup>
<tbody>
<tr>
<td style="text-align: left;">cable <em>n.</em> B2</td>
<td style="text-align: left;">classic <em>adj.</em>, <em>n.</em> B2</td>
<td style="text-align: left;">consist <em>v.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">cafe <em>n.</em> A1</td>
<td style="text-align: left;">classical <em>adj.</em> A2</td>
<td style="text-align: left;">consistent <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">cake <em>n.</em> A1</td>
<td style="text-align: left;">classroom <em>n.</em> A1</td>
<td style="text-align: left;">constant <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">calculate <em>v.</em> B2</td>
<td style="text-align: left;">clause <em>n.</em> B1</td>
<td style="text-align: left;">constantly <em>adv.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">call <em>v.</em>, <em>n.</em> A1</td>
<td style="text-align: left;">clean <em>adj.</em>, <em>v.</em> A1</td>
<td style="text-align: left;">construct <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">calm <em>adj.</em>, <em>v.</em>,
<em>n.</em> B1</td>
<td style="text-align: left;">clear <em>adj.</em> A2, <em>v.</em>
B1</td>
<td style="text-align: left;">construction <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">camera <em>n.</em> A1</td>
<td style="text-align: left;">clearly <em>adv.</em> A2</td>
<td style="text-align: left;">consume <em>v.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">camp <em>n.</em>, <em>v.</em> A2</td>
<td style="text-align: left;">clever <em>adj.</em> A2</td>
<td style="text-align: left;">consumer <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">campaign <em>n.</em>, <em>v.</em> B1</td>
<td style="text-align: left;">click <em>v.</em>, <em>n.</em> B1</td>
<td style="text-align: left;">contact <em>n.</em>, <em>v.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">camping <em>n.</em> A2</td>
<td style="text-align: left;">client <em>n.</em> B1</td>
<td style="text-align: left;">contain <em>v.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">campus <em>n.</em> B1</td>
<td style="text-align: left;">climate <em>n.</em> A2</td>
<td style="text-align: left;">container <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">can^1 modal <em>v.</em> A1</td>
<td style="text-align: left;">climb <em>v.</em> A1, <em>n.</em> B1</td>
<td style="text-align: left;">contemporary <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">can^2 <em>n.</em> A2</td>
<td style="text-align: left;">clock <em>n.</em> A1</td>
<td style="text-align: left;">content1 <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">cancel <em>v.</em> B2</td>
<td style="text-align: left;">close1 <em>v.</em> A1, <em>n.</em> B2</td>
<td style="text-align: left;">contest <em>n.</em>, <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">cancer <em>n.</em> B2</td>
<td style="text-align: left;">close2 <em>adj.</em> A2, <em>adv.</em>
B1</td>
<td style="text-align: left;">context <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">candidate <em>n.</em> B1</td>
<td style="text-align: left;">closed <em>adj.</em> A2</td>
<td style="text-align: left;">continent <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">cannot <em>v.</em> A1</td>
<td style="text-align: left;">closely <em>adv.</em> B2</td>
<td style="text-align: left;">continue <em>v.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">cap <em>n.</em> B1</td>
<td style="text-align: left;">cloth <em>n.</em> B1</td>
<td style="text-align: left;">continuous <em>adj.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">capable <em>adj.</em> B2</td>
<td style="text-align: left;">clothes <em>n.</em> A1</td>
<td style="text-align: left;">contract <em>n.</em>, <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">capacity <em>n.</em> B2</td>
<td style="text-align: left;">clothing <em>n.</em> A2</td>
<td style="text-align: left;">contrast <em>n.</em>, <em>v.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">capital <em>n.</em>, <em>adj.</em> A1</td>
<td style="text-align: left;">cloud <em>n.</em> A2</td>
<td style="text-align: left;">contribute <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">captain <em>n.</em> B1</td>
<td style="text-align: left;">club <em>n.</em> A1</td>
<td style="text-align: left;">contribution <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">capture <em>v.</em>, <em>n.</em> B2</td>
<td style="text-align: left;">clue <em>n.</em> B1</td>
<td style="text-align: left;">control <em>n.</em>, <em>v.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">car <em>n.</em> A1</td>
<td style="text-align: left;">coach <em>n.</em> A2, <em>v.</em> B1</td>
<td style="text-align: left;">convenient <em>adj.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">card <em>n.</em> A1</td>
<td style="text-align: left;">coal <em>n.</em> B1</td>
<td style="text-align: left;">conversation <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">care <em>n.</em>, <em>v.</em> A2</td>
<td style="text-align: left;">coast <em>n.</em> A2</td>
<td style="text-align: left;">convert <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">career <em>n.</em> A1</td>
<td style="text-align: left;">coat <em>n.</em> A1</td>
<td style="text-align: left;">convince <em>v.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">careful <em>adj.</em> A2</td>
<td style="text-align: left;">code <em>n.</em> A2</td>
<td style="text-align: left;">convinced <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">carefully <em>adv.</em> A2</td>
<td style="text-align: left;">coffee <em>n.</em> A1</td>
<td style="text-align: left;">cook <em>v.</em> A1, <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">careless <em>adj.</em> B1</td>
<td style="text-align: left;">coin <em>n.</em> B1</td>
<td style="text-align: left;">cooker <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">carpet <em>n.</em> A2</td>
<td style="text-align: left;">cold <em>adj.</em>, <em>n.</em> A1</td>
<td style="text-align: left;">cooking <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">carrot <em>n.</em> A1</td>
<td style="text-align: left;">collapse <em>v.</em>, <em>n.</em> B2</td>
<td style="text-align: left;">cool <em>adj.</em> A1, <em>v.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">carry <em>v.</em> A1</td>
<td style="text-align: left;">colleague <em>n.</em> A2</td>
<td style="text-align: left;">copy <em>n.</em>, <em>v.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">cartoon <em>n.</em> A2</td>
<td style="text-align: left;">collect <em>v.</em> A2</td>
<td style="text-align: left;">core <em>n.</em>, <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">case <em>n.</em> A2</td>
<td style="text-align: left;">collection <em>n.</em> B1</td>
<td style="text-align: left;">corner <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">cash <em>n.</em> A2</td>
<td style="text-align: left;">college <em>n.</em> A1</td>
<td style="text-align: left;">corporate <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">cast <em>n.</em>, <em>v.</em> B2</td>
<td style="text-align: left;">colour <em>n.</em> A1</td>
<td style="text-align: left;">correct <em>adj.</em>, <em>v.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">castle <em>n.</em> A2</td>
<td style="text-align: left;">coloured <em>adj.</em> B1</td>
<td style="text-align: left;">correctly <em>adv.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">cat <em>n.</em> A1</td>
<td style="text-align: left;">column <em>n.</em> A2</td>
<td style="text-align: left;">cost <em>n.</em>, <em>v.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">catch <em>v.</em> A2, <em>n.</em> B2</td>
<td style="text-align: left;">combination <em>n.</em> B2</td>
<td style="text-align: left;">costume <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">category <em>n.</em> B1</td>
<td style="text-align: left;">combine <em>v.</em> B1</td>
<td style="text-align: left;">cottage <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">cause <em>n.</em>, <em>v.</em> A2</td>
<td style="text-align: left;">come <em>v.</em> A1</td>
<td style="text-align: left;">cotton <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">CD <em>n.</em> A1</td>
<td style="text-align: left;">comedy <em>n.</em> A2</td>
<td style="text-align: left;">could modal <em>v.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">ceiling <em>n.</em> B1</td>
<td style="text-align: left;">comfort <em>n.</em>, <em>v.</em> B2</td>
<td style="text-align: left;">council <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">celebrate <em>v.</em> A2</td>
<td style="text-align: left;">comfortable <em>adj.</em> A2</td>
<td style="text-align: left;">count <em>v.</em> A2, <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">celebration <em>n.</em> B1</td>
<td style="text-align: left;">command <em>n.</em>, <em>v.</em> B2</td>
<td style="text-align: left;">country <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">celebrity <em>n.</em> A2</td>
<td style="text-align: left;">comment <em>n.</em> A2, <em>v.</em>
B1</td>
<td style="text-align: left;">countryside <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">cell <em>n.</em> B2</td>
<td style="text-align: left;">commercial <em>adj.</em>, <em>n.</em>
B1</td>
<td style="text-align: left;">county <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">cent <em>n.</em> A1</td>
<td style="text-align: left;">commission <em>n.</em>, <em>v.</em>
B2</td>
<td style="text-align: left;">couple <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">central <em>adj.</em> B1</td>
<td style="text-align: left;">commit <em>v.</em> B1</td>
<td style="text-align: left;">courage <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">centre <em>n.</em> A1, <em>v.</em> B1</td>
<td style="text-align: left;">commitment <em>n.</em> B2</td>
<td style="text-align: left;">course <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">century <em>n.</em> A1</td>
<td style="text-align: left;">committee <em>n.</em> B2</td>
<td style="text-align: left;">court <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">ceremony <em>n.</em> B1</td>
<td style="text-align: left;">common <em>adj.</em>, <em>n.</em> A1</td>
<td style="text-align: left;">cousin <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">certain <em>adj.</em> A2</td>
<td style="text-align: left;">commonly <em>adv.</em> B2</td>
<td style="text-align: left;">cover <em>v.</em> A2, <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">certainly <em>adv.</em> A2</td>
<td style="text-align: left;">communicate <em>v.</em> A2</td>
<td style="text-align: left;">covered <em>adj.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">chain <em>n.</em> B1, <em>v.</em> B2</td>
<td style="text-align: left;">communication <em>n.</em> B1</td>
<td style="text-align: left;">cow <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">chair <em>n.</em> A1, <em>v.</em> B2</td>
<td style="text-align: left;">community <em>n.</em> A2</td>
<td style="text-align: left;">crash <em>n.</em>, <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">chairman <em>n.</em> B2</td>
<td style="text-align: left;">company <em>n.</em> A1</td>
<td style="text-align: left;">crazy <em>adj.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">challenge <em>n.</em> B1, <em>v.</em>
B2</td>
<td style="text-align: left;">compare <em>v.</em> A1</td>
<td style="text-align: left;">cream <em>n.</em> A1, <em>adj.</em>
B1</td>
</tr>
<tr>
<td style="text-align: left;">champion <em>n.</em> B1</td>
<td style="text-align: left;">comparison <em>n.</em> B1</td>
<td style="text-align: left;">create <em>v.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">chance <em>n.</em> A2</td>
<td style="text-align: left;">compete <em>v.</em> A2</td>
<td style="text-align: left;">creation <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">change <em>v.</em>, <em>n.</em> A1</td>
<td style="text-align: left;">competition <em>n.</em> A2</td>
<td style="text-align: left;">creative <em>adj.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">channel <em>n.</em> B1</td>
<td style="text-align: left;">competitive <em>adj.</em> B1</td>
<td style="text-align: left;">creature <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">chapter <em>n.</em> B1</td>
<td style="text-align: left;">competitor <em>n.</em> B1</td>
<td style="text-align: left;">credit <em>n.</em> A2, <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">character <em>n.</em> A2</td>
<td style="text-align: left;">complain <em>v.</em> A2</td>
<td style="text-align: left;">crew <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">characteristic <em>n.</em>, <em>adj.</em>
B2</td>
<td style="text-align: left;">complaint <em>n.</em> B1</td>
<td style="text-align: left;">crime <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">charge <em>n.</em>, <em>v.</em> B1</td>
<td style="text-align: left;">complete <em>adj.</em>, <em>v.</em>
A1</td>
<td style="text-align: left;">criminal <em>n.</em> A2, <em>adj.</em>
B1</td>
</tr>
<tr>
<td style="text-align: left;">charity <em>n.</em> A2</td>
<td style="text-align: left;">completely <em>adv.</em> A2</td>
<td style="text-align: left;">crisis <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">chart <em>n.</em> A1, <em>v.</em> B2</td>
<td style="text-align: left;">complex <em>adj.</em> B1, <em>n.</em>
B2</td>
<td style="text-align: left;">criterion <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">chat <em>v.</em>, <em>n.</em> A2</td>
<td style="text-align: left;">complicated <em>adj.</em> B2</td>
<td style="text-align: left;">critic <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">cheap <em>adj.</em> A1, <em>adv.</em>
B1</td>
<td style="text-align: left;">component <em>n.</em> B2</td>
<td style="text-align: left;">critical <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">cheat <em>v.</em>, <em>n.</em> B1</td>
<td style="text-align: left;">computer <em>n.</em> A1</td>
<td style="text-align: left;">criticism <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">check <em>v.</em> A1, <em>n.</em> A2</td>
<td style="text-align: left;">concentrate <em>v.</em> B1</td>
<td style="text-align: left;">criticize <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">cheerful <em>adj.</em> B1</td>
<td style="text-align: left;">concentration <em>n.</em> B2</td>
<td style="text-align: left;">crop <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">cheese <em>n.</em> A1</td>
<td style="text-align: left;">concept <em>n.</em> B2</td>
<td style="text-align: left;">cross <em>v.</em>, <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">chef <em>n.</em> A2</td>
<td style="text-align: left;">concern <em>n.</em>, <em>v.</em> B2</td>
<td style="text-align: left;">crowd <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">chemical <em>adj.</em>, <em>n.</em>
B1</td>
<td style="text-align: left;">concerned <em>adj.</em> B2</td>
<td style="text-align: left;">crowded <em>adj.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">chemistry <em>n.</em> A2</td>
<td style="text-align: left;">concert <em>n.</em> A1</td>
<td style="text-align: left;">crucial <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">chest <em>n.</em> B1</td>
<td style="text-align: left;">conclude <em>v.</em> B1</td>
<td style="text-align: left;">cruel <em>adj.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">chicken <em>n.</em> A1</td>
<td style="text-align: left;">conclusion <em>n.</em> B1</td>
<td style="text-align: left;">cry <em>v.</em> A2, <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">chief <em>adj.</em>, <em>n.</em> B2</td>
<td style="text-align: left;">condition <em>n.</em> A2</td>
<td style="text-align: left;">cultural <em>adj.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">child <em>n.</em> A1</td>
<td style="text-align: left;">conduct <em>v.</em>, <em>n.</em> B2</td>
<td style="text-align: left;">culture <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">childhood <em>n.</em> B1</td>
<td style="text-align: left;">conference <em>n.</em> A2</td>
<td style="text-align: left;">cup <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">chip <em>n.</em> A2</td>
<td style="text-align: left;">confidence <em>n.</em> B2</td>
<td style="text-align: left;">cupboard <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">chocolate <em>n.</em> A1</td>
<td style="text-align: left;">confident <em>adj.</em> B1</td>
<td style="text-align: left;">cure <em>v.</em>, <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">choice <em>n.</em> A2</td>
<td style="text-align: left;">confirm <em>v.</em> B1</td>
<td style="text-align: left;">curly <em>adj.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">choose <em>v.</em> A1</td>
<td style="text-align: left;">conflict <em>n.</em>, <em>v.</em> B2</td>
<td style="text-align: left;">currency <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">church <em>n.</em> A2</td>
<td style="text-align: left;">confuse <em>v.</em> B1</td>
<td style="text-align: left;">current <em>adj.</em> B1, <em>n.</em>
B2</td>
</tr>
<tr>
<td style="text-align: left;">cigarette <em>n.</em> A2</td>
<td style="text-align: left;">confused <em>adj.</em> B1</td>
<td style="text-align: left;">currently <em>adv.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">cinema <em>n.</em> A1</td>
<td style="text-align: left;">confusing <em>adj.</em> B2</td>
<td style="text-align: left;">curtain <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">circle <em>n.</em>, <em>v.</em> A2</td>
<td style="text-align: left;">connect <em>v.</em> A2</td>
<td style="text-align: left;">curve <em>n.</em>, <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">circumstance <em>n.</em> B2</td>
<td style="text-align: left;">connected <em>adj.</em> A2</td>
<td style="text-align: left;">curved <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">cite <em>v.</em> B2</td>
<td style="text-align: left;">connection <em>n.</em> B1</td>
<td style="text-align: left;">custom <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">citizen <em>n.</em> B2</td>
<td style="text-align: left;">conscious <em>adj.</em> B2</td>
<td style="text-align: left;">customer <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">city <em>n.</em> A1</td>
<td style="text-align: left;">consequence <em>n.</em> B1</td>
<td style="text-align: left;">cut <em>v.</em> A1, <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">civil <em>adj.</em> B2</td>
<td style="text-align: left;">conservative <em>adj.</em>, <em>n.</em>
B2</td>
<td style="text-align: left;">cycle <em>n.</em>, <em>v.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">claim <em>v.</em>, <em>n.</em> B1</td>
<td style="text-align: left;">consider <em>v.</em> A2</td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">class <em>n.</em> A1</td>
<td style="text-align: left;">consideration <em>n.</em> B2</td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<h2 id="d">D</h2>
<table>
<colgroup>
<col style="width: 25%">
<col style="width: 29%">
<col style="width: 45%">
</colgroup>
<tbody>
<tr>
<td style="text-align: left;">dad <em>n.</em> A1</td>
<td style="text-align: left;">depressing <em>adj.</em> B2</td>
<td style="text-align: left;">discuss <em>v.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">daily <em>adj.</em> A2, <em>adv.</em>
B1</td>
<td style="text-align: left;">depth <em>n.</em> B2</td>
<td style="text-align: left;">discussion <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">damage <em>n.</em>, <em>v.</em> B1</td>
<td style="text-align: left;">describe <em>v.</em> A1</td>
<td style="text-align: left;">disease <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">dance <em>n.</em>, <em>v.</em> A1</td>
<td style="text-align: left;">description <em>n.</em> A1</td>
<td style="text-align: left;">dish <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">dancer <em>n.</em> A1</td>
<td style="text-align: left;">desert <em>n.</em> A2, <em>v.</em> B2</td>
<td style="text-align: left;">dishonest <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">dancing <em>n.</em> A1</td>
<td style="text-align: left;">deserve <em>v.</em> B2</td>
<td style="text-align: left;">dislike <em>v.</em>, <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">danger <em>n.</em> A2</td>
<td style="text-align: left;">design <em>n.</em>, <em>v.</em> A1</td>
<td style="text-align: left;">dismiss <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">dangerous <em>adj.</em> A1</td>
<td style="text-align: left;">designer <em>n.</em> A2</td>
<td style="text-align: left;">display <em>v.</em>, <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">dark <em>adj.</em> A1, <em>n.</em> A2</td>
<td style="text-align: left;">desire <em>n.</em>, <em>v.</em> B2</td>
<td style="text-align: left;">distance <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">data <em>n.</em> A2</td>
<td style="text-align: left;">desk <em>n.</em> A1</td>
<td style="text-align: left;">distribute <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">date <em>n.</em> A1, <em>v.</em> B2</td>
<td style="text-align: left;">desperate <em>adj.</em> B2</td>
<td style="text-align: left;">distribution <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">daughter <em>n.</em> A1</td>
<td style="text-align: left;">despite <em>prep.</em> B1</td>
<td style="text-align: left;">district <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">day <em>n.</em> A1</td>
<td style="text-align: left;">destination <em>n.</em> B1</td>
<td style="text-align: left;">divide <em>v.</em> B1, <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">dead <em>adj.</em> A2</td>
<td style="text-align: left;">destroy <em>v.</em> A2</td>
<td style="text-align: left;">division <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">deal <em>v.</em> A2, <em>n.</em> B1</td>
<td style="text-align: left;">detail <em>n.</em> A1, <em>v.</em> B2</td>
<td style="text-align: left;">divorced <em>adj.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">dear <em>adj.</em> A1, <em>exclam.</em>
A2</td>
<td style="text-align: left;">detailed <em>adj.</em> B2</td>
<td style="text-align: left;">do1 <em>v.</em>, auxiliary <em>v.</em>
A1</td>
</tr>
<tr>
<td style="text-align: left;">death <em>n.</em> A2</td>
<td style="text-align: left;">detect <em>v.</em> B2</td>
<td style="text-align: left;">doctor <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">debate <em>n.</em>, <em>v.</em> B2</td>
<td style="text-align: left;">detective <em>n.</em> A2</td>
<td style="text-align: left;">document <em>n.</em> A2, <em>v.</em>
B2</td>
</tr>
<tr>
<td style="text-align: left;">debt <em>n.</em> B2</td>
<td style="text-align: left;">determine <em>v.</em> B1</td>
<td style="text-align: left;">documentary <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">decade <em>n.</em> B1</td>
<td style="text-align: left;">determined <em>adj.</em> B1</td>
<td style="text-align: left;">dog <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">December <em>n.</em> A1</td>
<td style="text-align: left;">develop <em>v.</em> A2</td>
<td style="text-align: left;">dollar <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">decent <em>adj.</em> B2</td>
<td style="text-align: left;">development <em>n.</em> B1</td>
<td style="text-align: left;">domestic <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">decide <em>v.</em> A1</td>
<td style="text-align: left;">device <em>n.</em> A2</td>
<td style="text-align: left;">dominate <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">decision <em>n.</em> A2</td>
<td style="text-align: left;">diagram <em>n.</em> B1</td>
<td style="text-align: left;">donate <em>v.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">declare <em>v.</em> B2</td>
<td style="text-align: left;">dialogue <em>n.</em> A1</td>
<td style="text-align: left;">door <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">decline <em>v.</em>, <em>n.</em> B2</td>
<td style="text-align: left;">diamond <em>n.</em> B1</td>
<td style="text-align: left;">double <em>adj.</em>, <em>det.</em>,
<em>pron.</em>, <em>v.</em> A2, <em>adv.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">decorate <em>v.</em> B1</td>
<td style="text-align: left;">diary <em>n.</em> A2</td>
<td style="text-align: left;">doubt <em>n.</em>, <em>v.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">decoration <em>n.</em> B2</td>
<td style="text-align: left;">dictionary <em>n.</em> A1</td>
<td style="text-align: left;">down <em>adv.</em>, <em>prep.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">decrease <em>v.</em>, <em>n.</em> B2</td>
<td style="text-align: left;">die <em>v.</em> A1</td>
<td style="text-align: left;">download <em>v.</em>, <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">deep <em>adj.</em> A2, <em>adv.</em>
B1</td>
<td style="text-align: left;">diet <em>n.</em> A1</td>
<td style="text-align: left;">downstairs <em>adv.</em> A1, <em>adj.</em>
A2</td>
</tr>
<tr>
<td style="text-align: left;">deeply <em>adv.</em> B2</td>
<td style="text-align: left;">difference <em>n.</em> A1</td>
<td style="text-align: left;">downwards <em>adv.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">defeat <em>v.</em>, <em>n.</em> B2</td>
<td style="text-align: left;">different <em>adj.</em> A1</td>
<td style="text-align: left;">dozen <em>n.</em>, <em>det.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">defence <em>n.</em> B2</td>
<td style="text-align: left;">differently <em>adv.</em> A2</td>
<td style="text-align: left;">draft <em>n.</em>, <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">defend <em>v.</em> B2</td>
<td style="text-align: left;">difficult <em>adj.</em> A1</td>
<td style="text-align: left;">drag <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">define <em>v.</em> B1</td>
<td style="text-align: left;">difficulty <em>n.</em> B1</td>
<td style="text-align: left;">drama <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">definite <em>adj.</em> B1</td>
<td style="text-align: left;">dig <em>v.</em> B2</td>
<td style="text-align: left;">dramatic <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">definitely <em>adv.</em> A2</td>
<td style="text-align: left;">digital <em>adj.</em> A2</td>
<td style="text-align: left;">draw <em>v.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">definition <em>n.</em> B1</td>
<td style="text-align: left;">dinner <em>n.</em> A1</td>
<td style="text-align: left;">drawing <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">degree <em>n.</em> A2</td>
<td style="text-align: left;">direct <em>adj.</em> A2, <em>v.</em>,
<em>adv.</em> B1</td>
<td style="text-align: left;">dream <em>n.</em>, <em>v.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">delay <em>v.</em>, <em>n.</em> B2</td>
<td style="text-align: left;">direction <em>n.</em> A2</td>
<td style="text-align: left;">dress <em>n.</em>, <em>v.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">deliberate <em>adj.</em> B2</td>
<td style="text-align: left;">directly <em>adv.</em> B1</td>
<td style="text-align: left;">dressed <em>adj.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">deliberately <em>adv.</em> B2</td>
<td style="text-align: left;">director <em>n.</em> A2</td>
<td style="text-align: left;">drink <em>n.</em>, <em>v.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">delicious <em>adj.</em> A1</td>
<td style="text-align: left;">dirt <em>n.</em> B1</td>
<td style="text-align: left;">drive <em>v.</em> A1, <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">delight <em>v.</em>, <em>n.</em> B2</td>
<td style="text-align: left;">dirty <em>adj.</em> A1</td>
<td style="text-align: left;">driver <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">delighted <em>adj.</em> B2</td>
<td style="text-align: left;">disadvantage <em>n.</em> B1</td>
<td style="text-align: left;">driving <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">deliver <em>v.</em> B1</td>
<td style="text-align: left;">disagree <em>v.</em> A2</td>
<td style="text-align: left;">drop <em>v.</em> A2, <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">delivery <em>n.</em> B2</td>
<td style="text-align: left;">disappear <em>v.</em> A2</td>
<td style="text-align: left;">drug <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">demand <em>n.</em>, <em>v.</em> B2</td>
<td style="text-align: left;">disappointed <em>adj.</em> B1</td>
<td style="text-align: left;">drum <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">demonstrate <em>v.</em> B2</td>
<td style="text-align: left;">disappointing <em>adj.</em> B1</td>
<td style="text-align: left;">drunk <em>adj.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">dentist <em>n.</em> A2</td>
<td style="text-align: left;">disaster <em>n.</em> A2</td>
<td style="text-align: left;">dry <em>adj.</em>, <em>v.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">deny <em>v.</em> B2</td>
<td style="text-align: left;">disc <em>n.</em> B2</td>
<td style="text-align: left;">due <em>adj.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">department <em>n.</em> A2</td>
<td style="text-align: left;">discipline <em>n.</em> B2</td>
<td style="text-align: left;">during <em>prep.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">departure <em>n.</em> B1</td>
<td style="text-align: left;">discount <em>n.</em> B1, <em>v.</em>
B2</td>
<td style="text-align: left;">dust <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">depend <em>v.</em> A2</td>
<td style="text-align: left;">discover <em>v.</em> A2</td>
<td style="text-align: left;">duty <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">depressed <em>adj.</em> B2</td>
<td style="text-align: left;">discovery <em>n.</em> A2</td>
<td style="text-align: left;">DVD <em>n.</em> A1</td>
</tr>
</tbody>
</table>
<h2 id="e">E</h2>
<table>
<colgroup>
<col style="width: 32%">
<col style="width: 34%">
<col style="width: 32%">
</colgroup>
<tbody>
<tr>
<td style="text-align: left;">each
<em>det.</em>/<em>pron.</em>/<em>adv.</em> A1</td>
<td style="text-align: left;">employer <em>n.</em> A2</td>
<td style="text-align: left;">everyday <em>adj.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">ear <em>n.</em> A1</td>
<td style="text-align: left;">employment <em>n.</em> B1</td>
<td style="text-align: left;">everyone <em>pron.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">early <em>adj.</em>, <em>adv.</em> A1</td>
<td style="text-align: left;">empty <em>adj.</em> A2, <em>v.</em>
B1</td>
<td style="text-align: left;">everything <em>pron.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">earn <em>v.</em> A2</td>
<td style="text-align: left;">enable <em>v.</em> B2</td>
<td style="text-align: left;">everywhere <em>adv.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">earth <em>n.</em> A2</td>
<td style="text-align: left;">encounter <em>v.</em>, <em>n.</em> B2</td>
<td style="text-align: left;">evidence <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">earthquake <em>n.</em> B1</td>
<td style="text-align: left;">encourage <em>v.</em> B1</td>
<td style="text-align: left;">evil <em>adj.</em>, <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">easily <em>adv.</em> A2</td>
<td style="text-align: left;">end <em>n.</em>, <em>v.</em> A1</td>
<td style="text-align: left;">exact <em>adj.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">east <em>n.</em>, <em>adj.</em>,
<em>adv.</em> A1</td>
<td style="text-align: left;">ending <em>n.</em> A2</td>
<td style="text-align: left;">exactly <em>adv.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">eastern <em>adj.</em> B1</td>
<td style="text-align: left;">enemy <em>n.</em> B1</td>
<td style="text-align: left;">exam <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">easy <em>adj.</em> A1</td>
<td style="text-align: left;">energy <em>n.</em> A2</td>
<td style="text-align: left;">examination <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">eat <em>v.</em> A1</td>
<td style="text-align: left;">engage <em>v.</em> B2</td>
<td style="text-align: left;">examine <em>v.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">economic <em>adj.</em> B1</td>
<td style="text-align: left;">engaged <em>adj.</em> B1</td>
<td style="text-align: left;">example <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">economy <em>n.</em> B1</td>
<td style="text-align: left;">engine <em>n.</em> A2</td>
<td style="text-align: left;">excellent <em>adj.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">edge <em>n.</em> B1</td>
<td style="text-align: left;">engineer <em>n.</em> A2</td>
<td style="text-align: left;">except <em>prep.</em> A2, <em>conj.</em>
B1</td>
</tr>
<tr>
<td style="text-align: left;">edit <em>v.</em> B2</td>
<td style="text-align: left;">engineering <em>n.</em> B1</td>
<td style="text-align: left;">exchange <em>n.</em>, <em>v.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">edition <em>n.</em> B2</td>
<td style="text-align: left;">enhance <em>v.</em> B2</td>
<td style="text-align: left;">excited <em>adj.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">editor <em>n.</em> B1</td>
<td style="text-align: left;">enjoy <em>v.</em> A1</td>
<td style="text-align: left;">excitement <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">educate <em>v.</em> B1</td>
<td style="text-align: left;">enormous <em>adj.</em> A2</td>
<td style="text-align: left;">exciting <em>adj.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">educated <em>adj.</em> B1</td>
<td style="text-align: left;">enough <em>det.</em>, <em>pron.</em>,
<em>adv.</em> A1</td>
<td style="text-align: left;">excuse <em>n.</em>, <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">education <em>n.</em> A2</td>
<td style="text-align: left;">enquiry <em>n.</em> B2</td>
<td style="text-align: left;">executive <em>n.</em>, <em>adj.</em>
B2</td>
</tr>
<tr>
<td style="text-align: left;">educational <em>adj.</em> B1</td>
<td style="text-align: left;">ensure <em>v.</em> B2</td>
<td style="text-align: left;">exercise <em>n.</em>, <em>v.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">effect <em>n.</em> A2</td>
<td style="text-align: left;">enter <em>v.</em> A2</td>
<td style="text-align: left;">exhibition <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">effective <em>adj.</em> B1</td>
<td style="text-align: left;">entertain <em>v.</em> B1</td>
<td style="text-align: left;">exist <em>v.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">effectively <em>adv.</em> B1</td>
<td style="text-align: left;">entertainment <em>n.</em> B1</td>
<td style="text-align: left;">existence <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">efficient <em>adj.</em> B2</td>
<td style="text-align: left;">enthusiasm <em>n.</em> B2</td>
<td style="text-align: left;">expand <em>v.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">effort <em>n.</em> B1</td>
<td style="text-align: left;">enthusiastic <em>adj.</em> B2</td>
<td style="text-align: left;">expect <em>v.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">egg <em>n.</em> A1</td>
<td style="text-align: left;">entire <em>adj.</em> B2</td>
<td style="text-align: left;">expectation <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">eight <em>number</em> A1</td>
<td style="text-align: left;">entirely <em>adv.</em> B2</td>
<td style="text-align: left;">expected <em>adj.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">eighteen <em>number</em> A1</td>
<td style="text-align: left;">entrance <em>n.</em> B1</td>
<td style="text-align: left;">expedition <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">eighty <em>number</em> A1</td>
<td style="text-align: left;">entry <em>n.</em> B1</td>
<td style="text-align: left;">expense <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">either <em>det.</em>/<em>pron.</em>,
<em>adv.</em> A2</td>
<td style="text-align: left;">environment <em>n.</em> A2</td>
<td style="text-align: left;">expensive <em>adj.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">elderly <em>adj.</em> B2</td>
<td style="text-align: left;">environmental <em>adj.</em> B1</td>
<td style="text-align: left;">experience <em>n.</em> A2, <em>v.</em>
B1</td>
</tr>
<tr>
<td style="text-align: left;">elect <em>v.</em> B2</td>
<td style="text-align: left;">episode <em>n.</em> B1</td>
<td style="text-align: left;">experienced <em>adj.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">election <em>n.</em> B1</td>
<td style="text-align: left;">equal <em>adj.</em>, <em>v.</em> B1,
<em>n.</em> B2</td>
<td style="text-align: left;">experiment <em>n.</em> A2, <em>v.</em>
B1</td>
</tr>
<tr>
<td style="text-align: left;">electric <em>adj.</em> A2</td>
<td style="text-align: left;">equally <em>adv.</em> B1</td>
<td style="text-align: left;">expert <em>n.</em>, <em>adj.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">electrical <em>adj.</em> A2</td>
<td style="text-align: left;">equipment <em>n.</em> A2</td>
<td style="text-align: left;">explain <em>v.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">electricity <em>n.</em> A2</td>
<td style="text-align: left;">error <em>n.</em> A2</td>
<td style="text-align: left;">explanation <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">electronic <em>adj.</em> A2</td>
<td style="text-align: left;">escape <em>v.</em>, <em>n.</em> B1</td>
<td style="text-align: left;">explode <em>v.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">element <em>n.</em> B1</td>
<td style="text-align: left;">especially <em>adv.</em> A2</td>
<td style="text-align: left;">exploration <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">elephant <em>n.</em> A1</td>
<td style="text-align: left;">essay <em>n.</em> A2</td>
<td style="text-align: left;">explore <em>v.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">eleven <em>number</em> A1</td>
<td style="text-align: left;">essential <em>adj.</em> B1</td>
<td style="text-align: left;">explosion <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">else <em>adv.</em> A1</td>
<td style="text-align: left;">establish <em>v.</em> B2</td>
<td style="text-align: left;">export <em>n.</em>, <em>v.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">elsewhere <em>adv.</em> B2</td>
<td style="text-align: left;">estate <em>n.</em> B2</td>
<td style="text-align: left;">expose <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">email <em>n.</em>, <em>v.</em> A1</td>
<td style="text-align: left;">estimate <em>v.</em>, <em>n.</em> B2</td>
<td style="text-align: left;">express <em>v.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">embarrassed <em>adj.</em> B1</td>
<td style="text-align: left;">ethical <em>adj.</em> B2</td>
<td style="text-align: left;">expression <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">embarrassing <em>adj.</em> B1</td>
<td style="text-align: left;">euro <em>n.</em> A1</td>
<td style="text-align: left;">extend <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">emerge <em>v.</em> B2</td>
<td style="text-align: left;">evaluate <em>v.</em> B2</td>
<td style="text-align: left;">extent <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">emergency <em>n.</em> B1</td>
<td style="text-align: left;">even <em>adv.</em> A1, <em>adj.</em>
B2</td>
<td style="text-align: left;">external <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">emotion <em>n.</em> B1</td>
<td style="text-align: left;">evening <em>n.</em> A1</td>
<td style="text-align: left;">extra <em>adj.</em> A1, <em>n.</em>,
<em>adv.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">emotional <em>adj.</em> B2</td>
<td style="text-align: left;">event <em>n.</em> A1</td>
<td style="text-align: left;">extraordinary <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">emphasis <em>n.</em> B2</td>
<td style="text-align: left;">eventually <em>adv.</em> B1</td>
<td style="text-align: left;">extreme <em>adj.</em> A2, <em>n.</em>
B2</td>
</tr>
<tr>
<td style="text-align: left;">emphasize <em>v.</em> B2</td>
<td style="text-align: left;">ever <em>adv.</em> A1</td>
<td style="text-align: left;">extremely <em>adv.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">employ <em>v.</em> A2</td>
<td style="text-align: left;">every <em>det.</em> A1</td>
<td style="text-align: left;">eye <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">employee <em>n.</em> A2</td>
<td style="text-align: left;">everybody <em>pron.</em> A1</td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<h2 id="f">F</h2>
<table>
<colgroup>
<col style="width: 27%">
<col style="width: 39%">
<col style="width: 32%">
</colgroup>
<tbody>
<tr>
<td style="text-align: left;">face <em>n.</em> A1, <em>v.</em> B1</td>
<td style="text-align: left;">fighting <em>n.</em> B1</td>
<td style="text-align: left;">forest <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">facility <em>n.</em> B2</td>
<td style="text-align: left;">figure <em>n.</em> A2, <em>v.</em> B2</td>
<td style="text-align: left;">forever <em>adv.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">fact <em>n.</em> A1</td>
<td style="text-align: left;">file <em>n.</em> B1, <em>v.</em> B2</td>
<td style="text-align: left;">forget <em>v.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">factor <em>n.</em> A2</td>
<td style="text-align: left;">fill <em>v.</em> A1</td>
<td style="text-align: left;">forgive <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">factory <em>n.</em> A2</td>
<td style="text-align: left;">film <em>n.</em> A1, <em>v.</em> A2</td>
<td style="text-align: left;">fork <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">fail <em>v.</em> A2</td>
<td style="text-align: left;">final <em>adj.</em> A1, <em>n.</em>
A2</td>
<td style="text-align: left;">form <em>n.</em>, <em>v.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">failure <em>n.</em> B2</td>
<td style="text-align: left;">finally <em>adv.</em> A2</td>
<td style="text-align: left;">formal <em>adj.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">fair <em>adj.</em> A2</td>
<td style="text-align: left;">finance <em>n.</em>, <em>v.</em> B2</td>
<td style="text-align: left;">former <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">fairly <em>adv.</em> B1</td>
<td style="text-align: left;">financial <em>adj.</em> B1</td>
<td style="text-align: left;">fortunately <em>adv.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">faith <em>n.</em> B2</td>
<td style="text-align: left;">find <em>v.</em> A1</td>
<td style="text-align: left;">fortune <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">fall <em>v.</em> A1, <em>n.</em> A2</td>
<td style="text-align: left;">finding <em>n.</em> B2</td>
<td style="text-align: left;">forty <em>number</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">false <em>adj.</em> A1</td>
<td style="text-align: left;">fine <em>adj.</em> A1</td>
<td style="text-align: left;">forward <em>adv.</em> A2, <em>adj.</em>
B2</td>
</tr>
<tr>
<td style="text-align: left;">familiar <em>adj.</em> B1</td>
<td style="text-align: left;">finger <em>n.</em> A2</td>
<td style="text-align: left;">found <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">family <em>n.</em>, <em>adj.</em> A1</td>
<td style="text-align: left;">finish <em>v.</em> A1, <em>n.</em> A2</td>
<td style="text-align: left;">four <em>number</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">famous <em>adj.</em> A1</td>
<td style="text-align: left;">fire <em>n.</em> A1, <em>v.</em> B1</td>
<td style="text-align: left;">fourteen <em>number</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">fan <em>n.</em> A2</td>
<td style="text-align: left;">firm <em>n.</em> B2</td>
<td style="text-align: left;">fourth <em>number</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">fancy <em>v.</em>, <em>adj.</em> B1</td>
<td style="text-align: left;">first <em>det.</em>/<em>number</em>,
<em>adv.</em> A1, <em>n.</em> A2</td>
<td style="text-align: left;">frame <em>n.</em>, <em>v.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">fantastic <em>adj.</em> A1</td>
<td style="text-align: left;">firstly <em>adv.</em> A2</td>
<td style="text-align: left;">free <em>adj.</em> A1, <em>adv.</em> A2,
<em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">far <em>adv.</em> A1, <em>adj.</em>
B1</td>
<td style="text-align: left;">fish <em>n.</em> A1, <em>v.</em> A2</td>
<td style="text-align: left;">freedom <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">farm <em>n.</em> A1, <em>v.</em>A2</td>
<td style="text-align: left;">fishing <em>n.</em> A2</td>
<td style="text-align: left;">freeze <em>v.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">farmer <em>n.</em> A1</td>
<td style="text-align: left;">fit <em>v.</em>, <em>adj.</em> A2</td>
<td style="text-align: left;">frequency <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">farming <em>n.</em> A2</td>
<td style="text-align: left;">fitness <em>n.</em> B1</td>
<td style="text-align: left;">frequently <em>adv.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">fascinating <em>adj.</em> B1</td>
<td style="text-align: left;">five <em>number</em> A1</td>
<td style="text-align: left;">fresh <em>adj.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">fashion <em>n.</em> A2</td>
<td style="text-align: left;">fix <em>v.</em> A2, <em>n.</em> B2</td>
<td style="text-align: left;">Friday <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">fashionable <em>adj.</em> B1</td>
<td style="text-align: left;">fixed <em>adj.</em> B1</td>
<td style="text-align: left;">fridge <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">fast <em>adj.</em>, <em>adv.</em> A1</td>
<td style="text-align: left;">flag <em>n.</em> B1</td>
<td style="text-align: left;">friend <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">fasten <em>v.</em> B1</td>
<td style="text-align: left;">flame <em>n.</em> B2</td>
<td style="text-align: left;">friendly <em>adj.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">fat <em>adj.</em> A1, <em>n.</em>A2</td>
<td style="text-align: left;">flash <em>n.</em>, <em>v.</em> B2</td>
<td style="text-align: left;">friendship <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">father <em>n.</em> A1</td>
<td style="text-align: left;">flat <em>n.</em> A1, <em>adj.</em> A2</td>
<td style="text-align: left;">frighten <em>v.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">fault <em>n.</em> B2</td>
<td style="text-align: left;">flexible <em>adj.</em> B2</td>
<td style="text-align: left;">frightened <em>adj.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">favour <em>n.</em> B1, <em>v.</em> B2</td>
<td style="text-align: left;">flight <em>n.</em> A1</td>
<td style="text-align: left;">frightening <em>adj.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">favourite <em>adj.</em>, <em>n.</em>
A1</td>
<td style="text-align: left;">float <em>v.</em> B2</td>
<td style="text-align: left;">frog <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">fear <em>n.</em> A2, <em>v.</em> B1</td>
<td style="text-align: left;">flood <em>n.</em>, <em>v.</em> B1</td>
<td style="text-align: left;">from <em>prep.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">feather <em>n.</em> B2</td>
<td style="text-align: left;">floor <em>n.</em> A1</td>
<td style="text-align: left;">front <em>n.</em>, <em>adj.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">feature <em>n.</em> A2, <em>v.</em>
B1</td>
<td style="text-align: left;">flour <em>n.</em> B1</td>
<td style="text-align: left;">frozen <em>adj.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">February <em>n.</em> A1</td>
<td style="text-align: left;">flow <em>v.</em>, <em>n.</em> B1</td>
<td style="text-align: left;">fruit <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">fee <em>n.</em> B2</td>
<td style="text-align: left;">flower <em>n.</em> A1</td>
<td style="text-align: left;">fry <em>v.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">feed <em>v.</em> A2, <em>n.</em> B2</td>
<td style="text-align: left;">flu <em>n.</em> A2</td>
<td style="text-align: left;">fuel <em>n.</em> B1, <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">feedback <em>n.</em> B2</td>
<td style="text-align: left;">fly <em>v.</em> A1, <em>n.</em> A2</td>
<td style="text-align: left;">full <em>adj.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">feel <em>v.</em> A1, <em>n.</em> B2</td>
<td style="text-align: left;">flying <em>n.</em>, <em>adj.</em> A2</td>
<td style="text-align: left;">fully <em>adv.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">feeling <em>n.</em> A1</td>
<td style="text-align: left;">focus <em>v.</em>, <em>n.</em> A2</td>
<td style="text-align: left;">fun <em>n.</em> A1, <em>adj.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">fellow <em>adj.</em> B2</td>
<td style="text-align: left;">fold <em>v.</em> B1, <em>n.</em> B2</td>
<td style="text-align: left;">function <em>n.</em> B1, <em>v.</em>
B2</td>
</tr>
<tr>
<td style="text-align: left;">female <em>adj.</em>, <em>n.</em> A2</td>
<td style="text-align: left;">folding <em>adj.</em> B2</td>
<td style="text-align: left;">fund <em>n.</em>, <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">fence <em>n.</em> B1</td>
<td style="text-align: left;">folk <em>n.</em>, <em>adj.</em> B1</td>
<td style="text-align: left;">fundamental <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">festival <em>n.</em> A1</td>
<td style="text-align: left;">follow <em>v.</em> A1</td>
<td style="text-align: left;">funding <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">few <em>det.</em>/<em>adj.</em>,
<em>pron.</em> A1</td>
<td style="text-align: left;">following <em>adj.</em> A2, <em>n.</em>
B1, <em>prep.</em> B2</td>
<td style="text-align: left;">funny <em>adj.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">fiction <em>n.</em> A2</td>
<td style="text-align: left;">food <em>n.</em> A1</td>
<td style="text-align: left;">fur <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">field <em>n.</em> A2</td>
<td style="text-align: left;">foot <em>n.</em> A1</td>
<td style="text-align: left;">furniture <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">fifteen <em>number</em> A1</td>
<td style="text-align: left;">football <em>n.</em> A1</td>
<td style="text-align: left;">further <em>adj.</em> A2, <em>adv.</em>
B1</td>
</tr>
<tr>
<td style="text-align: left;">fifth <em>number</em> A1</td>
<td style="text-align: left;">for <em>prep.</em> A1</td>
<td style="text-align: left;">furthermore <em>adv.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">fifty <em>number</em> A1</td>
<td style="text-align: left;">force <em>n.</em>, <em>v.</em> B1</td>
<td style="text-align: left;">future <em>n.</em> A1, <em>adj.</em>
A2</td>
</tr>
<tr>
<td style="text-align: left;">fight <em>v.</em>, <em>n.</em> A2</td>
<td style="text-align: left;">foreign <em>adj.</em> A2</td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<h2 id="g">G</h2>
<table>
<colgroup>
<col style="width: 30%">
<col style="width: 36%">
<col style="width: 33%">
</colgroup>
<tbody>
<tr>
<td style="text-align: left;">gain <em>v.</em>, <em>n.</em> B2</td>
<td style="text-align: left;">girlfriend <em>n.</em> A1</td>
<td style="text-align: left;">grandparent <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">gallery <em>n.</em> A2</td>
<td style="text-align: left;">give <em>v.</em> A1</td>
<td style="text-align: left;">grant <em>v.</em>, <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">game <em>n.</em> A1</td>
<td style="text-align: left;">glad <em>adj.</em> B1</td>
<td style="text-align: left;">grass <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">gang <em>n.</em> B2</td>
<td style="text-align: left;">glass <em>n.</em> A1</td>
<td style="text-align: left;">grateful <em>adj.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">gap <em>n.</em> A2</td>
<td style="text-align: left;">global <em>adj.</em> B1</td>
<td style="text-align: left;">great <em>adj.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">garage <em>n.</em> B1</td>
<td style="text-align: left;">glove <em>n.</em> B1</td>
<td style="text-align: left;">green <em>adj.</em>, <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">garden <em>n.</em> A1</td>
<td style="text-align: left;">go <em>v.</em> A1, <em>n.</em> B1</td>
<td style="text-align: left;">greet <em>v.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">gas <em>n.</em> A2</td>
<td style="text-align: left;">goal <em>n.</em> A2</td>
<td style="text-align: left;">grey <em>adj.</em>, <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">gate <em>n.</em> A2</td>
<td style="text-align: left;">god <em>n.</em> A2</td>
<td style="text-align: left;">ground <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">gather <em>v.</em> B1</td>
<td style="text-align: left;">gold <em>n.</em>, <em>adj.</em> A2</td>
<td style="text-align: left;">group <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">general <em>adj.</em> A2</td>
<td style="text-align: left;">golf <em>n.</em> A2</td>
<td style="text-align: left;">grow <em>v.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">generally <em>adv.</em> B1</td>
<td style="text-align: left;">good <em>adj.</em> A1, <em>n.</em> A2</td>
<td style="text-align: left;">growth <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">generate <em>v.</em> B2</td>
<td style="text-align: left;">goodbye <em>exclam.</em>/<em>n.</em>
A1</td>
<td style="text-align: left;">guarantee <em>v.</em>, <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">generation <em>n.</em> B1</td>
<td style="text-align: left;">goods <em>n.</em> B1</td>
<td style="text-align: left;">guard <em>n.</em>, <em>v.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">generous <em>adj.</em> B1</td>
<td style="text-align: left;">govern <em>v.</em> B2</td>
<td style="text-align: left;">guess <em>v.</em>, <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">genre <em>n.</em> B2</td>
<td style="text-align: left;">government <em>n.</em> A2</td>
<td style="text-align: left;">guest <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">gentle <em>adj.</em> B1</td>
<td style="text-align: left;">grab <em>v.</em> B2</td>
<td style="text-align: left;">guide <em>n.</em>, <em>v.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">gentleman <em>n.</em> B1</td>
<td style="text-align: left;">grade <em>n.</em> B1, <em>v.</em> B2</td>
<td style="text-align: left;">guilty <em>adj.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">geography <em>n.</em> A1</td>
<td style="text-align: left;">gradually <em>adv.</em> B2</td>
<td style="text-align: left;">guitar <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">get <em>v.</em> A1</td>
<td style="text-align: left;">graduate <em>n.</em>, <em>v.</em> B1</td>
<td style="text-align: left;">gun <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">ghost <em>n.</em> B1</td>
<td style="text-align: left;">grain <em>n.</em> B1</td>
<td style="text-align: left;">guy <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">giant <em>adj.</em>, <em>n.</em> B1</td>
<td style="text-align: left;">grand <em>adj.</em> B2</td>
<td style="text-align: left;">gym <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">gift <em>n.</em> A2</td>
<td style="text-align: left;">grandfather <em>n.</em> A1</td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">girl <em>n.</em> A1</td>
<td style="text-align: left;">grandmother <em>n.</em> A1</td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<h2 id="h">H</h2>
<table>
<colgroup>
<col style="width: 37%">
<col style="width: 32%">
<col style="width: 29%">
</colgroup>
<tbody>
<tr>
<td style="text-align: left;">habit <em>n.</em> A2</td>
<td style="text-align: left;">heel <em>n.</em> B2</td>
<td style="text-align: left;">hollow <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">hair <em>n.</em> A1</td>
<td style="text-align: left;">height <em>n.</em> A2</td>
<td style="text-align: left;">holy <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">half <em>n.</em>,
<em>det.</em>/<em>pron.</em> A1, <em>adv.</em> A2</td>
<td style="text-align: left;">helicopter <em>n.</em> B1</td>
<td style="text-align: left;">home <em>n.</em>, <em>adv.</em> A1,
<em>adj.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">hall <em>n.</em> A2</td>
<td style="text-align: left;">hell <em>n.</em> B2</td>
<td style="text-align: left;">homework <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">hand <em>n.</em> A1, <em>v.</em> B1</td>
<td style="text-align: left;">hello <em>exclam.</em>/<em>n.</em> A1</td>
<td style="text-align: left;">honest <em>adj.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">handle <em>v.</em>, <em>n.</em> B2</td>
<td style="text-align: left;">help <em>v.</em>, <em>n.</em> A1</td>
<td style="text-align: left;">honour <em>n.</em>, <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">hang <em>v.</em> B1</td>
<td style="text-align: left;">helpful <em>adj.</em> A2</td>
<td style="text-align: left;">hope <em>v.</em> A1, <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">happen <em>v.</em> A1</td>
<td style="text-align: left;">her <em>pron.</em>, <em>det.</em> A1</td>
<td style="text-align: left;">horrible <em>adj.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">happily <em>adv.</em> A2</td>
<td style="text-align: left;">here <em>adv.</em> A1</td>
<td style="text-align: left;">horror <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">happiness <em>n.</em> B1</td>
<td style="text-align: left;">hero <em>n.</em> A2</td>
<td style="text-align: left;">horse <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">happy <em>adj.</em> A1</td>
<td style="text-align: left;">hers <em>pron.</em> A2</td>
<td style="text-align: left;">hospital <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">hard <em>adj.</em>, <em>adv.</em> A1</td>
<td style="text-align: left;">herself <em>pron.</em> A2</td>
<td style="text-align: left;">host <em>n.</em> B1, <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">hardly <em>adv.</em> B1</td>
<td style="text-align: left;">hesitate <em>v.</em> B2</td>
<td style="text-align: left;">hot <em>adj.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">harm <em>n.</em>, <em>v.</em> B2</td>
<td style="text-align: left;">hey <em>exclam.</em> A1</td>
<td style="text-align: left;">hotel <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">harmful <em>adj.</em> B2</td>
<td style="text-align: left;">hi <em>exclam.</em> A1</td>
<td style="text-align: left;">hour <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">hat <em>n.</em> A1</td>
<td style="text-align: left;">hide <em>v.</em> A2</td>
<td style="text-align: left;">house <em>n.</em> A1, <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">hate <em>v.</em> A1, <em>n.</em> B1</td>
<td style="text-align: left;">high <em>adj.</em> A1, <em>adv.</em> A2,
<em>n.</em> B2</td>
<td style="text-align: left;">household <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">have <em>v.</em> A1, auxiliary <em>v.</em>
A2</td>
<td style="text-align: left;">highlight <em>v.</em>, <em>n.</em> B1</td>
<td style="text-align: left;">housing <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">have to modal <em>v.</em> A1</td>
<td style="text-align: left;">highly <em>adv.</em> B1</td>
<td style="text-align: left;">how <em>adv.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">he <em>pron.</em> A1</td>
<td style="text-align: left;">hill <em>n.</em> A2</td>
<td style="text-align: left;">however <em>adv.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">head <em>n.</em> A1, <em>v.</em> B1</td>
<td style="text-align: left;">him <em>pron.</em> A1</td>
<td style="text-align: left;">huge <em>adj.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">headache <em>n.</em> A2</td>
<td style="text-align: left;">himself <em>pron.</em> A2</td>
<td style="text-align: left;">human <em>adj.</em>, <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">headline <em>n.</em> B1</td>
<td style="text-align: left;">hire <em>v.</em> B1, <em>n.</em> B2</td>
<td style="text-align: left;">humorous <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">health <em>n.</em> A1</td>
<td style="text-align: left;">his <em>det.</em> A1, <em>pron.</em>
A2</td>
<td style="text-align: left;">humour <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">healthy <em>adj.</em> A1</td>
<td style="text-align: left;">historic <em>adj.</em> B1</td>
<td style="text-align: left;">hundred <em>number</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">hear <em>v.</em> A1</td>
<td style="text-align: left;">historical <em>adj.</em> B1</td>
<td style="text-align: left;">hungry <em>adj.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">hearing <em>n.</em> B2</td>
<td style="text-align: left;">history <em>n.</em> A1</td>
<td style="text-align: left;">hunt <em>v.</em> B1, <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">heart <em>n.</em> A2</td>
<td style="text-align: left;">hit <em>v.</em>, <em>n.</em> A2</td>
<td style="text-align: left;">hunting <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">heat <em>n.</em>, <em>v.</em> A2</td>
<td style="text-align: left;">hobby <em>n.</em> A1</td>
<td style="text-align: left;">hurricane <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">heating <em>n.</em> B1</td>
<td style="text-align: left;">hockey <em>n.</em> A2</td>
<td style="text-align: left;">hurry <em>n.</em>, <em>v.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">heaven <em>n.</em> B2</td>
<td style="text-align: left;">hold <em>v.</em> A2, <em>n.</em> B2</td>
<td style="text-align: left;">hurt <em>v.</em>, <em>adj.</em> A2,
<em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">heavily <em>adv.</em> B1</td>
<td style="text-align: left;">hole <em>n.</em> A2</td>
<td style="text-align: left;">husband <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">heavy <em>adj.</em> A2</td>
<td style="text-align: left;">holiday <em>n.</em> A1</td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<h2 id="i">I</h2>
<table>
<colgroup>
<col style="width: 27%">
<col style="width: 45%">
<col style="width: 26%">
</colgroup>
<tbody>
<tr>
<td style="text-align: left;">I <em>pron.</em> A1</td>
<td style="text-align: left;">including <em>prep.</em> A2</td>
<td style="text-align: left;">instructor <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">ice <em>n.</em> A1</td>
<td style="text-align: left;">income <em>n.</em> B2</td>
<td style="text-align: left;">instrument <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">ice cream <em>n.</em> A1</td>
<td style="text-align: left;">increase <em>v.</em>, <em>n.</em> A2</td>
<td style="text-align: left;">insurance <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">idea <em>n.</em> A1</td>
<td style="text-align: left;">increasingly <em>adv.</em> B2</td>
<td style="text-align: left;">intelligence <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">ideal <em>adj.</em> A2, <em>n.</em>
B2</td>
<td style="text-align: left;">incredible <em>adj.</em> A2</td>
<td style="text-align: left;">intelligent <em>adj.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">identify <em>v.</em> A2</td>
<td style="text-align: left;">incredibly <em>adv.</em> B1</td>
<td style="text-align: left;">intend <em>v.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">identity <em>n.</em> B1</td>
<td style="text-align: left;">indeed <em>adv.</em> B1</td>
<td style="text-align: left;">intended <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">if <em>conj.</em> A1</td>
<td style="text-align: left;">independent <em>adj.</em> A2</td>
<td style="text-align: left;">intense <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">ignore <em>v.</em> B1</td>
<td style="text-align: left;">indicate <em>v.</em> B1</td>
<td style="text-align: left;">intention <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">ill <em>adj.</em> A2</td>
<td style="text-align: left;">indirect <em>adj.</em> B1</td>
<td style="text-align: left;">interest <em>n.</em>, <em>v.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">illegal <em>adj.</em> B1</td>
<td style="text-align: left;">individual <em>n.</em>, <em>adj.</em>
A2</td>
<td style="text-align: left;">interested <em>adj.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">illness <em>n.</em> A2</td>
<td style="text-align: left;">indoor <em>adj.</em> B1</td>
<td style="text-align: left;">interesting <em>adj.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">illustrate <em>v.</em> B2</td>
<td style="text-align: left;">indoors <em>adv.</em> B1</td>
<td style="text-align: left;">internal <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">illustration <em>n.</em> B2</td>
<td style="text-align: left;">industrial <em>adj.</em> B2</td>
<td style="text-align: left;">international <em>adj.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">image <em>n.</em> A2</td>
<td style="text-align: left;">industry <em>n.</em> A2</td>
<td style="text-align: left;">internet <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">imaginary <em>adj.</em> B1</td>
<td style="text-align: left;">infection <em>n.</em> B2</td>
<td style="text-align: left;">interpret <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">imagination <em>n.</em> B2</td>
<td style="text-align: left;">influence <em>n.</em>, <em>v.</em> B1</td>
<td style="text-align: left;">interrupt <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">imagine <em>v.</em> A1</td>
<td style="text-align: left;">inform <em>v.</em> B2</td>
<td style="text-align: left;">interview <em>n.</em>, <em>v.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">immediate <em>adj.</em> B1</td>
<td style="text-align: left;">informal <em>adj.</em> A2</td>
<td style="text-align: left;">into <em>prep.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">immediately <em>adv.</em> A2</td>
<td style="text-align: left;">information <em>n.</em> A1</td>
<td style="text-align: left;">introduce <em>v.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">immigrant <em>n.</em> B1</td>
<td style="text-align: left;">ingredient <em>n.</em> B1</td>
<td style="text-align: left;">introduction <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">impact <em>n.</em>, <em>v.</em> B1</td>
<td style="text-align: left;">initial <em>adj.</em> B2</td>
<td style="text-align: left;">invent <em>v.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">impatient <em>adj.</em> B2</td>
<td style="text-align: left;">initially <em>adv.</em> B2</td>
<td style="text-align: left;">invention <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">imply <em>v.</em> B2</td>
<td style="text-align: left;">initiative <em>n.</em> B2</td>
<td style="text-align: left;">invest <em>v.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">import <em>n.</em>, <em>v.</em> B1</td>
<td style="text-align: left;">injure <em>v.</em> B1</td>
<td style="text-align: left;">investigate <em>v.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">importance <em>n.</em> B1</td>
<td style="text-align: left;">injured <em>adj.</em> B1</td>
<td style="text-align: left;">investigation <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">important <em>adj.</em> A1</td>
<td style="text-align: left;">injury <em>n.</em> A2</td>
<td style="text-align: left;">investment <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">impose <em>v.</em> B2</td>
<td style="text-align: left;">inner <em>adj.</em> B2</td>
<td style="text-align: left;">invitation <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">impossible <em>adj.</em> A2</td>
<td style="text-align: left;">innocent <em>adj.</em> B1</td>
<td style="text-align: left;">invite <em>v.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">impress <em>v.</em> B2</td>
<td style="text-align: left;">insect <em>n.</em> A2</td>
<td style="text-align: left;">involve <em>v.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">impressed <em>adj.</em> B2</td>
<td style="text-align: left;">inside <em>prep.</em>, <em>adv.</em>,
<em>n.</em>, <em>adj.</em> A2</td>
<td style="text-align: left;">involved <em>adj.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">impression <em>n.</em> B1</td>
<td style="text-align: left;">insight <em>n.</em> B2</td>
<td style="text-align: left;">iron <em>n.</em>, <em>v.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">impressive <em>adj.</em> B1</td>
<td style="text-align: left;">insist <em>v.</em> B2</td>
<td style="text-align: left;">island <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">improve <em>v.</em> A1</td>
<td style="text-align: left;">inspire <em>v.</em> B2</td>
<td style="text-align: left;">issue <em>n.</em> B1, <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">improvement <em>n.</em> B1</td>
<td style="text-align: left;">install <em>v.</em> B2</td>
<td style="text-align: left;">IT <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">in <em>prep.</em>, <em>adv.</em> A1</td>
<td style="text-align: left;">instance <em>n.</em> B2</td>
<td style="text-align: left;">it <em>pron.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">inch <em>n.</em> B2</td>
<td style="text-align: left;">instead <em>adv.</em> A2</td>
<td style="text-align: left;">item <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">incident <em>n.</em> B2</td>
<td style="text-align: left;">institute <em>n.</em> B2</td>
<td style="text-align: left;">its <em>det.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">include <em>v.</em> A1</td>
<td style="text-align: left;">institution <em>n.</em> B2</td>
<td style="text-align: left;">itself <em>pron.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">included <em>adj.</em> A2</td>
<td style="text-align: left;">instruction <em>n.</em> A2</td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<h2 id="j">J</h2>
<table>
<tbody>
<tr>
<td style="text-align: left;">jacket <em>n.</em> A1</td>
<td style="text-align: left;">joke <em>n.</em>, <em>v.</em> A2</td>
<td style="text-align: left;">July <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">jam <em>n.</em> A2</td>
<td style="text-align: left;">journal <em>n.</em> B1</td>
<td style="text-align: left;">jump <em>v.</em>, <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">January <em>n.</em> A1</td>
<td style="text-align: left;">journalist <em>n.</em> A2</td>
<td style="text-align: left;">June <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">jazz <em>n.</em> A2</td>
<td style="text-align: left;">journey <em>n.</em> A1</td>
<td style="text-align: left;">junior <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">jeans <em>n.</em> A1</td>
<td style="text-align: left;">joy <em>n.</em> B2</td>
<td style="text-align: left;">just <em>adv.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">jewellery <em>n.</em> A2</td>
<td style="text-align: left;">judge <em>n.</em>, <em>v.</em> B1</td>
<td style="text-align: left;">justice <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">job <em>n.</em> A1</td>
<td style="text-align: left;">judgement <em>n.</em> B2</td>
<td style="text-align: left;">justify <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">join <em>v.</em> A1</td>
<td style="text-align: left;">juice <em>n.</em> A1</td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<h2 id="k">K</h2>
<table style="width:100%;">
<colgroup>
<col style="width: 38%">
<col style="width: 31%">
<col style="width: 30%">
</colgroup>
<tbody>
<tr>
<td style="text-align: left;">keen <em>adj.</em> B1</td>
<td style="text-align: left;">killing <em>n.</em> B1</td>
<td style="text-align: left;">knee <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">keep <em>v.</em> A1</td>
<td style="text-align: left;">kilometre <em>n.</em> A1</td>
<td style="text-align: left;">knife <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">key <em>n.</em>, <em>adj.</em> A1,
<em>v.</em> B1</td>
<td style="text-align: left;">kind (type) <em>n.</em> A1</td>
<td style="text-align: left;">knock <em>v.</em> A2, <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">keyboard <em>n.</em> B1</td>
<td style="text-align: left;">kind (caring) <em>adj.</em> B1</td>
<td style="text-align: left;">know <em>v.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">kick <em>v.</em>, <em>n.</em> B1</td>
<td style="text-align: left;">king <em>n.</em> A2</td>
<td style="text-align: left;">knowledge <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">kid <em>n.</em> A2</td>
<td style="text-align: left;">kiss <em>v.</em>, <em>n.</em> B1</td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">kill <em>v.</em> A2</td>
<td style="text-align: left;">kitchen <em>n.</em> A1</td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<h2 id="l">L</h2>
<table>
<colgroup>
<col style="width: 29%">
<col style="width: 38%">
<col style="width: 31%">
</colgroup>
<tbody>
<tr>
<td style="text-align: left;">lab <em>n.</em> A2</td>
<td style="text-align: left;">leather <em>n.</em> B1</td>
<td style="text-align: left;">literature <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">label <em>n.</em>, <em>v.</em> B1</td>
<td style="text-align: left;">leave <em>v.</em> A1, <em>n.</em> B2</td>
<td style="text-align: left;">little <em>adj.</em>,
<em>det.</em>/<em>pron.</em> A1, <em>adv.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">laboratory <em>n.</em> B1</td>
<td style="text-align: left;">lecture <em>n.</em>, <em>v.</em> A2</td>
<td style="text-align: left;">live1 <em>v.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">labour <em>n.</em> B2</td>
<td style="text-align: left;">left <em>adj.</em>, <em>adv.</em>,
<em>n.</em> A1</td>
<td style="text-align: left;">live2 <em>adj.</em>, <em>adv.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">lack <em>n.</em>, <em>v.</em> B1</td>
<td style="text-align: left;">leg <em>n.</em> A1</td>
<td style="text-align: left;">lively <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">lady <em>n.</em> A2</td>
<td style="text-align: left;">legal <em>adj.</em> B1</td>
<td style="text-align: left;">living <em>adj.</em>, <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">lake <em>n.</em> A2</td>
<td style="text-align: left;">leisure <em>n.</em> B1</td>
<td style="text-align: left;">load <em>n.</em>, <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">lamp <em>n.</em> A2</td>
<td style="text-align: left;">lemon <em>n.</em> A2</td>
<td style="text-align: left;">loan <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">land <em>n.</em> A1, <em>v.</em> A2</td>
<td style="text-align: left;">lend <em>v.</em> A2</td>
<td style="text-align: left;">local <em>adj.</em> A1, <em>n.</em>
B1</td>
</tr>
<tr>
<td style="text-align: left;">landscape <em>n.</em> B2</td>
<td style="text-align: left;">length <em>n.</em> B1</td>
<td style="text-align: left;">locate <em>v.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">language <em>n.</em> A1</td>
<td style="text-align: left;">less <em>det.</em>/<em>pron.</em>,
<em>adv.</em> A2</td>
<td style="text-align: left;">located <em>adj.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">laptop <em>n.</em> A2</td>
<td style="text-align: left;">lesson <em>n.</em> A1</td>
<td style="text-align: left;">location <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">large <em>adj.</em> A1</td>
<td style="text-align: left;">let <em>v.</em> A1</td>
<td style="text-align: left;">lock <em>v.</em>, <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">largely <em>adv.</em> B2</td>
<td style="text-align: left;">letter <em>n.</em> A1</td>
<td style="text-align: left;">logical <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">last1 (final) <em>det.</em> A1,
<em>adv.</em>, <em>n.</em> A2</td>
<td style="text-align: left;">level <em>n.</em> A2, <em>adj.</em> B1,
<em>v.</em> B2</td>
<td style="text-align: left;">lonely <em>adj.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">last1 (taking time) <em>v.</em> A2</td>
<td style="text-align: left;">library <em>n.</em> A1</td>
<td style="text-align: left;">long1 <em>adj.</em>, <em>adv.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">late <em>adj.</em>, <em>adv.</em> A1</td>
<td style="text-align: left;">licence <em>n.</em> B2</td>
<td style="text-align: left;">long-term <em>adj.</em>, <em>adv.</em>
B2</td>
</tr>
<tr>
<td style="text-align: left;">later <em>adv.</em> A1, <em>adj.</em>
A2</td>
<td style="text-align: left;">lie1 <em>v.</em> A1</td>
<td style="text-align: left;">look <em>v.</em> A1, <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">latest <em>adj.</em> B1, <em>n.</em>
B2</td>
<td style="text-align: left;">lie2 (tell a lie) <em>v.</em>, <em>n.</em>
B1</td>
<td style="text-align: left;">loose <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">laugh <em>v.</em>, <em>n.</em> A1</td>
<td style="text-align: left;">life <em>n.</em> A1</td>
<td style="text-align: left;">lord <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">laughter <em>n.</em> A2</td>
<td style="text-align: left;">lifestyle <em>n.</em> A2</td>
<td style="text-align: left;">lorry <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">launch <em>v.</em>, <em>n.</em> B2</td>
<td style="text-align: left;">lift <em>v.</em>, <em>n.</em> A2</td>
<td style="text-align: left;">lose <em>v.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">law <em>n.</em> A2</td>
<td style="text-align: left;">light (from the sun/a lamp) <em>n.</em>,
<em>adj.</em> A1, <em>v.</em> A2</td>
<td style="text-align: left;">loss <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">lawyer <em>n.</em> A2</td>
<td style="text-align: left;">light (not heavy) <em>adj.</em> A2</td>
<td style="text-align: left;">lost <em>adj.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">lay <em>v.</em> B1</td>
<td style="text-align: left;">like (similar) <em>prep.</em> A1</td>
<td style="text-align: left;">lot <em>pron.</em>, <em>det.</em>,
<em>adv.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">layer <em>n.</em> B1</td>
<td style="text-align: left;">like (find sb/sth pleasant) <em>v.</em>
A1, <em>n.</em> B1</td>
<td style="text-align: left;">loud <em>adj.</em>, <em>adv.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">lazy <em>adj.</em> A2</td>
<td style="text-align: left;">likely <em>adj.</em> A2</td>
<td style="text-align: left;">loudly <em>adv.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">lead1 <em>v.</em> A2, <em>n.</em> B1</td>
<td style="text-align: left;">limit <em>n.</em>, <em>v.</em> B1</td>
<td style="text-align: left;">love <em>n.</em>, <em>v.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">leader <em>n.</em> A2</td>
<td style="text-align: left;">limited <em>adj.</em> B2</td>
<td style="text-align: left;">lovely <em>adj.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">leadership <em>n.</em> B2</td>
<td style="text-align: left;">line <em>n.</em> A1, <em>v.</em> B2</td>
<td style="text-align: left;">low <em>adj.</em>, <em>adv.</em> A2,
<em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">leading <em>adj.</em> B1</td>
<td style="text-align: left;">link <em>n.</em>, <em>v.</em> A2</td>
<td style="text-align: left;">lower <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">leaf <em>n.</em> B1</td>
<td style="text-align: left;">lion <em>n.</em> A1</td>
<td style="text-align: left;">luck <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">league <em>n.</em> B2</td>
<td style="text-align: left;">lip <em>n.</em> B1</td>
<td style="text-align: left;">lucky <em>adj.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">lean <em>v.</em> B2</td>
<td style="text-align: left;">liquid <em>n.</em>, <em>adj.</em> B1</td>
<td style="text-align: left;">lunch <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">learn <em>v.</em> A1</td>
<td style="text-align: left;">list <em>n.</em>, <em>v.</em> A1</td>
<td style="text-align: left;">lung <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">learning <em>n.</em> A2</td>
<td style="text-align: left;">listen <em>v.</em> A1</td>
<td style="text-align: left;">luxury <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">least <em>det.</em>/<em>pron.</em>,
<em>adv.</em> A2</td>
<td style="text-align: left;">listener <em>n.</em> A2</td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<h2 id="m">M</h2>
<table>
<colgroup>
<col style="width: 38%">
<col style="width: 32%">
<col style="width: 29%">
</colgroup>
<tbody>
<tr>
<td style="text-align: left;">machine <em>n.</em> A1</td>
<td style="text-align: left;">meanwhile <em>adv.</em> B1</td>
<td style="text-align: left;">mixture <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">mad <em>adj.</em> B1</td>
<td style="text-align: left;">measure <em>v.</em>, <em>n.</em> B1</td>
<td style="text-align: left;">mobile <em>adj.</em>, <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">magazine <em>n.</em> A1</td>
<td style="text-align: left;">measurement <em>n.</em> B2</td>
<td style="text-align: left;">model <em>n.</em> A1, <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">magic <em>n.</em>, <em>adj.</em> B1</td>
<td style="text-align: left;">meat <em>n.</em> A1</td>
<td style="text-align: left;">modern <em>adj.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">mail <em>n.</em>, <em>v.</em> A2</td>
<td style="text-align: left;">media <em>n.</em> A2</td>
<td style="text-align: left;">modify <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">main <em>adj.</em> A1</td>
<td style="text-align: left;">medical <em>adj.</em> A2</td>
<td style="text-align: left;">moment <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">mainly <em>adv.</em> B1</td>
<td style="text-align: left;">medicine <em>n.</em> A2</td>
<td style="text-align: left;">Monday <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">maintain <em>v.</em> B2</td>
<td style="text-align: left;">medium <em>adj.</em> B1, <em>n.</em>
B2</td>
<td style="text-align: left;">money <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">major <em>adj.</em> A2</td>
<td style="text-align: left;">meet <em>v.</em> A1</td>
<td style="text-align: left;">monitor <em>n.</em>, <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">majority <em>n.</em> B2</td>
<td style="text-align: left;">meeting <em>n.</em> A1</td>
<td style="text-align: left;">monkey <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">make <em>v.</em> A1, <em>n.</em> B2</td>
<td style="text-align: left;">melt <em>v.</em> B2</td>
<td style="text-align: left;">month <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">male <em>adj.</em>, <em>n.</em> A2</td>
<td style="text-align: left;">member <em>n.</em> A1</td>
<td style="text-align: left;">mood <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">mall <em>n.</em> B1</td>
<td style="text-align: left;">memory <em>n.</em> A2</td>
<td style="text-align: left;">moon <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">man <em>n.</em> A1</td>
<td style="text-align: left;">mental <em>adj.</em> B1</td>
<td style="text-align: left;">moral <em>adj.</em>, <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">manage <em>v.</em> A2</td>
<td style="text-align: left;">mention <em>v.</em> A2, <em>n.</em>
B1</td>
<td style="text-align: left;">more <em>det.</em>/<em>pron.</em>,
<em>adv.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">management <em>n.</em> B1</td>
<td style="text-align: left;">menu <em>n.</em> A1</td>
<td style="text-align: left;">morning <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">manager <em>n.</em> A2</td>
<td style="text-align: left;">mess <em>n.</em>, <em>v.</em> B1</td>
<td style="text-align: left;">most <em>det.</em>/<em>pron.</em>,
<em>adv.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">manner <em>n.</em> A2</td>
<td style="text-align: left;">message <em>n.</em> A1</td>
<td style="text-align: left;">mostly <em>adv.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">many <em>det.</em>/<em>pron.</em> A1</td>
<td style="text-align: left;">metal <em>n.</em> A2</td>
<td style="text-align: left;">mother <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">map <em>n.</em> A1, <em>v.</em> B2</td>
<td style="text-align: left;">method <em>n.</em> A2</td>
<td style="text-align: left;">motor <em>n.</em>, <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">March <em>n.</em> A1</td>
<td style="text-align: left;">metre <em>n.</em> A1</td>
<td style="text-align: left;">motorcycle <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">mark <em>v.</em>, <em>n.</em> A2</td>
<td style="text-align: left;">middle <em>n.</em>, <em>adj.</em> A2</td>
<td style="text-align: left;">mount <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">market <em>n.</em> A1, <em>v.</em> B1</td>
<td style="text-align: left;">midnight <em>n.</em> A1</td>
<td style="text-align: left;">mountain <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">marketing <em>n.</em> B1</td>
<td style="text-align: left;">might modal <em>v.</em> A2</td>
<td style="text-align: left;">mouse <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">marriage <em>n.</em> B1</td>
<td style="text-align: left;">mild <em>adj.</em> B1</td>
<td style="text-align: left;">mouth <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">married <em>adj.</em> A1</td>
<td style="text-align: left;">mile <em>n.</em> A1</td>
<td style="text-align: left;">move <em>v.</em> A1, <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">marry <em>v.</em> A2</td>
<td style="text-align: left;">military <em>adj.</em>, <em>n.</em>
B2</td>
<td style="text-align: left;">movement <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">mass <em>n.</em>, <em>adj.</em> B2</td>
<td style="text-align: left;">milk <em>n.</em> A1</td>
<td style="text-align: left;">movie <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">massive <em>adj.</em> B2</td>
<td style="text-align: left;">million <em>number</em> A1</td>
<td style="text-align: left;">much <em>det.</em>/<em>pron.</em>,
<em>adv.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">master <em>n.</em>, <em>v.</em> B2</td>
<td style="text-align: left;">mind <em>n.</em>, <em>v.</em> A2</td>
<td style="text-align: left;">mud <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">match (contest/correspond) <em>n.</em>,
<em>v.</em> A1</td>
<td style="text-align: left;">mine (belongs to me) <em>pron.</em>
A2</td>
<td style="text-align: left;">multiple <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">matching <em>adj.</em> B2</td>
<td style="text-align: left;">mine (hole in the ground) <em>n.</em>
B1</td>
<td style="text-align: left;">multiply <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">material <em>n.</em> A2, <em>adj.</em>
B2</td>
<td style="text-align: left;">mineral <em>n.</em> B2</td>
<td style="text-align: left;">mum <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">mathematics <em>n.</em> A2</td>
<td style="text-align: left;">minimum <em>adj.</em>, <em>n.</em> B2</td>
<td style="text-align: left;">murder <em>n.</em>, <em>v.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">maths <em>n.</em> A2</td>
<td style="text-align: left;">minister <em>n.</em> B2</td>
<td style="text-align: left;">muscle <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">matter <em>n.</em>, <em>v.</em> A2</td>
<td style="text-align: left;">minor <em>adj.</em> B2</td>
<td style="text-align: left;">museum <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">maximum <em>adj.</em>, <em>n.</em> B2</td>
<td style="text-align: left;">minority <em>n.</em> B2</td>
<td style="text-align: left;">music <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">May <em>n.</em> A1</td>
<td style="text-align: left;">minute1 <em>n.</em> A1</td>
<td style="text-align: left;">musical <em>adj.</em> A2, <em>n.</em>
B1</td>
</tr>
<tr>
<td style="text-align: left;">may modal <em>v.</em> A2</td>
<td style="text-align: left;">mirror <em>n.</em> A2</td>
<td style="text-align: left;">musician <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">maybe <em>adv.</em> A1</td>
<td style="text-align: left;">miss <em>v.</em> A1</td>
<td style="text-align: left;">must modal <em>v.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">me <em>pron.</em> A1</td>
<td style="text-align: left;">missing <em>adj.</em> A2</td>
<td style="text-align: left;">my <em>det.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">meal <em>n.</em> A1</td>
<td style="text-align: left;">mission <em>n.</em> B2</td>
<td style="text-align: left;">myself <em>pron.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">mean <em>v.</em> A1</td>
<td style="text-align: left;">mistake <em>n.</em> A1, <em>v.</em>
B2</td>
<td style="text-align: left;">mysterious <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">meaning <em>n.</em> A1</td>
<td style="text-align: left;">mix <em>v.</em>, <em>n.</em> B1</td>
<td style="text-align: left;">mystery <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">means <em>n.</em> B2</td>
<td style="text-align: left;">mixed <em>adj.</em> B2</td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<h2 id="n">N</h2>
<table>
<colgroup>
<col style="width: 37%">
<col style="width: 32%">
<col style="width: 30%">
</colgroup>
<tbody>
<tr>
<td style="text-align: left;">nail <em>n.</em> B1</td>
<td style="text-align: left;">nerve <em>n.</em> B2</td>
<td style="text-align: left;">none <em>pron.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">name <em>n.</em>, <em>v.</em> A1</td>
<td style="text-align: left;">nervous <em>adj.</em> A2</td>
<td style="text-align: left;">nor <em>conj.</em>/<em>adv.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">narrative <em>n.</em>, <em>adj.</em>
B1</td>
<td style="text-align: left;">net <em>n.</em> B1</td>
<td style="text-align: left;">normal <em>adj.</em> A2, <em>n.</em>
B1</td>
</tr>
<tr>
<td style="text-align: left;">narrow <em>adj.</em> A2, <em>v.</em>
B2</td>
<td style="text-align: left;">network <em>n.</em> A2</td>
<td style="text-align: left;">normally <em>adv.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">nation <em>n.</em> B1</td>
<td style="text-align: left;">never <em>adv.</em> A1</td>
<td style="text-align: left;">north <em>n.</em>, <em>adj.</em>,
<em>adv.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">national <em>adj.</em> A2, <em>n.</em>
B2</td>
<td style="text-align: left;">nevertheless <em>adv.</em> B2</td>
<td style="text-align: left;">northern <em>adj.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">native <em>adj.</em>, <em>n.</em> B1</td>
<td style="text-align: left;">new <em>adj.</em> A1</td>
<td style="text-align: left;">nose <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">natural <em>adj.</em> A1</td>
<td style="text-align: left;">news <em>n.</em> A1</td>
<td style="text-align: left;">not <em>adv.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">naturally <em>adv.</em> B1</td>
<td style="text-align: left;">newspaper <em>n.</em> A1</td>
<td style="text-align: left;">note <em>n.</em> A1, <em>v.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">nature <em>n.</em> A2</td>
<td style="text-align: left;">next <em>adj.</em>, <em>adv.</em> A1,
<em>n.</em> B1</td>
<td style="text-align: left;">nothing <em>pron.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">near <em>prep.</em>, <em>adj.</em>,
<em>adv.</em> A1</td>
<td style="text-align: left;">next to <em>prep.</em> A1</td>
<td style="text-align: left;">notice <em>v.</em>, <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">nearly <em>adv.</em> A2</td>
<td style="text-align: left;">nice <em>adj.</em> A1</td>
<td style="text-align: left;">notion <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">neat <em>adj.</em> B2</td>
<td style="text-align: left;">night <em>n.</em> A1</td>
<td style="text-align: left;">novel <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">necessarily <em>adv.</em> B1</td>
<td style="text-align: left;">nightmare <em>n.</em> B2</td>
<td style="text-align: left;">November <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">necessary <em>adj.</em> A2</td>
<td style="text-align: left;">nine <em>number</em> A1</td>
<td style="text-align: left;">now <em>adv.</em> A1, <em>conj.</em>
B1</td>
</tr>
<tr>
<td style="text-align: left;">neck <em>n.</em> A2</td>
<td style="text-align: left;">nineteen <em>number</em> A1</td>
<td style="text-align: left;">nowhere <em>adv.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">need <em>v.</em> A1, <em>n.</em> A2, modal
<em>v.</em> B1</td>
<td style="text-align: left;">ninety <em>number</em> A1</td>
<td style="text-align: left;">nuclear <em>adj.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">needle <em>n.</em> B1</td>
<td style="text-align: left;">no <em>exclam.</em>, <em>det.</em> A1</td>
<td style="text-align: left;">number <em>n.</em> A1, <em>v.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">negative <em>adj.</em> A1, <em>n.</em>
B2</td>
<td style="text-align: left;">no one <em>pron.</em> A1</td>
<td style="text-align: left;">numerous <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">neighbour <em>n.</em> A1</td>
<td style="text-align: left;">nobody <em>pron.</em> A1</td>
<td style="text-align: left;">nurse <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">neighbourhood <em>n.</em> B1</td>
<td style="text-align: left;">noise <em>n.</em> A2</td>
<td style="text-align: left;">nut <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">neither <em>det.</em>/<em>pron.</em> A2,
<em>adv.</em> B1</td>
<td style="text-align: left;">noisy <em>adj.</em> A2</td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<h2 id="o">O</h2>
<table>
<colgroup>
<col style="width: 24%">
<col style="width: 36%">
<col style="width: 39%">
</colgroup>
<tbody>
<tr>
<td style="text-align: left;">obey <em>v.</em> B2</td>
<td style="text-align: left;">oil <em>n.</em> A2</td>
<td style="text-align: left;">organ <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">object <em>n.</em> A1, <em>v.</em> B2</td>
<td style="text-align: left;">OK <em>exclam.</em>,
<em>adj.</em>/<em>adv.</em> A1</td>
<td style="text-align: left;">organization <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">objective <em>n.</em>, <em>adj.</em>
B2</td>
<td style="text-align: left;">old <em>adj.</em> A1</td>
<td style="text-align: left;">organize <em>v.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">obligation <em>n.</em> B2</td>
<td style="text-align: left;">old-fashioned <em>adj.</em> B1</td>
<td style="text-align: left;">organized <em>adj.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">observation <em>n.</em> B2</td>
<td style="text-align: left;">on <em>prep.</em>, <em>adv.</em> A1</td>
<td style="text-align: left;">organizer <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">observe <em>v.</em> B2</td>
<td style="text-align: left;">once <em>adv.</em> A1, <em>conj.</em>
B1</td>
<td style="text-align: left;">origin <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">obtain <em>v.</em> B2</td>
<td style="text-align: left;">one <em>number</em>/<em>det.</em>,
<em>pron.</em> A1</td>
<td style="text-align: left;">original <em>adj.</em> A2,
<em>n.</em>B1</td>
</tr>
<tr>
<td style="text-align: left;">obvious <em>adj.</em> B1</td>
<td style="text-align: left;">onion <em>n.</em> A1</td>
<td style="text-align: left;">originally <em>adv.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">obviously <em>adv.</em> B1</td>
<td style="text-align: left;">online <em>adj.</em>, <em>adv.</em>
A1</td>
<td style="text-align: left;">other <em>adj.</em>/<em>pron.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">occasion <em>n.</em> B1</td>
<td style="text-align: left;">only <em>adj.</em>, <em>adv.</em> A1</td>
<td style="text-align: left;">otherwise <em>adv.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">occasionally <em>adv.</em> B2</td>
<td style="text-align: left;">onto <em>prep.</em> A2</td>
<td style="text-align: left;">ought modal <em>v.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">occur <em>v.</em> B1</td>
<td style="text-align: left;">open <em>adj.</em>, <em>v.</em> A1</td>
<td style="text-align: left;">our <em>det.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">ocean <em>n.</em> A2</td>
<td style="text-align: left;">opening <em>n.</em> B2</td>
<td style="text-align: left;">ours <em>pron.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">o’clock <em>adv.</em> A1</td>
<td style="text-align: left;">operate <em>v.</em> B2</td>
<td style="text-align: left;">ourselves <em>pron.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">October <em>n.</em> A1</td>
<td style="text-align: left;">operation <em>n.</em> B1</td>
<td style="text-align: left;">out <em>adv.</em>/<em>prep.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">odd <em>adj.</em> B1</td>
<td style="text-align: left;">opinion <em>n.</em> A1</td>
<td style="text-align: left;">outcome <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">of <em>prep.</em> A1</td>
<td style="text-align: left;">opponent <em>n.</em> B2</td>
<td style="text-align: left;">outdoor <em>adj.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">off <em>adv.</em>, <em>prep.</em> A1</td>
<td style="text-align: left;">opportunity <em>n.</em> A2</td>
<td style="text-align: left;">outdoors <em>adv.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">offence <em>n.</em> B2</td>
<td style="text-align: left;">oppose <em>v.</em> B2</td>
<td style="text-align: left;">outer <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">offend <em>v.</em> B2</td>
<td style="text-align: left;">opposed <em>adj.</em> B2</td>
<td style="text-align: left;">outline <em>n.</em>, <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">offensive <em>adj.</em> B2</td>
<td style="text-align: left;">opposite <em>adj.</em>, <em>adv.</em>,
<em>prep.</em>, <em>n.</em> A1</td>
<td style="text-align: left;">outside <em>adv.</em> A1, <em>prep.</em>,
noun., <em>adj.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">offer <em>v.</em>, <em>n.</em> A2</td>
<td style="text-align: left;">opposition <em>n.</em> B2</td>
<td style="text-align: left;">oven <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">office <em>n.</em> A1</td>
<td style="text-align: left;">option <em>n.</em> A2</td>
<td style="text-align: left;">over <em>prep.</em>, <em>adv.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">officer <em>n.</em> A2</td>
<td style="text-align: left;">or <em>conj.</em> A1</td>
<td style="text-align: left;">overall <em>adj.</em>, <em>adv.</em>
B2</td>
</tr>
<tr>
<td style="text-align: left;">official <em>adj.</em> B1, <em>n.</em>
B2</td>
<td style="text-align: left;">orange <em>n.</em>, <em>adj.</em> A1</td>
<td style="text-align: left;">owe <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">often <em>adv.</em> A1</td>
<td style="text-align: left;">order <em>n.</em>, <em>v.</em> A1</td>
<td style="text-align: left;">own <em>adj.</em>/<em>pron.</em> A1,
<em>v.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">oh <em>exclam.</em> A1</td>
<td style="text-align: left;">ordinary <em>adj.</em> A2</td>
<td style="text-align: left;">owner <em>n.</em> A2</td>
</tr>
</tbody>
</table>
<h2 id="p">P</h2>
<table>
<colgroup>
<col style="width: 35%">
<col style="width: 36%">
<col style="width: 28%">
</colgroup>
<tbody>
<tr>
<td style="text-align: left;">pace <em>n.</em>, <em>v.</em> B2</td>
<td style="text-align: left;">picture <em>n.</em> A1, <em>v.</em>
B2</td>
<td style="text-align: left;">preparation <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">pack <em>v.</em> A2, <em>n.</em> B1</td>
<td style="text-align: left;">piece <em>n.</em> A1</td>
<td style="text-align: left;">prepare <em>v.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">package <em>n.</em> B1, <em>v.</em>
B2</td>
<td style="text-align: left;">pig <em>n.</em> A1</td>
<td style="text-align: left;">prepared <em>adj.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">page <em>n.</em> A1</td>
<td style="text-align: left;">pile <em>n.</em>, <em>v.</em> B2</td>
<td style="text-align: left;">presence <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">pain <em>n.</em> A2</td>
<td style="text-align: left;">pilot <em>n.</em> A2</td>
<td style="text-align: left;">present <em>adj.</em>, <em>n.</em> A1,
<em>v.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">painful <em>adj.</em> B1</td>
<td style="text-align: left;">pin <em>n.</em>, <em>v.</em> B1</td>
<td style="text-align: left;">presentation <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">paint <em>v.</em>, <em>n.</em> A1</td>
<td style="text-align: left;">pink <em>adj.</em>, <em>n.</em> A1</td>
<td style="text-align: left;">preserve <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">painter <em>n.</em> A2</td>
<td style="text-align: left;">pipe <em>n.</em> B1</td>
<td style="text-align: left;">president <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">painting <em>n.</em> A1</td>
<td style="text-align: left;"><a href="https://josh-gao.top/posts/279fbed9.html">pitch</a> <em>n.</em>
B2</td>
<td style="text-align: left;">press <em>v.</em>, <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">pair <em>n.</em> A1</td>
<td style="text-align: left;">place <em>n.</em> A1, <em>v.</em> B1</td>
<td style="text-align: left;">pressure <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">palace <em>n.</em> A2</td>
<td style="text-align: left;">plain <em>adj.</em> B2</td>
<td style="text-align: left;">pretend <em>v.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">pale <em>adj.</em> B1</td>
<td style="text-align: left;">plan <em>n.</em>, <em>v.</em> A1</td>
<td style="text-align: left;">pretty <em>adj.</em>, <em>adv.</em>
A1</td>
</tr>
<tr>
<td style="text-align: left;">pan <em>n.</em> B1</td>
<td style="text-align: left;">plane <em>n.</em> A1</td>
<td style="text-align: left;">prevent <em>v.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">panel <em>n.</em> B2</td>
<td style="text-align: left;">planet <em>n.</em> A2</td>
<td style="text-align: left;">previous <em>adj.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">pants <em>n.</em> A2</td>
<td style="text-align: left;">planning <em>n.</em> B1</td>
<td style="text-align: left;">previously <em>adv.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">paper <em>n.</em> A1</td>
<td style="text-align: left;">plant <em>n.</em> A1, <em>v.</em> A2</td>
<td style="text-align: left;">price <em>n.</em> A1, <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">paragraph <em>n.</em> A1</td>
<td style="text-align: left;">plastic <em>n.</em>, <em>adj.</em> A2</td>
<td style="text-align: left;">priest <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">parent <em>n.</em> A1</td>
<td style="text-align: left;">plate <em>n.</em> A2</td>
<td style="text-align: left;">primary <em>adj.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">park <em>n.</em>, <em>v.</em> A1</td>
<td style="text-align: left;">platform <em>n.</em> A2</td>
<td style="text-align: left;">prime <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">parking <em>n.</em> A2</td>
<td style="text-align: left;">play <em>v.</em>, <em>n.</em> A1</td>
<td style="text-align: left;">prince <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">parliament <em>n.</em> B2</td>
<td style="text-align: left;">player <em>n.</em> A1</td>
<td style="text-align: left;">princess <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">part <em>n.</em> A1</td>
<td style="text-align: left;">pleasant <em>adj.</em> B1</td>
<td style="text-align: left;">principle <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">participant <em>n.</em> B2</td>
<td style="text-align: left;">please <em>exclam.</em> A1, <em>v.</em>
A2</td>
<td style="text-align: left;">print <em>v.</em> A2, <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">participate <em>v.</em> B1</td>
<td style="text-align: left;">pleased <em>adj.</em> A2</td>
<td style="text-align: left;">printer <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">particular <em>adj.</em> A2</td>
<td style="text-align: left;">pleasure <em>n.</em> B1</td>
<td style="text-align: left;">printing <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">particularly <em>adv.</em> B1</td>
<td style="text-align: left;">plenty <em>pron.</em> B1</td>
<td style="text-align: left;">priority <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">partly <em>adv.</em> B2</td>
<td style="text-align: left;">plot <em>n.</em> B1, <em>v.</em> B2</td>
<td style="text-align: left;">prison <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">partner <em>n.</em> A1</td>
<td style="text-align: left;">plus1 <em>prep.</em> B1, <em>adj.</em>,
<em>conj.</em>, <em>n.</em> B2</td>
<td style="text-align: left;">prisoner <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">party <em>n.</em> A1</td>
<td style="text-align: left;">pocket <em>n.</em> A2</td>
<td style="text-align: left;">privacy <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">pass <em>v.</em> A2, <em>n.</em> B1</td>
<td style="text-align: left;">poem <em>n.</em> B1</td>
<td style="text-align: left;">private <em>adj.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">passage <em>n.</em> B2</td>
<td style="text-align: left;">poet <em>n.</em> B1</td>
<td style="text-align: left;">prize <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">passenger <em>n.</em> A2</td>
<td style="text-align: left;">poetry <em>n.</em> B1</td>
<td style="text-align: left;">probably <em>adv.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">passion <em>n.</em> B1</td>
<td style="text-align: left;">point <em>n.</em> A1, <em>v.</em> B1</td>
<td style="text-align: left;">problem <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">passport <em>n.</em> A1</td>
<td style="text-align: left;">pointed <em>adj.</em> B2</td>
<td style="text-align: left;">procedure <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">past <em>adj.</em>, <em>n.</em>,
<em>prep.</em> A1, <em>adv.</em> A2</td>
<td style="text-align: left;">poison <em>n.</em>, <em>v.</em> B1</td>
<td style="text-align: left;">process <em>n.</em> A2, <em>v.</em>
B2</td>
</tr>
<tr>
<td style="text-align: left;">path <em>n.</em> B1</td>
<td style="text-align: left;">poisonous <em>adj.</em> B1</td>
<td style="text-align: left;">produce <em>v.</em> A2, <em>v.</em>
B2</td>
</tr>
<tr>
<td style="text-align: left;">patient <em>n.</em> A2, <em>adj.</em>
B2</td>
<td style="text-align: left;">police <em>n.</em> A1</td>
<td style="text-align: left;">producer <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">pattern <em>n.</em> A2</td>
<td style="text-align: left;">policeman <em>n.</em> A1</td>
<td style="text-align: left;">product <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">pay <em>v.</em> A1, <em>n.</em> A2</td>
<td style="text-align: left;">policy <em>n.</em> B1</td>
<td style="text-align: left;">production <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">payment <em>n.</em> B1</td>
<td style="text-align: left;">polite <em>adj.</em> A2</td>
<td style="text-align: left;">profession <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">peace <em>n.</em> A2</td>
<td style="text-align: left;">political <em>adj.</em> B1</td>
<td style="text-align: left;">professional <em>adj.</em> A2, <em>n.</em>
B2</td>
</tr>
<tr>
<td style="text-align: left;">peaceful <em>adj.</em> B1</td>
<td style="text-align: left;">politician <em>n.</em> B1</td>
<td style="text-align: left;">professor <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">pen <em>n.</em> A1</td>
<td style="text-align: left;">politics <em>n.</em> B1</td>
<td style="text-align: left;">profile <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">pencil <em>n.</em> A1</td>
<td style="text-align: left;">pollution <em>n.</em> A2</td>
<td style="text-align: left;">profit <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">penny <em>n.</em> A2</td>
<td style="text-align: left;">pool <em>n.</em> A1</td>
<td style="text-align: left;">program <em>n.</em> A2, <em>v.</em>
B1</td>
</tr>
<tr>
<td style="text-align: left;">pension1 <em>n.</em> B2</td>
<td style="text-align: left;">poor <em>adj.</em> A1</td>
<td style="text-align: left;">programme <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">people <em>n.</em> A1</td>
<td style="text-align: left;">pop <em>n.</em>, <em>adj.</em> A2</td>
<td style="text-align: left;">progress <em>n.</em> A2, <em>v.</em>
B2</td>
</tr>
<tr>
<td style="text-align: left;">pepper <em>n.</em> A1</td>
<td style="text-align: left;">popular <em>adj.</em> A1</td>
<td style="text-align: left;">project <em>n.</em> A1, <em>v.</em>
B2</td>
</tr>
<tr>
<td style="text-align: left;">per <em>prep.</em> A2</td>
<td style="text-align: left;">popularity <em>n.</em> B2</td>
<td style="text-align: left;">promise <em>v.</em>, <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">per cent <em>n.</em>,
<em>adj.</em>/<em>adv.</em> A2</td>
<td style="text-align: left;">population <em>n.</em> A2</td>
<td style="text-align: left;">promote <em>v.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">percentage <em>n.</em> B1</td>
<td style="text-align: left;">port <em>n.</em> B1</td>
<td style="text-align: left;">pronounce <em>v.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">perfect <em>adj.</em> A1</td>
<td style="text-align: left;">portrait <em>n.</em> B1</td>
<td style="text-align: left;">proof <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">perfectly <em>adv.</em> B1</td>
<td style="text-align: left;">pose <em>v.</em> B2</td>
<td style="text-align: left;">proper <em>adj.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">perform <em>v.</em> A2</td>
<td style="text-align: left;">position <em>n.</em> A2, <em>v.</em>
B2</td>
<td style="text-align: left;">properly <em>adv.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">performance <em>n.</em> B1</td>
<td style="text-align: left;">positive <em>adj.</em> A1, <em>n.</em>
B2</td>
<td style="text-align: left;">property <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">perhaps <em>adv.</em> A2</td>
<td style="text-align: left;">possess <em>v.</em> B2</td>
<td style="text-align: left;">proposal <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">period <em>n.</em> A1</td>
<td style="text-align: left;">possession <em>n.</em> A2</td>
<td style="text-align: left;">propose <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">permanent <em>adj.</em> B2</td>
<td style="text-align: left;">possibility <em>n.</em> A2</td>
<td style="text-align: left;">prospect <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">permission <em>n.</em> A2</td>
<td style="text-align: left;">possible <em>adj.</em> A1</td>
<td style="text-align: left;">protect <em>v.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">permit <em>v.</em>, <em>n.</em> B2</td>
<td style="text-align: left;">possibly <em>adv.</em> B1</td>
<td style="text-align: left;">protection <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">person <em>n.</em> A1</td>
<td style="text-align: left;">post <em>n.</em>, <em>v.</em> A1</td>
<td style="text-align: left;">protest <em>n.</em>, <em>v.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">personal <em>adj.</em> A1</td>
<td style="text-align: left;">poster <em>n.</em> A2</td>
<td style="text-align: left;">proud <em>adj.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">personality <em>n.</em> A2</td>
<td style="text-align: left;">pot <em>n.</em> B1</td>
<td style="text-align: left;">prove <em>v.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">personally <em>adv.</em> B1</td>
<td style="text-align: left;">potato <em>n.</em> A1</td>
<td style="text-align: left;">provide <em>v.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">perspective <em>n.</em> B2</td>
<td style="text-align: left;">potential <em>adj.</em>, <em>n.</em>
B2</td>
<td style="text-align: left;">psychologist <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">persuade <em>v.</em> B1</td>
<td style="text-align: left;">pound <em>n.</em> A1</td>
<td style="text-align: left;">psychology <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">pet <em>n.</em> A2</td>
<td style="text-align: left;">pour <em>v.</em> B1</td>
<td style="text-align: left;">pub <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">petrol <em>n.</em> A2</td>
<td style="text-align: left;">poverty <em>n.</em> B1</td>
<td style="text-align: left;">public <em>adj.</em>, <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">phase <em>n.</em> B2</td>
<td style="text-align: left;">powder <em>n.</em> B1</td>
<td style="text-align: left;">publication <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">phenomenon <em>n.</em> B2</td>
<td style="text-align: left;">power <em>n.</em> A2, <em>v.</em> B2</td>
<td style="text-align: left;">publish <em>v.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">philosophy <em>n.</em> B2</td>
<td style="text-align: left;">powerful <em>adj.</em> B1</td>
<td style="text-align: left;">pull <em>v.</em> A2, <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">phone <em>n.</em>, <em>v.</em> A1</td>
<td style="text-align: left;">practical <em>adj.</em> B1</td>
<td style="text-align: left;">punish <em>v.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">photo <em>n.</em> A1</td>
<td style="text-align: left;">practice <em>n.</em> A1</td>
<td style="text-align: left;">punishment <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">photograph <em>n.</em> A1, <em>v.</em>
A2</td>
<td style="text-align: left;">practise <em>v.</em> A1</td>
<td style="text-align: left;">pupil <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">photographer <em>n.</em> B1</td>
<td style="text-align: left;">praise <em>n.</em>, <em>v.</em> B2</td>
<td style="text-align: left;">purchase <em>n.</em>, <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">photography <em>n.</em> B1</td>
<td style="text-align: left;">pray <em>v.</em> B1</td>
<td style="text-align: left;">pure <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">phrase <em>n.</em> A1</td>
<td style="text-align: left;">prayer <em>n.</em> B1</td>
<td style="text-align: left;">purple <em>adj.</em>, <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">physical <em>adj.</em> A2</td>
<td style="text-align: left;">predict <em>v.</em> A2</td>
<td style="text-align: left;">purpose <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">physics <em>n.</em> A2</td>
<td style="text-align: left;">prediction <em>n.</em> B1</td>
<td style="text-align: left;">pursue <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">piano <em>n.</em> A1</td>
<td style="text-align: left;">prefer <em>v.</em> A1</td>
<td style="text-align: left;">push <em>v.</em> A2, <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">pick <em>v.</em> A2, <em>n.</em> B2</td>
<td style="text-align: left;">pregnant <em>adj.</em> B2</td>
<td style="text-align: left;">put <em>v.</em> A1</td>
</tr>
</tbody>
</table>
<h2 id="q">Q</h2>
<table>
<colgroup>
<col style="width: 32%">
<col style="width: 38%">
<col style="width: 29%">
</colgroup>
<tbody>
<tr>
<td style="text-align: left;">qualification <em>n.</em> B1</td>
<td style="text-align: left;">queen <em>n.</em> A2</td>
<td style="text-align: left;">quietly <em>adv.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">qualified <em>adj.</em> B1</td>
<td style="text-align: left;">question <em>n.</em> A1, <em>v.</em>
A2</td>
<td style="text-align: left;">quit <em>v.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">qualify <em>v.</em> B1</td>
<td style="text-align: left;">queue <em>n.</em>, <em>v.</em> B1</td>
<td style="text-align: left;">quite <em>adv.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">quality <em>n.</em> A2</td>
<td style="text-align: left;">quick <em>adj.</em> A1</td>
<td style="text-align: left;">quotation <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">quantity <em>n.</em> A2</td>
<td style="text-align: left;">quickly <em>adv.</em> A1</td>
<td style="text-align: left;">quote <em>v.</em>, <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">quarter <em>n.</em> A1</td>
<td style="text-align: left;">quiet <em>adj.</em> A1</td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<h2 id="r">R</h2>
<table>
<colgroup>
<col style="width: 31%">
<col style="width: 29%">
<col style="width: 39%">
</colgroup>
<tbody>
<tr>
<td style="text-align: left;">race (competition) <em>n.</em>,
<em>v.</em> A2</td>
<td style="text-align: left;">regret <em>v.</em>, <em>n.</em> B2</td>
<td style="text-align: left;">responsible <em>adj.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">race (people) <em>n.</em> B1</td>
<td style="text-align: left;">regular <em>adj.</em> A2</td>
<td style="text-align: left;">rest (remaining part) <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">racing <em>n.</em> B1</td>
<td style="text-align: left;">regularly <em>adv.</em> B1</td>
<td style="text-align: left;">rest (sleep/relax) <em>n.</em>,
<em>v.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">radio <em>n.</em> A1</td>
<td style="text-align: left;">regulation <em>n.</em> B2</td>
<td style="text-align: left;">restaurant <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">railway <em>n.</em> A2</td>
<td style="text-align: left;">reject <em>v.</em> B1</td>
<td style="text-align: left;">result <em>n.</em> A1, <em>v.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">rain <em>n.</em>, <em>v.</em> A1</td>
<td style="text-align: left;">relate <em>v.</em> B1</td>
<td style="text-align: left;">retain <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">raise <em>v.</em> A2</td>
<td style="text-align: left;">related <em>adj.</em> B1</td>
<td style="text-align: left;">retire <em>v.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">range <em>n.</em> B1, <em>v.</em> B2</td>
<td style="text-align: left;">relation <em>n.</em> B1</td>
<td style="text-align: left;">retired <em>adj.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">rank <em>n.</em>, <em>v.</em> B2</td>
<td style="text-align: left;">relationship <em>n.</em> A2</td>
<td style="text-align: left;">return <em>v.</em>, <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">rapid <em>adj.</em> B2</td>
<td style="text-align: left;">relative <em>adj.</em>, <em>n.</em>
B1</td>
<td style="text-align: left;">reveal <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">rapidly <em>adv.</em> B2</td>
<td style="text-align: left;">relatively <em>adv.</em> B2</td>
<td style="text-align: left;">review <em>n.</em>, <em>v.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">rare <em>adj.</em> B1</td>
<td style="text-align: left;">relax <em>v.</em> A1</td>
<td style="text-align: left;">revise <em>v.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">rarely <em>adv.</em> B1</td>
<td style="text-align: left;">relaxed <em>adj.</em> B1</td>
<td style="text-align: left;">revolution <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">rate <em>n.</em> A2, <em>v.</em> B2</td>
<td style="text-align: left;">relaxing <em>adj.</em> B1</td>
<td style="text-align: left;">reward <em>n.</em>, <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">rather <em>adv.</em> A2</td>
<td style="text-align: left;">release <em>v.</em>, <em>n.</em> B1</td>
<td style="text-align: left;">rhythm <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">raw <em>adj.</em> B2</td>
<td style="text-align: left;">relevant <em>adj.</em> B2</td>
<td style="text-align: left;">rice <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">reach <em>v.</em> A2, <em>n.</em> B2</td>
<td style="text-align: left;">reliable <em>adj.</em> B1</td>
<td style="text-align: left;">rich <em>adj.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">react <em>v.</em> A2</td>
<td style="text-align: left;">relief <em>n.</em> B2</td>
<td style="text-align: left;">rid <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">reaction <em>n.</em> B1</td>
<td style="text-align: left;">religion <em>n.</em> B1</td>
<td style="text-align: left;">ride <em>v.</em> A1, <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">read <em>v.</em> A1</td>
<td style="text-align: left;">religious <em>adj.</em> B1</td>
<td style="text-align: left;">right <em>adj.</em>, <em>adv.</em>,
<em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">reader <em>n.</em> A1</td>
<td style="text-align: left;">rely <em>v.</em> B2</td>
<td style="text-align: left;">ring1 <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">reading <em>n.</em> A1</td>
<td style="text-align: left;">remain <em>v.</em> B1</td>
<td style="text-align: left;">ring2 <em>v.</em> A2, <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">ready <em>adj.</em> A1</td>
<td style="text-align: left;">remark <em>n.</em>, <em>v.</em> B2</td>
<td style="text-align: left;">rise <em>v.</em> A2, <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">real <em>adj.</em> A1</td>
<td style="text-align: left;">remember <em>v.</em> A1</td>
<td style="text-align: left;">risk <em>n.</em>, <em>v.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">realistic <em>adj.</em> B2</td>
<td style="text-align: left;">remind <em>v.</em> B1</td>
<td style="text-align: left;">river <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">reality <em>n.</em> B1</td>
<td style="text-align: left;">remote <em>adj.</em> B1</td>
<td style="text-align: left;">road <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">realize <em>v.</em> A2</td>
<td style="text-align: left;">remove <em>v.</em> A2</td>
<td style="text-align: left;">robot <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">really <em>adv.</em> A1</td>
<td style="text-align: left;">rent <em>n.</em>, <em>v.</em> B1</td>
<td style="text-align: left;">rock (stone) <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">reason <em>n.</em> A1</td>
<td style="text-align: left;">repair <em>v.</em> A2, <em>n.</em> B1</td>
<td style="text-align: left;">rock (music) <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">reasonable <em>adj.</em> B2</td>
<td style="text-align: left;">repeat <em>v.</em> A1, <em>n.</em> B1</td>
<td style="text-align: left;">role <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">recall <em>v.</em> B2</td>
<td style="text-align: left;">repeated <em>adj.</em> B1</td>
<td style="text-align: left;">roll <em>v.</em>, <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">receipt <em>n.</em> B1</td>
<td style="text-align: left;">replace <em>v.</em> A2</td>
<td style="text-align: left;">romantic <em>adj.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">receive <em>v.</em> A2</td>
<td style="text-align: left;">reply <em>v.</em>, <em>n.</em> A2</td>
<td style="text-align: left;">roof <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">recent <em>adj.</em> A2</td>
<td style="text-align: left;">report <em>n.</em> A1, <em>v.</em> A2</td>
<td style="text-align: left;">room <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">recently <em>adv.</em> A2</td>
<td style="text-align: left;">reporter <em>n.</em> A2</td>
<td style="text-align: left;">root <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">reception <em>n.</em> A2</td>
<td style="text-align: left;">represent <em>v.</em> B1</td>
<td style="text-align: left;">rope <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">recipe <em>n.</em> A2</td>
<td style="text-align: left;">representative <em>n.</em>, <em>adj.</em>
B2</td>
<td style="text-align: left;">rough <em>adj.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">recognize <em>v.</em> A2</td>
<td style="text-align: left;">reputation <em>n.</em> B2</td>
<td style="text-align: left;">round <em>adj.</em>, <em>adv.</em>,
<em>prep.</em> A2, <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">recommend <em>v.</em> A2</td>
<td style="text-align: left;">request <em>n.</em> A2, <em>v.</em>
B1</td>
<td style="text-align: left;">route <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">recommendation <em>n.</em> B1</td>
<td style="text-align: left;">require <em>v.</em> B1</td>
<td style="text-align: left;">routine <em>n.</em> A1, <em>adj.</em>
B2</td>
</tr>
<tr>
<td style="text-align: left;">record <em>n.</em>, <em>v.</em> A2</td>
<td style="text-align: left;">requirement <em>n.</em> B2</td>
<td style="text-align: left;">row1 <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">recording <em>n.</em> A2</td>
<td style="text-align: left;">rescue <em>v.</em>, <em>n.</em> B2</td>
<td style="text-align: left;">royal <em>adj.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">recover <em>v.</em> B2</td>
<td style="text-align: left;">research <em>n.</em>, <em>v.</em> A2</td>
<td style="text-align: left;">rub <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">recycle <em>v.</em> A2</td>
<td style="text-align: left;">researcher <em>n.</em> A2</td>
<td style="text-align: left;">rubber <em>n.</em>, <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">red <em>adj.</em>, <em>n.</em> A1</td>
<td style="text-align: left;">reservation <em>n.</em> B1</td>
<td style="text-align: left;">rubbish <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">reduce <em>v.</em> A2</td>
<td style="text-align: left;">reserve <em>n.</em>, <em>v.</em> B2</td>
<td style="text-align: left;">rude <em>adj.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">reduction <em>n.</em> B2</td>
<td style="text-align: left;">resident <em>n.</em>, <em>adj.</em>
B2</td>
<td style="text-align: left;">rugby <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">refer <em>v.</em> A2</td>
<td style="text-align: left;">resist <em>v.</em> B2</td>
<td style="text-align: left;">rule <em>n.</em> A1, <em>v.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">reference <em>n.</em> B1</td>
<td style="text-align: left;">resolve <em>v.</em> B2</td>
<td style="text-align: left;">run <em>v.</em> A1, <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">reflect <em>v.</em> B1</td>
<td style="text-align: left;">resort <em>n.</em> B2</td>
<td style="text-align: left;">runner <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">refuse1 <em>v.</em> A2</td>
<td style="text-align: left;">resource <em>n.</em> B1</td>
<td style="text-align: left;">running <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">regard <em>v.</em>, <em>n.</em> B2</td>
<td style="text-align: left;">respect <em>n.</em>, <em>v.</em> B1</td>
<td style="text-align: left;">rural <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">region <em>n.</em> A2</td>
<td style="text-align: left;">respond <em>v.</em> A2</td>
<td style="text-align: left;">rush <em>v.</em>, <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">regional <em>adj.</em> B2</td>
<td style="text-align: left;">response <em>n.</em> A2</td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">register <em>v.</em>, <em>n.</em> B2</td>
<td style="text-align: left;">responsibility <em>n.</em> B1</td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<h2 id="s">S</h2>
<table>
<colgroup>
<col style="width: 47%">
<col style="width: 27%">
<col style="width: 24%">
</colgroup>
<tbody>
<tr>
<td style="text-align: left;">sad <em>adj.</em> A1</td>
<td style="text-align: left;">should modal <em>v.</em> A1</td>
<td style="text-align: left;">spoken <em>adj.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">sadly <em>adv.</em> A2</td>
<td style="text-align: left;">shoulder <em>n.</em> A2</td>
<td style="text-align: left;">sponsor <em>v.</em>, <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">safe <em>adj.</em> A2</td>
<td style="text-align: left;">shout <em>v.</em>, <em>n.</em> A2</td>
<td style="text-align: left;">spoon <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">safety <em>n.</em> B1</td>
<td style="text-align: left;">show <em>v.</em>, <em>n.</em> A1</td>
<td style="text-align: left;">sport <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">sail <em>v.</em> A2, <em>n.</em> B1</td>
<td style="text-align: left;">shower <em>n.</em> A1</td>
<td style="text-align: left;">spot <em>n.</em> B1, <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">sailing <em>n.</em> A2</td>
<td style="text-align: left;">shut <em>v.</em>, <em>adj.</em> A2</td>
<td style="text-align: left;">spread <em>v.</em> B1, <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">sailor <em>n.</em> B1</td>
<td style="text-align: left;">shy <em>adj.</em> B1</td>
<td style="text-align: left;">spring <em>n.</em> A1, <em>v.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">salad <em>n.</em> A1</td>
<td style="text-align: left;">sick <em>adj.</em> A1</td>
<td style="text-align: left;">square <em>adj.</em>, <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">salary <em>n.</em> A2</td>
<td style="text-align: left;">side <em>n.</em> A2</td>
<td style="text-align: left;">stable <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">sale <em>n.</em> A2</td>
<td style="text-align: left;">sight <em>n.</em> B1</td>
<td style="text-align: left;">stadium <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">salt <em>n.</em> A1</td>
<td style="text-align: left;">sign <em>n.</em>, <em>v.</em> A2</td>
<td style="text-align: left;">staff <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">same <em>adj.</em>, <em>pron.</em>,
<em>adv.</em> A1</td>
<td style="text-align: left;">signal <em>n.</em>, <em>v.</em> B1</td>
<td style="text-align: left;">stage <em>n.</em> A2, <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">sample <em>n.</em> B1, <em>v.</em> B2</td>
<td style="text-align: left;">significant <em>adj.</em> B2</td>
<td style="text-align: left;">stair <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">sand <em>n.</em> B1</td>
<td style="text-align: left;">significantly <em>adv.</em> B2</td>
<td style="text-align: left;">stamp <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">sandwich <em>n.</em> A1</td>
<td style="text-align: left;">silence <em>n.</em> B2</td>
<td style="text-align: left;">stand <em>v.</em> A1, <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">satellite <em>n.</em> B2</td>
<td style="text-align: left;">silent <em>adj.</em> B1</td>
<td style="text-align: left;">standard <em>n.</em>, <em>adj.</em>
B1</td>
</tr>
<tr>
<td style="text-align: left;">satisfied <em>adj.</em> B2</td>
<td style="text-align: left;">silk <em>n.</em> B2</td>
<td style="text-align: left;">star <em>n.</em> A1, <em>v.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">satisfy <em>v.</em> B2</td>
<td style="text-align: left;">silly <em>adj.</em> B1</td>
<td style="text-align: left;">stare <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">Saturday <em>n.</em> A1</td>
<td style="text-align: left;">silver <em>n.</em>, <em>adj.</em> A2</td>
<td style="text-align: left;">start <em>v.</em> A1, <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">sauce <em>n.</em> A2</td>
<td style="text-align: left;">similar <em>adj.</em> A1</td>
<td style="text-align: left;">state <em>n.</em> A2, <em>adj.</em>,
<em>v.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">save <em>v.</em> A2</td>
<td style="text-align: left;">similarity <em>n.</em> B1</td>
<td style="text-align: left;">statement <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">saving <em>n.</em> B2</td>
<td style="text-align: left;">similarly <em>adv.</em> B1</td>
<td style="text-align: left;">station <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">say <em>v.</em> A1</td>
<td style="text-align: left;">simple <em>adj.</em> A2</td>
<td style="text-align: left;">statistic <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">scale <em>n.</em> B2</td>
<td style="text-align: left;">simply <em>adv.</em> B1</td>
<td style="text-align: left;">statue <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">scan <em>v.</em> B1</td>
<td style="text-align: left;">since <em>prep.</em>, <em>conj.</em> A2,
<em>adv.</em> B1</td>
<td style="text-align: left;">status <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">scared <em>adj.</em> A2</td>
<td style="text-align: left;">sincere <em>adj.</em> B2</td>
<td style="text-align: left;">stay <em>v.</em> A1, <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">scary <em>adj.</em> A2</td>
<td style="text-align: left;">sing <em>v.</em> A1</td>
<td style="text-align: left;">steady <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">scene <em>n.</em> A2</td>
<td style="text-align: left;">singer <em>n.</em> A1</td>
<td style="text-align: left;">steal <em>v.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">schedule <em>n.</em> A2, <em>v.</em>
B2</td>
<td style="text-align: left;">singing <em>n.</em> A2</td>
<td style="text-align: left;">steel <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">scheme <em>n.</em> B2</td>
<td style="text-align: left;">single <em>adj.</em>, <em>n.</em> A2</td>
<td style="text-align: left;">steep <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">school <em>n.</em> A1</td>
<td style="text-align: left;">sink <em>v.</em> B1</td>
<td style="text-align: left;">step <em>n.</em> A2, <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">science <em>n.</em> A1</td>
<td style="text-align: left;">sir <em>n.</em> A2</td>
<td style="text-align: left;">stick (push into/attach) <em>v.</em>
B1</td>
</tr>
<tr>
<td style="text-align: left;">scientific <em>adj.</em> B1</td>
<td style="text-align: left;">sister <em>n.</em> A1</td>
<td style="text-align: left;">stick (piece of wood) <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">scientist <em>n.</em> A1</td>
<td style="text-align: left;">sit <em>v.</em> A1</td>
<td style="text-align: left;">sticky <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">score <em>v.</em>, <em>n.</em> A2</td>
<td style="text-align: left;">site <em>n.</em> A2</td>
<td style="text-align: left;">stiff <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">scream <em>v.</em>, <em>n.</em> B2</td>
<td style="text-align: left;">situation <em>n.</em> A1</td>
<td style="text-align: left;">still <em>adv.</em> A1, <em>adj.</em>
B1</td>
</tr>
<tr>
<td style="text-align: left;">screen <em>n.</em> A2, <em>v.</em> B2</td>
<td style="text-align: left;">six <em>number</em> A1</td>
<td style="text-align: left;">stock <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">script <em>n.</em> B1</td>
<td style="text-align: left;">sixteen <em>number</em> A1</td>
<td style="text-align: left;">stomach <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">sculpture <em>n.</em> B1</td>
<td style="text-align: left;">sixty <em>number</em> A1</td>
<td style="text-align: left;">stone <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">sea <em>n.</em> A1</td>
<td style="text-align: left;">size <em>n.</em> A2</td>
<td style="text-align: left;">stop <em>v.</em>, <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">search <em>n.</em>, <em>v.</em> A2</td>
<td style="text-align: left;">ski <em>v.</em>, <em>n.</em> A2</td>
<td style="text-align: left;">store <em>n.</em> A2, <em>v.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">season <em>n.</em> A2</td>
<td style="text-align: left;">skiing <em>n.</em> A2</td>
<td style="text-align: left;">storm <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">seat <em>n.</em> A2, <em>v.</em> B2</td>
<td style="text-align: left;">skill <em>n.</em> A1</td>
<td style="text-align: left;">story <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">second^1 (next after the first)
<em>det.</em>/<em>number</em> A1, <em>adv.</em> A2</td>
<td style="text-align: left;">skin <em>n.</em> A2</td>
<td style="text-align: left;">straight <em>adv.</em>, <em>adj.</em>
A2</td>
</tr>
<tr>
<td style="text-align: left;">second^1 (unit of time) <em>n.</em>
A1</td>
<td style="text-align: left;">skirt <em>n.</em> A1</td>
<td style="text-align: left;">strange <em>adj.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">secondary <em>adj.</em> B1</td>
<td style="text-align: left;">sky <em>n.</em> A2</td>
<td style="text-align: left;">stranger <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">secondly <em>adv.</em> A2</td>
<td style="text-align: left;">slave <em>n.</em> B2</td>
<td style="text-align: left;">strategy <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">secret <em>adj.</em>, <em>n.</em> A2</td>
<td style="text-align: left;">sleep <em>v.</em> A1, <em>n.</em> A2</td>
<td style="text-align: left;">stream <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">secretary <em>n.</em> A2</td>
<td style="text-align: left;">slice <em>n.</em>, <em>v.</em> B1</td>
<td style="text-align: left;">street <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">section <em>n.</em> A1</td>
<td style="text-align: left;">slide <em>v.</em>, <em>n.</em> B2</td>
<td style="text-align: left;">strength <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">sector <em>n.</em> B2</td>
<td style="text-align: left;">slight <em>adj.</em> B2</td>
<td style="text-align: left;">stress <em>n.</em>, <em>v.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">secure <em>v.</em>, <em>adj.</em> B2</td>
<td style="text-align: left;">slightly <em>adv.</em> B1</td>
<td style="text-align: left;">stretch <em>v.</em>, <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">security <em>n.</em> B1</td>
<td style="text-align: left;">slip <em>v.</em> B2</td>
<td style="text-align: left;">strict <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">see <em>v.</em> A1</td>
<td style="text-align: left;">slope <em>n.</em>, <em>v.</em> B2</td>
<td style="text-align: left;"><a href="https://josh-gao.top/posts/dc727c0.html">strike</a> <em>v.</em>,
<em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">seed <em>n.</em> B1</td>
<td style="text-align: left;">slow <em>adj.</em> A1, <em>v.</em> B1</td>
<td style="text-align: left;">string <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">seek <em>v.</em> B2</td>
<td style="text-align: left;">slowly <em>adv.</em> A2</td>
<td style="text-align: left;">strong <em>adj.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">seem <em>v.</em> A2</td>
<td style="text-align: left;">small <em>adj.</em> A1</td>
<td style="text-align: left;">strongly <em>adv.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">select <em>v.</em> B2</td>
<td style="text-align: left;">smart <em>adj.</em> B1</td>
<td style="text-align: left;">structure <em>n.</em> A2, <em>v.</em>
B2</td>
</tr>
<tr>
<td style="text-align: left;">selection <em>n.</em> B2</td>
<td style="text-align: left;">smartphone <em>n.</em> A2</td>
<td style="text-align: left;">struggle <em>v.</em>, <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">self <em>n.</em> B2</td>
<td style="text-align: left;">smell <em>v.</em>, <em>n.</em> A2</td>
<td style="text-align: left;">student <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">sell <em>v.</em> A1</td>
<td style="text-align: left;">smile <em>v.</em>, <em>n.</em> A2</td>
<td style="text-align: left;">studio <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">send <em>v.</em> A1</td>
<td style="text-align: left;">smoke <em>n.</em>, <em>v.</em> A2</td>
<td style="text-align: left;">study <em>n.</em>, <em>v.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">senior <em>adj.</em> B2</td>
<td style="text-align: left;">smoking <em>n.</em> A2</td>
<td style="text-align: left;">stuff <em>n.</em> B1, <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">sense <em>n.</em> A2, <em>v.</em> B2</td>
<td style="text-align: left;">smooth <em>adj.</em> B1</td>
<td style="text-align: left;">stupid <em>adj.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">sensible <em>adj.</em> B1</td>
<td style="text-align: left;">snake <em>n.</em> A1</td>
<td style="text-align: left;">style <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">sensitive <em>adj.</em> B2</td>
<td style="text-align: left;">snow <em>n.</em>, <em>v.</em> A1</td>
<td style="text-align: left;">subject <em>n.</em> A1, <em>adj.</em>
B2</td>
</tr>
<tr>
<td style="text-align: left;">sentence <em>n.</em> A1, <em>v.</em>
B2</td>
<td style="text-align: left;">so <em>adv.</em>, <em>conj.</em> A1</td>
<td style="text-align: left;">submit <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">separate <em>adj.</em> A2, <em>v.</em>
B1</td>
<td style="text-align: left;">soap <em>n.</em> A2</td>
<td style="text-align: left;">substance <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">September <em>n.</em> A1</td>
<td style="text-align: left;">soccer <em>n.</em> A2</td>
<td style="text-align: left;">succeed <em>v.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">sequence <em>n.</em> B2</td>
<td style="text-align: left;">social <em>adj.</em> A2</td>
<td style="text-align: left;">success <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">series <em>n.</em> A2</td>
<td style="text-align: left;">society <em>n.</em> A2</td>
<td style="text-align: left;">successful <em>adj.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">serious <em>adj.</em> A2</td>
<td style="text-align: left;">sock <em>n.</em> A2</td>
<td style="text-align: left;">successfully <em>adv.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">seriously <em>adv.</em> B1</td>
<td style="text-align: left;">soft <em>adj.</em> A2</td>
<td style="text-align: left;">such <em>det.</em>/<em>pron.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">servant <em>n.</em> B1</td>
<td style="text-align: left;">software <em>n.</em> B1</td>
<td style="text-align: left;">sudden <em>adj.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">serve <em>v.</em> A2</td>
<td style="text-align: left;">soil <em>n.</em> B1</td>
<td style="text-align: left;">suddenly <em>adv.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">service <em>n.</em> A2</td>
<td style="text-align: left;">solar <em>adj.</em> B2</td>
<td style="text-align: left;">suffer <em>v.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">session <em>n.</em> B2</td>
<td style="text-align: left;">soldier <em>n.</em> A2</td>
<td style="text-align: left;">sugar <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">set (put) <em>v.</em> B1</td>
<td style="text-align: left;">solid <em>adj.</em>, <em>n.</em> B1</td>
<td style="text-align: left;">suggest <em>v.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">set (group) <em>n.</em> B1</td>
<td style="text-align: left;">solution <em>n.</em> A2</td>
<td style="text-align: left;">suggestion <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">setting <em>n.</em> B1</td>
<td style="text-align: left;">solve <em>v.</em> A2</td>
<td style="text-align: left;">suit <em>n.</em> A2, <em>v.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">settle <em>v.</em> B2</td>
<td style="text-align: left;">some <em>det.</em>, <em>pron.</em> A1</td>
<td style="text-align: left;">suitable <em>adj.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">seven <em>number</em> A1</td>
<td style="text-align: left;">somebody <em>pron.</em> A1</td>
<td style="text-align: left;">sum <em>n.</em>, <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">seventeen <em>number</em> A1</td>
<td style="text-align: left;">someone <em>pron.</em> A1</td>
<td style="text-align: left;">summarize <em>v.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">seventy <em>number</em> A1</td>
<td style="text-align: left;">something <em>pron.</em> A1</td>
<td style="text-align: left;">summary <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">several <em>det.</em>/<em>pron.</em>
A2</td>
<td style="text-align: left;">sometimes <em>adv.</em> A1</td>
<td style="text-align: left;">summer <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">severe <em>adj.</em> B2</td>
<td style="text-align: left;">somewhat <em>adv.</em> B2</td>
<td style="text-align: left;">sun <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">sex <em>n.</em> B1</td>
<td style="text-align: left;">somewhere <em>adv.</em>, <em>pron.</em>
A2</td>
<td style="text-align: left;">Sunday <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">sexual <em>adj.</em> B1</td>
<td style="text-align: left;">son <em>n.</em> A1</td>
<td style="text-align: left;">supermarket <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">shade <em>n.</em> B2</td>
<td style="text-align: left;">song <em>n.</em> A1</td>
<td style="text-align: left;">supply <em>n.</em>, <em>v.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">shadow <em>n.</em> B2</td>
<td style="text-align: left;">soon <em>adv.</em> A1</td>
<td style="text-align: left;">support <em>v.</em>, <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">shake <em>v.</em> A2, <em>n.</em> B1</td>
<td style="text-align: left;">sorry <em>adj.</em>, <em>exclam.</em>
A1</td>
<td style="text-align: left;">supporter <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">shall modal <em>v.</em> A2</td>
<td style="text-align: left;">sort <em>n.</em> A2, <em>v.</em> B1</td>
<td style="text-align: left;">suppose <em>v.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">shallow <em>adj.</em> B2</td>
<td style="text-align: left;">soul <em>n.</em> B2</td>
<td style="text-align: left;">sure <em>adj.</em> A1, <em>adv.</em>
A2</td>
</tr>
<tr>
<td style="text-align: left;">shame <em>n.</em> B2</td>
<td style="text-align: left;">sound <em>n.</em>, <em>v.</em> A1</td>
<td style="text-align: left;">surely <em>adv.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">shape <em>n.</em> A2, <em>v.</em> B2</td>
<td style="text-align: left;">soup <em>n.</em> A1</td>
<td style="text-align: left;">surface <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">share <em>v.</em> A1, <em>n.</em> B1</td>
<td style="text-align: left;">source <em>n.</em> A2</td>
<td style="text-align: left;">surgery <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">sharp <em>adj.</em> B1</td>
<td style="text-align: left;">south <em>n.</em>, <em>adj.</em>,
<em>adv.</em> A1</td>
<td style="text-align: left;">surprise <em>n.</em>, <em>v.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">she <em>pron.</em> A1</td>
<td style="text-align: left;">southern <em>adj.</em> B1</td>
<td style="text-align: left;">surprised <em>adj.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">sheep <em>n.</em> A1</td>
<td style="text-align: left;">space <em>n.</em> A1</td>
<td style="text-align: left;">surprising <em>adj.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">sheet <em>n.</em> A2</td>
<td style="text-align: left;">speak <em>v.</em> A1</td>
<td style="text-align: left;">surround <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">shelf <em>n.</em> B1</td>
<td style="text-align: left;">speaker <em>n.</em> A2</td>
<td style="text-align: left;">surrounding <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">shell <em>n.</em> B1</td>
<td style="text-align: left;">special <em>adj.</em> A1</td>
<td style="text-align: left;">survey <em>n.</em> A2, <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">shelter <em>n.</em>, <em>v.</em> B2</td>
<td style="text-align: left;">specialist <em>n.</em>, <em>adj.</em>
B2</td>
<td style="text-align: left;">survive <em>v.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">shift <em>n.</em> B1, <em>v.</em> B2</td>
<td style="text-align: left;">species <em>n.</em> B2</td>
<td style="text-align: left;">suspect <em>v.</em>, <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">shine <em>v.</em> B1</td>
<td style="text-align: left;">specific <em>adj.</em> A2</td>
<td style="text-align: left;">swear <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">shiny <em>adj.</em> B1</td>
<td style="text-align: left;">specifically <em>adv.</em> B1</td>
<td style="text-align: left;">sweater <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">ship <em>n.</em> A2, <em>v.</em> B2</td>
<td style="text-align: left;">speech <em>n.</em> A2</td>
<td style="text-align: left;">sweep <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">shirt <em>n.</em> A1</td>
<td style="text-align: left;">speed <em>n.</em> A2, <em>v.</em> B2</td>
<td style="text-align: left;">sweet <em>adj.</em>, <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">shock <em>n.</em>, <em>v.</em> B2</td>
<td style="text-align: left;">spell <em>v.</em> A1</td>
<td style="text-align: left;">swim <em>v.</em> A1, <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">shocked <em>adj.</em> B2</td>
<td style="text-align: left;">spelling <em>n.</em> A1</td>
<td style="text-align: left;">swimming <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">shoe <em>n.</em> A1</td>
<td style="text-align: left;">spend <em>v.</em> A1</td>
<td style="text-align: left;">switch <em>v.</em> B1, <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">shoot <em>v.</em> B1</td>
<td style="text-align: left;">spending <em>n.</em> B1</td>
<td style="text-align: left;">symbol <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">shooting <em>n.</em> B2</td>
<td style="text-align: left;">spicy <em>adj.</em> B1</td>
<td style="text-align: left;">sympathy <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">shop <em>n.</em>, <em>v.</em> A1</td>
<td style="text-align: left;">spider <em>n.</em> A2</td>
<td style="text-align: left;">symptom <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">shopping <em>n.</em> A1</td>
<td style="text-align: left;">spirit <em>n.</em> B1</td>
<td style="text-align: left;">system <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">short <em>adj.</em> A1</td>
<td style="text-align: left;">spiritual <em>adj.</em> B2</td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">shot <em>n.</em> B2</td>
<td style="text-align: left;">split <em>v.</em>, <em>n.</em> B2</td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<h2 id="t">T</h2>
<table>
<colgroup>
<col style="width: 42%">
<col style="width: 32%">
<col style="width: 25%">
</colgroup>
<tbody>
<tr>
<td style="text-align: left;">table <em>n.</em> A1</td>
<td style="text-align: left;">therefore <em>adv.</em> B1</td>
<td style="text-align: left;">tourism <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">tablet <em>n.</em> A2</td>
<td style="text-align: left;">they <em>pron.</em> A1</td>
<td style="text-align: left;">tourist <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">tail <em>n.</em> B1</td>
<td style="text-align: left;">thick <em>adj.</em> A2</td>
<td style="text-align: left;">towards <em>prep.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">take <em>v.</em> A1</td>
<td style="text-align: left;">thief <em>n.</em> A2</td>
<td style="text-align: left;">towel <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">tale <em>n.</em> B2</td>
<td style="text-align: left;">thin <em>adj.</em> A2</td>
<td style="text-align: left;">tower <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">talent <em>n.</em> B1</td>
<td style="text-align: left;">thing <em>n.</em> A1</td>
<td style="text-align: left;">town <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">talented <em>adj.</em> B1</td>
<td style="text-align: left;">think <em>v.</em> A1</td>
<td style="text-align: left;">toy <em>n.</em>, <em>adj.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">talk <em>v.</em> A1, <em>n.</em> A2</td>
<td style="text-align: left;">thinking <em>n.</em> A2</td>
<td style="text-align: left;">track <em>n.</em> A2, <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">tall <em>adj.</em> A1</td>
<td style="text-align: left;">third <em>number</em> A1, <em>n.</em>
A2</td>
<td style="text-align: left;">trade <em>n.</em>, <em>v.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">tank <em>n.</em> B2</td>
<td style="text-align: left;">thirsty <em>adj.</em> A1</td>
<td style="text-align: left;">tradition <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">tape <em>n.</em> B1</td>
<td style="text-align: left;">thirteen <em>number</em> A1</td>
<td style="text-align: left;">traditional <em>adj.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">target <em>n.</em> A2, <em>v.</em> B2</td>
<td style="text-align: left;">thirty <em>number</em> A1</td>
<td style="text-align: left;">traffic <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">task <em>n.</em> A2</td>
<td style="text-align: left;">this <em>det.</em>/<em>pron.</em> A1,
<em>adv.</em> B1</td>
<td style="text-align: left;">train <em>n.</em> A1, <em>v.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">taste <em>n.</em>, <em>v.</em> A2</td>
<td style="text-align: left;">though <em>conj.</em>, <em>adv.</em>
B1</td>
<td style="text-align: left;">trainer <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">tax <em>n.</em>, <em>v.</em> B1</td>
<td style="text-align: left;">thought <em>n.</em> A2</td>
<td style="text-align: left;">training <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">taxi <em>n.</em> A1</td>
<td style="text-align: left;">thousand <em>number</em> A1</td>
<td style="text-align: left;">transfer <em>v.</em>, <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">tea <em>n.</em> A1</td>
<td style="text-align: left;">threat <em>n.</em> B2</td>
<td style="text-align: left;">transform <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">teach <em>v.</em> A1</td>
<td style="text-align: left;">threaten <em>v.</em> B2</td>
<td style="text-align: left;">transition <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">teacher <em>n.</em> A1</td>
<td style="text-align: left;">three <em>number</em> A1</td>
<td style="text-align: left;">translate <em>v.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">teaching <em>n.</em> A2</td>
<td style="text-align: left;">throat <em>n.</em> B1</td>
<td style="text-align: left;">translation <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">team <em>n.</em> A1</td>
<td style="text-align: left;">through <em>prep.</em>, <em>adv.</em>
A1</td>
<td style="text-align: left;">transport <em>n.</em> A2, <em>v.</em>
B1</td>
</tr>
<tr>
<td style="text-align: left;">tear1 <em>v.</em>, <em>n.</em> B2</td>
<td style="text-align: left;">throughout <em>prep.</em>/<em>adv.</em>
B1</td>
<td style="text-align: left;">travel <em>v.</em>, <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">tear2 <em>n.</em> B2</td>
<td style="text-align: left;">throw <em>v.</em> A2</td>
<td style="text-align: left;">traveller <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">technical <em>adj.</em> B1</td>
<td style="text-align: left;">Thursday <em>n.</em> A1</td>
<td style="text-align: left;">treat <em>v.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">technique <em>n.</em> B1</td>
<td style="text-align: left;">thus <em>adv.</em> B2</td>
<td style="text-align: left;">treatment <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">technology <em>n.</em> A2</td>
<td style="text-align: left;">ticket <em>n.</em> A1</td>
<td style="text-align: left;">tree <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">teenage <em>adj.</em> A2</td>
<td style="text-align: left;">tidy <em>adj.</em>, <em>v.</em> A2</td>
<td style="text-align: left;">trend <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">teenager <em>n.</em> A1</td>
<td style="text-align: left;">tie <em>v.</em>, <em>n.</em> A2</td>
<td style="text-align: left;">trial <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">telephone <em>n.</em>, <em>v.</em> A1</td>
<td style="text-align: left;">tight <em>adj.</em> B1</td>
<td style="text-align: left;">trick <em>n.</em>, <em>v.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">television <em>n.</em> A1</td>
<td style="text-align: left;">till <em>conj.</em>/<em>prep.</em> B1</td>
<td style="text-align: left;">trip <em>n.</em> A1, <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">tell <em>v.</em> A1</td>
<td style="text-align: left;">time <em>n.</em> A1, <em>v.</em> B2</td>
<td style="text-align: left;">tropical <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">temperature <em>n.</em> A2</td>
<td style="text-align: left;">tin <em>n.</em> B1</td>
<td style="text-align: left;">trouble <em>n.</em> A2, <em>v.</em>
B2</td>
</tr>
<tr>
<td style="text-align: left;">temporary <em>adj.</em> B2</td>
<td style="text-align: left;">tiny <em>adj.</em> B1</td>
<td style="text-align: left;">trousers <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">ten <em>number</em> A1</td>
<td style="text-align: left;">tip <em>n.</em> A2, <em>v.</em> B1</td>
<td style="text-align: left;">truck <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">tend <em>v.</em> B1</td>
<td style="text-align: left;">tired <em>adj.</em> A1</td>
<td style="text-align: left;">true <em>adj.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">tennis <em>n.</em> A1</td>
<td style="text-align: left;">title <em>n.</em> A1, <em>v.</em> B2</td>
<td style="text-align: left;">truly <em>adv.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">tent <em>n.</em> B1</td>
<td style="text-align: left;">to <em>prep.</em>, infinitive marker
A1</td>
<td style="text-align: left;">trust <em>n.</em>, <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">term <em>n.</em> A2, <em>v.</em> B2</td>
<td style="text-align: left;">today <em>adv.</em>, <em>n.</em> A1</td>
<td style="text-align: left;">truth <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">terrible <em>adj.</em> A1</td>
<td style="text-align: left;">toe <em>n.</em> B1</td>
<td style="text-align: left;">try <em>v.</em> A1, <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">test <em>n.</em>, <em>v.</em> A1</td>
<td style="text-align: left;">together <em>adv.</em> A1</td>
<td style="text-align: left;">T-shirt <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">text <em>n.</em> A1, <em>v.</em> A2</td>
<td style="text-align: left;">toilet <em>n.</em> A1</td>
<td style="text-align: left;">tube <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">than <em>conj.</em> A1</td>
<td style="text-align: left;">tomato <em>n.</em> A1</td>
<td style="text-align: left;">Tuesday <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">thank <em>v.</em> A1</td>
<td style="text-align: left;">tomorrow <em>adv.</em>, <em>n.</em>
A1</td>
<td style="text-align: left;">tune <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">thanks <em>exclam.</em>, <em>n.</em>
A1</td>
<td style="text-align: left;">tone <em>n.</em> B2</td>
<td style="text-align: left;">tunnel <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">that <em>det.</em>, <em>pron.</em>,
<em>conj.</em> A1, <em>adv.</em> B1</td>
<td style="text-align: left;">tongue <em>n.</em> B1</td>
<td style="text-align: left;">turn <em>v.</em>, <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">the <em>definite article</em> A1</td>
<td style="text-align: left;">tonight <em>adv.</em>, <em>n.</em> A1</td>
<td style="text-align: left;">TV <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">theatre <em>n.</em> A1</td>
<td style="text-align: left;">too <em>adv.</em> A1</td>
<td style="text-align: left;">twelve <em>number</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">their <em>det.</em> A1</td>
<td style="text-align: left;">tool <em>n.</em> A2</td>
<td style="text-align: left;">twenty <em>number</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">theirs <em>pron.</em> B1</td>
<td style="text-align: left;">tooth <em>n.</em> A1</td>
<td style="text-align: left;">twice <em>adv.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">them <em>pron.</em> A1</td>
<td style="text-align: left;">top <em>n.</em>, <em>adj.</em> A2</td>
<td style="text-align: left;">twin <em>n.</em>, <em>adj.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">theme <em>n.</em> B1</td>
<td style="text-align: left;">topic <em>n.</em> A1</td>
<td style="text-align: left;">two <em>number</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">themselves <em>pron.</em> A2</td>
<td style="text-align: left;">total <em>adj.</em>, <em>n.</em> B1</td>
<td style="text-align: left;">type <em>n.</em> A1, <em>v.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">then <em>adv.</em> A1</td>
<td style="text-align: left;">totally <em>adv.</em> B1</td>
<td style="text-align: left;">typical <em>adj.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">theory <em>n.</em> B1</td>
<td style="text-align: left;">touch <em>v.</em> A2, <em>n.</em> B1</td>
<td style="text-align: left;">typically <em>adv.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">therapy <em>n.</em> B2</td>
<td style="text-align: left;">tough <em>adj.</em> B2</td>
<td style="text-align: left;">tyre <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">there <em>adv.</em> A1</td>
<td style="text-align: left;">tour <em>n.</em> A2, <em>v.</em> B1</td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<h2 id="u">U</h2>
<table style="width:100%;">
<colgroup>
<col style="width: 35%">
<col style="width: 29%">
<col style="width: 35%">
</colgroup>
<tbody>
<tr>
<td style="text-align: left;">ugly <em>adj.</em> B1</td>
<td style="text-align: left;">unhappy <em>adj.</em> A2</td>
<td style="text-align: left;">update <em>v.</em>, <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">ultimately <em>adv.</em> B2</td>
<td style="text-align: left;">uniform <em>n.</em> A2</td>
<td style="text-align: left;">upon <em>prep.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">umbrella <em>n.</em> A1</td>
<td style="text-align: left;">union <em>n.</em> B1</td>
<td style="text-align: left;">upper <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">unable <em>adj.</em> B1</td>
<td style="text-align: left;">unique <em>adj.</em> B2</td>
<td style="text-align: left;">upset <em>adj.</em>, <em>v.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">uncle <em>n.</em> A1</td>
<td style="text-align: left;">unit <em>n.</em> A2</td>
<td style="text-align: left;">upstairs <em>adv.</em> A1, <em>adj.</em>
A2</td>
</tr>
<tr>
<td style="text-align: left;">uncomfortable <em>adj.</em> B1</td>
<td style="text-align: left;">united <em>adj.</em> A2</td>
<td style="text-align: left;">upwards <em>adv.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">unconscious <em>adj.</em> B2</td>
<td style="text-align: left;">universe <em>n.</em> B2</td>
<td style="text-align: left;">urban <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">under <em>prep.</em>, <em>adv.</em>
A1</td>
<td style="text-align: left;">university <em>n.</em> A1</td>
<td style="text-align: left;">urge <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">underground <em>adj.</em>, <em>adv.</em>
A2</td>
<td style="text-align: left;">unknown <em>adj.</em> B2</td>
<td style="text-align: left;">us <em>pron.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">understand <em>v.</em> A1</td>
<td style="text-align: left;">unless <em>conj.</em> B1</td>
<td style="text-align: left;">use <em>v.</em> A1, <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">understanding <em>n.</em> A2</td>
<td style="text-align: left;">unlike <em>prep.</em> B1</td>
<td style="text-align: left;">used1 <em>adj.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">underwear <em>n.</em> B1</td>
<td style="text-align: left;">unlikely <em>adj.</em> B1</td>
<td style="text-align: left;">used2 <em>adj.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">unemployed <em>adj.</em> B1</td>
<td style="text-align: left;">unnecessary <em>adj.</em> B1</td>
<td style="text-align: left;">used to modal <em>v.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">unemployment <em>n.</em> B1</td>
<td style="text-align: left;">unpleasant <em>adj.</em> B1</td>
<td style="text-align: left;">useful <em>adj.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">unexpected <em>adj.</em> B2</td>
<td style="text-align: left;">until <em>conj.</em>/<em>prep.</em>
A1</td>
<td style="text-align: left;">user <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">unfair <em>adj.</em> B1</td>
<td style="text-align: left;">unusual <em>adj.</em> A2</td>
<td style="text-align: left;">usual <em>adj.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">unfortunately <em>adv.</em> A2</td>
<td style="text-align: left;">up <em>adv.</em>, <em>prep.</em> A1</td>
<td style="text-align: left;">usually <em>adv.</em> A1</td>
</tr>
</tbody>
</table>
<h2 id="v">V</h2>
<table>
<colgroup>
<col style="width: 31%">
<col style="width: 35%">
<col style="width: 32%">
</colgroup>
<tbody>
<tr>
<td style="text-align: left;">vacation <em>n.</em> A1</td>
<td style="text-align: left;">version <em>n.</em> B1</td>
<td style="text-align: left;">virus <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">valley <em>n.</em> A2</td>
<td style="text-align: left;">very <em>adv.</em> A1, <em>adj.</em>
B2</td>
<td style="text-align: left;">vision <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">valuable <em>adj.</em> B1</td>
<td style="text-align: left;">via <em>prep.</em> B2</td>
<td style="text-align: left;">visit <em>v.</em>, <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">value <em>n.</em> B1, <em>v.</em> B2</td>
<td style="text-align: left;">victim <em>n.</em> B1</td>
<td style="text-align: left;">visitor <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">van <em>n.</em> A2</td>
<td style="text-align: left;">victory <em>n.</em> B2</td>
<td style="text-align: left;">visual <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">variety <em>n.</em> A2</td>
<td style="text-align: left;">video <em>n.</em> A1</td>
<td style="text-align: left;">vital <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">various <em>adj.</em> B1</td>
<td style="text-align: left;">view <em>n.</em> A2, <em>v.</em> B1</td>
<td style="text-align: left;">vitamin <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">vary <em>v.</em> B2</td>
<td style="text-align: left;">viewer <em>n.</em> B1</td>
<td style="text-align: left;">voice <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">vast <em>adj.</em> B2</td>
<td style="text-align: left;">village <em>n.</em> A1</td>
<td style="text-align: left;">volume <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">vegetable <em>n.</em> A1</td>
<td style="text-align: left;">violence <em>n.</em> B2</td>
<td style="text-align: left;">volunteer <em>n.</em>, <em>v.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">vehicle <em>n.</em> A2</td>
<td style="text-align: left;">violent <em>adj.</em> B1</td>
<td style="text-align: left;">vote <em>n.</em>, <em>v.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">venue <em>n.</em> B2</td>
<td style="text-align: left;">virtual <em>adj.</em> B2</td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<h2 id="w">W</h2>
<table>
<colgroup>
<col style="width: 38%">
<col style="width: 29%">
<col style="width: 31%">
</colgroup>
<tbody>
<tr>
<td style="text-align: left;">wage <em>n.</em> B2</td>
<td style="text-align: left;">well <em>adv.</em>, <em>adj.</em>,
<em>exclam.</em> A1</td>
<td style="text-align: left;">winner <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">wait <em>v.</em> A1, <em>n.</em> A2</td>
<td style="text-align: left;">west <em>n.</em>, <em>adj.</em>,
<em>adv.</em> A1</td>
<td style="text-align: left;">winter <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">waiter <em>n.</em> A1</td>
<td style="text-align: left;">western <em>adj.</em> B1</td>
<td style="text-align: left;">wire <em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">wake <em>v.</em> A1</td>
<td style="text-align: left;">wet <em>adj.</em> A2</td>
<td style="text-align: left;">wise <em>adj.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">walk <em>v.</em>, <em>n.</em> A1</td>
<td style="text-align: left;">what <em>pron.</em>/<em>det.</em> A1</td>
<td style="text-align: left;">wish <em>v.</em>, <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">wall <em>n.</em> A1</td>
<td style="text-align: left;">whatever <em>det.</em>/<em>pron.</em>
B1</td>
<td style="text-align: left;">with <em>prep.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">want <em>v.</em> A1</td>
<td style="text-align: left;">wheel <em>n.</em> A2</td>
<td style="text-align: left;">within <em>prep.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">war <em>n.</em> A2</td>
<td style="text-align: left;">when <em>adv.</em>, <em>pron.</em>,
<em>conj.</em> A1</td>
<td style="text-align: left;">without <em>prep.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">warm <em>adj.</em> A1, <em>v.</em> B1</td>
<td style="text-align: left;">whenever <em>conj.</em> B1</td>
<td style="text-align: left;">witness <em>n.</em>, <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">warn <em>v.</em> B1</td>
<td style="text-align: left;">where <em>adv.</em>, <em>conj.</em>
A1</td>
<td style="text-align: left;">woman <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">warning <em>n.</em> B1</td>
<td style="text-align: left;">whereas <em>conj.</em> B2</td>
<td style="text-align: left;">wonder <em>v.</em>, <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">wash <em>v.</em> A1, <em>n.</em> A2</td>
<td style="text-align: left;">wherever <em>conj.</em> B2</td>
<td style="text-align: left;">wonderful <em>adj.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">washing <em>n.</em> A2</td>
<td style="text-align: left;">whether <em>conj.</em> B1</td>
<td style="text-align: left;">wood <em>n.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">waste <em>n.</em>, <em>v.</em>,
<em>adj.</em> B1</td>
<td style="text-align: left;">which <em>pron.</em>/<em>det.</em> A1</td>
<td style="text-align: left;">wooden <em>adj.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">watch <em>v.</em>, <em>n.</em> A1</td>
<td style="text-align: left;">while <em>conj.</em> A2, <em>n.</em>
B1</td>
<td style="text-align: left;">wool <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">water <em>n.</em> A1, <em>v.</em> B1</td>
<td style="text-align: left;">whisper <em>v.</em>, <em>n.</em> B2</td>
<td style="text-align: left;">word <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">wave <em>n.</em> A2, <em>v.</em> B1</td>
<td style="text-align: left;">white <em>adj.</em>, <em>n.</em> A1</td>
<td style="text-align: left;">work <em>v.</em>, <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">way <em>n.</em> A1, <em>adv.</em> B2</td>
<td style="text-align: left;">who <em>pron.</em> A1</td>
<td style="text-align: left;">worker <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">we <em>pron.</em> A1</td>
<td style="text-align: left;">whole <em>adj.</em> A2, <em>n.</em>
B1</td>
<td style="text-align: left;">working <em>adj.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">weak <em>adj.</em> A2</td>
<td style="text-align: left;">whom <em>pron.</em> B2</td>
<td style="text-align: left;">world <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">weakness <em>n.</em> B2</td>
<td style="text-align: left;">whose <em>det.</em>/<em>pron.</em> A2</td>
<td style="text-align: left;">worldwide <em>adj.</em>, <em>adv.</em>
B1</td>
</tr>
<tr>
<td style="text-align: left;">wealth <em>n.</em> B2</td>
<td style="text-align: left;">why <em>adv.</em> A1</td>
<td style="text-align: left;">worried <em>adj.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">wealthy <em>adj.</em> B2</td>
<td style="text-align: left;">wide <em>adj.</em> A2</td>
<td style="text-align: left;">worry <em>v.</em> A2, <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">weapon <em>n.</em> B1</td>
<td style="text-align: left;">widely <em>adv.</em> B2</td>
<td style="text-align: left;">worse <em>adj.</em> A2, <em>adv.</em> B1,
<em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">wear <em>v.</em> A1</td>
<td style="text-align: left;">wife <em>n.</em> A1</td>
<td style="text-align: left;">worst <em>adj.</em> A2, <em>adv.</em> B1,
<em>n.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">weather <em>n.</em> A1</td>
<td style="text-align: left;">wild <em>adj.</em> A2</td>
<td style="text-align: left;">worth <em>adj.</em> B1, <em>n.</em>
B2</td>
</tr>
<tr>
<td style="text-align: left;">web <em>n.</em> A2</td>
<td style="text-align: left;">wildlife <em>n.</em> B2</td>
<td style="text-align: left;">would modal <em>v.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">website <em>n.</em> A1</td>
<td style="text-align: left;">will modal <em>v.</em> A1, <em>n.</em>
B1</td>
<td style="text-align: left;">wound <em>n.</em>, <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">wedding <em>n.</em> A2</td>
<td style="text-align: left;">willing <em>adj.</em> B2</td>
<td style="text-align: left;">wow <em>exclam.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">Wednesday <em>n.</em> A1</td>
<td style="text-align: left;">win <em>v.</em> A1, <em>n.</em> B1</td>
<td style="text-align: left;">wrap <em>v.</em> B2</td>
</tr>
<tr>
<td style="text-align: left;">week <em>n.</em> A1</td>
<td style="text-align: left;">wind1 <em>n.</em> A2</td>
<td style="text-align: left;">write <em>v.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">weekend <em>n.</em> A1</td>
<td style="text-align: left;">wind2 <em>v.</em> B2</td>
<td style="text-align: left;">writer <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">weigh <em>v.</em> B1</td>
<td style="text-align: left;">window <em>n.</em> A1</td>
<td style="text-align: left;">writing <em>n.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">weight <em>n.</em> A2</td>
<td style="text-align: left;">wine <em>n.</em> A1</td>
<td style="text-align: left;">written <em>adj.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">welcome <em>exclam.</em>, <em>v.</em>,
<em>adj.</em> A1, <em>n.</em> A2</td>
<td style="text-align: left;">wing <em>n.</em> B1</td>
<td style="text-align: left;">wrong <em>adj.</em> A1, <em>adv.</em> B1,
<em>n.</em> B2</td>
</tr>
</tbody>
</table>
<h2 id="y">Y</h2>
<table>
<colgroup>
<col style="width: 33%">
<col style="width: 37%">
<col style="width: 28%">
</colgroup>
<tbody>
<tr>
<td style="text-align: left;">yard <em>n.</em> B1</td>
<td style="text-align: left;">yesterday <em>adv.</em>, <em>n.</em>
A1</td>
<td style="text-align: left;">yours <em>pron.</em> A2</td>
</tr>
<tr>
<td style="text-align: left;">yeah <em>exclam.</em> A1</td>
<td style="text-align: left;">yet <em>adv.</em> A2, <em>conj.</em>
B2</td>
<td style="text-align: left;">yourself <em>pron.</em> A1</td>
</tr>
<tr>
<td style="text-align: left;">year <em>n.</em> A1</td>
<td style="text-align: left;">you <em>pron.</em> A1</td>
<td style="text-align: left;">youth <em>n.</em> B1</td>
</tr>
<tr>
<td style="text-align: left;">yellow <em>adj.</em>, <em>n.</em> A1</td>
<td style="text-align: left;">young <em>adj.</em> A1, <em>n.</em>
B1</td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">yes <em>exclam.</em> A1</td>
<td style="text-align: left;">your <em>det.</em> A1</td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<h2 id="z">Z</h2>
<table>
<tbody>
<tr>
<td style="text-align: left;">zero <em>number</em> A2</td>
<td style="text-align: left;">zone <em>n.</em> B2</td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/css/markmap.css">

<script src="/js/markmap.js"></script>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>英语词汇</tag>
        <tag>牛津3000</tag>
      </tags>
  </entry>
  <entry>
    <title>Josh&#39;s Summary — 工科数学分析&lt;br&gt;Part 1.1 基本微分与积分</title>
    <url>/posts/1823c9d1.html</url>
    <content><![CDATA[<p><span class="math inline">\(\newcommand\diff{\mathop{}\!\mathrm{d}}\)</span></p>
<h1 id="常见等价无穷小">1. 常见等价无穷小</h1>
<table>
<colgroup>
<col style="width: 33%">
<col style="width: 33%">
<col style="width: 33%">
</colgroup>
<tbody>
<tr>
<td style="text-align: center;"><span class="math inline">\(\sin x \sim
x\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\tan x \sim
x\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\arcsin x
\sim x\)</span></td>
</tr>
<tr>
<td style="text-align: center;"><span class="math inline">\(\arctan x
\sim x\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\displaystyle\left( 1 - \cos x \right) \sim
\dfrac{x^2}{2}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\ln (1+x)
\sim x\)</span></td>
</tr>
<tr>
<td style="text-align: center;"><span class="math inline">\(\left( e^x
-1 \right) \sim x\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\left( a^x -
1 \right) \sim x \ln a\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\left(
\left( 1+x \right) ^\alpha -1 \right) \sim \alpha x\)</span></td>
</tr>
</tbody>
</table>
<span id="more"></span>
<h1 id="导数基本公式">2. 导数基本公式</h1>
<table>
<colgroup>
<col style="width: 22%">
<col style="width: 22%">
<col style="width: 22%">
<col style="width: 33%">
</colgroup>
<thead>
<tr>
<th style="text-align: center;">一般函数</th>
<th style="text-align: center;">三角函数</th>
<th style="text-align: center;">反三角函数</th>
<th style="text-align: center;">双曲函数<br>(圆函数)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><span class="math inline">\(\left( C
\right)' = 0\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\left( \sin
x \right)' = \cos x\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\displaystyle\left( \arcsin x \right)' =
\dfrac{1}{\sqrt{1-x^2}}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\displaystyle\left( \sinh x \right)' =
\left(\dfrac{e^x-e^{-x}}{2}\right)' = \cosh x\)</span></td>
</tr>
<tr>
<td style="text-align: center;"><span class="math inline">\(\left(
x^\alpha \right)'=\alpha x^{\alpha-1} \left( \alpha \in  \mathbb{Z}
\right)\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\left( \cos
x \right)' = -\sin x\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\displaystyle\left( \arccos x \right)' =
-\dfrac{1}{\sqrt{1-x^2}}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\displaystyle\left( \cosh x \right)' = \left(
\dfrac{e^x+e^{-x}}{2} \right)'=\sinh x\)</span></td>
</tr>
<tr>
<td style="text-align: center;"><span class="math inline">\(\displaystyle\left(
\log_ax\right)'=\dfrac{1}{x\ln a}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\displaystyle\left( \tan x \right)' =
\dfrac{1}{\cos^2 x}=\sec^2 x\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\displaystyle\left( \arctan x \right)' =
\dfrac{1}{1+x^2}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\displaystyle\left( \mathrm{arsinh} \, x
\right)' = \left(\ln \left( x+\sqrt{x^2 + 1} \right) \right)' =
\dfrac{1}{x^2+1}\)</span></td>
</tr>
<tr>
<td style="text-align: center;"><span class="math inline">\((
\ln\)</span>| <span class="math inline">\(x\)</span> |<span class="math inline">\()'=\displaystyle\dfrac{1}{x}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\displaystyle\left( \cot x \right)' =
-\dfrac{1}{\sin^2 x} = -\csc^2 x\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\displaystyle\left( \mathrm{arccot} \, x
\right)' = -\dfrac{1}{1+x^2}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\displaystyle\left( \mathrm{arcosh} \, x
\right)' = \left( \ln \left( x + \sqrt{x^2 - 1} \right) \right)'
= \dfrac{1}{\sqrt{x^2-1}}\)</span></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"><span class="math inline">\(\left( \sec
x \right)' = \sec x \cdot \tan x\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"><span class="math inline">\(\left( \csc
x \right)' = \csc x \cdot \cot x\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<ul>
<li><p>Newton-Leibniz 公式：</p>
<p><span class="math display">\[
\begin{aligned}
\left( u \cdot v \right)^{\left( n \right)} &amp;= u^{\left( n \right)}v
+ nu^{\left( n-1 \right)}v' + \dfrac{n \left( n-1
\right)}{2!}u^{\left( n-2 \right)}v'' + \cdots + \dfrac{n\left(
n-1 \right)\cdots\left(n-k+1\right)}{k!}u^{\left( n-k \right)}v^{(k)} +
\cdots + uv^{\left( n \right)} \\
&amp;= \sum_{k=0}^{n}C_n^k u^{\left( u-k \right)}v^k
\end{aligned}
\]</span></p>
<p>可以注意到 Newton-Leibniz 公式具有类似二项式定理展开的形式。</p></li>
</ul>
<h1 id="几个初等函数的-maclaurin-公式">3. 几个初等函数的 Maclaurin
公式</h1>
<h2 id="taylor-公式的一般形式">3.1 Taylor 公式的一般形式</h2>
<p><span class="math display">\[\begin{aligned}
f(x)&amp;=f(x_0) + f'(x_0)(x-x_0) +
\dfrac{f''(x_0)}{2!}(x-x_0)^2 + \cdots +
\dfrac{f^{(n)}(x_0)}{n!}(x-x_0)^n + R_n
\\
&amp;= \sum_{k=0}^n \dfrac{f^{(n)}(x_0)}{n!}(x - x_0)^n + R_n
\end{aligned}\]</span></p>
<p>其中</p>
<p><span class="math display">\[
R_n = \dfrac{f^{(n+1)}(\xi)}{(n+1)!}(x-x_0)^{n+1} \xlongequal{x\to x_0}
o\left( \left( x - x_0 \right)^n \right), \quad
\xi\,在\,x\,和\,x_0\,之间
\]</span></p>
<h2 id="maclaurin-公式的一般形式">3.2 Maclaurin 公式的一般形式</h2>
<p><span class="math display">\[\begin{aligned}
f(x) &amp;= f(0)+f'(0)\,x + \dfrac{f''(0)}{2!}x^2 + \cdots +
\dfrac{f^{(n)}(0)}{n!}x^n + R_n
\\
&amp;= \sum_{k=0}^n \dfrac{f^{(n)}(0)}{n!}x^n + R_n
\end{aligned}\]</span></p>
<p>其中</p>
<p><span class="math display">\[
R_n = \dfrac{f^{(n+1)}(\xi)}{(n+1)!}x^{n+1} = \dfrac{f^{(n+1)}(\theta
x)}{(n+1)!} x^{n+1} \xlongequal{x\to x_0} o\left( \left( x - x_0
\right)^n \right), \quad \xi\,在\,0\,和\,x\,之间, 0&lt;\theta&lt;1
\]</span></p>
<h2 id="指数函数的-maclaurin-展开式">3.3 指数函数的 Maclaurin
展开式</h2>
<p><span class="math display">\[
e^x=1+x+\dfrac{x^2}{2} + \dfrac{x^3}{3} + \cdots +\dfrac{x^n}{n!} +
\dfrac{e^{\theta x}}{(n+1)!}, \quad 0&lt;\theta&lt;1
\]</span></p>
<h2 id="正弦函数的-maclaurin-展开式">3.4 正弦函数的 Maclaurin
展开式</h2>
<p><span class="math display">\[
\sin x = x - \dfrac{x^3}{3!} + \dfrac{x^5}{5!} + \cdots +
(-1)^{m-1}\dfrac{x^{2m-1}}{(2m-1)!} + R_{2m}
\]</span></p>
<p>其中</p>
<p><span class="math display">\[
R_{2m}=\dfrac{\sin\left( \theta x +
\dfrac{(2m-1)\pi}{2}\right)}{(2m+1)!}x^{2m+1} = o(x^{2m}), \quad
0&lt;\theta&lt;1
\]</span></p>
<h2 id="余弦函数的-maclaurin-展开式">3.5 余弦函数的 Maclaurin
展开式</h2>
<p><span class="math display">\[
\cos x = 1 - \dfrac{x^2}{2!} + \dfrac{x^4}{4!} + \cdots +
(-1)^m\dfrac{x^{2m}}{2m!} + R_{2m+1}
\]</span></p>
<p>其中</p>
<p><span class="math display">\[
R_{2m+1}=\dfrac{\cos(\theta x + (m+1)\pi)}{(2m+2)!}
x^{2m+2}=o(x^{2m+2}), \quad 0&lt;\theta&lt;1
\]</span></p>
<h2 id="ln-1x-的-maclaurin-展开式">3.6 <span class="math inline">\(\ln
(1+x)\)</span> 的 Maclaurin 展开式</h2>
<p><span class="math display">\[
\ln(1+x) = x - \dfrac{x^2}{2} + \dfrac{x^3}{3} -\dfrac{x^4}{4} + \cdots
+ \dfrac{(-1)^{n-1}x^n}{n} + R_n(x)
\]</span></p>
<p>其中</p>
<p><span class="math display">\[
R_n(x) = \dfrac{(-1)^n}{(n+1)(1+\theta x)^{n+1}}x^{n+1} = o(x^n), \quad
0&lt;\theta&lt;1
\]</span></p>
<h2 id="xalpha-的-maclaurin-展开式">3.7 <span class="math inline">\((1+x)^\alpha\)</span> 的 Maclaurin 展开式</h2>
<p><span class="math display">\[
(1+x)^\alpha = 1 + \alpha x + \dfrac{\alpha(\alpha-1)}{2!}x^2 + \cdots +
\dfrac{\alpha(\alpha - 1)\cdots (\alpha-n+1)}{n!}x^n + R_n(x)
\]</span></p>
<p>其中</p>
<p><span class="math display">\[
R_n(x) = \dfrac{\alpha(\alpha -1)\cdots(\alpha-n)}{(n+1)!}(1+\theta
x)^{\alpha-n-1}x^{n+1} = o(x), \quad 0&lt;\theta&lt;1
\]</span></p>
<h2 id="dfrac11-x-的-maclaurin-展开式">3.8 <span class="math inline">\(\dfrac{1}{1-x}\)</span> 的 Maclaurin 展开式</h2>
<p><span class="math display">\[
\dfrac{1}{1-x} = 1+x+x^2+\cdots+x^n +o(x^n)
\]</span></p>
<h1 id="曲率及曲率半径">4. 曲率及曲率半径</h1>
<table>
<colgroup>
<col style="width: 50%">
<col style="width: 50%">
</colgroup>
<thead>
<tr>
<th style="text-align: center;">曲率</th>
<th style="text-align: center;">曲率半径</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><span class="math inline">\(K=\left\|
\dfrac{\diff \alpha}{\diff s}\right\| \xlongequal{令\ \tan \alpha =
y', 则\ \alpha = \arctan y'} \dfrac{\left\|
\dfrac{y''}{1+y'^2}\diff x \right\|}{\sqrt{1+y'^2}}\diff
x = \dfrac{\left\| y'' \right\|}{\left( 1 + y'
\right)^{3/2}}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(R =
\dfrac{1}{K}\)</span></td>
</tr>
</tbody>
</table>
<h1 id="积分常用公式">5. 积分常用公式</h1>
<table>
<colgroup>
<col style="width: 6%">
<col style="width: 10%">
<col style="width: 82%">
</colgroup>
<thead>
<tr>
<th style="text-align: center;">序</th>
<th style="text-align: center;">描述</th>
<th style="text-align: center;">公式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">1</td>
<td style="text-align: center;">定积分的定义</td>
<td style="text-align: center;"><span class="math inline">\(\displaystyle\int^1_0f(x)\diff x=I=\lim_{\lambda
\to 0}\sum_{i=1}^{n}f(\xi_i)\Delta x_i\)</span>，其中 <span class="math inline">\(\lambda = \max \left\{ \Delta x_1,\Delta x_2,
\cdots, \Delta x_n \right\}\)</span></td>
</tr>
<tr>
<td style="text-align: center;">2</td>
<td style="text-align: center;">变上限积分</td>
<td style="text-align: center;"><span class="math inline">\(考察定积分\displaystyle\int^x_af(x)\diff
x=\int^x_af(t)\diff t\)</span>，对 <span class="math inline">\(\displaystyle\Phi(x)=\int_a^xf(t)\diff
t\)</span>，有 <span class="math inline">\(\displaystyle\Phi'(x)=\dfrac{\diff }{\diff
x}\int_a^xf(t)\diff t = f(x)\)</span></td>
</tr>
<tr>
<td style="text-align: center;">3</td>
<td style="text-align: center;">变上限积分的扩展</td>
<td style="text-align: center;"><span class="math inline">\(\displaystyle\dfrac{\diff }{\diff
x}\int^{\beta(x)}_{\alpha(x)}f'(t)\diff t = f\left[
\beta\left(x\right)\right]\beta'(x)-f[\alpha(x)]\alpha'(x)\)</span></td>
</tr>
<tr>
<td style="text-align: center;">4</td>
<td style="text-align: center;">上下限对称的积分</td>
<td style="text-align: center;">若 <span class="math inline">\(f(x)\)</span> 为偶函数，则 <span class="math inline">\(\displaystyle\int_{-a}^af(x)\diff
x=2\int_0^af(x)\diff x\)</span>；若 <span class="math inline">\(f(x)\)</span> 为奇函数，则 <span class="math inline">\(\displaystyle\int_{-a}^af(x)\diff
x=0\)</span></td>
</tr>
<tr>
<td style="text-align: center;">5</td>
<td style="text-align: center;">周期函数的积分</td>
<td style="text-align: center;"><span class="math inline">\(\displaystyle
f(x+T)=f(x)\Rightarrow\int_0^{nT}f(x)\diff x=n\int^T_0f(x)\diff
x\)</span></td>
</tr>
<tr>
<td style="text-align: center;">6</td>
<td style="text-align: center;">分部积分法</td>
<td style="text-align: center;"><span class="math inline">\(\displaystyle\int uv'\diff x=uv - \int
u'v\diff x \Leftrightarrow \int u\diff v = uv - \int v\diff
u\)</span></td>
</tr>
</tbody>
</table>
<h1 id="基本积分表">6. 基本积分表</h1>
<table>
<colgroup>
<col style="width: 12%">
<col style="width: 87%">
</colgroup>
<thead>
<tr>
<th style="text-align: center;">序</th>
<th style="text-align: center;">积分式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">1</td>
<td style="text-align: center;"><span class="math inline">\(\displaystyle\int k\diff x=kx+C\)</span>，特别地
<span class="math inline">\(\displaystyle\int\diff x=x+C\)</span></td>
</tr>
<tr>
<td style="text-align: center;">2</td>
<td style="text-align: center;"><span class="math inline">\(\displaystyle\int x^\mu\diff
x=\dfrac{x^{\mu+1}}{\mu+1}+C(\mu\ne-1)\)</span>，特别地 <span class="math inline">\(\displaystyle\int \dfrac{1}{x^2}\diff
x=-\dfrac{1}{x}+C,\int\dfrac{1}{\sqrt{x}}\diff
x=2\sqrt{x}+C\)</span></td>
</tr>
<tr>
<td style="text-align: center;">3</td>
<td style="text-align: center;"><span class="math inline">\(\displaystyle\int\dfrac{1}{x}\diff x=\ln
\|x\|+C\)</span></td>
</tr>
<tr>
<td style="text-align: center;">4</td>
<td style="text-align: center;"><span class="math inline">\(\displaystyle\int\dfrac{1}{1+x^2}\diff x = \arctan
x +C\)</span></td>
</tr>
<tr>
<td style="text-align: center;">5</td>
<td style="text-align: center;"><span class="math inline">\(\displaystyle\int\dfrac{1}{\sqrt{1-x^2}}\diff
x=\arcsin x+C\)</span></td>
</tr>
<tr>
<td style="text-align: center;">6</td>
<td style="text-align: center;"><span class="math inline">\(\displaystyle\int\sin x\diff x = -\cos x+C,
\int\cos x\diff x = \sin x +C\)</span></td>
</tr>
<tr>
<td style="text-align: center;">7</td>
<td style="text-align: center;"><span class="math inline">\(\displaystyle\int\dfrac{\diff x}{\cos^2x} =
\int\sec^2x\diff x = \tan x +C, \int\dfrac{\diff
x}{\sin^2x}=\int\csc^2x\diff x = -\cot x +C\)</span></td>
</tr>
<tr>
<td style="text-align: center;">8</td>
<td style="text-align: center;"><span class="math inline">\(\displaystyle\int a^x\diff x = \dfrac{a^x}{\ln a}
+ C\)</span>，特别地 <span class="math inline">\(\displaystyle\int
e^x\diff x = e^x +C\)</span></td>
</tr>
<tr>
<td style="text-align: center;">9</td>
<td style="text-align: center;"><span class="math inline">\(\displaystyle\int \sinh x\diff x = \cosh x +
C，\int \cosh x \diff x=\sinh x +C\)</span></td>
</tr>
</tbody>
</table>
<h1 id="三角函数相关公式">7. 三角函数相关公式</h1>
<table>
<colgroup>
<col style="width: 12%">
<col style="width: 87%">
</colgroup>
<thead>
<tr>
<th style="text-align: center;">序</th>
<th style="text-align: center;">公式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">1</td>
<td style="text-align: center;"><span class="math inline">\(\sin^2x+\cos^2x=1,
\tan^2x+1=\sec^2x,\cot^2x+1=\csc^2x\)</span></td>
</tr>
<tr>
<td style="text-align: center;">2</td>
<td style="text-align: center;"><span class="math inline">\(\begin{aligned}&amp;\cosh^2x-\sinh^2x=1,\\
&amp;\sinh(x\pm y)=\sinh x\cdot\cosh y \pm \sinh y\cdot\cosh x,
\cosh(x\pm y) = \cosh x\cdot\cosh y,\\ &amp;\sinh2x = 2\sinh x\cdot
\cosh x, \cosh 2x = \cosh^2x+\sinh^2x = 2\cosh^2x -
1\end{aligned}\)</span></td>
</tr>
<tr>
<td style="text-align: center;">3<br>积化和差公式</td>
<td style="text-align: center;"><span class="math inline">\(\sin\alpha\cos\beta=\dfrac12[\sin(\alpha+\beta)+\sin(\alpha-\beta)],\cos\alpha\sin\beta
= \dfrac12[\sin(\alpha+\beta) - \sin(\alpha-\beta)]\)</span> <br> <span class="math inline">\(\cos\alpha\cos\beta = \dfrac12[cos(\alpha+\beta) +
cos(\alpha - \beta)], \sin\alpha\sin\beta=-\dfrac12[\cos(\alpha+\beta) -
\cos(\alpha-\beta)]\)</span></td>
</tr>
<tr>
<td style="text-align: center;">4<br>和差化积公式</td>
<td style="text-align: center;"><span class="math inline">\(\displaystyle\sin\alpha + \sin\beta =
2\sin\left(\dfrac{\alpha+\beta}{2}\right)
\cos\left(\dfrac{\alpha-\beta}{2}\right), \sin\alpha - \sin\beta =
2\sin\left(\dfrac{\alpha-\beta}{2}\right)
\cos\left(\dfrac{\alpha+\beta}{2}\right)\)</span> <br> <span class="math inline">\(\displaystyle\cos\alpha + \cos\beta =
2\cos\left(\dfrac{\alpha+\beta}{2}\right)
\cos\left(\dfrac{\alpha-\beta}{2}\right), \cos\alpha - \cos\beta =
-2\sin\left(\dfrac{\alpha+\beta}{2}\right)
\sin\left(\dfrac{\alpha-\beta}{2}\right)\)</span></td>
</tr>
<tr>
<td style="text-align: center;">5<br>三角代换</td>
<td style="text-align: center;"><span class="math inline">\(\displaystyle\sqrt{a^2-x^2}\xrightarrow{x=a\sin
t}a\cos t, \sqrt{a^2+x^2} \xrightarrow{x=a\tan t}a\sec t,
\sqrt{x^2-a^2}\xrightarrow{x=a\sec t}a\tan t \left( a&gt;0,t\in\left(
-\dfrac{\pi}{2} , \dfrac{\pi}{2} \right) \right)\)</span></td>
</tr>
<tr>
<td style="text-align: center;">6</td>
<td style="text-align: center;"><span class="math inline">\(\displaystyle\int\sqrt{a^2-x^2}\diff x =
\dfrac{a^2}{2}\arcsin\dfrac xa + \dfrac12x\sqrt{a^2-x^2} +
C(a&gt;0)\)</span></td>
</tr>
<tr>
<td style="text-align: center;">7</td>
<td style="text-align: center;"><span class="math inline">\(\displaystyle\int\sqrt{x^2+a^2}\diff x = \dfrac
x2\sqrt{x^2+a^2} + \dfrac{a^2}2\ln \left\| x+\sqrt{x^2+a^2}
\right\|+C(a&gt;0)\)</span></td>
</tr>
<tr>
<td style="text-align: center;">8</td>
<td style="text-align: center;"><span class="math inline">\(\displaystyle\int\dfrac{1}{\sqrt{x^2+a^2}}\diff x
= \ln\left\| x+ \sqrt{x^2+a^2} \right\| +C\)</span>, <span class="math inline">\(\displaystyle\int\dfrac{1}{\sqrt{x^2-a^2}}\diff x
= \ln\left\| x +
\sqrt{x^2-a^2}\right\|(a&gt;0)\)</span><br>特别地，<span class="math inline">\(\displaystyle\int\dfrac{1}{\sqrt{x^2+1}}\diff
x=\ln\left(x+\sqrt{x^2+1}\right) = \mathrm{arsinh}\, x\)</span>, <span class="math inline">\(\displaystyle\int\dfrac{1}{\sqrt{x^2-1}}\diff x =
\ln\left( x+\sqrt{x^2-1}\right) = \mathrm{arcosh}\, x\)</span></td>
</tr>
<tr>
<td style="text-align: center;">9</td>
<td style="text-align: center;"><span class="math inline">\(\displaystyle\int\sec x\diff x =
\int\dfrac{1}{\cos x}\diff x = \int\dfrac{\sec^2x+\sec x \tan x}{\sec x
+ \tan x}\diff x = \int\dfrac{1}{\sec x + \tan x}\diff (\sec x + \tan x)
= \ln \left\| \sec x + \tan x \right\| + C\)</span></td>
</tr>
<tr>
<td style="text-align: center;">10</td>
<td style="text-align: center;"><span class="math inline">\(\displaystyle\int\csc x\diff x =
\int\dfrac{1}{\sin x}\diff x = \ln\left\| \tan\dfrac x2 \right\| + C =
\dfrac 12 \ln \left\| \dfrac{1-\cos x}{1 + \cos x}\right\| +
C\)</span></td>
</tr>
<tr>
<td style="text-align: center;">11</td>
<td style="text-align: center;"><span class="math inline">\(\displaystyle\int\tan x\diff x = \int\dfrac{\sin
x}{\cos x}\diff x = -\int\dfrac{1}{\cos x}\diff (\cos x) = -\ln \left\|
\cos x\right\| +C\)</span></td>
</tr>
<tr>
<td style="text-align: center;">12</td>
<td style="text-align: center;"><span class="math inline">\(\displaystyle\int\dfrac{1}{\tan x}\diff x =
\int\dfrac{\cos x}{\sin x}\diff x = \int\dfrac{1}{\sin x}\diff (\sin x)
= \ln\left\| \sin x \right\| + C\)</span></td>
</tr>
<tr>
<td style="text-align: center;">13</td>
<td style="text-align: center;"><span class="math inline">\(\displaystyle\int\arctan x\diff x = x\arctan x -
\ln \left\| 1+x^2 \right\| +C\)</span></td>
</tr>
<tr>
<td style="text-align: center;">14<br>Wallis 公式</td>
<td style="text-align: center;"><span class="math inline">\(\displaystyle\int^{\pi/2}_{0}\sin^nx\diff x =
\int^{\pi/2}_{0}\cos^nx\diff x = \begin{cases}
\displaystyle\dfrac{n-1}{n}\cdot\dfrac{n-3}{n-2}\cdot\cdots\cdot\dfrac12\cdot\dfrac\pi2,&amp;n为偶数
\\
\displaystyle\dfrac{n-1}{n}\cdot\dfrac{n-3}{n-2}\cdot\cdots\cdot\dfrac23\cdot1,&amp;n为奇数
\end{cases} \\ = \begin{cases}
\displaystyle\dfrac{(n-1)!!}{n!!}\cdot\dfrac\pi2,&amp;n为偶数 \\
\displaystyle\dfrac{(n-1)!!}{n!!},&amp;n为奇数 \end{cases}\)</span></td>
</tr>
<tr>
<td style="text-align: center;">15</td>
<td style="text-align: center;"><span class="math inline">\(\displaystyle\int_0^\pi\sin^nx\diff x =
2\int^{\pi/2}_0\sin^nx\diff x,\int_0^\pi\cos^nx\diff x = \begin{cases}
2\displaystyle\int^{\pi/2}_0\cos^nx\diff x,&amp;n为偶数 \\
0,&amp;n为奇数 \end{cases}\)</span> <br> <span class="math inline">\(\displaystyle\int_0^{2\pi}\sin^nx =
\int_0^{2\pi}\cos^nx\diff x = \begin{cases}
4\displaystyle\int^{\pi/2}_0\sin^nx\diff x,&amp;n为偶数 \\
0,&amp;n为奇数 \end{cases}\)</span> <br> <span class="math inline">\(\displaystyle\int_0^{\pi/2}f(\sin x)\diff x =
\int_0^{\pi/2}f(\cos x)\diff x\)</span>, <span class="math inline">\(\displaystyle\int_0^\pi f(\sin x)\diff x \ne
\int_0^\pi f(\cos x)\diff x\)</span> <br> <span class="math inline">\(\displaystyle\int_0^\pi\pi f(\sin x)\diff x =
\dfrac\pi2\int_0^\pi f(\sin x)\diff x = \pi\int_0^{\pi/2} f(\sin x)\diff
x\)</span></td>
</tr>
<tr>
<td style="text-align: center;">16<br>万能公式</td>
<td style="text-align: center;">令&nbsp;<span class="math inline">\(u=\displaystyle\tan\dfrac x2,x=2\arctan
u\)</span>，则&nbsp;<span class="math inline">\(\displaystyle\sin x =
\dfrac{2u}{1+u^2},\cos x=\dfrac{1-u^2}{1+u^2}, \diff x =
\dfrac{2}{1+u^2}\diff u\)</span></td>
</tr>
<tr>
<td style="text-align: center;">17</td>
<td style="text-align: center;"><span class="math inline">\(\displaystyle\int \dfrac{a\cos x+ b\sin x}{c\cos x
+ d \sin x} = A\int\diff x+B\int\dfrac{\diff (c\cos x+d \sin x)}{c \cos
x + d \sin x}\)</span> <br> (设 <span class="math inline">\(a\cos x +
b\sin x = A(c \cos x + d \sin x) + B(c \cos x + d \sin
x)'\)</span>，由待定系数法求出 <span class="math inline">\(A,
B\)</span>)</td>
</tr>
</tbody>
</table>
<h1 id="定积分的几何应用">8. 定积分的几何应用</h1>
<h2 id="平面">8.1 平面</h2>
<h3 id="直角坐标">8.1.1 直角坐标</h3>
<ol type="1">
<li>直角梯形的面积</li>
</ol>
<p><span class="math display">\[\begin{equation*}
A = \int_a^b [f(x_1) - f(x_2)] \diff x
\end{equation*}\]</span></p>
<ol start="2" type="1">
<li><p>曲边梯形的面积：对于参数方程 <span class="math inline">\(\begin{cases}
  x = \varphi(x) \\ y = {\psi(x)}
\end{cases}\)</span>，曲边梯形的面积（变换上下限）</p>
<p><span class="math display">\[\begin{equation*}
A = \int_a^b y\diff x = \int_{t_1}^{t_2} \psi(t) \diff \varphi(t) =
\int_{t_1}^{t_2} \psi(t)\varphi'(t) \diff t
\end{equation*}\]</span></p></li>
<li><p>椭圆的面积：椭圆 <span class="math inline">\(\begin{cases}
  x = a \cos t \\ y = b \sin t
\end{cases}\)</span>，即 <span class="math inline">\(\dfrac{x^2}{a^2} +
\dfrac{y^2}{b^2} = 1\)</span> 的面积</p>
<p><span class="math display">\[\begin{equation*}
  A = 4 \int_0^a y \diff x = 4ab \int_0^{\pi/2} (1-\cos t)^2 \diff t =
3\pi a^2
\end{equation*}\]</span></p></li>
<li><p>摆线的面积：摆线 <span class="math inline">\(\begin{cases}
  x = a (t - \sin t) \\ y = a (1 - \cos t)
\end{cases}\)</span> 的一拱与 <span class="math inline">\(x\)</span>
轴所围图形的面积</p>
<p><span class="math display">\[\begin{equation*}
  A = \int_0^2\pi a y \diff x = a^2 \int_0^{2\pi} (1 - \cos t)^2 \diff t
= 3\pi a^2
\end{equation*}\]</span></p></li>
</ol>
<h3 id="极坐标">8.1.2 极坐标</h3>
<ol type="1">
<li><p>扇形的面积：由 <span class="math inline">\(\rho  =
\rho(\theta)\)</span> 及射线 <span class="math inline">\(\theta =
\alpha\)</span> 和 <span class="math inline">\(\theta = \beta\)</span>
所围曲边扇形的面积</p>
<p><span class="math display">\[\begin{equation*}
   A = \int_\alpha^\beta \frac{1}{2} \rho^2(\theta) \diff \theta =
\frac{1}{2} \int_\alpha^\beta \rho^2 \diff \theta
\end{equation*}\]</span></p></li>
<li><p>阿基米德螺线：阿基米德螺线 <span class="math inline">\(\rho = a
\theta (a &gt; 0)\)</span> 对应 <span class="math inline">\(\theta\)</span> 从 <span class="math inline">\(0\)</span> 变换到 <span class="math inline">\(2\pi\)</span> 所围图形的面积</p>
<p><span class="math display">\[\begin{equation*}
   A = \int_0^{2\pi} \frac{1}{2} (a\theta)^2\diff \theta = \frac{4}{3}
\pi^3 a^2
\end{equation*}\]</span></p></li>
<li><p>双纽线：双纽线 <span class="math inline">\(\rho^2 = a^2 \cos
2\theta\)</span> 所围平面图形的面积</p>
<p><span class="math display">\[\begin{equation*}
   A = 4 \int_0^{\pi/4} a^2 \cos 2\theta \diff \theta = a^2
\end{equation*}\]</span></p></li>
<li><p>心形线：心形线 <span class="math inline">\(\rho =
a(a+\cos\theta), a&gt;0\)</span> 所围平面图形的面积</p>
<p><span class="math display">\[\begin{equation*}
   A = 2 \cdot \frac{1}{2} \int_0^\pi a^2 (1+ \cos \theta)^2 \diff
\theta = \frac{3}{2}\pi a^2
\end{equation*}\]</span></p></li>
<li><p>曲线的弧长</p>
<table>
<colgroup>
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 25%">
</colgroup>
<thead>
<tr>
<th style="text-align: center;">弧微分</th>
<th style="text-align: center;">直角坐标</th>
<th style="text-align: center;">参数方程</th>
<th style="text-align: center;">极坐标</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><span class="math inline">\(\diff s =
\sqrt{(\diff x)^2 + (\diff y)^2}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(s =
\displaystyle\int_a^b \sqrt{1 + y'^2}\diff x\)</span></td>
<td style="text-align: center;"><span class="math inline">\(s =
\displaystyle\int_a^b \sqrt{\varphi'^2(t) + \psi'^2(t)}\diff
t\)</span></td>
<td style="text-align: center;"><span class="math inline">\(s =
\displaystyle\int_\alpha^\beta \sqrt{\rho^2{\theta} +
\rho'^2(\theta)} \diff\theta\)</span></td>
</tr>
</tbody>
</table></li>
</ol>
<h2 id="空间">8.2 空间</h2>
<ol type="1">
<li><p>已知平行截面面积求立体体积：令 <span class="math inline">\(A(x)\)</span> 为截面面积，则立体体积</p>
<p><span class="math display">\[\begin{equation*}
   V = \int_a^b A(x) \diff x
\end{equation*}\]</span></p></li>
<li><p>旋转体体积</p>
<table>
<colgroup>
<col style="width: 50%">
<col style="width: 50%">
</colgroup>
<thead>
<tr>
<th style="text-align: center;">薄片法</th>
<th style="text-align: center;">柱壳法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><span class="math inline">\(V =
\displaystyle\int_a^b \pi f^2(x) \diff x\)</span></td>
<td style="text-align: center;"><span class="math inline">\(V =
\displaystyle\int_a^b 2\pi x \left| f(x) \right|\diff x\)</span></td>
</tr>
</tbody>
</table></li>
</ol>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/css/markmap.css">

<script src="/js/markmap.js"></script>
]]></content>
      <categories>
        <category>Josh 的学习笔记</category>
        <category>微积分</category>
        <category>数学</category>
        <category>微积分</category>
      </categories>
      <tags>
        <tag>等价无穷小</tag>
        <tag>导数公式</tag>
        <tag>Maclaurin 公式</tag>
        <tag>曲率</tag>
        <tag>积分公式</tag>
        <tag>三角函数</tag>
      </tags>
  </entry>
  <entry>
    <title>Josh&#39;s Review — 数字信号处理&lt;br&gt;Part 1 离散时间信号和系统分析基础</title>
    <url>/posts/1391fb05.html</url>
    <content><![CDATA[<h1 id="理想取样信号的频谱">1. 理想取样信号的频谱</h1>
<p>  设有输入连续时间信号 <span class="math inline">\(x_a\left(t\right)\)</span>，理想取样信号 <span class="math inline">\(\hat{x}\left(t\right)\)</span>，单位周期冲激串
<span class="math inline">\(p_\delta\left(t\right)=\displaystyle\sum_{n=-\infty}^{\infty}\delta\left(t-nT\right)\)</span>，则理想取样信号可表示为</p>
<p><span class="math display">\[\begin{equation}
\hat{x}\left(t\right)=x_a\left(t\right)p_\delta\left(t\right)=x_a\left(t\right)\sum_{n=-\infty}^{\infty}\delta\left(t-nT\right)
\end{equation}\]</span></p>
<p>由于 <span class="math inline">\(\delta\left(t-nT\right)\)</span>
仅在 <span class="math inline">\(t=nT\)</span>
时非零，因此理想取样信号可进一步表示为</p>
<p><span class="math display">\[\begin{equation}
\hat{x}\left(t\right)=\sum_{n=-\infty}^{\infty}{x_a\left(nT\right)\delta\left(t-nT\right)}
\end{equation}\]</span></p>
<span id="more"></span>
<p>  将单位周期冲激串 <span class="math inline">\(p_\delta\left(t\right)\)</span>
按指数形式的傅氏级数展开<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>，有</p>
<p><span class="math display">\[\begin{equation}
p_\delta\left(t\right)=\sum_{n=-\infty}^{\infty}\delta\left(t-nT\right)=\sum_{m=-\infty}^{\infty}{c_me^{jm\frac{2\pi}{T}\cdot
t}}
\end{equation}\]</span></p>
<p>其中</p>
<p><span class="math display">\[\begin{equation}
c_m=\frac{1}{T}\int_{-\frac{T}{2}}^{\frac{T}{2}}{\sum_{n=-\infty}^{\infty}\delta\left(t-nT\right)e^{-jm\frac{2\pi}{T}t}\mathrm{d}t}
\end{equation}\]</span></p>
<p>由于在积分区间 <span class="math inline">\(\left[-\dfrac{T}{2},\dfrac{T}{2}\right]\)</span>内只有一个冲激脉冲
<span class="math inline">\(\delta\left(t\right)\)</span>，则</p>
<p><span class="math display">\[\begin{equation}
c_m=\frac{1}{T}\int_{-\frac{T}{2}}^{\frac{T}{2}}{\delta\left(t\right)e^{-jm\frac{2\pi}{T}t}\mathrm{d}t}=\frac{1}{T}
\end{equation}\]</span></p>
<p>由此，单位周期冲激串可进一步表示为</p>
<p><span class="math display">\[\begin{equation}
p_\delta\left(t\right)=\sum_{n=-\infty}^{\infty}\delta\left(t-nT\right)=\frac{1}{T}\sum_{m=-\infty}^{\infty}e^{jm\frac{2\pi}{T}\cdot
t}
\end{equation}\]</span></p>
<p>  理想取样信号 <span class="math inline">\(\hat{x}\left(t\right)\)</span>
的傅里叶变换（取样角频率 <span class="math inline">\(\Omega_s=\dfrac{2\pi}{T}\)</span>）</p>
<p><span class="math display">\[\begin{align}
  \hat{X}\left(j\Omega\right)&amp;=\int_{-\infty}^{\infty}{\hat{x}\left(t\right)e^{-j\Omega
t}\mathrm{d}t}=\int_{-\infty}^{\infty}{x_a\left(t\right)p_\delta\left(t\right)e^{-j\Omega
t}\mathrm{d}t}\\
  &amp;=\frac{1}{T}\int_{-\infty}^{\infty}{x_a\left(t\right)\sum_{m=-\infty}^{\infty}{e^{jm\Omega_st}e^{-j\Omega
t}}\mathrm{d}t}=\frac{1}{T}\sum_{m=-\infty}^{\infty}\int_{-\infty}^{\infty}{x_a\left(t\right)e^{-j\left(\Omega-m\Omega_s\right)t}\mathrm{d}t}
\end{align}\]</span></p>
<p>与连续时间信号 <span class="math inline">\(x_a\left(t\right)\)</span>
的傅里叶变换对比</p>
<p><span class="math display">\[\begin{equation}
X_a\left(j\Omega\right)=\int_{-\infty}^{\infty}{x_a\left(t\right)e^{-j\Omega
t}\mathrm{d}t}
\end{equation}\]</span></p>
<p>有 <span class="math display">\[\begin{equation}
\hat{X}\left(j\Omega\right)=\frac{1}{T}\sum_{m=-\infty}^{\infty}{X_a\left[j\left(\Omega-m\Omega_s\right)\right]}=\frac{1}{T}\sum_{m=-\infty}^{\infty}{X_a\left[j\left(\Omega-m\frac{2\pi}{T}\right)\right]}
\end{equation}\]</span></p>
<p>由此，理想取样后信号频谱的幅值乘以 <span class="math inline">\(\dfrac{1}{T}\)</span> 因子，且周期延拓<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>。</p>
<h1 id="按非零脉宽取样的信号的频谱">2. 按非零脉宽取样的信号的频谱</h1>
<p>  设有输入连续时间信号 <span class="math inline">\(x_a\left(t\right)\)</span>，取样信号 <span class="math inline">\(\hat{x}\left(t\right)\)</span>，幅度为 <span class="math inline">\(1\)</span> 重复周期为 <span class="math inline">\(T\)</span> 宽度为 <span class="math inline">\(\tau\)</span> 的周期取样脉冲 <span class="math inline">\(p\left(t\right)\)</span>。取样脉冲的傅里叶变换<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>为</p>
<p><span class="math display">\[\begin{align}
p\left( t \right) =\begin{cases}
  1,&amp;0&lt;\left| t \right|&lt;\dfrac{\tau}{2}\\
  0,&amp;\dfrac{\tau}{2}&lt;\left| t \right|&lt;\dfrac{T}{2}\\
\end{cases}
且p\left(t+T\right)=p\left(t\right) \xleftrightarrow{\text{Fourier
Transform}}
P\left(j\Omega\right)=\sum_{m=-\infty}^{\infty}\frac{2\sin{\left(\dfrac{m\pi\tau}{T}\right)}}{m}\delta\left(\Omega-\frac{2\pi}{T}\right)
\end{align}\]</span></p>
<p>则取样信号 <span class="math inline">\(\hat{x}\left(t\right)\)</span>
的频谱</p>
<p><span class="math display">\[\begin{align}
\hat{X}\left(j\Omega\right)&amp;=\dfrac{1}{2\pi}X_a\left(j\Omega\right)\ast
P\left(j\Omega\right)=\dfrac{1}{2\pi}\sum_{m=-\infty}^{\infty}\dfrac{2\sin{\left(\dfrac{m\pi\tau}{T}\right)}}{m}X_a\left[j\left(\Omega-m\frac{2\pi}{T}\right)\right]\\
&amp;=\frac{\tau}{T}\sum_{m=-\infty}^{\infty}Sa\left(\frac{m\pi\tau}{T}\right)X_a\left[j\left(\Omega-m\frac{2\pi}{T}\right)\right]
\end{align}\]</span></p>
<p>其中</p>
<p><span class="math display">\[\begin{equation}
\Omega_s=\frac{2\pi}{T}，\mathrm{Sa}\left(x\right)=\frac{\sin{x}}{x}
\end{equation}\]</span></p>
<p>由此可见取样信号的频谱是周期重复的，其幅度是按照 <span class="math inline">\(\mathrm{Sa}\)</span> 函数（或 <span class="math inline">\(\mathrm{sinc}\)</span> 函数）<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>的变化规律随频率而逐渐下降的。</p>
<h1 id="shannon-取样定理">3. Shannon 取样定理</h1>
<p>  对于任何采样（不论是理想或实际），取样频率 <span class="math inline">\(\Omega_s\)</span> 必须大于原模拟信号频谱中最高频率
<span class="math inline">\(\Omega_h\)</span> 的两倍，则取样信号 <span class="math inline">\(x_a\left(t\right)\)</span> 可由其取样信号 <span class="math inline">\(x\left(nT\right)\)</span>
唯一表示表示，即不发生频谱混叠。</p>
<p>  信号频谱中最高频率 <span class="math inline">\(\Omega_h\)</span>
称为 Nyquist 频率，理论上能够再恢复出原信号的最小频率 <span class="math inline">\(\Omega_s={2\Omega}_h\)</span> 称为 Nyquist
采样率。</p>
<h1 id="信号的恢复及取样内插公式">4. 信号的恢复及取样内插公式</h1>
<p>  当满足 Shannon 取样定理时，将取样信号 <span class="math inline">\(\hat{x}\left(t\right)\)</span>
通过一带宽等于折叠频率 <span class="math inline">\(\Omega_0=\dfrac{\Omega_s}{2}\)</span>
的只允许通过基带频谱的理想低通滤波器可恢复出原模拟信号。滤波器的频域表达式及其脉冲响应为</p>
<p><span class="math display">\[\begin{equation}
H\left( j\varOmega \right) =\begin{cases}
  T,\left| \Omega \right|&lt;\dfrac{\Omega _s}{2}\\
  0,\left| \Omega \right|\geqslant \dfrac{\Omega _s}{2}\\
\end{cases}
\end{equation}\]</span></p>
<p><span class="math display">\[\begin{equation}
\text{Fourier} \updownarrow  \text{Transform}
\\
h_a\left( t \right) =\frac{1}{2\pi}\int_{-\infty}^{\infty}{H\left(
j\Omega \right) e^{j\Omega
t}\text{d}t}=\frac{T}{2\pi}\int_{-\frac{\Omega _s}{2}}^{\frac{\Omega
_{\text{s}}}{2}}{e^{j\Omega t}\text{d}t}
=\dfrac{\sin \!\:\dfrac{\Omega _s}{2}t}{\dfrac{\Omega
_s}{2}t}=\dfrac{\sin \!\:\dfrac{\pi}{T}t}{\dfrac{\pi}{T}t}
\end{equation}\]</span></p>
<p>则由时域卷积定理<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a></p>
<p><span class="math display">\[\begin{align}
  y\left(t\right)&amp;=\hat{x}\left(t\right)\ast
h_a\left(t\right)=\int_{-\infty}^{\infty}{\hat{x}\left(t\right)h_a\left(t-\tau\right)d\tau}=\int_{-\infty}^{\infty}{\left[\sum_{n=-\infty}^{\infty}{x_a\left(\tau\right)\delta\left(\tau-nT\right)}\right]h_a\left(t-\tau\right)d\tau}\\
  &amp;=\sum_{n=-\infty}^{\infty}\int_{-\infty}^{\infty}{x_a\left(\tau\right)h_a\left(t-\tau\right)\delta\left(\tau-nT\right)d\tau}=\sum_{n=-\infty}^{\infty}{x_a\left(nT\right)h_a\left(t-nT\right)}\\
  &amp;=\sum_{n=-\infty}^{\infty}{x_a\left(nT\right)\dfrac{\sin{\dfrac{\pi}{T}\left(t-nT\right)}}{\dfrac{\pi}{T}\left(t-nT\right)}=x_a\left(t\right)}
\end{align}\]</span></p>
<p>其中内插函数</p>
<p><span class="math display">\[\begin{equation}
h_a\left(t-nT\right)=\frac{\sin{\dfrac{\pi}{T}\left(t-nT\right)}}{\dfrac{\pi}{T}\left(t-nT\right)}
\end{equation}\]</span></p>
<p>由此，只要取样率 <span class="math inline">\(\Omega_s\)</span> 满足
Shannon 取样定理，连续时间函数 <span class="math inline">\(x_a\left(t\right)\)</span>
就可以由它的取样值来表达而不损失任何信息。这时只要把每一个瞬间的函数乘以对应的内插函数
<span class="math inline">\(h_a\left(t-nT\right)\)</span>
并求总和，即可得出 <span class="math inline">\(x_a(t)\)</span>。</p>
<h1 id="数字域角频率和模拟域角频率的关系">5.
数字域角频率和模拟域角频率的关系</h1>
<p>  以正弦序列为例</p>
<p><span class="math display">\[\begin{equation}
x\left(n\right)=\left.x\left(\Omega_0t\right)\right|_{t=nT}=\sin{\left(\Omega_0Tn\right)}=\sin{\left(\omega_0n\right)}
\end{equation}\]</span></p>
<p>则数字域角频率和模拟域角频率的关系为</p>
<p><span class="math display">\[\begin{equation}
\omega_0=\Omega_0T=\frac{\Omega_0}{f_s}
\end{equation}\]</span></p>
<p>也可以说模拟域角频率 <span class="math inline">\(\Omega_0\)</span>
对取样频率 <span class="math inline">\(f_s\)</span> 取归一化的值 <span class="math inline">\(\dfrac{\Omega_0}{f_s}\)</span>。</p>
<h1 id="离散线性卷积的矩阵算法">6. 离散线性卷积的矩阵算法</h1>
<p><span class="math display">\[\begin{equation}
y=h\ast
x=\left[\begin{matrix}h_1&amp;0&amp;\cdots&amp;0&amp;0\\h_2&amp;h_1&amp;\ddots&amp;\vdots&amp;\vdots\\\vdots&amp;\vdots&amp;\ddots&amp;0&amp;0\\h_m&amp;h_{m-1}&amp;&amp;h_1&amp;0\\0&amp;h_m&amp;\ddots&amp;\vdots&amp;h_1\\0&amp;0&amp;\ddots&amp;h_{m-1}&amp;\vdots\\\vdots&amp;\vdots&amp;&amp;h_m&amp;h_{m-1}\\0&amp;0&amp;\cdots&amp;0&amp;h_m\\\end{matrix}\right]_{\left(m+n-1\right)\times
n}\cdot\left[\begin{matrix}x_1\\x_2\\x_3\\\vdots\\x_n\\\end{matrix}\right]_{n\times1}
\end{equation}\]</span></p>
<p><span class="math display">\[\begin{equation}
y^T=\left[\begin{matrix}h_1&amp;h_2&amp;h_3&amp;\cdots&amp;h_{m-1}&amp;h_m\\\end{matrix}\right]_{1\times
n}\cdot\left[\begin{matrix}x_1&amp;x_2&amp;x_3&amp;\cdots&amp;x_n&amp;0&amp;0&amp;0&amp;\cdots&amp;0\\0&amp;x_1&amp;x_2&amp;x_3&amp;\cdots&amp;x_n&amp;0&amp;0&amp;\cdots&amp;0\\0&amp;0&amp;x_1&amp;x_2&amp;x_3&amp;\cdots&amp;x_n&amp;0&amp;\cdots&amp;0\\\vdots&amp;\vdots&amp;\vdots&amp;\ddots&amp;&amp;&amp;\vdots&amp;\ddots&amp;\vdots&amp;\vdots\\0&amp;\cdots&amp;0&amp;0&amp;x_1&amp;\cdots&amp;x_{n-2}&amp;x_{n-1}&amp;x_n&amp;0\\0&amp;\cdots&amp;0&amp;0&amp;0&amp;x_1&amp;\cdots&amp;x_{n-2}&amp;x_{n-1}&amp;x_n\\\end{matrix}\right]_{n\times\left(n+m-1\right)}
\end{equation}\]</span></p>
<h1 id="单位取样响应-hleftnright-和系统频率响应-hleftejomegaright-的关系">7.
单位取样响应 <span class="math inline">\(h\left(n\right)\)</span>
和系统频率响应 <span class="math inline">\(H\left(e^{j\omega}\right)\)</span> 的关系</h1>
<h2 id="通过单位取样响应-hleftnright-从时域表征系统">7.1.
通过单位取样响应 <span class="math inline">\(h\left(n\right)\)</span>
从时域表征系统</h2>
<p>  当系统的输入为单位取样序列 <span class="math inline">\(\delta\left(n\right)\)</span>
时的输出序列称为系统的单位取样响应 <span class="math inline">\(h\left(n\right)\)</span>，记</p>
<p><span class="math display">\[\begin{equation}
h\left(n\right)=T\left[\delta\left(n\right)\right]
\end{equation}\]</span></p>
<p>若系统是线性时不变的，则系统对移位 <span class="math inline">\(k\)</span> 步的单位取样序列 <span class="math inline">\(\delta\left(n-k\right)\)</span> 的响应为</p>
<p><span class="math display">\[\begin{equation}
h\left(n-k\right)=T\left[\delta\left(n-k\right)\right]
\end{equation}\]</span></p>
<p>由于任何一输入序列均可表示为加权延时单位取样响应的线性组合，即</p>
<p><span class="math display">\[\begin{equation}
x\left(n\right)=\sum_{k=-\infty}^{\infty}x\left(k\right)\delta\left(n-k\right)
\end{equation}\]</span></p>
<p>由此，线性时不变系统的输出可表示为</p>
<p><span class="math display">\[\begin{align}
  y\left(n\right)&amp;=T\left[x\left(n\right)\right]=T\left[\sum_{k=-\infty}^{\infty}x\left(k\right)\delta\left(n-k\right)\right]\\
  &amp;\xlongequal{\text{叠加性、均匀性}}\sum_{k=-\infty}^{\infty}{x\left(
k \right)}T\left[ \delta \left( n-k \right) \right]
\xlongequal{\text{非时变性}}\sum_{k=-\infty}^{\infty}{x\left( k
\right)}\text{h}\left( n-k \right)
\end{align}\]</span></p>
<p>故任何离散时间线性时不变系统，可以通过其单位取样响应 <span class="math inline">\(h\left(n\right)\)</span>
来<strong>完全表征</strong>。</p>
<h2 id="通过系统频率响应-hleftejomegaright-从频域表征系统">7.2.
通过系统频率响应 <span class="math inline">\(H\left(e^{j\omega}\right)\)</span>
从频域表征系统</h2>
<p>  离散时间系统的频率响应是由系统的结构参数决定的。当输入频率为 <span class="math inline">\(\omega\)</span>
的复指数序列时，其输出必仍为同一频率的、乘上因子 <span class="math inline">\(H\left(e^{j\omega}\right)\)</span>
的复指数序列。随着输入频率 <span class="math inline">\(\omega\)</span>
的不同，<span class="math inline">\(H\left(e^{j\omega}\right)\)</span>
的值也不同。因此系统的频率响应 <span class="math inline">\(H\left(e^{j\omega}\right)\)</span>
<strong>描述了系统对不同频率的复指数序列的不同传输能力</strong>。</p>
<h2 id="单位取样响应-hleftnright-和系统频率响应-hleftejomegaright-的关系-1">7.3.
单位取样响应 <span class="math inline">\(h\left(n\right)\)</span>
和系统频率响应 <span class="math inline">\(H\left(e^{j\omega}\right)\)</span> 的关系</h2>
<p>  令单位取样响应为 <span class="math inline">\(h\left(n\right)\)</span> 的线性时不变系统的输入
<span class="math inline">\(x\left(n\right)=Ae^{j\left(\omega
n+\varphi_x\right)}=Ae^{j\omega n}e^{j\varphi_x}\)</span>，则输出</p>
<p><span class="math display">\[\begin{equation}
y\left(n\right)=\sum_{k=-\infty}^{\infty}h\left(k\right)x\left(n-k\right)=\left[\sum_{k=-\infty}^{\infty}{h\left(k\right)e^{-j\omega
k}}\right]\cdot Ae^{j\left(\omega
n+\varphi_x\right)}=\left[\sum_{k=-\infty}^{\infty}{h\left(k\right)e^{-j\omega
k}}\right]\cdot x\left(n\right)
\end{equation}\]</span></p>
<p>则系统频率响应</p>
<p><span class="math display">\[\begin{equation}
H\left(e^{j\omega}\right)=\sum_{k=-\infty}^{\infty}{h\left(k\right)e^{-j\omega
k}}=\sum_{n=-\infty}^{\infty}{h\left(n\right)e^{-j\omega n}}
\end{equation}\]</span></p>
<p>即离散时间线性时不变系统的频率响应 <span class="math inline">\(H\left(e^{j\omega}\right)\)</span>
就是系统的单位取样响应 <span class="math inline">\(h\left(n\right)\)</span> 的傅氏变换，是 <span class="math inline">\(h\left(n\right)\)</span> 的频谱。</p>
<h1 id="共轭对称与共轭反对称">8. 共轭对称与共轭反对称</h1>
<h2 id="共轭对称">8.1. 共轭对称</h2>
<p>  若序列 <span class="math inline">\(x_e\left(n\right)=x_e^\ast(-n)\)</span>，则称
<span class="math inline">\(x_e\left(n\right)\)</span>
是共轭对称的序列，对实序列，又称为偶序列。</p>
<h2 id="共轭反对称">8.2. 共轭反对称</h2>
<p>  若序列 <span class="math inline">\(x_o\left(n\right)=-x_o^\ast(-n)\)</span>，则称
<span class="math inline">\(x_o\left(n\right)\)</span>
是共轭反对称的序列，对实序列，又称为奇序列。</p>
<h2 id="序列的对称性">8.3. 序列的对称性</h2>
<p>  若</p>
<p><span class="math display">\[\begin{equation}
x_e\left(n\right)=\frac{1}{2}\left[x\left(n\right)+x^\ast\left(-n\right)\right],\
x_o\left(n\right)=\frac{1}{2}\left[x\left(n\right)+x^\ast\left(-n\right)\right]
\end{equation}\]</span></p>
<p>则 <span class="math inline">\(x_e\left(n\right)、x_o\left(n\right)\)</span>
分别称为 <span class="math inline">\(x\left(n\right)\)</span>
的共轭对称序列和共轭反对称序列。显然，任意序列均可表示为该序列的共轭对称序列和共轭反对称序列的和，即</p>
<p><span class="math display">\[\begin{equation}
x\left(n\right)=x_e\left(n\right)+x_o\left(n\right)
\end{equation}\]</span></p>
<h2 id="傅里叶变换的共轭对称性">8.4. 傅里叶变换的共轭对称性</h2>
<p><span class="math display">\[\begin{equation}
X\left(e^{j\omega}\right)=X_e\left(e^{j\omega}\right)+X_o\left(e^{j\omega}\right)
\end{equation}\]</span></p>
<p><span class="math display">\[\begin{equation}
X_e\left(e^{j\omega}\right)=\frac{1}{2}\left[X\left(e^{j\omega}\right)+X^\ast\left(e^{j\omega}\right)\right],\
X_o\left(e^{j\omega}\right)=\frac{1}{2}\left[X\left(e^{j\omega}\right)-X^\ast\left(e^{j\omega}\right)\right]
\end{equation}\]</span></p>
<h1 id="傅里叶变换拉氏变换和-z-变换的关系">9. 傅里叶变换、拉氏变换和
<span class="math inline">\(z\)</span> 变换的关系</h1>
<figure>
<img data-src="../images/post/2023-04-14-josh-dsp-part-1/2023-04-14-josh-dsp-part-1-010-RelationshipBetweenTransform.png?imageMogr2/thumbnail/!100p%7Cwatermark/2/text/QEpvc2ggR2Fv/font/YWhyb25iZC50dGY=/fontsize/80/dissolve/20/gravity/southeast/dx/5/dy/5" width="600" alt="傅里叶变换、拉氏变换和 z 变换的关系">
<figcaption aria-hidden="true">傅里叶变换、拉氏变换和 <span class="math inline">\(z\)</span> 变换的关系</figcaption>
</figure>
<h1 id="参考文献">10. 参考文献</h1>
<p>王世一. <em>数字信号处理, 修订版.</em> 北京理工大学出版社, 1997.</p>
<p>其中</p>
<p><span class="math display">\[
c_m=\frac{1}{2l}\int_{-l}^{l}{f\left(x\right)e^{-jm\frac{x}{l}}\mathrm{d}x}
\]</span></p>
<p><span class="math display">\[P_\delta\left(t\right)=\frac{2\pi}{T}\sum_{m=-\infty}^{\infty}{\delta(\Omega-m\Omega_s)}
\]</span></p>
<p>与 <span class="math inline">\(x_a\left(t\right)\)</span>
的傅里叶变换 <span class="math inline">\(X_a\left(j\Omega\right)\)</span> 卷积后除以 <span class="math inline">\(2\pi\)</span> 也可得到相应结果。</p>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr>
<ol>
<li id="fn1"><p><span class="math inline">\(f\left( x \right)\)</span>
的以 <span class="math inline">\(2l\)</span>
为周期的傅氏级数的指数形式为 <span class="math display">\[
f\left(x\right)\sim\sum_{m=-\infty}^{\infty}{c_me^{jm\frac{x}{l}}}
\]</span><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>直接用 <span class="math inline">\(p_\delta\left(t\right)\)</span> 的傅里叶变换<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>即为周期方波的傅里叶变换。<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>《信号与系统（第四版）》（曾禹村等编著，北京理工大学出版社，2018）中对
<span class="math inline">\(\mathrm{sinc}\)</span>
函数的定义不准确，严格来说归一化的 <span class="math inline">\(\mathrm{sinc}\)</span>
函数（常在信号处理领域应用）定义为 <span class="math inline">\(\mathrm{sinc}\left(x\right)=\dfrac{\sin{\left(\pi
x\right)}}{\pi x}\)</span>，而非归一化的 <span class="math inline">\(\mathrm{sinc}\)</span>
函数（常用在数学领域）定义为 <span class="math inline">\(\mathrm{sinc}\left(x\right)=\dfrac{\sin{x}}{x}\)</span>。在信号处理中，为了区别归一化的
<span class="math inline">\(\mathrm{sinc}\)</span>
函数，定义取样函数（Sampling function）<span class="math inline">\(\mathrm{Sa}\left(x\right)=\dfrac{\sin{x}}{x}\)</span>，但二者并无本质区别。<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p>时域卷积定理：<span class="math inline">\(x\left(t\right)\ast
y\left(t\right)=X\left(j\Omega\right)\cdot
Y(j\Omega)\)</span>，频域卷积定理：<span class="math inline">\(x\left(t\right)\cdot
y\left(t\right)=\dfrac{1}{2\pi}X\left(j\Omega\right)\ast
Y(j\Omega)\)</span>。<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/css/markmap.css">

<script src="/js/markmap.js"></script>
]]></content>
      <categories>
        <category>Josh 的学习笔记</category>
        <category>数字信号处理</category>
      </categories>
      <tags>
        <tag>数字信号和处理</tag>
        <tag>DSP</tag>
        <tag>采样定理</tag>
        <tag>内插函数</tag>
        <tag>角频率</tag>
        <tag>单位取样响应</tag>
        <tag>系统频率响应</tag>
        <tag>共轭对称</tag>
      </tags>
  </entry>
  <entry>
    <title>Josh&#39;s Review — 数字信号处理&lt;br&gt;Part 2 离散傅里叶级数 DFS</title>
    <url>/posts/3345523e.html</url>
    <content><![CDATA[<h1 id="傅里叶变换的几种形式">1. 傅里叶变换的几种形式</h1>
<h2 id="非周期连续时间信号的傅里叶变换">1.1
非周期连续时间信号的傅里叶变换</h2>
<p>  非周期连续时间信号的傅里叶变换（连续时间傅里叶变换，Continuous-Time
Fourier Transform, CTFT）的形式为：</p>
<p><span class="math display">\[\begin{equation}
X_a\left(j\Omega\right)=\int_{-\infty}^{\infty}{x_a\left(t\right)e^{-j\Omega
t}\mathrm{d}t}
\end{equation}\]</span></p>
<p><span class="math display">\[\begin{equation}
x_a\left(t\right)=\frac{1}{2\pi}\int_{-\infty}^{\infty}{X_a\left(j\Omega\right)e^{j\Omega
t}\mathrm{d}\Omega}
\end{equation}\]</span></p>
<span id="more"></span>
<h2 id="周期连续时间信号的傅里叶变换">1.2
周期连续时间信号的傅里叶变换</h2>
<p>  周期连续时间信号的傅里叶变换（连续傅里叶级数，Continous Fourier
Series, CFS）的形式为：</p>
<p><span class="math display">\[\begin{equation}
X\left(m\Omega\right)=\frac{1}{t_p}\int_{-\frac{t_p}{2}}^{\frac{t_p}{2}}{x_a\left(t\right)e^{-jm\Omega
t}\mathrm{d}t}
\end{equation}\]</span></p>
<p><span class="math display">\[\begin{equation}
x_a\left(t\right)=\sum_{m=-\infty}^{\infty}{X\left(m\Omega\right)e^{jm\Omega
t}}
\end{equation}\]</span></p>
<p>其中 <span class="math inline">\(t_p\)</span>
为信号的周期，频域相邻谱线间角频率增量 <span class="math inline">\(\Omega=\dfrac{2\pi}{t_p}\)</span>。</p>
<h2 id="非周期离散时间信号的傅里叶变换">1.3
非周期离散时间信号的傅里叶变换</h2>
<p>  非周期离散时间信号的傅里叶变换（离散时间傅里叶变换，Discrete-Time
Fourier Transform, DTFT）的形式为：</p>
<p><span class="math display">\[\begin{equation}
X\left(e^{j\omega}\right)=\sum_{n=-\infty}^{\infty}{x\left(n\right)e^{-j\omega
n}}
\end{equation}\]</span></p>
<p><span class="math display">\[\begin{equation}
x\left(n\right)=\frac{1}{2\pi}\int_{-\pi}^{\pi}{X\left(e^{j\omega}\right)e^{j\omega
n}\mathrm{d}\omega}
\end{equation}\]</span></p>
<p>取样频率 <span class="math inline">\(f_s=\dfrac{1}{T}\)</span>，取样角频率 <span class="math inline">\(\Omega_s=\dfrac{2\pi}{T}\)</span>，取样数字频率<span class="math inline">\(\omega_s=2\pi\)</span>。</p>
<h2 id="周期离散时间信号的傅里叶变换">1.4
周期离散时间信号的傅里叶变换</h2>
<p>  周期离散时间信号的傅里叶变换（离散傅里叶级数，Discrete Fourier
Series, DFS）的形式为：</p>
<p><span class="math display">\[\begin{equation}
\widetilde{X}\left(k\right)=\left.\widetilde{X}\left(e^{j\omega}\right)\right|_{\omega=k\frac{2\pi}{N}}=\sum_{n=0}^{N-1}{\widetilde{x}\left(n\right)e^{-j\frac{2\pi}{N}kn}}=\sum_{n=0}^{N-1}{\widetilde{x}\left(n\right)W_N^{kn}}
\end{equation}\]</span></p>
<p><span class="math display">\[\begin{equation}
\widetilde{x}\left(n\right)=\frac{1}{N}\sum_{k=0}^{N-1}{\widetilde{X}\left(k\right)e^{j\frac{2\pi}{N}kn}}=\frac{1}{N}\sum_{k=0}^{N-1}{\widetilde{X}\left(k\right)W_N^{-kn}}
\end{equation}\]</span></p>
<p>其中 <span class="math inline">\(N\)</span>
为一个周期内的点数，时域相邻谱线间隔为 <span class="math inline">\(T\)</span> ，频域相邻谱线间隔为 <span class="math inline">\(\dfrac{1}{NT}\)</span>，以数字频率表征时为 <span class="math inline">\(\dfrac{2\pi}{N}\)</span>。</p>
<blockquote>
<p><strong>由以上，在一个域中对函数进行取样，两取样点间增量的倒数，必是另一个域中的周期。</strong></p>
</blockquote>
<h1 id="离散傅里叶级数dfs的推导">2. 离散傅里叶级数（DFS）的推导</h1>
<h2 id="正变换">2.1 正变换</h2>
<p>  令 <span class="math inline">\(x\left(n\right)\)</span> 为 <span class="math inline">\(N\)</span> 点长的离散序列，则其
DTFT（上标“~”用来表征周期性）</p>
<p><span class="math display">\[\begin{equation}
\widetilde{X}\left(e^{j\omega}\right)=\sum_{n=-\infty}^{\infty}{x\left(n\right)e^{-j\omega
n}}=\sum_{n=0}^{N-1}{x\left(n\right)e^{-j\omega n}}
\end{equation}\]</span></p>
<p>对 <span class="math inline">\(\widetilde{X}\left(e^{j\omega}\right)\)</span>
取样，使其称为周期离散频率函数，由此时域序列 <span class="math inline">\(x\left(n\right)\)</span> 周期化为 <span class="math inline">\(\widetilde{x}\left(n\right)\)</span>，令其谱线间隔为
<span class="math inline">\(T\)</span>，则时域序列的周期为 <span class="math inline">\(NT\)</span>，所以对频谱取样的谱间距为 <span class="math inline">\(\dfrac{1}{NT}\)</span>，以数字频率表征时，谱间距</p>
<p><span class="math display">\[\begin{equation}
\omega_\mathrm{I}=\frac{2\pi}{N}
\end{equation}\]</span></p>
<p>因此，以数字频率 <span class="math inline">\(\omega\)</span> 为变量的
<span class="math inline">\(X\left(e^{j\omega}\right)\)</span>
被离散化时，其变量 <span class="math inline">\(\omega\)</span> 变为</p>
<p><span class="math display">\[\begin{equation}
\omega=k\omega_\mathrm{I}=k\frac{2\pi}{N}
\end{equation}\]</span></p>
<p>因此离散周期序列 <span class="math inline">\(\widetilde{x}\left(n\right)\)</span>
的傅里叶级数可写为</p>
<p><span class="math display">\[\begin{equation}
\widetilde{X}\left(k\right)=\left.\widetilde{X}\left(e^{j\omega}\right)\right|_{\omega=k\frac{2\pi}{N}}=\sum_{n=0}^{N-1}{\widetilde{x}\left(n\right)e^{-j\frac{2\pi}{N}kn}}=\sum_{n=0}^{N-1}{\widetilde{x}\left(n\right)W_N^{kn}}
\end{equation}\]</span></p>
<p>并将数字域频率用 <span class="math inline">\(k\)</span>
简化表示。且</p>
<p><span class="math display">\[\begin{equation}
\widetilde{X}\left(k+N\right)=\sum_{n=0}^{N-1}{\widetilde{x}\left(n\right)e^{-j\frac{2\pi}{N}\left(k+N\right)n}}=\sum_{n=0}^{N-1}{\widetilde{x}\left(n\right)e^{-j2\pi
n}e^{-j\frac{2\pi}{N}kn}=}\sum_{n=0}^{N-1}{\widetilde{x}\left(n\right)e^{-j\frac{2\pi}{N}kn}=}\widetilde{X}\left(k\right)
\end{equation}\]</span></p>
<p>即 <span class="math inline">\(\widetilde{X}\left(k\right)\)</span>
是以 <span class="math inline">\(N\)</span> 为周期的周期函数。</p>
<h2 id="逆变换">2.2 逆变换</h2>
<p>  将正变换两边乘以 <span class="math inline">\(e^{j\frac{2\pi}{N}kr}\)</span>，并在一个周期内求和，有</p>
<p><span class="math display">\[\begin{equation}
\sum_{k=0}^{N-1}{\widetilde{X}\left(k\right)e^{j\frac{2\pi}{N}kr}}=\sum_{k=0}^{N-1}{\left(\sum_{n=0}^{N-1}{\widetilde{x}\left(n\right)e^{-j\frac{2\pi}{N}kn}}\right)e^{j\frac{2\pi}{N}kr}}=N\left[\sum_{n=0}^{N-1}{\widetilde{x}\left(n\right)\left(\frac{1}{N}\sum_{k=0}^{N-1}e^{j\frac{2\pi}{N}k\left(r-n\right)}\right)}\right]
\end{equation}\]</span></p>
<p>由正交定理</p>
<p><span class="math display">\[\begin{equation}
\frac{1}{N}\sum_{k=0}^{N-1}e^{j\frac{2\pi}{N}k\left(r-n\right)}=
\begin{aligned}
\begin{cases}
1,&amp;r=n\\
0,&amp;r≠n
\end{cases}
\end{aligned}
\end{equation}\]</span></p>
<p>则</p>
<p><span class="math display">\[\begin{equation}
\sum_{k=0}^{N-1}{\widetilde{X}\left(k\right)e^{j\frac{2\pi}{N}kr}}=N\left.\left[\sum_{n=0}^{N-1}{\widetilde{x}\left(n\right)}\right]\right|_{n=r}=N\widetilde{x}\left(r\right)
\end{equation}\]</span></p>
<p>可得逆离散傅里叶变换</p>
<p><span class="math display">\[\begin{equation}
\widetilde{x}\left(n\right)=\frac{1}{N}\sum_{k=0}^{N-1}{\widetilde{X}\left(k\right)e^{j\frac{2\pi}{N}kn}}=\frac{1}{N}\sum_{k=0}^{N-1}{\widetilde{X}\left(k\right)W_N^{-kn}}
\end{equation}\]</span></p>
<p>且</p>
<p><span class="math display">\[\begin{equation}
\widetilde{x}\left(n+mN\right)=\frac{1}{N}\sum_{k=0}^{N-1}{\widetilde{X}\left(k\right)e^{j\frac{2\pi}{N}k\left(n+mN\right)}}=\frac{1}{N}\sum_{k=0}^{N-1}{\widetilde{X}\left(k\right)e^{j\frac{2\pi}{N}kn}e^{j2\pi
km}}=\widetilde{x}\left(n\right)
\end{equation}\]</span></p>
<p>即 <span class="math inline">\(\widetilde{x}\left(n\right)\)</span>
是以 <span class="math inline">\(N\)</span> 为周期的周期函数。</p>
<h1 id="离散傅里叶级数dfs的性质">3. 离散傅里叶级数（DFS）的性质</h1>
<h2 id="线性性质">3.1 线性性质</h2>
<p><span class="math display">\[\begin{equation}
\mathrm{DFS}\left[a{\widetilde{x}}_1\left(n\right)+{b\widetilde{x}}_2\left(n\right)\right]=a{\widetilde{X}}_1\left(k\right)+b{\widetilde{X}}_2\left(k\right)
\end{equation}\]</span></p>
<h2 id="时移性质">3.2 时移性质</h2>
<p><span class="math display">\[\begin{equation}
\mathrm{DFS}\left[\widetilde{x}\left(n+m\right)\right]=W_N^{-mk}\widetilde{X}\left(k\right)
\end{equation}\]</span></p>
<p>证明：</p>
<p><span class="math display">\[\begin{equation}
\begin{aligned}
\mathrm{DFS}\left[\widetilde{x}\left(n+m\right)\right]&amp;=\sum_{n=0}^{N-1}{\widetilde{x}\left(n+m\right)W_N^{nk}}=\sum_{n=m}^{N-1+m}{\widetilde{x}\left(n\right)W_N^{\left(n-m\right)k}}=\sum_{n=m}^{N-1+m}{\widetilde{x}\left(n\right)W_N^{nk}W_N^{-mk}}
\\
&amp;\xlongequal{利用\widetilde{x}\left(n\right)和W_N^{nk}的周期性}\left(\sum_{n=0}^{N-1}{\widetilde{x}\left(n\right)W_N^{nk}}\right)W_N^{-mk}=W_N^{-mk}\widetilde{X}\left(k\right)
\end{aligned}
\end{equation}\]</span></p>
<h2 id="频移性质">3.3 频移性质</h2>
<p><span class="math display">\[\begin{equation}
\mathrm{IDFS}\left[\widetilde{X}\left(k+l\right)\right]=W_N^{nl}\widetilde{x}\left(n\right)
\end{equation}\]</span></p>
<p>证明：</p>
<p><span class="math display">\[\begin{equation}
\begin{aligned}
\mathrm{IDFS}\left[\widetilde{X}\left(k+l\right)\right]&amp;=\frac{1}{N}\sum_{k=0}^{N-1}{\widetilde{X}\left(k+l\right)W_N^{-kn}}=\frac{1}{N}\sum_{k=l}^{N-1+l}{\widetilde{X}\left(k\right)W_N^{-\left(k-l\right)n}}=\frac{1}{N}\sum_{k=l}^{N-1+l}{\widetilde{X}\left(k\right)W_N^{-kn}W_N^{nl}}
\\
&amp;\xlongequal{利用\widetilde{X}\left(n\right)和W_N^{-nk}的周期性}\frac{1}{N}\left(\sum_{k=0}^{N-1}{\widetilde{X}\left(k\right)W_N^{-kn}}\right)W_N^{nl}=W_N^{nl}\widetilde{x}\left(n\right)
\end{aligned}
\end{equation}\]</span></p>
<h2 id="时域周期卷积">3.4 时域周期卷积</h2>
<p><span class="math display">\[\begin{equation}
{\widetilde{x}}_1\left(n\right)\odot{\widetilde{x}}_2\left(n\right)=\mathrm{IDFS}\left[{\widetilde{X}}_1\left(k\right)\cdot{\widetilde{X}}_2\left(k\right)\right]
\end{equation}\]</span></p>
<p>证明：</p>
<p><span class="math display">\[\begin{equation}
\begin{aligned}
\mathrm{IDFS}\left[{\widetilde{X}}_1\left(k\right)\cdot{\widetilde{X}}_2\left(k\right)\right]&amp;=\frac{1}{N}\sum_{k=0}^{N-1}{\left[{\widetilde{X}}_1\left(k\right)\cdot{\widetilde{X}}_2\left(k\right)\right]W_N^{-nk}}\\
&amp;=\frac{1}{N}\sum_{k=0}^{N-1}{\left[\sum_{m=0}^{N-1}{\widetilde{x}}_1\left(m\right)W_N^{mk}\right]{\widetilde{X}}_2\left(k\right)W_N^{-nk}}\\
&amp;=\frac{1}{N}\sum_{k=0}^{N-1}\left[\sum_{m=0}^{N-1}{\widetilde{x}}_1\left(m\right){\widetilde{X}_2\left(k\right)W}_N^{-\left(n-m\right)k}\right]\\
&amp;=\sum_{m=0}^{N-1}{\widetilde{x}}_1\left(m\right)\left[\frac{1}{N}\sum_{k=0}^{N-1}{\widetilde{X}_2\left(k\right)W}_N^{-\left(n-m\right)k}\right]\\
&amp;=\sum_{m=0}^{N-1}{\widetilde{x}}_1\left(m\right){\widetilde{x}}_2\left(n-m\right)
\\
&amp;={\widetilde{x}}_1\left(n\right)\odot{\widetilde{x}}_2\left(n\right)
\end{aligned}
\end{equation}\]</span></p>
<blockquote>
<p>注：此处用 <span class="math inline">\(\odot\)</span>
表示圆周卷积，不同教材中圆周卷积的符号表述可能不同。</p>
</blockquote>
<h2 id="频域周期卷积">3.5 频域周期卷积</h2>
<p><span class="math display">\[\begin{equation}
\mathrm{DFS}\left[{\widetilde{x}}_1\left(n\right){\widetilde{x}}_2\left(n\right)\right]=\frac{1}{N}\left[{\widetilde{X}}_1\left(k\right)\odot{\widetilde{X}}_2\left(k\right)\right]
\end{equation}\]</span></p>
<p>证明：</p>
<p><span class="math display">\[\begin{equation}
\begin{aligned}
\mathrm{DFS}\left[{\widetilde{x}}_1\left(n\right){\widetilde{x}}_2\left(n\right)\right]&amp;=\sum_{n=0}^{N-1}{\widetilde{X}_1\left(n\right){\widetilde{x}}_2\left(n\right)W_N^{kn}}=\sum_{n=0}^{N-1}\left[\frac{1}{N}\sum_{r=0}^{N-1}{\widetilde{X}_1\left(r\right)W_N^{-rn}}\right]{\widetilde{x}}_2\left(n\right)W_N^{kn}\\
&amp;=\frac{1}{N}\sum_{n=0}^{N-1}\left[\sum_{r=0}^{N-1}{\widetilde{X}_1\left(r\right){\widetilde{x}}_2\left(n\right)W_N^{\left(k-r\right)n}}\right]\\
&amp;=\frac{1}{N}\sum_{r=0}^{N-1}{\widetilde{X}}_1\left(r\right)\left[\sum_{k=0}^{N-1}{\widetilde{X}_2\left(n\right)W_N^{\left(k-r\right)n}}\right]\\
&amp;=\frac{1}{N}\sum_{r=0}^{N-1}{\widetilde{X}}_1\left(r\right){\widetilde{X}}_2\left(k-r\right)\\
&amp;=\frac{1}{N}\left[{\widetilde{X}}_1\left(k\right)\odot{\widetilde{X}}_2\left(k\right)\right]
\end{aligned}
\end{equation}\]</span></p>
<blockquote>
<p>注：此处用 <span class="math inline">\(\odot\)</span>
表示圆周卷积，不同教材中圆周卷积的符号表述可能不同。</p>
</blockquote>
<h1 id="参考文献">参考文献</h1>
<p>王世一. <em>数字信号处理, 修订版.</em> 北京理工大学出版社, 1997.</p>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/css/markmap.css">

<script src="/js/markmap.js"></script>
]]></content>
      <categories>
        <category>Josh 的学习笔记</category>
        <category>数字信号处理</category>
      </categories>
      <tags>
        <tag>数字信号和处理</tag>
        <tag>DSP</tag>
        <tag>共轭对称</tag>
        <tag>离散傅里叶级数</tag>
        <tag>DFS</tag>
        <tag>连续时间傅里叶变换</tag>
        <tag>连续傅里叶级数</tag>
        <tag>离散时间傅里叶变换</tag>
        <tag>DTFT</tag>
        <tag>圆周卷积</tag>
        <tag>周期卷积</tag>
      </tags>
  </entry>
  <entry>
    <title>Josh&#39;s Review — 数字信号处理&lt;br&gt;Part 3 离散傅里叶变换 DFT</title>
    <url>/posts/fd9f9a29.html</url>
    <content><![CDATA[<h1 id="离散傅里叶变换discrete-fourier-transform-dft的定义">1.
离散傅里叶变换（Discrete Fourier Transform, DFT）的定义</h1>
<p>  取离散傅里叶级数的主值，得离散傅里叶变换</p>
<p><span class="math display">\[\begin{equation}
X\left(k\right)=\widetilde{X}\left(k\right)R_N\left(k\right)=\sum_{n=0}^{N-1}{x\left(n\right)W_N^{kn}},\
\ k=0,1,\cdots,N-1
\end{equation}\]</span></p>
<p><span class="math display">\[\begin{equation}
x\left(n\right)=\widetilde{x}\left(n\right)R_N\left(n\right)=\frac{1}{N}\sum_{k=0}^{N-1}{X\left(k\right)W_N^{-kn}},\
\ n=0,1,\cdots,N-1
\end{equation}\]</span></p>
<p>且 <span class="math inline">\(\widetilde{X}\left(k\right)=X\left(\left(k\right)\right)_N,\widetilde{x}\left(n\right)=x\left(\left(n\right)\right)_N\)</span>。其中
<span class="math inline">\(R_N\left(n\right)\)</span>
表示矩形序列，表示取主值；<span class="math inline">\(\left(\left(n\right)\right)_N\)</span> 表示 <span class="math inline">\(n\)</span> 对 <span class="math inline">\(N\)</span> 取余。</p>
<blockquote>
<p>注：不同教材中取主值、取余的符号表述可能不同。</p>
</blockquote>
<span id="more"></span>
<h1 id="dft-的矩阵算法">2. DFT 的矩阵算法</h1>
<p>  若令 <span class="math inline">\(X=\left[\begin{matrix}X\left(0\right),X\left(1\right),\cdots,X\left(N-1\right)\\\end{matrix}\right]^\mathrm{T}\)</span>，<span class="math inline">\(x=\left[\begin{matrix}x\left(0\right),x\left(1\right),\cdots,x\left(N-1\right)\\\end{matrix}\right]^\mathrm{T}\)</span>，则
DFT 和 IDFT 可分别表示为</p>
<p><span class="math display">\[\begin{equation}
X=D_Nx,\ \ x=D_N^{-1}X
\end{equation}\]</span></p>
<p>其中 Vandermonde 矩阵</p>
<p><span class="math display">\[\begin{equation}
D_N=\left[\begin{matrix}1&amp;1&amp;1&amp;\cdots&amp;1\\1&amp;W_N^1&amp;W_N^2&amp;\cdots&amp;W_N^{\left(N-1\right)}\\1&amp;W_N^2&amp;W_N^4&amp;\cdots&amp;W_N^{2\left(N-1\right)}\\\vdots&amp;\vdots&amp;\vdots&amp;&amp;\vdots\\1&amp;W_N^{\left(N-1\right)}&amp;W_N^{2\left(N-1\right)}&amp;\cdots&amp;W_N^{\left(N-1\right)^2}\\\end{matrix}\right]
\end{equation}\]</span></p>
<p><span class="math display">\[\begin{equation}
D_N^{-1}=\frac{1}{N}\left[\begin{matrix}1&amp;1&amp;1&amp;\cdots&amp;1\\1&amp;W_N^{-1}&amp;W_N^{-2}&amp;\cdots&amp;W_N^{-\left(N-1\right)}\\1&amp;W_N^{-2}&amp;W_N^{-4}&amp;\cdots&amp;W_N^{-2\left(N-1\right)}\\\vdots&amp;\vdots&amp;\vdots&amp;&amp;\vdots\\1&amp;W_N^{-\left(N-1\right)}&amp;W_N^{-2\left(N-1\right)}&amp;\cdots&amp;W_N^{-\left(N-1\right)^2}\\\end{matrix}\right]
\end{equation}\]</span></p>
<p>且有 <span class="math inline">\(D_N^{-1}=\dfrac{1}{N}D_N^\ast\)</span>。</p>
<h1 id="离散傅里叶变换dft的性质">3. 离散傅里叶变换（DFT）的性质</h1>
<h2 id="线性性质">3.1 线性性质</h2>
<p><span class="math display">\[\begin{equation}
\mathrm{DFT}\left[ax_1\left(n\right)+{bx}_2\left(n\right)\right]=aX_1\left(k\right)+bX_2\left(k\right)
\end{equation}\]</span></p>
<h2 id="用正变换计算逆变换">3.2 用正变换计算逆变换</h2>
<p><span class="math display">\[\begin{equation}
x\left(n\right)=\frac{1}{N}\left[\sum_{k=0}^{N-1}{X^\ast\left(k\right)W_N^{nk}}\right]^\ast,\
\ n=0,1,\cdots,N-1
\end{equation}\]</span></p>
<p>证明：</p>
<p><span class="math display">\[\begin{equation}
\frac{1}{N}\left[\sum_{k=0}^{N-1}{X^\ast\left(k\right)W_N^{nk}}\right]^\ast=\frac{1}{N}\left[\sum_{k=0}^{N-1}{X\left(k\right)W_N^{-nk}}\right]=x\left(n\right)
\end{equation}\]</span></p>
<h2 id="对称定理">3.3 对称定理</h2>
<p><span class="math display">\[\begin{equation}
\mathrm{DFT}\left[\frac{1}{N}X\left(n\right)\right]=x\left(-k\right)=x\left(N-k\right)
\end{equation}\]</span></p>
<p>证明：</p>
<p><span class="math display">\[\begin{align}
&amp;x\left(-n\right)=x\left(N-n\right)=\frac{1}{N}\sum_{k=0}^{N-1}{X\left(k\right)W_N^{-\left(N-n\right)k}}=\frac{1}{N}\sum_{k=0}^{N-1}{X\left(k\right)W_N^{nk}}
\\
\Longrightarrow
&amp;x\left(-k\right)=x\left(N-k\right)=\sum_{n=0}^{N-1}{\left[\frac{X\left(n\right)}{N}\right]W_N^{kn}}=\mathrm{DFT}\left[\frac{X\left(n\right)}{N}\right]
\end{align}\]</span></p>
<h2 id="反转定理">3.4 反转定理</h2>
<p><span class="math display">\[\begin{equation}
\mathrm{DFT}\left[x\left(-n\right)\right]=X\left(-k\right)
\end{equation}\]</span></p>
<p>证明：</p>
<p><span class="math display">\[\begin{equation}
\mathrm{DFT}\left[x\left(-n\right)\right]=\sum_{n=0}^{N-1}{x\left(-n\right)W_N^{nk}}\xlongequal{令m=-n}\sum_{m=-\left(N-1\right)}^{0}{x\left(m\right)W_N^{-mk}}=\sum_{m=0}^{N-1}{x\left(m\right)W_N^{m\cdot\left(-k\right)}}=X\left(-k\right)
\end{equation}\]</span></p>
<h2 id="序列的总和">3.5 序列的总和</h2>
<p><span class="math display">\[\begin{equation}
\sum_{n=0}^{N-1}x\left(n\right)=\left.\sum_{n=0}^{N-1}{x\left(n\right)W_N^{kn}}\right|_{k=0}\left.=X\left(k\right)\right|_{k=0}=X\left(0\right)
\end{equation}\]</span></p>
<h2 id="序列的起始值">3.6 序列的起始值</h2>
<p><span class="math display">\[\begin{equation}
x\left(0\right)=\frac{1}{N}\left.\sum_{k=0}^{N-1}{X\left(k\right)W_N^{-kn}}\right|_{n=0}=\frac{1}{N}\sum_{k=0}^{N-1}X\left(k\right)
\end{equation}\]</span></p>
<h2 id="延长序列的-dft">3.7 延长序列的 DFT</h2>
<p>  将 <span class="math inline">\(N\)</span> 点长序列 <span class="math inline">\(x\left(n\right)\left(n=1,2,\cdots,N-1\right)\)</span>
补零延长 <span class="math inline">\(rN\)</span> 点得到序列 <span class="math inline">\(g\left(n\right)\)</span>，即</p>
<p><span class="math display">\[\begin{equation}
g\left(n\right)=
\begin{cases}
x(n),&amp;n=0,1,⋯,N-1\\
0,&amp;n=N,N+1,⋯rN-1
\end{cases}
\end{equation}\]</span></p>
<p>则 <span class="math inline">\(g\left(n\right)\)</span> 的 DFT</p>
<p><span class="math display">\[\begin{align}
G\left(k\right)&amp;=\mathrm{DFT}\left[g\left(n\right)\right]=\sum_{n=0}^{rN-1}{g\left(n\right)e^{-j\frac{2\pi
nk}{rN}}}=\sum_{n=0}^{N-1}{g\left(n\right)e^{-j\frac{2\pi
n\left(\frac{k}{r}\right)}{N}}}
\\
&amp;=X\left(\frac{k}{r}\right),\ \ k=0,1,\cdots,rN-1\
\end{align}\]</span></p>
<p>由此，<strong><span class="math inline">\(G\left(k\right)\)</span> 与
<span class="math inline">\(X\left(k\right )\)</span>具有相同的形状，但
<span class="math inline">\(G\left(k\right)\)</span> 的频谱间隔比 <span class="math inline">\(X\left(k\right)\)</span> 的小。即
<mark class="label primary">通过补零，频谱变得更加细致。但是补零不能提高频谱分辨能力。</mark></strong></p>
<h2 id="有限长序列的圆周特性">3.8 有限长序列的圆周特性</h2>
<h3 id="圆周移位周期化移位取主值">3.8.1
圆周移位（周期化→移位→取主值）</h3>
<p><span class="math display">\[\begin{equation}
x\left(\left(n-m\right)\right)_NR_N\left(n\right)=
\begin{cases}
x\left(n-m\right),&amp;m\leqslant n\leqslant N-1
\\
x\left(N-m+n\right),&amp;0\leqslant n\leqslant m
\end{cases}
\end{equation}\]</span></p>
<h3 id="圆周反转周期化反转取主值">3.8.2
圆周反转（周期化→反转→取主值）</h3>
<p><span class="math display">\[\begin{equation}
x\left(\left(-n\right)\right)_NR_N\left(n\right)=
\begin{cases}
x\left(0\right),&amp;n=0
\\
x\left(N-n\right),&amp;1\leqslant n\leqslant N-1
\end{cases}
\end{equation}\]</span></p>
<h3 id="有限长序列的时间圆周移位定理可以通过-dfs-证明">3.8.3
有限长序列的时间圆周移位定理（可以通过 DFS 证明）</h3>
<p><span class="math display">\[\begin{equation}
\mathrm{DFT}\left[x\left(\left(n+m\right)\right)_NR_N\left(n\right)\right]=W_N^{-mk}X\left(k\right)
\end{equation}\]</span></p>
<p>由此，<strong>有限长序列的圆周移位导致频谱线性相移，而对频谱幅度无影响</strong>。</p>
<h3 id="限长序列的频率圆周移位定理调制特性可以通过-dfs-证明">3.8.4
限长序列的频率圆周移位定理（调制特性，可以通过 DFS 证明）</h3>
<p><span class="math display">\[\begin{equation}
\mathrm{IDFT}\left[X\left(\left(k+l\right)\right)_NR_N\left(k\right)\right]=W_N^{nl}x\left(n\right)=e^{-j\frac{2\pi}{N}nl}x\left(n\right)
\end{equation}\]</span></p>
<p>由此，<strong>时域序列的调制等效于频域的圆周移位</strong>，且可以推得</p>
<p><span class="math display">\[\begin{equation}
\mathrm{DFT}\left[x\left(n\right)\cos{\left(\frac{2\pi
nl}{N}\right)}\right]=\frac{1}{2}\left[X\left(\left(k-l\right)\right)_N+X\left(\left(k+l\right)\right)_N\right]R_N\left(k\right)
\end{equation}\]</span></p>
<p><span class="math display">\[\begin{equation}
\mathrm{DFT}\left[x\left(n\right)\sin{\left(\frac{2\pi
nl}{N}\right)}\right]=\frac{1}{2}\left[X\left(\left(k-l\right)\right)_N-X\left(\left(k+l\right)\right)_N\right]R_N\left(k\right)
\end{equation}\]</span></p>
<h3 id="dft的圆周对称性">3.8.5 DFT的圆周对称性</h3>
<h4 id="奇序列和偶序列的-dft">3.8.5.1 奇序列和偶序列的 DFT</h4>
<p>奇序列的 DFT</p>
<p><span class="math display">\[\begin{equation}
x\left(n\right)=-x\left(-n\right)=-x\left(\left(-n\right)\right)_NR_N\left(n\right)\rightarrow
X\left(k\right)=-X\left(-k\right)=-X\left(\left(N-k\right)\right)_NR_N\left(k\right)
\end{equation}\]</span></p>
<p>偶序列的 DFT</p>
<p><span class="math display">\[\begin{equation}
x\left(n\right)=x\left(-n\right)=x\left(\left(-n\right)\right)_NR_N\left(n\right)\rightarrow
X\left(k\right)=X\left(-k\right)=X\left(\left(N-k\right)\right)_NR_N\left(k\right)
\end{equation}\]</span></p>
<h4 id="序列的对称分解">3.8.5.2 序列的对称分解</h4>
<p>  普通序列 <span class="math inline">\(x\left(n\right)\)</span>
的共轭对称分量和共轭反对称分量分别为</p>
<p><span class="math display">\[\begin{equation}
x_e\left(n\right)=\frac{1}{2}\left[x\left(n\right)+x^\ast\left(-n\right)\right],\
\
x_o\left(n\right)=\frac{1}{2}\left[x\left(n\right)-x^\ast\left(-n\right)\right]
\end{equation}\]</span></p>
<p>对有限长序列的 DFT
进行分析时，定义周期共轭对称分量和周期共轭反对称分量分别为</p>
<p><span class="math display">\[\begin{equation}
x_{ep}\left(n\right)=\frac{1}{2}\left[x\left(\left(n\right)\right)_N+x^\ast\left(\left(-n\right)\right)_N\right]R_N\left(n\right)=\frac{1}{2}\left[x\left(n\right)+x^\ast\left(N-n\right)\right]
\end{equation}\]</span></p>
<p><span class="math display">\[\begin{equation}
x_{op}\left(n\right)=\frac{1}{2}\left[x\left(\left(n\right)\right)_N-x^\ast\left(\left(-n\right)\right)_N\right]R_N\left(n\right)=\frac{1}{2}\left[x\left(n\right)-x^\ast\left(N-n\right)\right]
\end{equation}\]</span></p>
<p>二者关系为</p>
<p><span class="math display">\[\begin{equation}
x_{ep}\left(n\right)=\left[x_e\left(n\right)+x_e\left(n-N\right)\right]R_N\left(n\right),\
\
x_{op}\left(n\right)=\left[x_o\left(n\right)+x_o\left(n-N\right)\right]R_N\left(n\right)
\end{equation}\]</span></p>
<p><a id="3.8.5.3"></a></p>
<h4 id="共轭复序列的-dft">3.8.5.3 共轭复序列的 DFT</h4>
<p><span class="math display">\[\begin{equation}
\mathrm{DFT}\left[x^\ast\left(n\right)\right]=X^\ast\left(\left(N-k\right)\right)_N
\end{equation}\]</span></p>
<p><span class="math display">\[\begin{equation}
\mathrm{DFT}\left[x^\ast\left(-n\right)\right]=X^\ast\left(k\right)
\end{equation}\]</span></p>
<p>证明：</p>
<p><span class="math display">\[\begin{equation}
\mathrm{DFT}\left[x^\ast\left(n\right)\right]=\sum_{n=0}^{N-1}{x^\ast\left(n\right)W_N^{kn}}=\left[\sum_{n=0}^{N-1}{x\left(n\right)W_N^{-kn}}\right]^\ast=X^\ast\left(-k\right)=X^\ast\left(\left(N-k\right)\right)_N
\end{equation}\]</span></p>
<p><span class="math display">\[\begin{align}
\mathrm{DFT}\left[x^\ast\left(-n\right)\right]&amp;=\sum_{n=0}^{N-1}{x^\ast\left(-n\right)W_N^{kn}}=\left[\sum_{n=0}^{N-1}{x\left(-n\right)W_N^{-kn}}\right]^\ast
\\
&amp;=\left[\sum_{m=-N+1}^{0}{x\left(m\right)W_N^{km}}\right]^\ast=\left[\sum_{n=0}^{N-1}{x\left(n\right)W_N^{kn}}\right]^\ast=X^\ast\left(k\right)
\end{align}\]</span></p>
<p><a id="3.8.5.4"></a></p>
<h4 id="复数序列的-dft">3.8.5.4 复数序列的 DFT</h4>
<p><span class="math display">\[\begin{equation}
x\left(n\right)=x_r\left(n\right)+jx_i\left(n\right)
\end{equation}\]</span></p>
<p><span class="math display">\[\begin{equation}
\quad\quad\quad\updownarrow\qquad\quad \updownarrow
\end{equation}\]</span></p>
<p><span class="math display">\[\begin{equation}
X\left(k\right)=X_{ep}\left(k\right)+X_{op}\left(k\right)
\end{equation}\]</span></p>
<p>证明：</p>
<p><span class="math display">\[\begin{equation}
X_{ep}\left(k\right)=\mathrm{DFT}\left[x_r\left(n\right)\right]=\frac{1}{2}\mathrm{DFT}\left[x\left(n\right)+x^\ast\left(n\right)\right]=\frac{1}{2}\left[X\left(k\right)+X^\ast\left(N-k\right)\right]
\end{equation}\]</span></p>
<p><span class="math display">\[\begin{equation}
X_{op}\left(k\right)=\mathrm{DFT}\left[{jx}_i\left(n\right)\right]=\frac{1}{2}\mathrm{DFT}\left[x\left(n\right)-x^\ast\left(n\right)\right]=\frac{1}{2}\left[X\left(k\right)+X^\ast\left(N-k\right)\right]
\end{equation}\]</span></p>
<p>且由 <a href="#3.8.5.3">3.8.5.3 共轭复序列的 DFT</a> 可推知</p>
<p><span class="math display">\[\begin{equation}
X_{ep}\left(k\right)=X_{ep}^\ast\left(N-k\right)\ \ \
(实部相等，虚部相反)
\end{equation}\]</span></p>
<p><span class="math display">\[\begin{equation}
X_{op}\left(k\right)=-X_{op}^\ast\left(N-k\right)(实部相反，虚部相等)
\end{equation}\]</span></p>
<h4 id="dft-的奇偶虚实特性">3.8.5.5 DFT 的奇偶虚实特性</h4>
<table>
<thead>
<tr>
<th style="text-align: center;"><span class="math inline">\(x(n)\)</span></th>
<th style="text-align: center;"><span class="math inline">\(X(k)\)</span></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">偶</td>
<td style="text-align: center;">偶</td>
</tr>
<tr>
<td style="text-align: center;">奇</td>
<td style="text-align: center;">奇</td>
</tr>
<tr>
<td style="text-align: center;">实</td>
<td style="text-align: center;">实部为偶，虚部为奇</td>
</tr>
<tr>
<td style="text-align: center;">虚</td>
<td style="text-align: center;">实部为奇，虚部为偶</td>
</tr>
<tr>
<td style="text-align: center;">实偶</td>
<td style="text-align: center;">实偶</td>
</tr>
<tr>
<td style="text-align: center;">实奇</td>
<td style="text-align: center;">虚奇</td>
</tr>
<tr>
<td style="text-align: center;">虚偶</td>
<td style="text-align: center;">虚偶</td>
</tr>
<tr>
<td style="text-align: center;">虚奇</td>
<td style="text-align: center;">实奇</td>
</tr>
</tbody>
</table>
<h3 id="圆周卷积定理">3.8.6 圆周卷积定理</h3>
<blockquote>
<p>注：此处用 <span class="math inline">\(\odot\)</span>
表示圆周卷积，不同教材中圆周卷积的符号表述可能不同。</p>
</blockquote>
<h4 id="时域圆周卷积定理">3.8.6.1 时域圆周卷积定理</h4>
<p><span class="math display">\[\begin{align}
x\left(n\right)=x_1\left(n\right)\odot
x_2\left(n\right)&amp;=\widetilde{y}\left(n\right)=\sum_{m=0}^{N-1}{x_1\left(m\right)\left[x_2\left(\left(n-m\right)\right)_NR_N\left(n\right)\right]}
\\
&amp;=\mathrm{IDFT}\left[X_1\left(k\right)\cdot X_2\left(k\right)\right]
\end{align}\]</span></p>
<h4 id="频域圆周卷积定理">3.8.6.2 频域圆周卷积定理</h4>
<p><span class="math display">\[\begin{align}
X\left(k\right)=X_1\left(k\right)\odot
X_2\left(k\right)&amp;=\widetilde{X}\left(k\right)R_N\left(k\right)=\frac{1}{N}\sum_{l=0}^{N-1}{X_1\left(l\right)\left[X_2\left(\left(k-l\right)\right)_NR_N\left(k\right)\right]}
\\
&amp;=\mathrm{DFT}\left[x_1\left(n\right)\cdot x_2\left(n\right)\right]
\end{align}\]</span></p>
<h4 id="圆周卷积和线性卷积的关系">3.8.6.3 圆周卷积和线性卷积的关系</h4>
<p>  长度为 <span class="math inline">\(L\)</span> 的序列 <span class="math inline">\(x_1\left(n\right)\)</span> 和长度为 <span class="math inline">\(M\)</span> 的序列 <span class="math inline">\(x_2\left(n\right)\)</span>
的周期卷积是二者的线性卷积的以 <span class="math inline">\(N\)</span>
为周期的周期延拓，若满足</p>
<p><span class="math display">\[\begin{equation}
N\geqslant L+M-1
\end{equation}\]</span></p>
<p>则周期卷积的主值序列即圆周卷积与线性卷积完全相同，即 <span class="math inline">\(x_1\left(n\right)\odot
x_2\left(n\right)=x_1\left(n\right)\ast x_2\left(n\right)\)</span></p>
<h4 id="圆周卷积的矩阵算法">3.8.6.4 圆周卷积的矩阵算法</h4>
<p><span class="math display">\[\begin{equation}
y=h\odot
x=\left[\begin{matrix}h_1&amp;0&amp;\cdots&amp;0&amp;h_m&amp;\cdots\\h_2&amp;h_1&amp;\cdots&amp;0&amp;0&amp;\cdots\\\vdots&amp;\vdots&amp;&amp;\vdots&amp;\vdots&amp;\cdots\\h_m&amp;h_{m-1}&amp;\cdots&amp;0&amp;0&amp;\cdots\\0&amp;h_m&amp;\cdots&amp;h_1&amp;0&amp;\cdots\\0&amp;0&amp;&amp;\vdots&amp;h_1&amp;\cdots\\\vdots&amp;\vdots&amp;&amp;h_{m-1}&amp;\vdots&amp;\cdots\\0&amp;0&amp;\cdots&amp;h_m&amp;h_{m-1}&amp;\cdots\\\end{matrix}\right]_{N\times
N}\cdot\left[\begin{matrix}x_1\\x_2\\\vdots\\x_n\\0\\\vdots\\0\\\end{matrix}\right]_{N\times1}
\end{equation}\]</span></p>
<p>也可先计算线性卷积以 <span class="math inline">\(N\)</span>
为周期进行周期化后取主值得到圆周卷积。注意周期化时 <span class="math inline">\(N&lt;m+n-1\)</span>
的情况，此时会出现重叠，重叠部分相加后才是圆周卷积的结果。</p>
<h3 id="重叠相加法和重叠保留法">3.8.7 重叠相加法和重叠保留法</h3>
<p><strong>例</strong> 已知序列</p>
<p><span class="math display">\[\begin{equation}x\left(n\right)=\left\{2,-3,4,5,-6,7,8,-9,-10,11,-12,-13,-14\right\}\left(0\leqslant
n\leqslant12\right)
\end{equation}\]</span></p>
<p><span class="math display">\[\begin{equation}
h\left(n\right)=\left\{1,-2,-3\right\}(0\leqslant n\leqslant2)
\end{equation}\]</span></p>
<p>  试分别用重叠相加法和重叠保留法计算线性卷积，取分段长度 <span class="math inline">\(L=5\)</span>。</p>
<p>解：①重叠相加法</p>
<p>   将长序列 <span class="math inline">\(x\left(n\right)\)</span>
分段，每段长度为 <span class="math inline">\(5\)</span></p>
<p><span class="math display">\[\begin{align}
&amp;x_1\left(n\right)=\left\{2,-3,4,5,-6\right\} \\
&amp;x_2\left(n\right)=\left\{7,8,-9,-10,11\right\} \\
&amp;x_3\left(n\right)=\left\{ -12,-13,-14\right\}
\end{align}\]</span></p>
<p>   用圆周卷积计算计算各段与 <span class="math inline">\(h\left(n\right)\)</span>
的线性卷积，下划线标注部分是需要重叠相加的部分</p>
<p><span class="math display">\[\begin{align}
&amp;y_1\left(n\right)=\left\{2,-7,4,6,-28,\underline{-3,18}\right\}\\
&amp;y_2\left(n\right)=\left\{\underline{7,-6},-46,-16,58,\underline{8,-33}\right\}\\
&amp;y_3\left(n\right)=\left\{\underline{-12,11},48,67,42\right\}
\end{align}\]</span></p>
<p>   将各段结果重叠相加，连接成线性卷积结果</p>
<p><span class="math display">\[\begin{equation}
y\left(n\right)=\left\{2,-7,4,6,-28,\mathbf{4},\mathbf{12},-46,-16,58,-\mathbf{4},-\mathbf{22},48,67,42\right\}
\end{equation}\]</span></p>
<p>  ②重叠保留法</p>
<p>   将长序列 <span class="math inline">\(x\left(n\right)\)</span>
分段，每段长度为 <span class="math inline">\(5\)</span></p>
<p><span class="math display">\[\begin{align}
&amp;x_1\left(n\right)=\left\{\underline{0,0,2},-3,4\right\}\\
&amp;x_2\left(n\right)=\left\{\underline{-3,4},5,-6,7\right\}\\
&amp;x_3\left(n\right)=\left\{\underline{-6,-7},8,-9,-10\right\}\\
&amp;x_4\left(n\right)=\left\{\underline{-9,-10},11,-12,-13\right\}\\
&amp;x_5\left(n\right)=\left\{\underline{-12,-13},-14,0,0\right\}
\end{align}\]</span></p>
<p>   用圆周卷积计算计算各段与 <span class="math inline">\(h\left(n\right)\)</span>
的线性卷积，下划线标注部分是需要舍去的部分</p>
<p><span class="math display">\[\begin{align}
&amp;y_1\left(n\right)=\left\{\underline{1,-12},2,-7,4\right\}\\
&amp;y_2\left(n\right)=\left\{\underline{1,-11},6,28,4\right\}\\
&amp;y_3\left(n\right)=\left\{\underline{41,49},12,-46,-16\right\}\\
&amp;y_4\left(n\right)=\left\{\underline{53,47},58,-4,-22\right\}\\
&amp;y_5\left(n\right)=\left\{\underline{-12,11},48,67,42\right\}
\end{align}\]</span></p>
<p>   将各段重叠部分舍去，连接成线性卷积结果</p>
<p><span class="math display">\[\begin{equation}
y\left(n\right)=\left\{2,-7,4,6,-28,4,12,-46,-16,58,-4,-22,48,67,42\right\}
\end{equation}\]</span></p>
<h2 id="parseval-定理能量守恒">3.9 Parseval 定理（能量守恒）</h2>
<p><span class="math display">\[\begin{equation}
\sum_{n=0\
}^{N-1}{x^2\left(n\right)}=\frac{1}{N}\sum_{k=0}^{N-1}\left|X\left(k\right)\right|^2
\end{equation}\]</span></p>
<h2 id="dft-与-z-变换">3.10 DFT 与 <span class="math inline">\(z\)</span> 变换</h2>
<p><span class="math display">\[\begin{align}
X\left(k\right)&amp;=\sum_{n=0}^{N-1}{x\left(n\right)W_N^{nk}}=\sum_{n=0}^{N-1}{x\left(n\right)e^{-j\frac{2\pi}{N}nk}}=\left.\sum_{n=0}^{N-1}{x\left(n\right)z^{-n}}\right|_{z=e^{j\frac{2\pi}{N}k}}
\\
&amp;=\left.X\left(z\right)\right|_{z=e^{j\frac{2\pi}{N}k}}=\left.\sum_{n=0}^{N-1}{x\left(n\right)e^{-j\omega
n}}\right|_{\omega=\frac{2\pi}{N}k}\left(k=0,1,\cdots,N-1\right)
\end{align}\]</span></p>
<p>因此 <span class="math inline">\(x\left(n\right)\)</span> 的 DFT 的
<span class="math inline">\(N\)</span> 个系数即为 <span class="math inline">\(x\left(n\right)\)</span> 的 <span class="math inline">\(z\)</span> 变换 <span class="math inline">\(X\left(z\right)\)</span> 在单位圆上 <span class="math inline">\(N\)</span> 等分的取样点。</p>
<h1 id="频域取样的点数限制">4. 频域取样的点数限制</h1>
<p>  设 <span class="math inline">\(M\)</span> 点序列 <span class="math inline">\(x\left(n\right)\)</span> 的 <span class="math inline">\(z\)</span> 变换为 <span class="math inline">\(X\left(z\right)\)</span>，DTFT 为 <span class="math inline">\(X\left(e^{j\omega}\right)\)</span>，则有</p>
<blockquote>
<p>在 <span class="math inline">\(X\left(z\right)\)</span>
的单位圆上均匀采样 <span class="math inline">\(N\)</span> 点，其 IDFT
是序列 <span class="math inline">\(x\left(n\right)\)</span> 以周期 <span class="math inline">\(N\)</span> 进行周期延拓后的主值序列；</p>
<p>在 <span class="math inline">\(X\left(e^{j\omega}\right)\)</span>
的一个周期内均匀采样 <span class="math inline">\(N\)</span> 点，其 IDFT
是序列 <span class="math inline">\(x\left(n\right)\)</span> 以周期 <span class="math inline">\(N\)</span> 进行周期延拓后的主值序列；</p>
<p>在 <span class="math inline">\(X\left(e^{j\omega}\right)\)</span>
的一个周期内均匀采样 <span class="math inline">\(M\)</span> 点，其 IDFT
是序列 <span class="math inline">\(x\left(n\right)\)</span> 本身。</p>
</blockquote>
<p>由此，对于列长为M的有限长序列 <span class="math inline">\(x\left(n\right)\)</span>，频域取样不失真的条件是取样点数
<span class="math inline">\(N\)</span> 满足</p>
<p><span class="math display">\[\begin{equation}
N\geqslant M
\end{equation}\]</span></p>
<p>并且对于无限长序列 <span class="math inline">\(x\left(n\right)\)</span>，无论 <span class="math inline">\(N\)</span>
取值如何，都不可能消除混叠，只能随着取样点 <span class="math inline">\(N\)</span> 增加而接近 <span class="math inline">\(x\left(n\right)\)</span>。</p>
<h1 id="内插公式">5. 内插公式</h1>
<p>  用 DFT 表示 ZT</p>
<p><span class="math display">\[\begin{align}
X\left(z\right)&amp;=\sum_{n=0}^{N-1}{x\left(n\right)z^{-n}}=\sum_{n=0}^{N-1}{\left[\frac{1}{N}\sum_{k=0}^{N-1}{X\left(k\right)W_N^{-nk}}\right]z^{-n}}=\frac{1}{N}\sum_{k=0}^{N-1}\left[X\left(k\right)\sum_{n=0}^{N-1}\left(W_N^{-k}z^{-1}\right)^n\right]
\\
&amp;=\frac{1}{N}\sum_{k=0}^{N-1}{X\left(k\right)\frac{1-W_N^{-kn}z^{-N}}{1-W_N^{-k}z^{-1}}}=\frac{1}{N}\sum_{k=0}^{N-1}{X\left(k\right)\frac{1-z^{-N}}{1-W_N^{-k}z^{-1}}}
\\
&amp;=\frac{1-z^{-N}}{N}\sum_{k=0}^{N-1}\frac{X\left(k\right)}{1-W_N^{-k}z^{-1}}=\sum_{k=0}^{N-1}{X\left(k\right)\varphi_k\left(z\right)}
\end{align}\]</span></p>
<p>其中 <span class="math inline">\(X\left(z\right)\)</span>
的内插公式</p>
<p><span class="math display">\[\begin{equation}
\varphi_k\left(z\right)=\frac{1}{N}\cdot\frac{1-z^{-N}}{1-W_N^{-k}z^{-1}}
\end{equation}\]</span></p>
<p>  用 DFT 表示 DTFT</p>
<p><span class="math display">\[\begin{equation}
X\left(e^{j\omega}\right)=\left.X\left(z\right)\right|_{z=e^{j\omega}}=\sum_{k=0}^{N-1}{X\left(k\right)\varphi_k\left(e^{j\omega}\right)}=\sum_{k=0}^{N-1}X\left(k\right)\varphi\left(\omega-k\frac{2\pi}{N}\right)
\end{equation}\]</span></p>
<p>其中内插函数</p>
<p><span class="math display">\[\begin{equation}
\varphi\left(\omega\right)=\frac{1}{N}\frac{\sin{\left(\frac{\omega
N}{2}\right)}}{\sin{\left(\frac{\omega}{2}\right)}}e^{-j\omega\left(\frac{N-1}{2}\right)}
\end{equation}\]</span></p>
<p><strong>时域取样定理说明，对频域带限的信号，可对其进行时域取样而不丢失任何信息。频域取样理论说明，时间有限的信号（有限长序列），也可对其进行频域取样（DFT）而不丢失任何信息。</strong></p>
<h1 id="用-dft-对连续时间信号逼近的问题">6. 用 DFT
对连续时间信号逼近的问题</h1>
<h2 id="混叠现象">6.1 混叠现象</h2>
<p>  时域采样会引起频谱周期化，通过 <span class="math inline">\(f_s\geqslant 2f_h\)</span> 消除。</p>
<h2 id="频谱泄露现象">6.2 频谱泄露现象</h2>
<p>  取用有限个数据，即将信号截断的过程，等同于将信号乘以窗函数。如果窗函数是矩形窗，在时域内将信号截断相当于乘以矩形窗，而在频域中则相当于原信号的频谱与矩形窗的频谱卷积，使得原信号的频谱被展宽，造成频谱泄露。<strong>通常通过选择频谱特性更接近于
<span class="math inline">\(\delta\left(k\right)\)</span>
的函数来减少频谱泄露。</strong></p>
<h2 id="栅栏效应">6.3 栅栏效应</h2>
<p>  用 DFT
计算频谱时，采样点为基频的整数倍，由此观察到的频谱特征时有限的，<strong>若在两个取样点之间有剧烈的频谱变化，将无法检测出来</strong>。通常通过在原序列的末端添加一些零值点来改变周期内的点数，从而在保持原有频谱连续形式不变的情况下，变更了谱线的位置，原来看不到的频谱分量就能移动到可见的位置上。</p>
<h2 id="dft-参数的选择">6.4 DFT 参数的选择</h2>
<h3 id="取样频率-f_s由取样定理">6.4.1 取样频率 <span class="math inline">\(f_s\)</span>（由取样定理）</h3>
<p><span class="math display">\[\begin{equation}
f_s\geqslant 2f_h
\end{equation}\]</span></p>
<h3 id="取样周期-t">6.4.2 取样周期 <span class="math inline">\(T\)</span></h3>
<p><span class="math display">\[\begin{equation}
T=\frac{1}{f_s}\leqslant\frac{1}{2f_h}
\end{equation}\]</span></p>
<h3 id="频率分辨率频率分量间的增量f">6.4.3
频率分辨率（频率分量间的增量）<span class="math inline">\(F\)</span></h3>
<p><span class="math display">\[\begin{equation}
F=\frac{f_s}{N}
\end{equation}\]</span></p>
<p><span class="math inline">\(F\)</span> 越小，频率分辨率越高。</p>
<h3 id="最小记录长度周期性函数的有效周期t_p">6.4.4
最小记录长度（周期性函数的有效周期）<span class="math inline">\(t_p\)</span></h3>
<p><span class="math display">\[\begin{equation}
t_p=\frac{1}{F}=NT
\end{equation}\]</span></p>
<h3 id="一个记录长度内的点数-n">6.4.5 一个记录长度内的点数 <span class="math inline">\(N\)</span></h3>
<p><span class="math display">\[\begin{equation}
N\geqslant\frac{2f_h}{F}
\end{equation}\]</span></p>
<blockquote>
<p>注：最高频率 <span class="math inline">\(f_h\)</span> 和频率分辨率
<span class="math inline">\(F\)</span> 存在矛盾，即</p>
<p><span class="math display">\[\begin{equation}
f_h\uparrow \xrightarrow{f_s\geqslant 2f_h}f_s\uparrow
\xrightarrow{T=\frac{1}{f_s}}T\downarrow
\xrightarrow{N\text{给定时}}t_p\downarrow \longrightarrow F\uparrow
\left( \text{频率分辨率}\downarrow \right)
\end{equation}\]</span></p>
</blockquote>
<h1 id="参考文献">参考文献</h1>
<p>王世一. <em>数字信号处理, 修订版.</em> 北京理工大学出版社, 1997.</p>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/css/markmap.css">

<script src="/js/markmap.js"></script>
]]></content>
      <categories>
        <category>Josh 的学习笔记</category>
        <category>数字信号处理</category>
      </categories>
      <tags>
        <tag>数字信号和处理</tag>
        <tag>DSP</tag>
        <tag>圆周卷积</tag>
        <tag>离散傅里叶变换</tag>
        <tag>DFT</tag>
        <tag>延长序列</tag>
        <tag>重叠相加</tag>
        <tag>重叠保留</tag>
        <tag>内插公式</tag>
        <tag>混叠</tag>
        <tag>频谱泄露</tag>
        <tag>栅栏效应</tag>
      </tags>
  </entry>
  <entry>
    <title>Josh&#39;s Review — 数字信号处理&lt;br&gt;Part 4 快速傅里叶变换 FFT</title>
    <url>/posts/7c6d68a2.html</url>
    <content><![CDATA[<h1 id="直接计算-dft-的计算量">1. 直接计算 DFT 的计算量</h1>
<p>  考察列长为 <span class="math inline">\(N\)</span> 的序列 <span class="math inline">\(x\left(n\right)\)</span> 的 DFT</p>
<p><span class="math display">\[\begin{align}
X\left(k\right)&amp;=\sum_{n=0}^{N-1}{x\left(n\right)W_N^{nk}}=\sum_{n=0}^{N-1}\left\{\Re{\left[x\left(n\right)\right]}+j\Im{\left[x\left(n\right)\right]}\right\}\left\{\Re{\left[W_N^{nk}\right]}+j\Im{\left[W_N^{nk}\right]}\right\}
\\
&amp;=\sum_{n=0}^{N-1}{\left\{ \Re \left[ x\left( n \right) \right] \Re
\left[ W_{N}^{nk} \right] -\Im \left[ x\left( n \right) \right] \Im
\left[ W_{N}^{nk} \right] \right\} +j\left\{ \Re \!\:\left[ x\left( n
\right) \right] \Im \!\:\left[ W_{N}^{nk} \right] +\Im \left[
\!\:x\left( n \right) \right] \Re \!\:\left[ W_{N}^{nk} \right]
\right\}}
\end{align}\]</span></p>
<p>由此，直接计算 DFT 时，在不忽略 <span class="math inline">\(W_N^0=1\)</span> 等特例时，实数乘法次数为 <span class="math inline">\(4N^2\)</span>，实数加法次数为 <span class="math inline">\(2N\left(2N-1\right)\)</span>，均与 <span class="math inline">\(N^2\)</span> 成正比，计算量非常庞大。</p>
<span id="more"></span>
<h1 id="利用旋转因子-w_nnk-的特性改善-dft-的运算效率">2. 利用旋转因子
<span class="math inline">\(W_N^{nk}\)</span> 的特性改善 DFT
的运算效率</h1>
<table>
<colgroup>
<col style="width: 50%">
<col style="width: 50%">
</colgroup>
<thead>
<tr>
<th style="text-align: center;"></th>
<th style="text-align: center;"><span class="math inline">\(W_N^{nk}=e^{j\frac{2\pi}{N}nk}\)</span></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">对称性</td>
<td style="text-align: center;"><span class="math inline">\(\left(W_N^{nk}\right)^\ast=W_N^{-nk}=W_N^{\left(N-n\right)k}=W_N^{n\left(N-k\right)}\)</span></td>
</tr>
<tr>
<td style="text-align: center;">周期性</td>
<td style="text-align: center;"><span class="math inline">\(W_N^{nk}=W_N^{\left(N+n\right)k}=W_N^{n\left(N+k\right)}\)</span></td>
</tr>
<tr>
<td style="text-align: center;">可约性</td>
<td style="text-align: center;"><span class="math inline">\(W_N^{nk}=W_{mN}^{mnk},W_N^{nk}=W_{\frac{N}{m}}^{\frac{nk}{m}}\)</span></td>
</tr>
<tr>
<td style="text-align: center;">特殊点</td>
<td style="text-align: center;"><span class="math inline">\(W_N^0=W_N^N=1,W_N^{\frac{N}{2}}=-1,W_N^{k+\frac{N}{2}}=-W_N^k\)</span></td>
</tr>
</tbody>
</table>
<p>利用旋转因子 <span class="math inline">\(W_N^{nk}\)</span>
的特性，可将直接计算 DFT
算式中的对称项合并，从使长序列的DFT分解为为更小点数的DFT，即</p>
<p><span class="math display">\[\begin{equation}
\Re \left[ x\left( n \right) \right] \Re \left[ W_{N}^{nk} \right] +\Re
\left[ x\left( N-n \right) \right] \Re \left[ W_{N}^{\left( N-n \right)
k} \right] =\left\{ \Re \left[ x\left( n \right) \right] +\Re \left[
x\left( N-n \right) \right] \right\} \Re \left[ W_{N}^{nk} \right]
\end{equation}\]</span></p>
<p><span class="math display">\[\begin{equation}
-\Im \left[ x\left( n \right) \right] \Im \left[ W_{N}^{nk} \right] -\Im
\left[ x\left( N-n \right) \right] \Im \left[ W_{N}^{\left( N-n \right)
k} \right] =-\left\{ \Im \left[ x\left( n \right) \right] -\Im
\left[x\left( N-n \right) \right] \right\} \Im \left[ W_{N}^{nk} \right]
\end{equation}\]</span></p>
<h1 id="基-2-按时间抽取的-fft-算法">3. 基-2 按时间抽取的 FFT 算法</h1>
<p>（radix-2 Decimation in Time Fast Fourier Transform, radix-2 DIT-FFT,
i.e.&nbsp;Cooley-Turkey Method）</p>
<p><a id="3.1"></a></p>
<h2 id="算法原理">3.1 算法原理</h2>
<p>  设序列 <span class="math inline">\(x\left(n\right)\)</span> 的列长
<span class="math inline">\(N=2^\nu\)</span>，<span class="math inline">\(\nu\)</span> 为整数，则其 DFT</p>
<p><span class="math display">\[\begin{equation}
X\left(k\right)=\sum_{n=0}^{N-1}{x\left(n\right)W_N^{nk}},\ \
k=0,1,\cdots,N-1
\end{equation}\]</span></p>
<p><strong>将 <span class="math inline">\(x\left(n\right)\)</span> 按照
<span class="math inline">\(n\)</span> 的奇偶分成两个子序列</strong></p>
<p><span class="math display">\[\begin{equation}
\begin{cases}
x_1\left(r\right)=x\left(2r\right)\\
x_2\left(r\right)=x\left(2r+1\right)
\end{cases}
,\ \ r=0,1,\cdots,\frac{N}{2}-1
\end{equation}\]</span></p>
<p>则序列 DFT 的<strong>前半部分</strong>可表示为</p>
<p><span class="math display">\[\begin{align}
X\left(k\right)&amp;=\sum_{r=0}^{\frac{N}{2}-1}{x\left(2r\right)W_N^{2rk}}+\sum_{r=0}^{\frac{N}{2}-1}{x\left(2r+1\right)W_N^{\left(2r+1\right)k}}=\sum_{r=0}^{\frac{N}{2}-1}{x_1\left(r\right)W_{\frac{N}{2}}^{rk}}+W_N^k\sum_{r=0}^{\frac{N}{2}-1}{x_2\left(r\right)W_{\frac{N}{2}}^{rk}}
\\
&amp;=\mathrm{DFT}\left[x_1\left(n\right)\right]+W_N^k\mathrm{DFT}\left[x_2\left(n\right)\right]
\\
&amp;=X_1\left(k\right)+W_N^kX_2\left(k\right),\ \
k=0,1,\cdots,\frac{N}{2}-1
\end{align}\]</span></p>
<p>由旋转因子的周期性，即</p>
<p><span class="math display">\[\begin{equation}
W_{\frac{N}{2}}^{rk}=W_{\frac{N}{2}}^{r\left(k+\frac{N}{2}\right)}
\end{equation}\]</span></p>
<p>可将序列 DFT 的<strong>后半部分</strong>表示为</p>
<p><span class="math display">\[\begin{align}
X\left(k+\frac{N}{2}\right)&amp;=X_1\left(k+\frac{N}{2}\right)+W_N^{\left(k+\frac{N}{2}\right)}X_2\left(k+\frac{N}{2}\right)
\\
&amp;=X_1\left(k\right)+W_N^{\left(k+\frac{N}{2}\right)}X_2\left(k\right)
\\
&amp;=X_1\left(k\right)-W_N^kX_2\left(k\right),\ \
k=0,1,\cdots,\frac{N}{2}-1
\end{align}\]</span></p>
<p>类似地，可以将分离后的序列继续按奇偶序号分成两个序列计算，<strong>直到每个序列中只含有两个点</strong>。此时开始计算
DFT。这种方法称为<strong>基-2 按时间抽取的 FFT 算法</strong>。</p>
<h2 id="蝶形运算流图符号">3.2 蝶形运算流图符号</h2>
<figure>
<img data-src="../images/post/2023-04-14-josh-dsp-part-4/2023-04-14-josh-dsp-part-4-010-Radix2DITFFTButterfly.png?imageMogr2/thumbnail/!100p%7Cwatermark/2/text/QEpvc2ggR2Fv/font/YWhyb25iZC50dGY=/fontsize/80/dissolve/20/gravity/southeast/dx/5/dy/5" width="1000" alt="基-2 按时间抽取的 FFT 算法的鲽形图">
<figcaption aria-hidden="true">基-2 按时间抽取的 FFT
算法的鲽形图</figcaption>
</figure>
<h2 id="点基-2-dit-fft-推导">3.3 8 点基-2 DIT-FFT 推导</h2>
<figure>
<img data-src="../images/post/2023-04-14-josh-dsp-part-4/2023-04-14-josh-dsp-part-4-020-Radix2DITFFTDerivation.png?imageMogr2/thumbnail/!100p%7Cwatermark/2/text/QEpvc2ggR2Fv/font/YWhyb25iZC50dGY=/fontsize/40/dissolve/20/gravity/southeast/dx/5/dy/5" width="1000" alt="8 点 radix-2 DIT-FFT 推导">
<figcaption aria-hidden="true">8 点 radix-2 DIT-FFT 推导</figcaption>
</figure>
<p>  对于 8 点的序列，进行两次分解后每部分序列只含有两个点，可以直接计算
DFT。为了得到自然顺序输出的 DFT
序列，将第二级分解以后的结果作为输入。下面推导每级分解后序列的结果表示。</p>
<p>  对于第一级分解，直接用<a href="#3.1">算法原理</a>中的式子表示结果，有</p>
<p><span class="math display">\[\begin{align}
&amp;X\left(k\right)=X_1\left(k\right)+W_N^kX_2\left(k\right),&amp;k=0,1,\cdots,\frac{N}{2}\\
&amp;X\left(k+\frac{N}{2}\right)=X_1\left(k\right)+W_N^kX_2\left(k\right),&amp;k=0,1,\cdots,\frac{N}{2}
\end{align}\]</span></p>
<p>对于第二级分解</p>
<p><span class="math display">\[\begin{align}
X_1\left(k\right)&amp;=\sum_{l=0}^{\frac{N}{4}-1}{x_1\left(2l\right)W_{\frac{N}{2}}^{2lk}}+\sum_{l=0}^{\frac{N}{4}-1}{x_1\left(2l+1\right)W_{\frac{N}{2}}^{\left(2l+1\right)k}}
\\
&amp;=\sum_{l=0}^{\frac{N}{4}-1}{x_3\left(l\right)W_{\frac{N}{4}}^{lk}}+W_{\frac{N}{2}}^k\sum_{l=0}^{\frac{N}{4}-1}{x_4\left(l\right)W_{\frac{N}{4}}^{lk}}=X_3\left(k\right)+W_{\frac{N}{2}}^kX_4\left(k\right),\
\ k=0,1,\cdots,\frac{N}{4}-1
\end{align}\]</span></p>
<p><span class="math display">\[\begin{equation}
X_1\left(k+\frac{N}{4}\right)=X_3\left(k\right)-W_{\frac{N}{2}}^kX_4\left(k\right),\
\ k=0,1,\cdots,\frac{N}{4}-1
\end{equation}\]</span></p>
<p>同理</p>
<p><span class="math display">\[\begin{equation}
X_2\left(k\right)=X_5\left(k\right)+W_{\frac{N}{2}}^kX_6\left(k\right),X_2\left(k+\frac{N}{2}\right)=X_5\left(k\right)-W_{\frac{N}{2}}^kX_6\left(k\right),\
\ k=0,1,\cdots,\frac{N}{4}-1
\end{equation}\]</span></p>
<p>对于最后剩下的四个 <span class="math inline">\(\dfrac{N}{4}=2\)</span> 点的 DFT，即 <span class="math inline">\(X_3\left(k\right)、X_4\left(k\right)、X_5\left(k\right)、X_6\left(k\right)，k=0,1\)</span>，可按定义计算，如对
<span class="math inline">\(X_3\left(k\right)\)</span></p>
<p><span class="math display">\[\begin{align}
&amp;X_3\left(k\right)=\sum_{l=0}^{\frac{N}{4}-1}{x_3\left(l\right)W_{\frac{N}{4}}^{lk}}=\sum_{l=0}^{1}{x_3\left(l\right)W_{\frac{N}{4}}^{lk}}\\
\Longrightarrow
&amp;X_3\left(0\right)=x_3\left(0\right)+W_2^0x_3\left(1\right)=x\left(0\right)+W_N^0x\left(4\right),X_3\left(1\right)=x_3\left(0\right)+W_2^1x_3\left(1\right)=x\left(0\right)-W_N^0x\left(4\right)
\end{align}\]</span></p>
<p>将上述各式的旋转因子统一为 <span class="math inline">\(W_{\frac{N}{2}}^k=W_N^{2k}\)</span>，则一个 8 点的
DFT 可以分解为四个 <span class="math inline">\(\dfrac{N}{4}\)</span>
点的 DFT ，先做 <span class="math inline">\(\dfrac{N}{4}\)</span> 点的
DFT，再用相应的两个 <span class="math inline">\(\dfrac{N}{4}\)</span> 点
DFT 的结果合成 <span class="math inline">\(\dfrac{N}{2}\)</span> 点的
DFT，从而得到 <span class="math inline">\(X_1\left(k\right)、X_2\left(k\right)\)</span>，最后组合成为
<span class="math inline">\(N\)</span> 点的
DFT。上述过程的运算流图如下左图，实际绘制按照如下右图即可。</p>
<figure>
<img data-src="../images/post/2023-04-14-josh-dsp-part-4/2023-04-14-josh-dsp-part-4-030-8PointRadix2DITFFTButterfly.png?imageMogr2/thumbnail/!100p%7Cwatermark/2/text/QEpvc2ggR2Fv/font/YWhyb25iZC50dGY=/fontsize/80/dissolve/20/gravity/southeast/dx/5/dy/5" width="1000" alt="8 点 radix-2 DIT-FFT 的蝶形图">
<figcaption aria-hidden="true">8 点 radix-2 DIT-FFT
的蝶形图</figcaption>
</figure>
<h2 id="算法特点">3.4 算法特点</h2>
<h3 id="原位运算">3.4.1 原位运算</h3>
<p>  每级计算所得点数相同，且上一级数据不影响下级运算，数据可以保存在原寄存器中。</p>
<h3 id="比特反位序">3.4.2 比特反位序</h3>
<p>  若下标 <span class="math inline">\(n\)</span> 可用二进制表示为
<span class="math inline">\(n=\left(b_2b_1b_0\right)_2\)</span>，则 FFT
的输入样本序号 <span class="math inline">\(k\)</span> 就可用二进制表示为
<span class="math inline">\(k=\left(b_0b_1b_2\right)_2\)</span>。</p>
<h3 id="计算复杂度">3.4.3 计算复杂度</h3>
<p>  对于长度为 <span class="math inline">\(N=2^\nu\)</span>
的序列，共有 <span class="math inline">\(\nu\)</span> 级蝶形运算，每级有
<span class="math inline">\(\dfrac{N}{2}\)</span> 个蝶形，每个蝶形有
<span class="math inline">\(1\)</span> 次复数加法、<span class="math inline">\(2\)</span> 次复数乘法，因此 <span class="math inline">\(\nu\)</span> 级蝶形运算共有</p>
<p><span class="math display">\[\begin{align}
&amp;复数乘法：m_F=\frac{N}{2}\cdot\nu=\frac{N}{2}\log_2{N}\\
&amp;复数加法：a_F=N\cdot\nu=N\log_2{N}
\end{align}\]</span></p>
<h3 id="各类蝶形运算两个点相距的距离及-w_nk-的变化规律">3.4.4
各类蝶形运算两个点相距的“距离”及 <span class="math inline">\(W_N^k\)</span> 的变化规律</h3>
<table>
<colgroup>
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
</colgroup>
<thead>
<tr>
<th style="text-align: center;">点数 <span class="math inline">\(N\)</span></th>
<th style="text-align: center;">列数</th>
<th style="text-align: center;">蝶形运算的种类数</th>
<th style="text-align: center;">蝶形运算的系数</th>
<th style="text-align: center;">参加蝶形运算的<br>两数据点的间距</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><span class="math inline">\(\top\)</span></td>
<td style="text-align: center;">第 <span class="math inline">\(1\)</span> 列</td>
<td style="text-align: center;"><span class="math inline">\(1\)</span>
种</td>
<td style="text-align: center;"><span class="math inline">\(W_2^0/W_8^0=1\)</span></td>
<td style="text-align: center;"><span class="math inline">\(1\)</span></td>
</tr>
<tr>
<td style="text-align: center;"><span class="math inline">\(8\)</span></td>
<td style="text-align: center;">第 <span class="math inline">\(2\)</span> 列</td>
<td style="text-align: center;"><span class="math inline">\(2\)</span>
种</td>
<td style="text-align: center;"><span class="math inline">\(W_4^0/W_8^0,{W_4^1/W}_8^2\)</span></td>
<td style="text-align: center;"><span class="math inline">\(2\)</span></td>
</tr>
<tr>
<td style="text-align: center;"><span class="math inline">\(\bot\)</span></td>
<td style="text-align: center;">第 <span class="math inline">\(3\)</span> 列</td>
<td style="text-align: center;"><span class="math inline">\(4\)</span>
种</td>
<td style="text-align: center;"><span class="math inline">\(W_8^0,W_8^1,W_8^2,W_8^3\)</span></td>
<td style="text-align: center;"><span class="math inline">\(4\)</span></td>
</tr>
<tr>
<td style="text-align: center;"><span class="math inline">\(\top\)</span></td>
<td style="text-align: center;">第 <span class="math inline">\(1\)</span> 列</td>
<td style="text-align: center;"><span class="math inline">\(2^0\)</span>
种</td>
<td style="text-align: center;"><span class="math inline">\(W_2^0/W_N^0\)</span></td>
<td style="text-align: center;"><span class="math inline">\(1\)</span></td>
</tr>
<tr>
<td style="text-align: center;"><span class="math inline">\(\mid\)</span></td>
<td style="text-align: center;">第 <span class="math inline">\(2\)</span> 列</td>
<td style="text-align: center;"><span class="math inline">\(2^1\)</span>
种</td>
<td style="text-align: center;"><span class="math inline">\(W_4^0/W_N^0,{W_4^1/W}_N^{\frac{N}{4}}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(2\)</span></td>
</tr>
<tr>
<td style="text-align: center;"><span class="math inline">\(\mid\)</span></td>
<td style="text-align: center;">第 <span class="math inline">\(3\)</span> 列</td>
<td style="text-align: center;"><span class="math inline">\(2^2\)</span>
种</td>
<td style="text-align: center;"><span class="math inline">\(W_8^0,W_8^1,W_8^2,W_8^3/\)</span><br><span class="math inline">\(W_N^0,W_N^{\frac{8}{N}},W_N^{2\cdot\frac{8}{N}},W_8^{3\cdot\frac{8}{N}}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(4\)</span></td>
</tr>
<tr>
<td style="text-align: center;"><span class="math inline">\(2^\nu\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\vdots\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\vdots\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\vdots\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\vdots\)</span></td>
</tr>
<tr>
<td style="text-align: center;"><span class="math inline">\(\mid\)</span></td>
<td style="text-align: center;">第 <span class="math inline">\(\nu-1\)</span> 列</td>
<td style="text-align: center;"><span class="math inline">\(2^{\nu-2}\)</span> 种</td>
<td style="text-align: center;"><span class="math inline">\(W_{\frac{N}{2}}^0,W_{\frac{N}{2}}^1,W_{\frac{N}{2}}^2,\cdots,W_{\frac{N}{2}}^{\frac{N}{4}-1}\)</span>
<span class="math inline">\(W_N^0,W_N^2,W_N^4,\cdots,W_N^{\frac{N}{2}-2}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\dfrac{N}{4}\)</span></td>
</tr>
<tr>
<td style="text-align: center;"><span class="math inline">\(\bot\)</span></td>
<td style="text-align: center;">第 <span class="math inline">\(\nu\)</span> 列</td>
<td style="text-align: center;"><span class="math inline">\(2^{\nu-1}\)</span> 种</td>
<td style="text-align: center;"><span class="math inline">\(W_N^0,W_N^1,W_N^2,\cdots,W_N^{\frac{N}{2}-1}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\dfrac{N}{2}\)</span></td>
</tr>
</tbody>
</table>
<p>  以上述 8 点 FFT
为例，各列蝶形运算的种类数和系数以及参加蝶形运算的两数据点的间距如上表上半部。可见，每列的蝶形类型比前一列增加一倍，参加蝶形运算的两个数据点的间距也增大一倍。最后一列系数用的最多，为
4 个，即 <span class="math inline">\(W_8^0,W_8^1,W_8^2,W_8^3\)</span>；而前一列只用带它偶序号的那一半，即
<span class="math inline">\({W_4^0/W}_8^0,{W_4^1/W}_8^2\)</span>；第一列只有一个系数即
<span class="math inline">\({W_2^0/W}_8^0\)</span>。</p>
<p>  上述结论可推广至 <span class="math inline">\(N=2^\nu\)</span>
的一般情况。如上表下半部。从前向后，第一列只有一种类型的蝶形运算 <span class="math inline">\(W_N^0\)</span>，以后的每列蝶形的类型逗逼前一列增加一倍，到第
<span class="math inline">\(\nu\)</span> 列是 <span class="math inline">\(\dfrac{N}{2}\)</span> 个蝶形类型，系数是 <span class="math inline">\(W_N^0,W_N^1,\cdots,W_N^{\frac{N}{2}-1}\)</span>，共
<span class="math inline">\(\dfrac{N}{2}\)</span>
个。从后向前，系数是后一级的偶数序号的那一半。参加蝶形运算的两个数据点的间距，是最末一级最大，其值为
<span class="math inline">\(\dfrac{N}{2}\)</span>，向前每推进一列，间距减少一半。</p>
<h1 id="基-2-按频率抽取的-fft-算法">4. 基-2 按频率抽取的 FFT 算法</h1>
<p>（radix-2 Decimation in Frequency Fast Fourier Transform, radix-2
DIF-FFT, i.e.&nbsp;Sande-Tukey Method）</p>
<h2 id="算法原理-1">4.1 算法原理</h2>
<p>  设序列 <span class="math inline">\(x\left(n\right)的列长N=2^\nu\)</span>，<span class="math inline">\(\nu\)</span> 为整数，则其 DFT</p>
<p><span class="math display">\[\begin{equation}
X\left(k\right)=\sum_{n=0}^{N-1}{x\left(n\right)W_N^{nk}},\ \
k=0,1,\cdots,N-1
\end{equation}\]</span></p>
<p><strong>将 <span class="math inline">\(x\left(n\right)\)</span> 按照
<span class="math inline">\(n\)</span> 的顺序分成两个子序列（即可将
<span class="math inline">\(X\left(k\right)\)</span>
按照奇偶分组）</strong></p>
<p><span class="math display">\[\begin{equation}
\begin{cases}
前半子序列x\left(n\right)\\
后半子序列x\left(n+\dfrac{N}{2}\right)
\end{cases}
,\ \ n=0,1,\cdots,\frac{N}{2}-1
\end{equation}\]</span></p>
<p>则序列的 DFT 可表示为</p>
<p><span class="math display">\[\begin{align}
X\left(k\right)&amp;=\sum_{n=0}^{\frac{N}{2}-1}{x\left(n\right)W_N^{nk}}+\sum_{n=\frac{N}{2}}^{N-1}{x\left(n\right)W_N^{nk}}=\sum_{n=0}^{\frac{N}{2}-1}{x\left(n\right)W_N^{nk}}+\sum_{n=0}^{\frac{N}{2}-1}{x\left(n+\frac{N}{2}\right)W_N^{(n+\frac{N}{2})k}}
\\
&amp;=\sum_{n=0}^{\frac{N}{2}-1}{\left[x\left(n\right)+W_N^{\frac{N}{2}k}x\left(n+\frac{N}{2}\right)\right]W_N^{nk}}
\\
&amp;\xlongequal{W_{N}^{\frac{N}{2}k}=\left( -1 \right)
^k}\sum_{n=0}^{\frac{N}{2}-1}{\left[x\left(n\right)+\left(-1\right)^kx\left(n+\frac{N}{2}\right)\right]W_N^{nk}},\
\ k=0,1,\cdots,\frac{N}{2}-1
\end{align}\]</span></p>
<p>由 <span class="math inline">\(W_N^{\frac{N}{2}k}=\left(-1\right)^k\)</span>，按照
<span class="math inline">\(k\)</span> 的奇偶可将 <span class="math inline">\(X\left(k\right)\)</span> 分成两部分，令 <span class="math inline">\(k=2r\)</span> 及 <span class="math inline">\(k=2r+1,\
r=0,1,\cdots,\dfrac{N}{2}-1\)</span>，则</p>
<p><span class="math display">\[\begin{align}
&amp;X\left(2r\right)=\sum_{n=0}^{\frac{N}{2}-1}{\left[x\left(n\right)+x\left(n+\frac{N}{2}\right)\right]W_N^{2rn}}=\sum_{n=0}^{\frac{N}{2}-1}{\left[x\left(n\right)+x\left(n+\frac{N}{2}\right)\right]W_{\frac{N}{2}}^{rn}}
\\
&amp;X\left(2r+1\right)=\sum_{n=0}^{\frac{N}{2}-1}{\left[x\left(n\right)-x\left(n+\frac{N}{2}\right)\right]W_N^{2rn}}=\sum_{n=0}^{\frac{N}{2}-1}{\left[x\left(n\right)-x\left(n+\frac{N}{2}\right)\right]W_N^nW_{\frac{N}{2}}^{rn}}
\end{align}\]</span></p>
<p>上两式种的前者是输入序列前一半和后一半之和的 <span class="math inline">\(\dfrac{N}{2}\)</span> 点
DFT，后者是输入序列前一半和后一半之差与 <span class="math inline">\(W_N^n\)</span> 之积的 <span class="math inline">\(\dfrac{N}{2}\)</span> 点 DFT。令</p>
<p><span class="math display">\[\begin{equation}
\begin{cases}
x_1\left(n\right)=x\left(n\right)+x\left(n+\dfrac{N}{2}\right)\\
x_2\left(n\right)=\left[x\left(n\right)-x\left(n+\dfrac{N}{2}\right)\right]W_N^n
\end{cases}
,\ \ n=0,1,\cdots,\frac{N}{2}-1
\end{equation}\]</span></p>
<p>则</p>
<p><span class="math display">\[\begin{equation}
X\left(2r\right)=\sum_{n=0}^{\frac{N}{2}-1}{x_1\left(n\right)W_{\frac{N}{2}}^{rn}},\
\
X\left(2r+1\right)=\sum_{n=0}^{\frac{N}{2}-1}{x_2\left(n\right)W_{\frac{N}{2}}^{rn}}
\end{equation}\]</span></p>
<p>由此，可将 <span class="math inline">\(N\)</span> 点 DFT 按频率 <span class="math inline">\(k\)</span> 的奇偶分解为两个序列的 <span class="math inline">\(\dfrac{N}{2}\)</span> 点
DFT。类似地，可以将分离后的序列继续按频率k的奇偶分成两个序列计算，<strong>直到每个序列中只含有两个点</strong>。此时开始计算
DFT。这种方法称为<strong>基-2 按频率抽取的 FFT 算法</strong>。</p>
<h2 id="蝶形运算流图符号-1">4.2 蝶形运算流图符号</h2>
<figure>
<img data-src="../images/post/2023-04-14-josh-dsp-part-4/2023-04-14-josh-dsp-part-4-040-Radix2DIFFFTButterfly.png?imageMogr2/thumbnail/!100p%7Cwatermark/2/text/QEpvc2ggR2Fv/font/YWhyb25iZC50dGY=/fontsize/80/dissolve/20/gravity/southeast/dx/5/dy/5" width="1000" alt="基-2 按频率抽取的 FFT 算法的蝶形图">
<figcaption aria-hidden="true">基-2 按频率抽取的 FFT
算法的蝶形图</figcaption>
</figure>
<h2 id="点基-2-dif-fft-推导简述">4.3 8 点基-2 DIF-FFT 推导简述</h2>
<figure>
<img data-src="../images/post/2023-04-14-josh-dsp-part-4/2023-04-14-josh-dsp-part-4-050-Radix2DIFFFTDerivation.png?imageMogr2/thumbnail/!100p%7Cwatermark/2/text/QEpvc2ggR2Fv/font/YWhyb25iZC50dGY=/fontsize/40/dissolve/20/gravity/southeast/dx/5/dy/5" width="1000" alt="8 点 radix-2 DIF-FFT 推导">
<figcaption aria-hidden="true">8 点 radix-2 DIF-FFT 推导</figcaption>
</figure>
<p>运算流图如下左图，实际绘制按照如下右图即可。</p>
<figure>
<img data-src="../images/post/2023-04-14-josh-dsp-part-4/2023-04-14-josh-dsp-part-4-060-8PointRadix2DIFFFTButterfly.png?imageMogr2/thumbnail/!100p%7Cwatermark/2/text/QEpvc2ggR2Fv/font/YWhyb25iZC50dGY=/fontsize/80/dissolve/20/gravity/southeast/dx/5/dy/5" width="1000" alt="8 点 radix-2 DIF-FFT 的蝶形图">
<figcaption aria-hidden="true">8 点 radix-2 DIF-FFT
的蝶形图</figcaption>
</figure>
<p><strong>对于任何流图，只要保持各节点所连的支路及其传输系数不变，则不论节点位置怎么排列，所得流图总是等效的，最后所得
DFT 结果也是正确的</strong>，只是数据的提取和存放次序不同而已。</p>
<h2 id="算法特点-1">4.4 算法特点</h2>
<h3 id="原位运算-1">4.4.1 原位运算</h3>
<p>  每级计算所得点数相同，且上一级数据不影响下级运算，数据可以保存在原寄存器中。</p>
<h3 id="比特反位序-1">4.4.2 比特反位序</h3>
<p>  若下标 <span class="math inline">\(n\)</span> 可用二进制表示为
<span class="math inline">\(n=\left(b_2b_1b_0\right)_2\)</span>，则 FFT
的输入样本序号 <span class="math inline">\(k\)</span> 就可用二进制表示为
<span class="math inline">\(k=\left(b_0b_1b_2\right)_2\)</span>。</p>
<h3 id="计算复杂度-1">4.4.3 计算复杂度</h3>
<p>  对于长度为 <span class="math inline">\(N=2^\nu\)</span>
的序列，共有 <span class="math inline">\(\nu\)</span> 级蝶形运算，每级有
<span class="math inline">\(\dfrac{N}{2}\)</span> 个蝶形，每个蝶形有
<span class="math inline">\(1\)</span> 次复数加法、<span class="math inline">\(2\)</span> 次复数乘法，因此 <span class="math inline">\(\nu\)</span> 级蝶形运算共有</p>
<p><span class="math display">\[\begin{align}
&amp;复数乘法：m_F=\frac{N}{2}\cdot\nu=\frac{N}{2}\log_2{N}\\
&amp;复数加法：a_F=N\cdot\nu=N\log_2{N}
\end{align}\]</span></p>
<h1 id="基-2-dit-fft-和-基-2-dif-fft-的比较">5. 基-2 DIT-FFT 和 基-2
DIF-FFT 的比较</h1>
<figure>
<img data-src="../images/post/2023-04-14-josh-dsp-part-4/2023-04-14-josh-dsp-part-4-070-Radix2DIFFFTRadix2DIFFFTComparison.png?imageMogr2/thumbnail/!100p%7Cwatermark/2/text/QEpvc2ggR2Fv/font/YWhyb25iZC50dGY=/fontsize/40/dissolve/20/gravity/southeast/dx/5/dy/5" width="1000" alt="radix-2 DIT-FFT 和 radix-2 DIF-FFT 的比较">
<figcaption aria-hidden="true">radix-2 DIT-FFT 和 radix-2 DIF-FFT
的比较</figcaption>
</figure>
<h1 id="分裂基-fft-算法split-radix-fft-method">6. 分裂基 FFT
算法（split-radix FFT Method）</h1>
<h2 id="算法原理基-4-dif-fft同理">6.1 算法原理（基-4 DIF-FFT同理）</h2>
<p>  设序列 <span class="math inline">\(x\left(n\right)\)</span> 的列长
<span class="math inline">\(N=2^\nu\)</span>，<span class="math inline">\(\nu\)</span>为整数，则其 DFT</p>
<p><span class="math display">\[\begin{equation}
X\left(k\right)=\sum_{n=0}^{N-1}{x\left(n\right)W_N^{nk}},\ \
k=0,1,\cdots,N-1
\end{equation}\]</span></p>
<p>将 <span class="math inline">\(x\left(n\right)\)</span> 按照 <span class="math inline">\(n\)</span> 的顺序分成四个子序列</p>
<p><span class="math display">\[\begin{equation}
\begin{cases}
第一子序列x\left(n\right)\\
第二子序列x\left(n+\dfrac{N}{4}\right)\\
第三子序列x\left(n+\dfrac{N}{2}\right)\\
第四子序列x\left(n+\dfrac{3N}{4}\right)
\end{cases}
,\ \ n=0,1,\cdots,\frac{N}{2}-1
\end{equation}\]</span></p>
<p>则序列的 DFT 可表示为</p>
<p><span class="math display">\[\begin{align}
X\left(k\right)&amp;=\sum_{n=0}^{\frac{N}{4}-1}{x\left(n\right)W_N^{nk}}+\sum_{n=\frac{N}{4}}^{\frac{N}{2}-1}{x\left(n\right)W_N^{nk}}+\sum_{n=\frac{N}{2}}^{\frac{3N}{4}-1}{x\left(n\right)W_N^{nk}}+\sum_{n=\frac{3N}{4}}^{N-1}{x\left(n\right)W_N^{nk}}
\\
&amp;=\sum_{n=0}^{\frac{N}{4}-1}\left[x\left(n\right)W_N^{nk}+x\left(n+\frac{N}{4}\right)W_N^{\left(n+\frac{N}{4}\right)k}+x\left(n+\frac{N}{2}\right)W_N^{\left(n+\frac{N}{2}\right)k}+x\left(n+\frac{3N}{4}\right)W_N^{\left(n+\frac{3N}{4}\right)k}\right]
\\
&amp;=\sum_{n=0}^{\frac{N}{4}-1}{\left[x\left(n\right)+x\left(n+\frac{N}{4}\right)W_N^{\frac{N}{4}k}+x\left(n+\frac{N}{2}\right)W_N^{\frac{N}{2}k}+x\left(n+\frac{3N}{4}\right)W_N^{\frac{3N}{4}k}\right]W_N^{nk}}
\\
&amp;=\sum_{n=0}^{\frac{N}{4}-1}{\left[x\left(n\right)+x\left(n+\frac{N}{4}\right)W_4^k+x\left(n+\frac{N}{2}\right)W_4^{2k}+x\left(n+\frac{3N}{4}\right)W_4^{3k}\right]W_N^{nk}}
\end{align}\]</span></p>
<p>按照 <span class="math inline">\(k\)</span> 除以 <span class="math inline">\(4\)</span> 的余数可将 <span class="math inline">\(X\left(k\right)\)</span> 分成四部分，分别令 <span class="math inline">\(k=4r、k=4r+1、k=4r+2、k=4r+3\)</span>，其中 <span class="math inline">\(r=0,1,\cdots,\dfrac{N}{4}-1\)</span>，则有</p>
<p><span class="math display">\[\begin{equation}
\begin{cases}
X\left(4r\right)=\displaystyle\sum_{n=0}^{\frac{N}{4}-1}{\left[x\left(n\right)+x\left(n+\dfrac{N}{4}\right)+x\left(n+\dfrac{N}{2}\right)+x\left(n+\dfrac{3N}{4}\right)\right]W_{\frac{N}{4}}^{rn}}
\\
X\left(4r+1\right)=\displaystyle\sum_{n=0}^{\frac{N}{4}-1}{\left[x\left(n\right)-jx\left(n+\dfrac{N}{4}\right)-x\left(n+\dfrac{N}{2}\right)+jx\left(n+\dfrac{3N}{4}\right)\right]W_N^nW_{\frac{N}{4}}^{rn}}
\\
X\left(4r+2\right)=\displaystyle\sum_{n=0}^{\frac{N}{4}-1}{\left[x\left(n\right)-x\left(n+\dfrac{N}{4}\right)+x\left(n+\dfrac{N}{2}\right)-x\left(n+\dfrac{3N}{4}\right)\right]W_N^{2n}W_{\frac{N}{4}}^{rn}}
\\
X\left(4r+3\right)=\displaystyle\sum_{n=0}^{\frac{N}{4}-1}{\left[x\left(n\right)+jx\left(n+\dfrac{N}{4}\right)-x\left(n+\dfrac{N}{2}\right)-jx\left(n+\dfrac{3N}{4}\right)\right]W_N^{3n}W_{\frac{N}{4}}^{rn}}
\end{cases}
,\ \ r=0,1,\cdots,\frac{N}{4}-1
\end{equation}\]</span></p>
<p>上述过程也是基-4 DIF-FFT 的推导。上式中的偶数序号项合并，得</p>
<p><span class="math display">\[\begin{equation}
\begin{cases}
X\left(2r\right)=\displaystyle\sum_{n=0}^{\frac{N}{2}-1}{\left[x\left(n\right)+x\left(n+\dfrac{N}{2}\right)\right]W_N^{2rn}},
&amp;r=0,1,\cdots,\dfrac{N}{2}-1
\\
X\left(4r+1\right)=\displaystyle\sum_{n=0}^{\frac{N}{4}-1}{\left[\left(x\left(n\right)-x\left(n+\dfrac{N}{2}\right)\right)-j\left(x\left(n+\dfrac{N}{4}\right)-x\left(n+\dfrac{3N}{4}\right)\right)\right]W_N^nW_{\frac{N}{4}}^{rn}},&amp;r=0,1,\cdots,\dfrac{N}{4}-1
\\
X\left(4r+3\right)=\displaystyle\sum_{n=0}^{\frac{N}{4}-1}{\left[\left(x\left(n\right)-x\left(n+\dfrac{N}{2}\right)\right)+j\left(x\left(n+\dfrac{N}{4}\right)-x\left(n+\dfrac{3N}{4}\right)\right)\right]W_N^{3n}W_{\frac{N}{4}}^{rn}},&amp;r=0,1,\cdots,\dfrac{N}{4}-1
\end{cases}
\end{equation}\]</span></p>
<p>令</p>
<p><span class="math display">\[\begin{equation}
\begin{cases}
x_2\left(n\right)=x\left(n\right)+x\left(n+\dfrac{N}{2}\right),
&amp;n=0,1,\cdots,\dfrac{N}{2}-1
\\
x_4^1\left(n\right)=\left[\left(x\left(n\right)-x\left(n+\dfrac{N}{2}\right)\right)-j\left(x\left(n+\dfrac{N}{4}\right)-x\left(n+\dfrac{3N}{4}\right)\right)\right]W_N^n,&amp;n=0,1,\cdots,\dfrac{N}{4}-1
\\
x_4^2\left(n\right)=\left[\left(x\left(n\right)-x\left(n+\dfrac{N}{2}\right)\right)+j\left(x\left(n+\dfrac{N}{4}\right)-x\left(n+\dfrac{3N}{4}\right)\right)\right]W_N^{3n},&amp;n=0,1,\cdots,\dfrac{N}{4}-1
\end{cases}
\end{equation}\]</span></p>
<p>则有</p>
<p><span class="math display">\[\begin{equation}
\begin{cases}
X\left(2r\right)=\displaystyle\sum_{n=0}^{\frac{N}{2}-1}{x_2\left(n\right)W_{\frac{N}{2}}^{rn}}=DFT\left[x_2\left(n\right)\right],
&amp;r=0,1,\cdots,\dfrac{N}{2}-1
\\
X\left(4r+1\right)=\displaystyle\sum_{n=0}^{\frac{N}{4}-1}{x_4^1\left(n\right)W_{\frac{N}{4}}^{rn}}=\mathrm{DFT}\left[x_4^1\left(n\right)\right],&amp;r=0,1,\cdots,\dfrac{N}{4}-1
\\
X\left(4r+3\right)=\displaystyle\sum_{n=0}^{\frac{N}{4}-1}{x_4^2\left(n\right)W_{\frac{N}{4}}^{rn}}=\mathrm{DFT}\left[x_4^2\left(n\right)\right],&amp;r=0,1,\cdots,\dfrac{N}{4}-1
\end{cases}
\end{equation}\]</span></p>
<p>由此，DFT 的偶数部分采用基-2 算法，奇数部分采用基-4 算法，将一个
<span class="math inline">\(N\)</span> 点 DFT 的分解为一个 <span class="math inline">\(\dfrac{N}{2}\)</span> 点 DFT 和两个 <span class="math inline">\(\dfrac{N}{4}\)</span> 点 DFT。可将分裂基-2/4
算法看成<strong>时域分段、频域抽取</strong>的方法。先将整个 <span class="math inline">\(N\)</span>
点序列在时域分成两段，对于偶数段，在时域进一步分成两段，相当于在频域抽取偶数点
<span class="math inline">\(X\left(2r\right)\)</span>；对于奇数段，在时域分成
4 段，相当于在频域抽取奇数点 <span class="math inline">\(X\left(4r+1\right)\)</span> 和 <span class="math inline">\(X\left(4r+3\right)\)</span>。类似地，可将分离后的序列继续分解，直到最后一级。这种方法称为<strong>分裂基
FFT 算法</strong>。</p>
<h2 id="l-蝶形运算流图符号">6.2 L 蝶形运算流图符号</h2>
<figure>
<img data-src="../images/post/2023-04-14-josh-dsp-part-4/2023-04-14-josh-dsp-part-4-080-Radix24LButterfly.png?imageMogr2/thumbnail/!100p%7Cwatermark/2/text/QEpvc2ggR2Fv/font/YWhyb25iZC50dGY=/fontsize/80/dissolve/20/gravity/southeast/dx/5/dy/5" width="1000" alt="L 蝶形运算流图符号">
<figcaption aria-hidden="true">L 蝶形运算流图符号</figcaption>
</figure>
<h2 id="点-radix-24-fft举例">6.3 8 点 radix-2/4 FFT举例</h2>
<figure>
<img data-src="../images/post/2023-04-14-josh-dsp-part-4/2023-04-14-josh-dsp-part-4-090-8PointRadix24LButterfly.png?imageMogr2/thumbnail/!100p%7Cwatermark/2/text/QEpvc2ggR2Fv/font/YWhyb25iZC50dGY=/fontsize/80/dissolve/20/gravity/southeast/dx/5/dy/5" width="600" alt="8 点 radix-2/4 FFT举例">
<figcaption aria-hidden="true">8 点 radix-2/4 FFT举例</figcaption>
</figure>
<h2 id="运算量分析">6.4 运算量分析</h2>
<p>  对于 <span class="math inline">\(N=2^\nu\)</span> 点 DFT，设第
<span class="math inline">\(i\)</span> 级有 <span class="math inline">\(l_i\)</span> 个蝶形，<span class="math inline">\(j=0,1,\cdots,\nu-1\)</span>，则</p>
<p><span class="math display">\[\begin{equation}
\begin{cases}
l_1=\dfrac{N}{4}\\
l_i=\dfrac{N}{4}-\dfrac{l_{j-1}}{2}=\dfrac{N}{6}\left[1-\left(-\dfrac{1}{2}\right)^i\right],\
\ i\neq1
\end{cases}
\Longrightarrow\sum_{i=1}^{\nu-1}l_i=\frac{N}{6}\left[\nu-\frac{2}{3}+\frac{2}{3}\left(-\frac{1}{2}\right)^\nu\right]
\end{equation}\]</span></p>
<p>其中 <span class="math inline">\(l_i\)</span> 来自 L
蝶形的特殊结构。总的复乘次数为 L 蝶形数的两倍，而总的复加次数与基-2 FFT
算法相同，即</p>
<p><span class="math display">\[\begin{align}
&amp;复数乘法：C_F=2\cdot\sum_{i=1}^{\nu-1}l_i=\frac{N}{3}\log_2{N}-\frac{2N}{9}+\frac{\left(-1\right)^\nu2}{9}\
\ \propto\ \ \frac{N}{3}\log_2{N}\\
&amp;复数加法：a_F=N\cdot\nu=N\log_2{N}
\end{align}\]</span></p>
<p>显然，<strong>复乘次数相比基-2 FFT 算法下降了33%</strong>。</p>
<blockquote>
<p><strong>L 蝶形数与流图中 <span class="math inline">\(-j\)</span>
的个数相等。</strong></p>
</blockquote>
<h1 id="实序列的-fft-算法">7. 实序列的 FFT 算法</h1>
<h2 id="用一个-n-点-dft-同时计算两个-n-点实序列的-dft">7.1 用一个 <span class="math inline">\(N\)</span> 点 DFT 同时计算两个 <span class="math inline">\(N\)</span> 点实序列的 DFT</h2>
<p>  设 <span class="math inline">\(x_1\left(n\right),x_2\left(n\right)\)</span>
是相互独立的两个 <span class="math inline">\(N\)</span> 点实序列，将
<span class="math inline">\(x_1\left(n\right)\)</span> 和 <span class="math inline">\(x_2\left(n\right)\)</span>
分别当作一复序列的实部和虚部，即</p>
<p><span class="math display">\[\begin{equation}
x\left(n\right)=x_1\left(n\right)+jx_2\left(n\right)
\end{equation}\]</span></p>
<p>则由 DFT 的线性性质，<span class="math inline">\(x\left(n\right)\)</span> 的 DFT 可表示为</p>
<p><span class="math display">\[\begin{equation}
X\left(k\right)=X_1\left(k\right)+jX_2\left(k\right)
\end{equation}\]</span></p>
<p>再由的<a href="https://josh-gao.top/posts/fd9f9a29.html#共轭复序列的-dft">复序列的
DFT 性质</a></p>
<p><span class="math display">\[\begin{equation}
X\left(k\right)=X_{ep}\left(k\right)+X_{op}\left(k\right)
\end{equation}\]</span></p>
<p>则有 <span class="math inline">\(X_1\left(k\right)\)</span> 和 <span class="math inline">\(X_2\left(k\right)\)</span></p>
<p><span class="math display">\[\begin{equation}
X_1\left(k\right)=X_{ep}\left(k\right)=\frac{1}{2}\left[X\left(k\right)+X^\ast\left(N-k\right)\right]
\end{equation}\]</span></p>
<p><span class="math display">\[\begin{equation}
X_2\left(k\right)=-{jX}_{op}\left(k\right)=-\frac{j}{2}\left[X\left(k\right)-X^\ast\left(N-k\right)\right]
\end{equation}\]</span></p>
<p>蝶形图如下： <img data-src="../images/post/2023-04-14-josh-dsp-part-4/2023-04-14-josh-dsp-part-4-100-ComputeNPointComplxDFT.png?imageMogr2/thumbnail/!100p%7Cwatermark/2/text/QEpvc2ggR2Fv/font/YWhyb25iZC50dGY=/fontsize/40/dissolve/20/gravity/southeast/dx/5/dy/5" width="500" alt="用一个 N点 DFT 同时计算两个 N 点实序列的 DFT的蝶形图"></p>
<h2 id="用一个-n-点-dft-计算一个-2n-点实序列的-dft">7.2 用一个 <span class="math inline">\(N\)</span> 点 DFT 计算一个 <span class="math inline">\(2N\)</span> 点实序列的 DFT</h2>
<p>  设 <span class="math inline">\(x\left(n\right)\)</span> 是一个
<span class="math inline">\(2N\)</span>
点的实序列，将其按照奇偶分为两个独立的 <span class="math inline">\(N\)</span> 点实序列 <span class="math inline">\(x_1\left(n\right),x_2\left(n\right)\)</span>，即</p>
<p><span class="math display">\[\begin{equation}
\begin{cases}
x_1\left(n\right)=x\left(2n\right)\\
x_2\left(n\right)=x\left(2n+1\right)
\end{cases}
,\ \ n=0,1,\cdots,N-1
\end{equation}\]</span></p>
<p>将 <span class="math inline">\(x_1\left(n\right)\)</span> 和 <span class="math inline">\(x_2\left(n\right)\)</span>
分别当作一复序列的实部和虚部，即</p>
<p><span class="math display">\[\begin{equation}
y\left(n\right)=x_1\left(n\right)+jx_2\left(n\right)
\end{equation}\]</span></p>
<p>则由 DFT 的线性性质，<span class="math inline">\(y\left(n\right)\)</span> 的 DFT 可表示为</p>
<p><span class="math display">\[\begin{equation}
Y\left(k\right)=X_1\left(k\right)+jX_2\left(k\right)
\end{equation}\]</span></p>
<p>则由上述讨论，有 <span class="math inline">\(X_1\left(k\right)\)</span> 和 <span class="math inline">\(X_2\left(k\right)\)</span></p>
<p><span class="math display">\[\begin{equation}
X_1\left(k\right)=Y_{ep}\left(k\right)=\frac{1}{2}\left[Y\left(k\right)+Y^\ast\left(N-k\right)\right]
\end{equation}\]</span></p>
<p><span class="math display">\[\begin{equation}
X_2\left(k\right)=-{jY}_{op}\left(k\right)=-\frac{j}{2}\left[Y\left(k\right)-Y^\ast\left(N-k\right)\right]
\end{equation}\]</span></p>
<p>因此 <span class="math inline">\(x\left(n\right)\)</span>
的傅里叶变换（类似基-2 DIT）</p>
<p><span class="math display">\[\begin{align}
X\left(k\right)&amp;=\sum_{n=0}^{2N-1}{x\left(n\right)W_N^{nk}}=\sum_{n=0}^{N-1}{x\left(2n\right)W_{2N}^{2nk}}+\sum_{n=0}^{N-1}{x\left(2n+1\right)W_{2N}^{\left(2n+1\right)k}}
\\
&amp;=\sum_{n=0}^{N-1}{x\left(2n\right)W_{2N}^{2nk}}+W_{2N}^k\sum_{n=0}^{N-1}{x\left(2n+1\right)W_{2N}^{2nk}}
\\
&amp;=\sum_{n=0}^{N-1}{x_1\left(n\right)W_N^{nk}}+W_{2N}^k\sum_{n=0}^{N-1}{x_2\left(n\right)W_N^{nk}}
\\
&amp;=X_1\left(k\right)+W_{2N}^kX_2\left(k\right),\ \ \ \ \ \ \ \ \ \ \
k=0,1,\cdots,N-1
\end{align}\]</span></p>
<p><span class="math display">\[\begin{equation}
X\left(k+N\right)=X_1\left(k\right)-W_{2N}^kX_2\left(k\right),\ \
k=0,1,\cdots,N-1\qquad\qquad\quad\
\end{equation}\]</span></p>
<p>蝶形图如下：</p>
<figure>
<img data-src="../images/post/2023-04-14-josh-dsp-part-4/2023-04-14-josh-dsp-part-4-110-Compute2NPointRealDFT.png?imageMogr2/thumbnail/!100p%7Cwatermark/2/text/QEpvc2ggR2Fv/font/YWhyb25iZC50dGY=/fontsize/40/dissolve/20/gravity/southeast/dx/5/dy/5" width="500" alt="用一个 N 点 DFT 计算一个 2N 点实序列的 DFT的蝶形图">
<figcaption aria-hidden="true">用一个 N 点 DFT 计算一个 2N 点实序列的
DFT的蝶形图</figcaption>
</figure>
<h1 id="参考文献">参考文献</h1>
<p>王世一. <em>数字信号处理, 修订版.</em> 北京理工大学出版社, 1997.</p>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/css/markmap.css">

<script src="/js/markmap.js"></script>
]]></content>
      <categories>
        <category>Josh 的学习笔记</category>
        <category>数字信号处理</category>
      </categories>
      <tags>
        <tag>数字信号和处理</tag>
        <tag>DSP</tag>
        <tag>快速傅里叶变换</tag>
        <tag>FFT</tag>
        <tag>基2按时间抽取</tag>
        <tag>基2按频率抽取</tag>
        <tag>基4</tag>
        <tag>分裂基FFT</tag>
        <tag>蝶形图</tag>
        <tag>旋转因子</tag>
      </tags>
  </entry>
  <entry>
    <title>Josh&#39;s Review — 数字信号处理&lt;br&gt;Part 5 部分 FFT 蝶形图</title>
    <url>/posts/14fc3f1c.html</url>
    <content><![CDATA[<h1 id="点-fft">1. 4 点 FFT</h1>
<h2 id="基-2-按时间抽取-fft4-point-radix-2-dit-fft">1.1. 基-2 按时间抽取
FFT（4-point radix-2 DIT-FFT）</h2>
<h3 id="比特位反序输入自然顺序输出">1.1.1.
比特位反序输入、自然顺序输出</h3>
<figure>
<img data-src="../images/post/2023-04-15-josh-dsp-part-5/2023-04-15-josh-dsp-part-5-010-4PointRadix2DITFFTIRON.png" width="400" alt="4-point radix-2 DIT-FFT 比特位反序输入、自然顺序输出">
<figcaption aria-hidden="true">4-point radix-2 DIT-FFT
比特位反序输入、自然顺序输出</figcaption>
</figure>
<span id="more"></span>
<h3 id="自然顺序输入比特位反序输出">1.1.2.
自然顺序输入、比特位反序输出</h3>
<figure>
<img data-src="../images/post/2023-04-15-josh-dsp-part-5/2023-04-15-josh-dsp-part-5-020-4PointRadix2DITFFTINOR.png" width="400" alt="4-point radix-2 DIT-FFT 自然顺序输入、比特位反序输出">
<figcaption aria-hidden="true">4-point radix-2 DIT-FFT
自然顺序输入、比特位反序输出</figcaption>
</figure>
<h2 id="基-2-按频率抽取-fft4-point-radix-2-dif-fft">1.2. 基-2 按频率抽取
FFT（4-point radix-2 DIF-FFT）</h2>
<h3 id="比特位反序输入自然顺序输出-1">1.2.1.
比特位反序输入、自然顺序输出</h3>
<figure>
<img data-src="../images/post/2023-04-15-josh-dsp-part-5/2023-04-15-josh-dsp-part-5-030-4PointRadix2DIFFFTIRON.png" width="400" alt="4-point radix-2 DIF-FFT 比特位反序输入、自然顺序输出">
<figcaption aria-hidden="true">4-point radix-2 DIF-FFT
比特位反序输入、自然顺序输出</figcaption>
</figure>
<h3 id="自然顺序输入比特位反序输出-1">1.2.2.
自然顺序输入、比特位反序输出</h3>
<figure>
<img data-src="../images/post/2023-04-15-josh-dsp-part-5/2023-04-15-josh-dsp-part-5-040-4PointRadix2DIFFFTINOR.png" width="400" alt="4-point radix-2 DIF-FFT 自然顺序输入、比特位反序输出">
<figcaption aria-hidden="true">4-point radix-2 DIF-FFT
自然顺序输入、比特位反序输出</figcaption>
</figure>
<h2 id="分裂基按频率抽取-fft4-point-split-radix-24-dif-fft">1.3.
分裂基按频率抽取 FFT（4-point split radix-2/4 DIF-FFT）</h2>
<figure>
<img data-src="../images/post/2023-04-15-josh-dsp-part-5/2023-04-15-josh-dsp-part-5-050-4PointSplitRadix24DIFFFT.png" width="400" alt="4-point split radix-2/4 DIF-FFT">
<figcaption aria-hidden="true">4-point split radix-2/4
DIF-FFT</figcaption>
</figure>
<h2 id="基-4-按频率抽取-fft4-point-radix-4-dif-fft">1.4. 基-4 按频率抽取
FFT（4-point radix-4 DIF-FFT）</h2>
<figure>
<img data-src="../images/post/2023-04-15-josh-dsp-part-5/2023-04-15-josh-dsp-part-5-060-4PointRadix4DIFFFT.png" width="400" alt="4-point radix-4 DIF-FFT">
<figcaption aria-hidden="true">4-point radix-4 DIF-FFT</figcaption>
</figure>
<h1 id="点-fft-1">2. 8 点 FFT</h1>
<h2 id="基-2-按时间抽取-fft8-point-radix-2-dit-fft">2.1. 基-2 按时间抽取
FFT（8-point radix-2 DIT-FFT）</h2>
<h3 id="比特位反序输入自然顺序输出-2">2.1.1.
比特位反序输入、自然顺序输出</h3>
<figure>
<img data-src="../images/post/2023-04-15-josh-dsp-part-5/2023-04-15-josh-dsp-part-5-070-8PointRadix2DITFFTIRON.png" width="600" alt="8-point radix-2 DIT-FFT 比特位反序输入、自然顺序输出">
<figcaption aria-hidden="true">8-point radix-2 DIT-FFT
比特位反序输入、自然顺序输出</figcaption>
</figure>
<h3 id="自然顺序输入比特位反序输出-2">2.1.2.
自然顺序输入、比特位反序输出</h3>
<figure>
<img data-src="../images/post/2023-04-15-josh-dsp-part-5/2023-04-15-josh-dsp-part-5-080-8PointRadix2DITFFTINOR.png" width="600" alt="8-point radix-2 DIT-FFT 自然顺序输入、比特位反序输出">
<figcaption aria-hidden="true">8-point radix-2 DIT-FFT
自然顺序输入、比特位反序输出</figcaption>
</figure>
<h2 id="基-2-按频率抽取-fft8-point-radix-2-dif-fft">2.2. 基-2 按频率抽取
FFT（8-point radix-2 DIF-FFT）</h2>
<h3 id="比特位反序输入自然顺序输出-3">2.2.1.
比特位反序输入、自然顺序输出</h3>
<figure>
<img data-src="../images/post/2023-04-15-josh-dsp-part-5/2023-04-15-josh-dsp-part-5-090-8PointRadix2DIFFFTIRON.png" width="600" alt="8-point radix-2 DIF-FFT 自然顺序输入、比特位反序输出">
<figcaption aria-hidden="true">8-point radix-2 DIF-FFT
自然顺序输入、比特位反序输出</figcaption>
</figure>
<h3 id="自然顺序输入比特位反序输出-3">2.2.2.
2自然顺序输入、比特位反序输出</h3>
<figure>
<img data-src="../images/post/2023-04-15-josh-dsp-part-5/2023-04-15-josh-dsp-part-5-100-8PointRadix2DIFFFTINOR.png" width="600" alt="8-point radix-2 DIF-FFT 自然顺序输入、比特位反序输出">
<figcaption aria-hidden="true">8-point radix-2 DIF-FFT
自然顺序输入、比特位反序输出</figcaption>
</figure>
<h2 id="分裂基按频率抽取-fft8-point-split-radix-24-dif-fft">2.3.
分裂基按频率抽取 FFT（8-point split radix-2/4 DIF-FFT）</h2>
<figure>
<img data-src="../images/post/2023-04-15-josh-dsp-part-5/2023-04-15-josh-dsp-part-5-110-8PointSplitRadix24DIFFFT.png" width="600" alt="8-point split radix-2/4 DIF-FFT">
<figcaption aria-hidden="true">8-point split radix-2/4
DIF-FFT</figcaption>
</figure>
<h1 id="点-fft-2">3. 16 点 FFT</h1>
<h2 id="基-2-按时间抽取-fft16-point-radix-2-dit-fft">3.1. 基-2
按时间抽取 FFT（16-point radix-2 DIT-FFT）</h2>
<h3 id="比特位反序输入自然顺序输出-4">3.1.1.
比特位反序输入、自然顺序输出</h3>
<figure>
<img data-src="../images/post/2023-04-15-josh-dsp-part-5/2023-04-15-josh-dsp-part-5-120-16PointRadix2DITFFTIRON.png" width="1000" alt="16-point radix-2 DIT-FFT 比特位反序输入、自然顺序输出">
<figcaption aria-hidden="true">16-point radix-2 DIT-FFT
比特位反序输入、自然顺序输出</figcaption>
</figure>
<h3 id="自然顺序输入比特位反序输出-4">3.1.2.
自然顺序输入、比特位反序输出</h3>
<figure>
<img data-src="../images/post/2023-04-15-josh-dsp-part-5/2023-04-15-josh-dsp-part-5-130-16PointRadix2DITFFTINOR.png" width="1000" alt="16-point radix-2 DIT-FFT 自然顺序输入、比特位反序输出">
<figcaption aria-hidden="true">16-point radix-2 DIT-FFT
自然顺序输入、比特位反序输出</figcaption>
</figure>
<h2 id="基-2-按频率抽取-fft16-point-radix-2-dif-fft">3.2. 基-2
按频率抽取 FFT（16-point radix-2 DIF-FFT）</h2>
<h3 id="比特位反序输入自然顺序输出-5">3.2.1.
比特位反序输入、自然顺序输出</h3>
<figure>
<img data-src="../images/post/2023-04-15-josh-dsp-part-5/2023-04-15-josh-dsp-part-5-140-16PointRadix2DIFFFTIRON.png" width="1000" alt="16-point radix-2 DIF-FFT 比特位反序输入、自然顺序输出">
<figcaption aria-hidden="true">16-point radix-2 DIF-FFT
比特位反序输入、自然顺序输出</figcaption>
</figure>
<h3 id="自然顺序输入比特位反序输出-5">3.2.2.
自然顺序输入、比特位反序输出</h3>
<figure>
<img data-src="../images/post/2023-04-15-josh-dsp-part-5/2023-04-15-josh-dsp-part-5-150-16PointRadix2DIFFFTINOR.png" width="1000" alt="16-point radix-2 DIF-FFT 自然顺序输入、比特位反序输出">
<figcaption aria-hidden="true">16-point radix-2 DIF-FFT
自然顺序输入、比特位反序输出</figcaption>
</figure>
<h2 id="分裂基按时间抽取-fft16-point-split-radix-24-dit-fft">3.3.
分裂基按时间抽取 FFT（16-point split radix-2/4 DIT-FFT）</h2>
<figure>
<img data-src="../images/post/2023-04-15-josh-dsp-part-5/2023-04-15-josh-dsp-part-5-160-16PointSplitRadix24DITFFT.png" width="1000" alt="16-point split radix-2 DIT-FFT">
<figcaption aria-hidden="true">16-point split radix-2
DIT-FFT</figcaption>
</figure>
<h2 id="分裂基按频率抽取-fft16-point-split-radix-24-dif-fft">3.4.
分裂基按频率抽取 FFT（16-point split radix-2/4 DIF-FFT）</h2>
<figure>
<img data-src="../images/post/2023-04-15-josh-dsp-part-5/2023-04-15-josh-dsp-part-5-170-16PointSplitRadix24DIFFFT.png" width="1000" alt="16-point split radix-2 DIF-FFT">
<figcaption aria-hidden="true">16-point split radix-2
DIF-FFT</figcaption>
</figure>
<h2 id="基-4-按频率抽取-fft16-point-radix-4-dif-fft">3.5. 基-4
按频率抽取 FFT（16-point radix-4 DIF-FFT）</h2>
<figure>
<img data-src="../images/post/2023-04-15-josh-dsp-part-5/2023-04-15-josh-dsp-part-5-180-16PointRadix4DITFFT.png" width="1000" alt="16-point radix-4 DIF-FFT">
<figcaption aria-hidden="true">16-point radix-4 DIF-FFT</figcaption>
</figure>
<p>可以定义如下基-4 DIF-FFT 简化蝶形来简化流图表示的复杂程度</p>
<figure>
<img data-src="../images/post/2023-04-15-josh-dsp-part-5/2023-04-15-josh-dsp-part-5-190-SimplifiedRadix4Butterfly.png" width="800" alt="基-4 DIF-FFT 简化蝶形">
<figcaption aria-hidden="true">基-4 DIF-FFT 简化蝶形</figcaption>
</figure>
<h1 id="参考文献">参考文献</h1>
<p>王世一. <em>数字信号处理, 修订版.</em> 北京理工大学出版社, 1997.</p>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/css/markmap.css">

<script src="/js/markmap.js"></script>
]]></content>
      <categories>
        <category>Josh 的学习笔记</category>
        <category>数字信号处理</category>
      </categories>
      <tags>
        <tag>数字信号和处理</tag>
        <tag>DSP</tag>
        <tag>FFT</tag>
        <tag>基2按时间抽取</tag>
        <tag>基2按频率抽取</tag>
        <tag>基4</tag>
        <tag>分裂基FFT</tag>
        <tag>蝶形图</tag>
      </tags>
  </entry>
  <entry>
    <title>Josh&#39;s Review — 数字信号处理&lt;br&gt;Part 6 数字滤波器的基本结构</title>
    <url>/posts/8df56ea6.html</url>
    <content><![CDATA[<h1 id="基本运算单元的结构图表示">1. 基本运算单元的结构图表示</h1>
<table>
<colgroup>
<col style="width: 25%">
<col style="width: 37%">
<col style="width: 37%">
</colgroup>
<thead>
<tr>
<th style="text-align: center;">基本运算单元</th>
<th style="text-align: center;">方框图</th>
<th style="text-align: center;">流图</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">单位延时</td>
<td style="text-align: center;"><img data-src="../images/post/2023-04-15-josh-dsp-part-6/2023-04-15-josh-dsp-part-6-010-UnitDelayBlock.png" width="150" alt="单位延时方框图"></td>
<td style="text-align: center;"><img data-src="../images/post/2023-04-15-josh-dsp-part-6/2023-04-15-josh-dsp-part-6-020-UnitDelayFlow.png" width="150" alt="单位延时流图"></td>
</tr>
<tr>
<td style="text-align: center;">常数乘法器</td>
<td style="text-align: center;"><img data-src="../images/post/2023-04-15-josh-dsp-part-6/2023-04-15-josh-dsp-part-6-030-MultiplierBlock.png" width="150" alt="常数乘法器方框图"></td>
<td style="text-align: center;"><img data-src="../images/post/2023-04-15-josh-dsp-part-6/2023-04-15-josh-dsp-part-6-040-MultiplierFlow.png" width="150" alt="常数乘法器流图"></td>
</tr>
<tr>
<td style="text-align: center;">加法器</td>
<td style="text-align: center;"><img data-src="../images/post/2023-04-15-josh-dsp-part-6/2023-04-15-josh-dsp-part-6-050-AdderBlock.png" width="150" alt="加法器方框图"></td>
<td style="text-align: center;"><img data-src="../images/post/2023-04-15-josh-dsp-part-6/2023-04-15-josh-dsp-part-6-060-AdderFlow.png" width="150" alt="加法器流图"></td>
</tr>
</tbody>
</table>
<span id="more"></span>
<h1 id="iirinfinite-impulse-response数字滤波器的基本结构">2.
IIR（Infinite Impulse Response）数字滤波器的基本结构</h1>
<p>  IIR 数字滤波器的结构特点</p>
<p><span class="math display">\[\begin{align}
&amp;系统函数：H\left(z\right)=\frac{Y\left(z\right)}{X\left(z\right)}=\frac{\displaystyle\sum_{k=0}^{M}{b_kz^{-k}}}{1-\displaystyle\sum_{k=1}^{N}{a_kz^{-k}}}\\
&amp;差分方程：y\left(n\right)=\sum_{k=1}^{N}{a_ky\left(n-k\right)}+\sum_{k=0}^{M}{b_kx\left(n-k\right)}
\end{align}\]</span></p>
<ul>
<li><p>系统的单位脉冲响应 <span class="math inline">\(h\left(n\right)\)</span> 无限长；</p></li>
<li><p>系统函数 <span class="math inline">\(H\left(z\right)\)</span>
在有限 <span class="math inline">\(z\)</span> 平面（<span class="math inline">\(0&lt;\left|z\right|&lt;\infty\)</span>）上有极点存在；</p></li>
<li><p>存在输出到输入的反馈，递归型结构：直接Ⅰ、Ⅱ型，级、并联型。</p></li>
</ul>
<h2 id="直接ⅰ型">2.1. 直接Ⅰ型</h2>
<p>  将系统函数写为</p>
<p><span class="math display">\[\begin{equation}
H\left( z \right) =\frac{Y\left( z \right)}{X\left( z
\right)}=\frac{\displaystyle\sum_{k=0}^M{b_kz^{-k}}}{1-\displaystyle\sum_{k=1}^N{a_kz^{-k}}}=\underset{H_1\left(
z \right)}{\underbrace{\sum_{k=0}^M{b_kz^{-k}}}}\times
\underset{H_2\left( z \right)}{\underbrace{\left(
1-\displaystyle\sum_{k=1}^N{a_kz^{-k}} \right) ^{-1}}}
\end{equation}\]</span></p>
<p>则系统框图可表示为</p>
<figure>
<img data-src="../images/post/2023-04-15-josh-dsp-part-6/2023-04-15-josh-dsp-part-6-070-Direct1SystemBlock.png" width="500" alt="直接Ⅰ型系统框图">
<figcaption aria-hidden="true">直接Ⅰ型系统框图</figcaption>
</figure>
<p>由此可得系统的两级输入输出的微分方程</p>
<p><span class="math display">\[\begin{equation}
H_1\left(z\right)=\sum_{k=0}^{M}{b_kz^{-k}}=\frac{U\left(z\right)}{X\left(z\right)}\Longrightarrow
u\left(n\right)=\sum_{k=0}^{M}{b_kx\left(n-k\right)}
\end{equation}\]</span></p>
<p><span class="math display">\[\begin{equation}
H_2\left(z\right)=\left(1-\sum_{k=1}^{N}{a_kz^{-k}}\right)^{-1}=\frac{Y\left(z\right)}{U\left(z\right)}\Longrightarrow
y\left(n\right)=u\left(n\right)+\sum_{k=1}^{M}{a_ky\left(n-k\right)}
\end{equation}\]</span></p>
<p>由微分方程可得直接Ⅰ型 IIR 滤波器的流图</p>
<figure>
<img data-src="../images/post/2023-04-15-josh-dsp-part-6/2023-04-15-josh-dsp-part-6-080-Direct1IIRFlow.png" width="500" alt="直接Ⅰ型 IIR 滤波器的流图">
<figcaption aria-hidden="true">直接Ⅰ型 IIR 滤波器的流图</figcaption>
</figure>
<h2 id="直接ⅱ型典范型">2.2. 直接Ⅱ型（典范型）</h2>
<p>  系统函数仍为</p>
<p><span class="math display">\[\begin{equation}
H\left( z \right) =\frac{Y\left( z \right)}{X\left( z
\right)}=\frac{\displaystyle\sum_{k=0}^M{b_kz^{-k}}}{1-\displaystyle\sum_{k=1}^N{a_kz^{-k}}}=\underset{H_1\left(
z \right)}{\underbrace{\sum_{k=0}^M{b_kz^{-k}}}}\times
\underset{H_2\left( z \right)}{\underbrace{\left(
1-\displaystyle\sum_{k=1}^N{a_kz^{-k}} \right) ^{-1}}}
\end{equation}\]</span></p>
<p>将系统框图变为</p>
<figure>
<img data-src="../images/post/2023-04-15-josh-dsp-part-6/2023-04-15-josh-dsp-part-6-090-Direct2SystemBlock.png" width="500" alt="直接Ⅱ型系统框图">
<figcaption aria-hidden="true">直接Ⅱ型系统框图</figcaption>
</figure>
<p>由此可得系统的两级输入输出的微分方程</p>
<p><span class="math display">\[\begin{equation}
H_2\left(z\right)=\left(1-\sum_{k=1}^{N}{a_kz^{-k}}\right)^{-1}=\frac{W\left(z\right)}{X\left(z\right)}\Longrightarrow
w\left(n\right)=x\left(n\right)+\sum_{k=1}^{M}{a_kx\left(n-k\right)}
\end{equation}\]</span></p>
<p><span class="math display">\[\begin{equation}
H_1\left(z\right)=\sum_{k=0}^{M}{b_kz^{-k}}=\frac{Y\left(z\right)}{W\left(z\right)}\Longrightarrow
y\left(n\right)=\sum_{k=0}^{M}{b_kw\left(n-k\right)}
\end{equation}\]</span></p>
<p>由微分方程可得直接Ⅱ型 IIR 滤波器的流图</p>
<figure>
<img data-src="../images/post/2023-04-15-josh-dsp-part-6/2023-04-15-josh-dsp-part-6-100-Direct2IIRFlow.png" width="400" alt="直接Ⅱ型 IIR 滤波器的流图">
<figcaption aria-hidden="true">直接Ⅱ型 IIR 滤波器的流图</figcaption>
</figure>
<ul>
<li><p>直接型 IIR 滤波器的结构特点</p>
<table>
<tbody><tr>
<td>
</td>
<th>
<p>直接Ⅰ型</p>
</th>
<th>
<p>直接Ⅱ型</p>
</th>
</tr>
<tr>
<th rowspan="2">
<p>不同点</p>
</th>
<td>
<p>两个网络级联：第一个横向结构 <i>M</i>
节延时网络实现零点，第二个有反馈的 <i>N</i> 节延时网络实现极点。</p>
</td>
<td>
<p>两个网络级联：第一个有反馈的 <i>N</i>
节延时网络实现极点，第二个横向结构 <i>M</i> 节延时网络实现零点。</p>
</td>
</tr>
<tr>
<td>
<p>延时单元数：<i>N</i> + <i>M</i><br>乘法器数：<i>N</i> + <i>M</i> +
1<br>加法器数：1</p>
</td>
<td>
<p>延时单元数：max{<i>N</i> , <i>M</i>}<br>乘法器数：<i>N</i> + <i>M</i>
+ 1<br>加法器数：2</p>
</td>
</tr>
<tr>
<th rowspan="3">
<p>相同点</p>
</th>
<td colspan="2">
<p>系数 <i>a<sub>k</sub> , b<sub>k</sub></i>
不能直接决定单个零极点，因而不能很好地进行滤波器性能控制。</p>
</td>
</tr>
<tr>
<td colspan="2">
<p>极点对系数（零极点的位置）变化过于灵敏，从而使系统频率响应对系数变化过于灵敏，也就是对有限精度（有限字长）运算过于灵敏，容易出现不稳定或产生较大误差。</p>
</td>
</tr>
<tr>
<td colspan="2">
<p>计算的累积误差较大</p>
</td>
</tr>
</tbody></table></li>
</ul>
<h2 id="级联型">2.3. 级联型</h2>
<p>  将系统函数按零极点因式分解，可表示为</p>
<p><span class="math display">\[\begin{equation}
H\left(z\right)=\frac{\displaystyle\sum_{k=0}^{M}{b_kz^{-k}}}{1-\displaystyle\sum_{k=1}^{N}{a_kz^{-k}}}=A\frac{\displaystyle\prod_{k=1}^{M_1}\left(1-p_kz^{-1}\right)\displaystyle\prod_{k=1}^{M_2}\left(1-q_kz^{-1}\right)\left(1-q_k^\ast
z^{-1}\right)}{\displaystyle\prod_{k=1}^{N_1}\left(1-c_kz^{-1}\right)\displaystyle\prod_{k=1}^{N_2}\left(1-d_kz^{-1}\right)\left(1-d_k^\ast
z^{-1}\right)}
\end{equation}\]</span></p>
<p>其中 <span class="math inline">\(A\)</span> 为常数，<span class="math inline">\(M=M_1+2M_2\)</span>，<span class="math inline">\(N=N_1+2N_2\)</span>，<span class="math inline">\(p_k,c_k\)</span>分别为实数零、极点，<span class="math inline">\(q_k,q_k^\ast\)</span> 和 <span class="math inline">\(d_k,d_k^\ast\)</span>
分别为复共轭零、极点。将共轭成对的复数零、极点合并为为实系数二阶多项式，得</p>
<p><span class="math display">\[\begin{equation}
H\left(z\right)=A\prod_{k=1}^{L}\left[\frac{1+\beta_{1k}z^{-1}+\beta_{2k}z^{-2}}{1-\alpha_{1k}z^{-1}-\alpha_{2k}z^{-2}}\right]=A\prod_{k=1}^{L}{H_k\left(z\right)},\
\ L=\left\lfloor\frac{N+1}{2}\right\rfloor
\end{equation}\]</span></p>
<p>则系统框图可表示为</p>
<figure>
<img data-src="../images/post/2023-04-15-josh-dsp-part-6/2023-04-15-josh-dsp-part-6-110-CascadingIIRBlock.png" width="700" alt="级联型 IIR 滤波器的系统框图">
<figcaption aria-hidden="true">级联型 IIR 滤波器的系统框图</figcaption>
</figure>
<p>进一步可得级联型 IIR 滤波器的流图</p>
<figure>
<img data-src="../images/post/2023-04-15-josh-dsp-part-6/2023-04-15-josh-dsp-part-6-120-CascadingIIRFlow.png" width="700" alt="级联型 IIR 滤波器的流图">
<figcaption aria-hidden="true">级联型 IIR 滤波器的流图</figcaption>
</figure>
<ul>
<li><p>级联型 IIR 滤波器的结构特点</p>
<ul>
<li><p>分别调整系数 <span class="math inline">\(\beta_{1k},\beta_{2k}\)</span>、<span class="math inline">\(\alpha_{1k},\alpha_{2k}\)</span>，能单独调整滤波器的第k对零、极点，而不影响其它零、极点，由此，可以方便的调整滤波器的频响性能。</p></li>
<li><p>运算的累积误差较小、所需存储单元少，可实现时分复用、组合方式多等。</p></li>
</ul></li>
</ul>
<h2 id="并联型">2.4. 并联型</h2>
<p>  将系统函数展开成部分分式的形式，可表示为</p>
<p><span class="math display">\[\begin{equation}
H\left(z\right)=\sum_{k=0}^{M-N}{G_kz^{-k}}+\sum_{k=1}^{N_1}\frac{A_k}{1-g_kz^{-1}}+\sum_{k=1}^{N_2}\frac{\beta_{0k}+\beta_{1k}z^{-1}}{1-\alpha_{1k}z^{-1}-\alpha_{2k}z^{-2}}
\end{equation}\]</span></p>
<p>其中 <span class="math inline">\(G_k,A_k,g_k,\beta_{0k},\beta_{1k},\alpha_{1k},\alpha_{2k}\)</span>
均为实数。且当 <span class="math inline">\(M&lt;N\)</span>
时，上式不包含 <span class="math inline">\(\displaystyle\sum_{k=0}^{M-N}{G_kz^{-k}}\)</span>
项；当 <span class="math inline">\(M=N\)</span> 时，上式变为</p>
<p><span class="math display">\[\begin{equation}
H\left(z\right)=G_0+\sum_{k=1}^{N_1}\frac{A_k}{1-g_kz^{-1}}+\sum_{k=1}^{N_2}\frac{\beta_{0k}+\beta_{1k}z^{-1}}{1-\alpha_{1k}z^{-1}-\alpha_{2k}z^{-2}}\
(M=N)
\end{equation}\]</span></p>
<p>可得 <span class="math inline">\(M=N\)</span> 时并联型 IIR
滤波器的系统框图和流图</p>
<figure>
<img data-src="../images/post/2023-04-15-josh-dsp-part-6/2023-04-15-josh-dsp-part-6-130-ParallelIIRBlockFlow.png" width="1000" alt="并联型 IIR 滤波器的系统框图和流图">
<figcaption aria-hidden="true">并联型 IIR
滤波器的系统框图和流图</figcaption>
</figure>
<ul>
<li><p>并联型IIR滤波器的结构特点</p>
<ul>
<li><p>通过调整系数 <span class="math inline">\(\alpha_{1k},\alpha_{2k}\)</span>，可单独调整一对极点位置，但不能单独调整零点位置。</p></li>
<li><p>各并联基本节的误差互相不影响，故运算累积误差小。</p></li>
<li><p>可进行并行运算，运算速度高。</p></li>
</ul></li>
</ul>
<h2 id="转置定理">2.5. 转置定理</h2>
<p>  对于单输入单输出系统，将原网络中所有支路方向倒转，并将输入 <span class="math inline">\(x\left(n\right)\)</span> 和输出 <span class="math inline">\(y\left(n\right)\)</span>
相互交换，则倒转后的结构与原结构的系统函数 <span class="math inline">\(H(z)\)</span> 向相同。</p>
<h1 id="firfinite-impulse-response数字滤波器的基本结构">3. FIR（Finite
Impulse Response）数字滤波器的基本结构</h1>
<p>  FIR 数字滤波器的结构特点</p>
<p><span class="math display">\[\begin{align}
&amp;系统函数：H\left(z\right)=\frac{Y\left(z\right)}{X\left(z\right)}=\sum_{n=0}^{N-1}{h\left(n\right)z^{-n}}\\
&amp;差分方程：y\left(n\right)=\sum_{k=0}^{N-1}h\left(k\right)x\left(n-k\right)=h\left(n\right)\ast
x\left(n\right)
\end{align}\]</span></p>
<ul>
<li><p>系统的单位脉冲响应 <span class="math inline">\(h(n)\)</span>
有限长（<span class="math inline">\(N\)</span> 点）；</p></li>
<li><p>系统函数 <span class="math inline">\(H\left(z\right)\)</span> 在
<span class="math inline">\(\left|z\right|&gt;0\)</span> 处收敛，有限
<span class="math inline">\(z\)</span> 平面只有零点，全部极点在 <span class="math inline">\(z=0\)</span> 处（因果系统）；</p></li>
<li><p>没有输出到输入的反馈，一般为非递归型结构。</p></li>
</ul>
<h2 id="直接型卷积型横截型">3.1. 直接型（卷积型、横截型）</h2>
<p>  由 FIR 数字滤波器的差分方程</p>
<p><span class="math display">\[\begin{equation}
y\left(n\right)=\sum_{k=0}^{N=1}h\left(k\right)x\left(n-k\right)=h\left(n\right)\ast
x\left(n\right)
\end{equation}\]</span></p>
<p>可得直接型 FIR 滤波器的流图</p>
<figure>
<img data-src="../images/post/2023-04-15-josh-dsp-part-6/2023-04-15-josh-dsp-part-6-140-Direct1FIRFlow.png" width="600" alt="直接型 FIR 滤波器的流图">
<figcaption aria-hidden="true">直接型 FIR 滤波器的流图</figcaption>
</figure>
<h2 id="级联型-1">3.2. 级联型</h2>
<p>  当需要灵活方便地控制滤波器的传输零点时，可将 <span class="math inline">\(H\left(z\right)\)</span>
分解成实系数二阶因式的乘积形式，表示为</p>
<p><span class="math display">\[\begin{equation}
H\left(z\right)=\sum_{n=0}^{N-1}{h\left(n\right)z^{-n}}=\sum_{k=1}^{\left\lfloor\frac{N}{2}\right\rfloor}\left(\beta_{0k}+\beta_{1k}z^{-1}+\beta_{2k}z^{-2}\right)
\end{equation}\]</span></p>
<p>可得级联型 FIR 滤波器的流图</p>
<figure>
<img data-src="../images/post/2023-04-15-josh-dsp-part-6/2023-04-15-josh-dsp-part-6-150-CascadingFIRFlow.png" width="600" alt="级联型 FIR 滤波器的流图">
<figcaption aria-hidden="true">级联型 FIR 滤波器的流图</figcaption>
</figure>
<ul>
<li><p>级联型FIR滤波器的结构特点：</p>
<ul>
<li><p>由于这种结构所需的系数比直接型多，所需乘法运算也比直接型多，很少用。</p></li>
<li><p>由于这种结构的每一节控制一对零点，因而通常仅在需要控制传输零点时用。</p></li>
</ul></li>
</ul>
<h2 id="频率取样型">3.3. 频率取样型</h2>
<p>  系统函数 <span class="math inline">\(H\left(z\right)\)</span>
在单位圆上作 <span class="math inline">\(N\)</span> 等分取样的取样值就是
<span class="math inline">\(h\left(n\right)\)</span> 的 DFT <span class="math inline">\(H\left(k\right)\)</span>。由<a href="https://josh-gao.blog.csdn.net/article/details/106087154#5__319">内插公式</a>，用
<span class="math inline">\(H\left(k\right)\)</span> 恢复 <span class="math inline">\(H\left(z\right)\)</span> 的内插公式为</p>
<p><span class="math display">\[\begin{equation}
H\left( z \right) =\underset{H_c\left( z \right)}{\underbrace{\left(
1-z^{-N} \right) }}\frac{1}{N}\sum_{k=0}^{N-1}{\underset{H_k\left( z
\right)}{\underbrace{\frac{H\left( k \right)}{1-W_{N}^{-k}z^{-1}}}}}
\end{equation}\]</span></p>
<p>可见频率取样型 FIR 系统可用子 FIR 系统 <span class="math inline">\(H_c\left(z\right)=1-z^{-N}\)</span> 和子 IIR 系统
<span class="math inline">\(\displaystyle\sum_{k=0}^{N-1}{H_k\left(z\right)}\)</span>
表示。</p>
<h3 id="梳状滤波器-h_cleftzright">3.3.1. 梳状滤波器 <span class="math inline">\(H_c\left(z\right)\)</span></h3>
<figure>
<img data-src="../images/post/2023-04-15-josh-dsp-part-6/2023-04-15-josh-dsp-part-6-160-CombFilter.png" width="800" alt="梳状滤波器">
<figcaption aria-hidden="true">梳状滤波器</figcaption>
</figure>
<p>  子 FIR 系统 <span class="math inline">\(H_c\left(z\right)=1-z^{-N}\)</span> 是一个由 <span class="math inline">\(N\)</span>
节延迟单元组成的梳状滤波器，在单位圆上有 <span class="math inline">\(N\)</span>
个等分零点。可将梳状滤波器的频率响应写为</p>
<p><span class="math display">\[\begin{equation}
\begin{aligned}
H_c\left(e^{j\omega}\right)&amp;=\left.H_c\left(z\right)\right|_{z=e^{j\omega}}=1-e^{-j\omega
N}\\
&amp;=e^{-j\frac{\omega N}{2}}\left(e^{j\frac{\omega
N}{2}}-e^{-j\frac{\omega N}{2}}\right)=2je^{-j\frac{\omega
N}{2}}\sin{\frac{\omega N}{2}}
\end{aligned}
\end{equation}\]</span></p>
<p>其幅频特性</p>
<p><span class="math display">\[\begin{equation}
\left|H_c\left(e^{j\omega}\right)\right|=2\left|\sin{\frac{\omega
N}{2}}\right|
\end{equation}\]</span></p>
<h3 id="谐振柜-displaystylesum_k0n-1h_kleftzright">3.3.2. 谐振柜 <span class="math inline">\(\displaystyle\sum_{k=0}^{N-1}{H_k\left(z\right)}\)</span></h3>
<p>  子 IIR 系统 <span class="math inline">\(\displaystyle\sum_{k=0}^{N-1}{H_k\left(z\right)}\)</span>
是由 <span class="math inline">\(N\)</span>
个谐振器组成的谐振“柜”。每一个谐振器 <span class="math inline">\(H_k\left(z\right)=\dfrac{H\left(k\right)}{1-W_N^{-k}z^{-1}}\)</span>
都是一个一阶网络，在单位圆上有一极点 <span class="math inline">\(z_k=W_N^{-k}=e^{j\frac{2\pi}{N}k}\)</span>，因此谐振器对频率为
<span class="math inline">\(\omega=\dfrac{2\pi}{N}k\)</span> 的响应是
<span class="math inline">\(\infty\)</span>，是一个谐振频率为 <span class="math inline">\(\dfrac{2\pi}{N}k\)</span>
的无耗谐振器。并联谐振柜的极点正好各自抵消一个梳状滤波器的零点，从而使系统在频率点
<span class="math inline">\(\omega=\dfrac{2\pi}{N}k\)</span> 的响应就是
<span class="math inline">\(H\left(k\right)\)</span>。</p>
<p>  将梳状滤波器和谐振柜级联可得到频率取样型 FIR 滤波器的结构</p>
<figure>
<img data-src="../images/post/2023-04-15-josh-dsp-part-6/2023-04-15-josh-dsp-part-6-170-FrequencySampling.png" width="600" alt="频率取样型 FIR 滤波器的结构">
<figcaption aria-hidden="true">频率取样型 FIR 滤波器的结构</figcaption>
</figure>
<ul>
<li><p>频率取样型 FIR 滤波器的结构特点：</p>
<ul>
<li><p>（优点）调整 <span class="math inline">\(H\left(k\right)\)</span>
就可以有效地调整频响特性（在频率 <span class="math inline">\(\omega_k=\dfrac{2\pi}{N}k\)</span> 处的响应即为
<span class="math inline">\(H\left(k\right)\)</span>）。</p></li>
<li><p>（优点）若 <span class="math inline">\(h\left(n\right)\)</span>
长度相同，则除了各支路增益 <span class="math inline">\(H\left(k\right)\)</span>
外网络结构完全相同，便于标准化、模块化。</p></li>
<li><p>（缺点）有限字长效应可能导致零极点不能完全对消(梳状滤波器的零点由延时器形成，并不受量化误差影响)，导致系统不稳定。</p></li>
<li><p>（缺点）系数多为复数，增加了复数乘法和存储量。</p></li>
</ul></li>
</ul>
<h3 id="修正频率取样型">3.3.3. 修正频率取样型</h3>
<p>  由于谐振器的所有极点均在单位圆上，当系数量化时，这些极点会移动，因此系统的稳定裕度为零，实际上是不能使用的。因此将所有谐振器的极点设置在半径
<span class="math inline">\(r\)</span> 小于 <span class="math inline">\(1\)</span> 又接近于 <span class="math inline">\(1\)</span> 的圆周上，为了使得子 FIR
系统的零点需要和这些极点重合以相互抵消，故梳状滤波器的零点也移到半径r的圆周上。修正后的系统函数为</p>
<p><span class="math display">\[\begin{equation}
H\left(z\right)=\frac{1-r^Nz^{-N}}{N}\sum_{k=0}^{N-1}\frac{H_r\left(k\right)}{1-rW_N^{-k}z^{-1}}
\end{equation}\]</span></p>
<p>此时谐振柜的第 <span class="math inline">\(k\)</span>
个谐振器的极点变为 <span class="math inline">\(rW_N^{-k}\)</span>，其中
<span class="math inline">\(H_r\left(k\right)\)</span>
是修正点的取样值，因为 <span class="math inline">\(r\approx1\)</span>，则</p>
<p><span class="math display">\[\begin{equation}
H_r\left(k\right)=\left.H\left(z\right)\right|_{z=rW_N^{-k}}=H\left(rW_N^{-k}\right)\approx
H\left(W_N^{-k}\right)=H\left(k\right)
\end{equation}\]</span></p>
<p>则修正后的系统函数可近似为</p>
<p><span class="math display">\[\begin{equation}
H\left(z\right)=\frac{1-r^Nz^{-N}}{N}\sum_{k=0}^{N-1}\frac{H\left(k\right)}{1-rW_N^{-k}z^{-1}}
\end{equation}\]</span></p>
<p>为了使系数是实数，将共轭根合并，这些共轭根在半径为r的圆周上以实轴对称分布。由对称性
<span class="math inline">\(z_{N-k}=z_k^\ast,W_N^{-\left(N-k\right)}=W_N^k=\left(W_N^{-k}\right)^\ast\)</span>，将第
<span class="math inline">\(k\)</span> 个和第 <span class="math inline">\(N-k\)</span>
个谐振器合并成一个实系数的二阶网络</p>
<p><span class="math display">\[\begin{equation}
\begin{aligned}
H_k\left(z\right)&amp;\approx\frac{H\left(k\right)}{1-rW_N^{-k}z^{-1}}+\frac{H\left(N-k\right)}{1-rW_N^{-\left(N-k\right)}z^{-1}}=\frac{H\left(k\right)}{1-rW_N^{-k}z^{-1}}+\frac{H^\ast\left(k\right)}{1-r\left(W_N^{-k}\right)^\ast
z^{-1}}\\
&amp;=\frac{H\left(k\right)+H^\ast\left(k\right)-H\left(k\right)rW_N^kz^{-1}-H^\ast\left(k\right)rW_N^{-k}z^{-1}}{1-z^{-1}\left(W_N^{-k}+W_N^k\right)+r^2z^{-2}}\\
&amp;=\frac{\beta_{0k}+\beta_{1k}z^{-1}}{1-z^{-1}2r\cos{\left(\frac{2\pi}{N}k\right)+r^2z^{-2}}}
\end{aligned}
\end{equation}\]</span></p>
<p>其中</p>
<p><span class="math display">\[\begin{equation}
\begin{cases}
\beta_{0k}=2\Re{\left[H\left(k\right)\right]}\\
\beta_{1k}=-2r\Re{\left[H\left(k\right)W_N^k\right]}
\end{cases},\ \
\begin{cases}
\begin{aligned}
k&amp;=1,2,\cdots,\frac{N-1}{2},\ \ &amp;k为奇数\\
k&amp;=1,2,\cdots,\frac{N}{2},&amp;k为偶数
\end{aligned}
\end{cases}
\end{equation}\]</span></p>
<figure>
<img data-src="../images/post/2023-04-15-josh-dsp-part-6/2023-04-15-josh-dsp-part-6-180-ModifiedFrequencySampling.png" width="800" alt="修正频率取样型">
<figcaption aria-hidden="true">修正频率取样型</figcaption>
</figure>
<p>  当 <span class="math inline">\(N\)</span>
为偶数时，除了共轭根，还有一对实数根，分别位于 <span class="math inline">\(k=0,\dfrac{N}{2}\)</span>
两点，则此时系统函数为</p>
<p><span class="math display">\[\begin{equation}
H\left(z\right)=\left(1-r^Nz^{-N}\right)\cdot\frac{1}{N}\cdot\left[H_0\left(z\right)+H_\frac{N}{2}\left(z\right)+\sum_{k=1}^{\frac{N}{2}-1}{H_k\left(z\right)}\right]
\end{equation}\]</span></p>
<p>  当 <span class="math inline">\(N\)</span>
为奇数时，除了共轭根，只有一个实数根，位于 <span class="math inline">\(k=0\)</span> 处，则此时系统函数为</p>
<p><span class="math display">\[\begin{equation}
H\left(z\right)=\left(1-r^Nz^{-N}\right)\cdot\frac{1}{N}\cdot\left[H_0\left(z\right)+\sum_{k=1}^{\frac{N-1}{2}}{H_k\left(z\right)}\right]
\end{equation}\]</span></p>
<p>在上两式中</p>
<p><span class="math display">\[\begin{equation}
H_0\left(z\right)=\frac{H\left(0\right)}{1-rz^{-1}},\ \
H_\frac{N}{2}\left(z\right)=\frac{H\left(\dfrac{N}{2}\right)}{1+rz^{-1}}
\end{equation}\]</span></p>
<p>则修正频率取样型 FIR 滤波器的结构为</p>
<figure>
<img data-src="../images/post/2023-04-15-josh-dsp-part-6/2023-04-15-josh-dsp-part-6-190-ModifiedFrequencySamplingFIRStructure.png" width="600" alt="修正频率取样型 FIR 滤波器的结构">
<figcaption aria-hidden="true">修正频率取样型 FIR
滤波器的结构</figcaption>
</figure>
<ul>
<li><p>修正频率取样型 FIR 滤波器的结构特点：</p>
<ul>
<li><p>结构有递归部分——谐振柜；又有非递归部分——梳状滤波器。</p></li>
<li><p>它的零、极点数目只取决于单位脉冲响应的长度，因而单位脉冲响应长度相同。利用同一梳状滤波器、同一结构而只有加权系数
<span class="math inline">\(\beta_{0k},\beta_{1k},H\left(0\right),H\left(\dfrac{N}{2}\right)\)</span>
不同的谐振器，就能得到不同的滤波器。</p></li>
<li><p>其结构可以高度模块化，可时分复用。</p></li>
</ul></li>
</ul>
<h2 id="线性相位型">3.4. 线性相位型</h2>
<p>  线性相位的因果FIR系统的单位取样响应满足</p>
<p><span class="math display">\[\begin{equation}
h\left(n\right)=\pm h\left(N-1-n\right)
\end{equation}\]</span></p>
<p>即序列要么是奇对称的，要么是偶对称的。</p>
<p>  当 <span class="math inline">\(N\)</span>
为奇数时，系统函数可表示为</p>
<p><span class="math display">\[\begin{equation}
\begin{aligned}
H\left(z\right)&amp;=\sum_{n=0}^{N-1}{h\left(n\right)z^{-n}}=\sum_{n=0}^{\frac{N-1}{2}-1}{h\left(n\right)z^{-n}}+h\left(\frac{N-1}{2}\right)z^\frac{N-1}{2}+\sum_{n=\frac{N-1}{2}+1}^{N-1}{h\left(n\right)z^{-n}}\\
&amp;=\sum_{n=0}^{\frac{N-1}{2}-1}h\left(n\right)\left[z^{-n}\pm
z^{-\left(N-1-n\right)}\right]+h\left(\frac{N-1}{2}\right)z^\frac{N-1}{2}
\end{aligned}
\end{equation}\]</span></p>
<p>  当 <span class="math inline">\(N\)</span>
为偶数时，系统函数可表示为</p>
<p><span class="math display">\[\begin{equation}
H\left(z\right)=\sum_{n=0}^{N-1}{h\left(n\right)z^{-n}}=\sum_{n=0}^{\frac{N}{2}-1}{h\left(n\right)z^{-n}}+\sum_{n=\frac{N}{2}}^{N-1}{h\left(n\right)z^{-n}}=\sum_{n=0}^{\frac{N}{2}-1}h\left(n\right)\left[z^{-n}\pm
z^{-\left(N-1-n\right)}\right]
\end{equation}\]</span></p>
<p><strong>当序列 <span class="math inline">\(h\left(n\right)\)</span>
偶对称时，取“<span class="math inline">\(+\)</span>”号；当序列奇对称时，取“<span class="math inline">\(-\)</span>”号</strong>。则线性相位型 FIR
滤波器的结构为</p>
<figure>
<img data-src="../images/post/2023-04-15-josh-dsp-part-6/2023-04-15-josh-dsp-part-6-200-LinearPhaseFIRStructure.png" width="900" alt="线性相位型 FIR 滤波器的结构">
<figcaption aria-hidden="true">线性相位型 FIR 滤波器的结构</figcaption>
</figure>
<h2 id="快速卷积型略">3.5. 快速卷积型（略）</h2>
<h1 id="参考文献">参考文献</h1>
<p>王世一. <em>数字信号处理, 修订版.</em> 北京理工大学出版社, 1997.</p>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/css/markmap.css">

<script src="/js/markmap.js"></script>
]]></content>
      <categories>
        <category>Josh 的学习笔记</category>
        <category>数字信号处理</category>
      </categories>
      <tags>
        <tag>数字信号和处理</tag>
        <tag>DSP</tag>
        <tag>IIR</tag>
        <tag>FIR</tag>
        <tag>直接型</tag>
        <tag>级联型</tag>
        <tag>并联型</tag>
        <tag>梳状滤波器</tag>
        <tag>谐振柜</tag>
        <tag>频率取样</tag>
        <tag>线性相位</tag>
      </tags>
  </entry>
  <entry>
    <title>Josh&#39;s Review — 数字信号处理&lt;br&gt;Part 7 数字滤波器设计</title>
    <url>/posts/60664a7e.html</url>
    <content><![CDATA[<h1 id="幅度平方响应与数字滤波器的技术指标">1.
幅度平方响应与数字滤波器的技术指标</h1>
<h2 id="幅度平方响应">1.1. 幅度平方响应</h2>
<p>  常采用滤波器的幅度平方响应 <span class="math inline">\(\left|H\left(e^{j\omega}\right)\right|^2\)</span>
来描述滤波器的选频特性。</p>
<h2 id="数字滤波器的技术指标">1.2. 数字滤波器的技术指标</h2>
<figure>
<img data-src="../images/post/2023-04-15-josh-dsp-part-7/2023-04-15-josh-dsp-part-7-010-DigtalFilterBenchmark.png" width="600" alt="数字滤波器的技术指标">
<figcaption aria-hidden="true">数字滤波器的技术指标</figcaption>
</figure>
<ol type="1">
<li><p>通带截止频率（passband edge frequency）：<span class="math inline">\(\omega_p\)</span>。</p></li>
<li><p>阻带截止频率（stopband edge frequency）：<span class="math inline">\(\omega_s\)</span>。</p></li>
<li><p>通带波动（passband ripple in dB）：<span class="math inline">\(R_p=-10\lg{\dfrac{1}{1+\varepsilon^2}}\)</span>，其中
<span class="math inline">\(\varepsilon\)</span>
为通带波动系数。</p></li>
<li><p>阻带衰减（stopband attenuation in dB）：<span class="math inline">\(A_s=20\lg{\delta}\)</span>。</p></li>
</ol>
<span id="more"></span>
<h1 id="低通-iir-数字滤波器设计">2. 低通 IIR 数字滤波器设计</h1>
<h2 id="巴特沃斯butterworth模拟原型滤波器">2.1.
巴特沃斯（Butterworth）模拟原型滤波器</h2>
<figure>
<img data-src="../images/post/2023-04-15-josh-dsp-part-7/2023-04-15-josh-dsp-part-7-020-ButterworthAnalogFilter.png" width="500" alt="巴特沃斯（Butterworth）模拟原型滤波器">
<figcaption aria-hidden="true">巴特沃斯（Butterworth）模拟原型滤波器</figcaption>
</figure>
<h3 id="幅度平方频率响应">2.1.1. 幅度平方频率响应</h3>
<p>  <span class="math inline">\(N\)</span> 阶 Butterworth
模拟滤波器的幅度平方频率响应为</p>
<p><span class="math display">\[\begin{equation}
A^2\left(\Omega\right)=\left|H_a\left(j\Omega\right)\right|^2=\frac{1}{1+\left(\dfrac{\Omega}{\Omega_c}\right)^{2N}}
\end{equation}\]</span></p>
<p>其中 <span class="math inline">\(A^2\left(\Omega\right)\)</span>
为幅度平方函数，整数 <span class="math inline">\(N\)</span>
为滤波器阶数，<span class="math inline">\(\Omega_c\)</span> 为 3 dB
截止频率，<span class="math inline">\(\Omega_p\)</span>
为通带截止频率，<span class="math inline">\(\left(1+\varepsilon^2\right)^{-1}\)</span>
为通带截止频率处的幅度平方频响值，<span class="math inline">\(\Omega_s\)</span> 为阻带截止频率，<span class="math inline">\(\delta^2\)</span>
为阻带截止频率处的幅度平方频响值。</p>
<p>  Butterworth 滤波器在通带中拥有最大平坦的振幅特性，即 <span class="math inline">\(N\)</span> 阶低通 Butterworth 滤波器在 <span class="math inline">\(\Omega=0\)</span> 处的幅度平方函数的前 <span class="math inline">\((2N-1)\)</span>
阶导数等于零，在止带内接近于单调变化。</p>
<h3 id="极点分布及系统函数的确定">2.1.2. 极点分布及系统函数的确定</h3>
<p>  <span class="math inline">\(N\)</span> 阶 Butterworth
模拟滤波器的幅度平方频率响应可表示为</p>
<p><span class="math display">\[\begin{equation}
\begin{aligned}
A^2\left(\Omega\right)&amp;=\left|H_a\left(j\Omega\right)\right|^2=H_a\left(j\Omega\right)H_a^\ast\left(j\Omega\right)=H_a\left(j\Omega\right)H_a\left(-j\Omega\right)\\
&amp;=\left.H_a\left(s\right)H_a\left(-s\right)\right|_{s=j\Omega}=\frac{1}{1+\left(\dfrac{s}{j\Omega_c}\right)^{2N}}
\end{aligned}
\end{equation}\]</span></p>
<p>令 <span class="math inline">\(A^2\left(\Omega\right)=0\)</span>，可解得极点</p>
<p><span class="math display">\[\begin{equation}
s_k=\left(-1\right)^\frac{1}{2N}\left(j\Omega_c\right)=\Omega_ce^{j\left(\frac{1}{2}+\frac{2k+1}{2N}\right)\pi},\
\ k=0,1,\cdots,2N-1
\end{equation}\]</span></p>
<p>由此可得常用低阶次Butterworth滤波器的系统函数</p>
<table>
<colgroup>
<col style="width: 20%">
<col style="width: 80%">
</colgroup>
<thead>
<tr>
<th style="text-align: center;">阶次</th>
<th style="text-align: center;">系统函数 <span class="math inline">\(H_a\left(s\right)=\dfrac{\left(-1\right)^Ns_0s_1\cdots
s_{N-1}}{\left(s-s_0\right)\left(s-s_1\right)\cdots(s-s_{N-1})}\)</span></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">1</td>
<td style="text-align: center;"><span class="math inline">\(\displaystyle\frac{\Omega_c}{\left(s+\Omega_c\right)}\)</span></td>
</tr>
<tr>
<td style="text-align: center;">2</td>
<td style="text-align: center;"><span class="math inline">\(\displaystyle\frac{\Omega_c^2}{\left(s^2+\sqrt2\Omega_cs+\Omega_c^2\right)}\)</span></td>
</tr>
<tr>
<td style="text-align: center;">3</td>
<td style="text-align: center;"><span class="math inline">\(\displaystyle\frac{\Omega_c^3}{(s^3+2\Omega_cs^2+2\Omega_c^2s+\Omega_c^3)}\)</span></td>
</tr>
</tbody>
</table>
<h3 id="参数-n-和-omega_c-的确定">2.1.3. 参数 <span class="math inline">\(N\)</span> 和 <span class="math inline">\(\Omega_c\)</span> 的确定</h3>
<h4 id="参数选取原则">2.1.3.1. 参数选取原则</h4>
<ol type="1">
<li><p>在通带范围内允许的最大衰减为 <span class="math inline">\(\left(1+\varepsilon^2\right)^{-1}\)</span> 或
<span class="math inline">\(\alpha_p\text{dB}\)</span>，截止频率为<span class="math inline">\(\Omega_p\)</span>。</p>
<p><span class="math display">\[\begin{equation}
10\lg{\frac{1}{1+\varepsilon^2}}=-\alpha_p\Longrightarrow\lg{\left(1+\varepsilon^2\right)}=\frac{\alpha_p}{10}\Longrightarrow\varepsilon=\sqrt{10^{\frac{\alpha_p}{10}-1}}
\end{equation}\]</span></p></li>
<li><p>在阻带范围内允许的最小衰减为 <span class="math inline">\(\delta^2\)</span> 或 <span class="math inline">\(\alpha_s\text{dB}\)</span>，临界频率为 <span class="math inline">\(\Omega_s\)</span>。</p>
<p><span class="math display">\[\begin{equation}
10\lg{\delta^2}=-\alpha_s\Longrightarrow\delta^{-2}={10}^\frac{\alpha_s}{10}
\end{equation}\]</span></p></li>
</ol>
<h4 id="参数确定">2.1.3.2. 参数确定</h4>
<p>  由参数选取原则，有</p>
<p><span class="math display">\[\begin{equation}
\begin{aligned}
&amp;\left|H_a\left(j\Omega_p\right)\right|^2=\frac{1}{1+\left(\frac{\Omega_p}{\Omega_c}\right)^{2N}}\geqslant\frac{1}{1+\varepsilon^2}\Longrightarrow\left(\frac{\Omega_p}{\Omega_c}\right)^{2N}\leqslant\varepsilon^2\\
\Longrightarrow&amp;\left(\frac{\Omega_c}{\Omega_p}\right)^N\geqslant\varepsilon^{-1}\\
&amp;\left|H_a\left(j\Omega_s\right)\right|^2=\frac{1}{1+\left(\dfrac{\Omega_s}{\Omega_c}\right)^{2N}}\leqslant\delta^2\Longrightarrow\left(\frac{\Omega_s}{\Omega_c}\right)^{2N}\geqslant\delta^{-2}-1\\
\Longrightarrow&amp;\left(\frac{\Omega_s}{\Omega_c}\right)^N\geqslant\sqrt{\delta^{-2}-1}
\end{aligned}
\end{equation}\]</span></p>
<p>由上两式，有</p>
<p><span class="math display">\[\begin{equation}
N\geqslant\left\lceil\frac{\lg{\left(\dfrac{\sqrt{\delta^{-2}-1}}{\varepsilon}\right)}}{\lg{\left(\dfrac{\Omega_s}{\Omega_p}\right)}}\right\rceil=\left\lceil\frac{\lg{\dfrac{10^\frac{\alpha_s}{10}-1}{10^\frac{\alpha_p}{10}-1}}}{2\lg{\left(\dfrac{\Omega_s}{\Omega_p}\right)}}\right\rceil
\end{equation}\]</span></p>
<p><span class="math display">\[\begin{equation}
\Omega_c\in\left[\Omega_p\varepsilon^{-\frac{1}{N}},\Omega_s\left(\delta^2-1\right)^{-\frac{1}{2N}}\right]=\left[\Omega_p\left({10}^\frac{\alpha_p}{10}-1\right)^{-\frac{1}{2N}},\Omega_s\left({10}^\frac{\alpha_s}{10}-1\right)^{-\frac{1}{2N}}\right]
\end{equation}\]</span></p>
<p>对于 <span class="math inline">\(\Omega_c\)</span>，通常取其下边带即可，即</p>
<p><span class="math display">\[\begin{equation}
\Omega_c=\Omega_p\varepsilon^{-\frac{1}{N}}=\Omega_p\left({10}^\frac{\alpha_p}{10}-1\right)^{-\frac{1}{2N}}
\end{equation}\]</span></p>
<h2 id="模拟原型低通滤波器数字化的时域方法脉冲响应不变法impulse-invariance-method">2.2.
模拟原型低通滤波器数字化的时域方法——脉冲响应不变法（Impulse Invariance
Method）</h2>
<h3 id="变换原理">2.2.1. 变换原理</h3>
<p>  对模拟原型滤波器的系统函数 <span class="math inline">\(H_a\left(s\right)\)</span>
进行反拉氏变换，得到相应模拟滤波器的单位脉冲响应 <span class="math inline">\(h_a\left(t\right)\)</span>，即</p>
<p><span class="math display">\[\begin{equation}
h_a\left(t\right)=\mathrm{ILT}\left[H_a\left(s\right)\right]=\mathrm{ILT}\left[\sum_{k=0}^{N-1}\frac{c_k}{s-s_k}\right]=\sum_{k=0}^{N-1}{c_ke^{s_kt}u\left(t\right)}
\end{equation}\]</span></p>
<p>对模拟滤波器的单位脉冲响应进行采样后进行 <span class="math inline">\(z\)</span> 变换即可得到数字滤波器的系统函数 <span class="math inline">\(H\left(z\right)\)</span>，即</p>
<p><span class="math display">\[\begin{equation}
H\left(z\right)=\mathrm{ZT}\left[h\left(n\right)\right]=\mathrm{ZT}\left[\left.h_a\left(t\right)\right|_{t=nT}\right]
\end{equation}\]</span></p>
<p>在实际设计时，为了避免数字滤波器在取样间隔T很小(采样频率很高)的情况下出现过高的增益，对取样进行如下修正</p>
<p><span class="math display">\[\begin{equation}
h\left(n\right)=Th_a\left(nT\right)
\end{equation}\]</span></p>
<p>由此可将导出 Butterworth 数字低通滤波器的系统函数</p>
<p><span class="math display">\[\begin{equation}
\begin{aligned}
H\left(z\right)&amp;=\mathrm{ZT}\left[h\left(n\right)\right]=\mathrm{ZT}\left[Th_a\left(nT\right)\right]=\mathrm{ZT}\left[\sum_{k=0}^{N-1}{Tc_ke^{s_knT}u\left(t\right)}\right]\\
&amp;=\sum_{n=-\infty}^{\infty}{\left[\sum_{k=0}^{N-1}{Tc_k\left(e^{s_kT}\right)^nu\left(t\right)}\right]z^{-n}}=\sum_{k=0}^{N-1}{Tc_k\left[\sum_{n=0}^{\infty}\left(e^{s_kT}z^{-1}\right)^n\right]}\\
&amp;=\sum_{k=0}^{N-1}{Tc_k\left[ \lim_{N\rightarrow \infty}
\!\:\frac{1-\left( e^{s_kT}z^{-1} \right) ^N}{1-e^{s_kT}z^{-1}}
\right]}\\
&amp;\xlongequal{\left|z\right|&gt;\left|e^{s_kT}\right|}\sum_{k=1}^{N-1}\frac{Tc_k}{1-e^{s_kT}z^{-1}}
\end{aligned}
\end{equation}\]</span></p>
<p>对比模拟滤波器的单位脉冲响应 <span class="math inline">\(h_a\left(t\right)\)</span>，可得脉冲响应不变法的系统函数转换关系</p>
<p><span class="math display">\[\begin{equation}
H_a\left(s\right)=\sum_{k=0}^{N-1}\frac{c_k}{s-s_k}\Longleftrightarrow
H\left(z\right)=\sum_{k=1}^{N-1}\frac{Tc_k}{1-e^{s_kT}z^{-1}}
\end{equation}\]</span></p>
<h3 id="变换后数字滤波器的稳定性">2.2.2. 变换后数字滤波器的稳定性</h3>
<p>  模拟 Butterworth 滤波器的所有极点均在 <span class="math inline">\(s\)</span> 平面的左半平面内，其实部 <span class="math inline">\(\sigma_k&lt;0\)</span>，则在极点变化的过程中 <span class="math inline">\(s_k\Rightarrow
e^{s_kT}&lt;1\)</span>，即变换后得到的数字滤波器的极点位于 <span class="math inline">\(z\)</span>
平面的单位圆内，因而脉冲响应不变法所设计的数字滤波器也是稳定的。</p>
<h3 id="优缺点">2.2.3. 优缺点</h3>
<ol type="1">
<li><p>（优点）脉冲响应变换法的频率坐标变换是线性的，即 <span class="math inline">\(\omega=\Omega
T\)</span>。因此如果模拟滤波器的频响是带限的且在折叠频率以内的话，变换后的得到的数字滤波器的频响可以不失真地反映原响应与频率的关系</p>
<p><span class="math display">\[\begin{equation}
H\left(e^{j\Omega T}\right)=H\left(j\Omega\right),\ \
\left|\Omega\right|&lt;\frac{\pi}{T}
\end{equation}\]</span></p></li>
<li><p>（主要缺点）由于时域的取样，<span class="math inline">\(h_a\left(t\right)\)</span> 拉氏变换 <span class="math inline">\(H_a\left(s\right)\)</span> 在 <span class="math inline">\(s\)</span> 平面上沿虚轴周期延拓，然后再经过 <span class="math inline">\(z=e^{sT}\)</span> 的映射关系，将 <span class="math inline">\(H_a\left(s\right)\)</span> 映射到 <span class="math inline">\(z\)</span> 平面上，得到 <span class="math inline">\(H\left(z\right)\)</span>。对于上述修正后的变换</p>
<p><span class="math display">\[\begin{equation}
H\left(e^{j\omega}\right)=\left.H\left(z\right)\right|_{z=e^{j\omega}}=\sum_{k=0}^{N-1}\frac{Tc_k}{1-s^{s_kTe^{-j\omega}}}=\sum_{m=-\infty}^{\infty}{H_a\left(j\frac{\omega-2\pi
m}{T}\right)}\approx{\widetilde{H}}_a\left(j\frac{\omega}{T}\right)
\end{equation}\]</span></p>
<p>由于 <span class="math inline">\(H_a\left(s\right)\)</span>
的周期延拓，可能造成频谱混叠，导致滤波器的阻带性能降低。因此只能用于具有带限的频响特性的信号，<strong>一般用于设计低通、带通滤波器，而不用于设计高通、带阻滤波器</strong>。</p></li>
</ol>
<h3 id="脉冲响应不变法的主要步骤">2.2.4. 脉冲响应不变法的主要步骤</h3>
<ol type="1">
<li><p>确定滤波器的技术指标（通常在数字域给出）</p>
<ol type="1">
<li><p>通带、阻带的波动；</p></li>
<li><p>通带、过渡带、阻带的截止频率；</p></li>
<li><p>频率选择特性（低通）。</p></li>
</ol></li>
<li><p>对数字域的频率指标进行如下变换</p>
<p><span class="math display">\[\begin{equation}
\Omega=\frac{\omega}{T}
\end{equation}\]</span></p></li>
<li><p>选择模拟逼近方法（Butterworth），并确定其传递函数 <span class="math inline">\(H_a\left(s\right)\)</span>。</p></li>
<li><p>按照脉冲响应不变法的系统函数转换关系，将 <span class="math inline">\(H_a\left(s\right)\)</span> 转变为 <span class="math inline">\(H\left(z\right)\)</span>，完成数字化。</p>
<p><span class="math display">\[\begin{equation}
H_a\left(s\right)=\sum_{k=0}^{N-1}\frac{c_k}{s-s_k}\Longleftrightarrow
H\left(z\right)=\sum_{k=1}^{N-1}\frac{Tc_k}{1-e^{s_kT}z^{-1}}
\end{equation}\]</span></p></li>
</ol>
<h2 id="模拟原型低通滤波器数字化的频域方法双线性变换法bilinear-transform-method">2.3.
模拟原型低通滤波器数字化的频域方法——双线性变换法（Bilinear Transform
Method）</h2>
<h3 id="变换原理-1">2.3.1. 变换原理</h3>
<p>  由 <span class="math inline">\(s\)</span> 平面与 <span class="math inline">\(z\)</span> 平面的双线性变换关系（变化式中 <span class="math inline">\(s\)</span> 与 <span class="math inline">\(z\)</span>
的关系无论分子还是分母部分都是线性的）</p>
<p><span class="math display">\[\begin{equation}
s=\frac{2}{T}\cdot\frac{1-z^{-1}}{1+z^{-1}},\ \ z=\frac{2/T+s}{2/T-s}
\end{equation}\]</span></p>
<p>将 <span class="math inline">\(s=\sigma+j\omega\)</span> 代入可得</p>
<p><span class="math display">\[\begin{equation}
z=\frac{2/T+\sigma+j\Omega}{2/T-\sigma-j\Omega}\Longrightarrow\left|z\right|=\sqrt{\frac{\left(
2/T+\sigma\right)^2+\Omega^2}{\left(2/T-\sigma\right)^2+\Omega^2}}
\end{equation}\]</span></p>
<p>由上式，当 <span class="math inline">\(\sigma&lt;0\)</span> 时，<span class="math inline">\(\left|z\right|&lt;1\)</span>；当 <span class="math inline">\(\sigma=0\)</span> 时，<span class="math inline">\(\left|z\right|=1\)</span>；当 <span class="math inline">\(\sigma&gt;0\)</span> 时，<span class="math inline">\(\left|z\right|&gt;1\)</span>。也即把 <span class="math inline">\(s\)</span> 左半开平面映射在单位圆 <span class="math inline">\(\left|z\right|=1\)</span> 的内部；把 <span class="math inline">\(s\)</span> 平面的整个 <span class="math inline">\(j\Omega\)</span> 轴映射成单位圆 <span class="math inline">\(\left|z\right|=1\)</span>，把 <span class="math inline">\(s\)</span> 右半开平面映射到单位圆 <span class="math inline">\(\left|z\right|=1\)</span> 的外部。</p>
<p>由 <span class="math inline">\(s\)</span> 平面与 <span class="math inline">\(z\)</span> 平面的双线性变换关系（变化式中 <span class="math inline">\(s\)</span> 与 <span class="math inline">\(z\)</span>
的关系无论分子还是分母部考虑映射到单位圆上的情况，则由 <span class="math inline">\(s\)</span> 平面与 <span class="math inline">\(z\)</span>
平面的双线性变换关系可得模拟滤波器和数字滤波器的频率关系</p>
<p><span class="math display">\[\begin{equation}
\begin{aligned}
&amp;z=e^{j\omega}=\frac{2/T+j\Omega}{2/T-j\Omega}\\
\Longrightarrow&amp;\Omega=j\frac{2}{T}\cdot\frac{1-e^{j\omega}}{1+e^{j\omega}}=j\frac{2}{T}\cdot\frac{e^{j\frac{\omega}{2}}\left(e^{-j\frac{\omega}{2}}-e^{j\frac{\omega}{2}}\right)}{e^{j\frac{\omega}{2}}\left(e^{-j\frac{\omega}{2}}+e^{j\frac{\omega}{2}}\right)}=j\frac{2}{T}\cdot\frac{-2j\sin{\dfrac{\omega}{2}}}{2\cos{\dfrac{\omega}{2}}}=\dfrac{2}{T}\tan{\frac{\omega}{2}}
\end{aligned}
\end{equation}\]</span></p>
<h3 id="优缺点-1">2.3.2. 优缺点</h3>
<ol type="1">
<li><p>（优点）消除了混频误差。</p></li>
<li><p>（优点）在零频附近，模拟频率 <span class="math inline">\(\Omega\)</span> 与数字频率 <span class="math inline">\(\omega\)</span> 的关系接近与线性。</p></li>
<li><p>（缺点）模拟滤波器的全部频响特性被压缩在等效的数字频率 <span class="math inline">\(0&lt;\omega&lt;\pi\)</span>
之间，可见<strong>双线性变换消除混叠的特性是依托严重的非线性得到的</strong>。</p></li>
</ol>
<h3 id="双线性变换法的主要步骤">2.3.3. 双线性变换法的主要步骤</h3>
<ol type="1">
<li><p>确定滤波器的技术指标(通常在数字域给出)</p>
<ol type="1">
<li><p>通带、阻带的波动；</p></li>
<li><p>通带、过渡带、阻带的截止频率；</p></li>
<li><p>频率选择特性（低通）。</p></li>
</ol></li>
<li><p>对数字域的指标进行如下式的<strong>预畸</strong>处理</p>
<p><span class="math display">\[\begin{equation}
\Omega=\frac{2}{T}\tan{\frac{\omega}{2}}
\end{equation}\]</span></p></li>
<li><p>选择模拟逼近方法（Butterworth），并确定其传递函数 <span class="math inline">\(H_a\left(s\right)\)</span>。</p></li>
<li><p>按照双线性变换关系将 <span class="math inline">\(H_a\left(s\right)\)</span> 转变为 <span class="math inline">\(H\left(z\right)\)</span>，完成数字化。</p>
<p><span class="math display">\[\begin{equation}
s=\frac{2}{T}\cdot\frac{1-z^{-1}}{1+z^{-1}}
\end{equation}\]</span></p></li>
<li><p>检查结果是否满足指标，如不满足，返回第 3 步，改变 <span class="math inline">\(N\)</span>。</p></li>
</ol>
<h1 id="线性相位-fir-数字滤波器的特点">3. 线性相位 FIR
数字滤波器的特点</h1>
<h2 id="线性相位条件">3.1. 线性相位条件</h2>
<p><span class="math display">\[\begin{align}
&amp;偶对称\qquad h\left(n\right)=h\left(N-1-n\right)\\
&amp;奇对称\qquad h\left(n\right)=-h\left(N-1-n\right)
\end{align}\]</span></p>
<figure>
<img data-src="../images/post/2023-04-15-josh-dsp-part-7/2023-04-15-josh-dsp-part-7-030-LinearPhaseCondition.png" width="700" alt="线性相位条件">
<figcaption aria-hidden="true">线性相位条件</figcaption>
</figure>
<h2 id="线性相位-fir-系统的频域特点hleftnright-中心偶对称n-为奇数时">3.2.
线性相位 FIR 系统的频域特点（<span class="math inline">\(h\left(n\right)\)</span> 中心偶对称，<span class="math inline">\(N\)</span> 为奇数时）</h2>
<h3 id="hleftnright-中心偶对称n-为奇数情况的推导">3.2.1. <span class="math inline">\(h\left(n\right)\)</span> 中心偶对称，<span class="math inline">\(N\)</span>
为奇数情况的推导<a name="3.2.1"></a></h3>
<p><span class="math display">\[\begin{equation}
\begin{aligned}
H\left(e^{j\omega}\right)&amp;=\sum_{n=0}^{N-1}{h\left(n\right)e^{-j\omega
n}}=\sum_{n=0}^{\frac{N-1}{2}-1}{h\left(n\right)e^{-j\omega
n}}+h\left(\frac{N-1}{2}\right)e^{-j\omega\left(\frac{N-1}{2}\right)}+\sum_{n=\frac{N+1}{2}}^{N-1}{h\left(n\right)e^{-j\omega
n}}\\
&amp;=\sum_{n=0}^{\frac{N-1}{2}-1}{h\left(n\right)e^{-j\omega
n}}+h\left(\frac{N-1}{2}\right)e^{-j\omega\left(\frac{N-1}{2}\right)}+\sum_{n=0}^{\frac{N-1}{2}-1}{h\left(N-1-n\right)e^{-j\omega\left(N-1-n\right)}}\\
&amp;=\sum_{n=0}^{\frac{N-1}{2}-1}h\left(n\right)\left[e^{-j\omega
n}+e^{-j\omega\left(N-1-n\right)}\right]+h\left(\frac{N-1}{2}\right)e^{-j\omega\left(\frac{N-1}{2}\right)}\\
&amp;=e^{-j\omega\left(\frac{N-1}{2}\right)}\left\{h\left(\frac{N-1}{2}\right)+\sum_{n=0}^{\frac{N-1}{2}-1}h\left(n\right)\left[e^{j\omega\left(\frac{N-1}{2}-n\right)}+e^{-j\omega\left(\frac{N-1}{2}-n\right)}\right]\right\}\\
&amp;=e^{-j\omega\left(\frac{N-1}{2}\right)}\left\{h\left(\frac{N-1}{2}\right)+\sum_{n=0}^{\frac{N-1}{2}-1}{2h\left(n\right)\cos{\left[\omega\left(\frac{N-1}{2}-n\right)\right]}}\right\}
\end{aligned}
\end{equation}\]</span></p>
<p>定义一个 <span class="math inline">\(\dfrac{N+1}{2}\)</span> 点序列
<span class="math inline">\(a\left(n\right)\)</span></p>
<p><span class="math display">\[\begin{equation}
\begin{cases}
a\left(0\right)=h\left(\dfrac{N-1}{2}\right)\\
a\left(n\right)=2h\left(\dfrac{N-1}{2}-n\right),\qquad
n=1,2,\cdots,\dfrac{N-1}{2}
\end{cases}
\end{equation}\]</span></p>
<p>即<strong>取序列 <span class="math inline">\(h\left(n\right)\)</span>
的后半部，中间值不变，其余翻倍</strong>。则 <span class="math inline">\(H\left(e^{j\omega}\right)\)</span>
可以进一步化为</p>
<p><span class="math display">\[\begin{equation}
H\left(e^{j\omega}\right)=e^{-j\omega\left(\frac{N-1}{2}\right)}\sum_{n=0}^{\frac{N-1}{2}}{a\left(n\right)\cos{\left(\omega
n\right)}}=A\left(\omega\right)e^{j\varphi\left(\omega\right)}
\end{equation}\]</span></p>
<p>其中 <span class="math inline">\(A\left(\omega\right)=\displaystyle\sum_{n=0}^{\frac{N-1}{2}}{a\left(n\right)\cos{\left(\omega
n\right)}}\)</span>
称为符幅频率响应，其值可正可负，其与幅度频率响应的关系为 <span class="math inline">\(\left|A\left(\omega\right)\right|=\left|H\left(e^{j\omega}\right)\right|\)</span>。</p>
<h3 id="四种线性相位fir滤波器的特性">3.2.2.
四种线性相位FIR滤波器的特性</h3>
<table style="width:100%;">
<colgroup>
<col style="width: 14%">
<col style="width: 14%">
<col style="width: 14%">
<col style="width: 14%">
<col style="width: 14%">
<col style="width: 14%">
<col style="width: 14%">
</colgroup>
<thead>
<tr>
<th style="text-align: center;"></th>
<th style="text-align: center;"><span class="math inline">\(h\left(n\right)\)</span></th>
<th style="text-align: center;"><span class="math inline">\(N\)</span></th>
<th style="text-align: center;">单位脉冲响应</th>
<th style="text-align: center;">符幅频率响应</th>
<th style="text-align: center;">相位特性</th>
<th style="text-align: center;">特点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">情况 1</td>
<td style="text-align: center;">中<br>心<br>偶<br>对<br>称</td>
<td style="text-align: center;">奇数</td>
<td style="text-align: center;"><img data-src="../images/post/2023-04-15-josh-dsp-part-7/2023-04-15-josh-dsp-part-7-040-Case1h.png" width="150" alt="情况1-h"> <img data-src="../images/post/2023-04-15-josh-dsp-part-7/2023-04-15-josh-dsp-part-7-050-Case1a.png" width="150" alt="情况1-a"></td>
<td style="text-align: center;"><span class="math inline">\(\displaystyle
A\left(\omega\right)=\sum_{n=0}^{\frac{N-1}{2}}{a\left(n\right)\cos{\left(\omega
n\right)}}\)</span> <img data-src="../images/post/2023-04-15-josh-dsp-part-7/2023-04-15-josh-dsp-part-7-060-Case1A.png" width="200" alt="情况1-A"></td>
<td style="text-align: center;"><span class="math inline">\(\displaystyle\varphi\left(\omega\right)=-\frac{N-1}{2}\omega\)</span>
<img data-src="../images/post/2023-04-15-josh-dsp-part-7/2023-04-15-josh-dsp-part-7-070-Case1phi.png" width="1200" alt="情况1-相位"></td>
<td style="text-align: center;">可实现<br>低通<br>高通<br>带通<br>带阻</td>
</tr>
<tr>
<td style="text-align: center;">情况 2</td>
<td style="text-align: center;">中<br>心<br>偶<br>对<br>称</td>
<td style="text-align: center;">偶数</td>
<td style="text-align: center;"><img data-src="../images/post/2023-04-15-josh-dsp-part-7/2023-04-15-josh-dsp-part-7-080-Case2h.png" width="200" alt="情况2-h"> <img data-src="../images/post/2023-04-15-josh-dsp-part-7/2023-04-15-josh-dsp-part-7-090-Case2b.png" width="150" alt="情况2-b"></td>
<td style="text-align: center;"><span class="math inline">\(\displaystyle
B\left(\omega\right)=\sum_{n=0}^{\frac{N}{2}}{b\left(n\right)\cos{\left[\omega\left(n-\frac{1}{2}\right)\right]}}\)</span>
<img data-src="../images/post/2023-04-15-josh-dsp-part-7/2023-04-15-josh-dsp-part-7-100-Case2B.png" width="200" alt="情况2-B"></td>
<td style="text-align: center;">同上</td>
<td style="text-align: center;">可实现<br>低通<br>带通</td>
</tr>
<tr>
<td style="text-align: center;">情况 3</td>
<td style="text-align: center;">中心奇对称</td>
<td style="text-align: center;">奇数</td>
<td style="text-align: center;"><img data-src="../images/post/2023-04-15-josh-dsp-part-7/2023-04-15-josh-dsp-part-7-110-Case3h.png" width="200" alt="情况3-h"> <img data-src="../images/post/2023-04-15-josh-dsp-part-7/2023-04-15-josh-dsp-part-7-120-Case3c.png" width="150" alt="情况3-c"></td>
<td style="text-align: center;"><span class="math inline">\(\displaystyle
C\left(\omega\right)=\sum_{n=0}^{\frac{N-1}{2}}{c\left(n\right)\sin{\left(\omega
n\right)}}\)</span> <img data-src="../images/post/2023-04-15-josh-dsp-part-7/2023-04-15-josh-dsp-part-7-130-Case3C.png" width="200" alt="情况3-C"></td>
<td style="text-align: center;"><span class="math inline">\(\displaystyle\varphi\left(\omega\right)=\frac{\pi}{2}-\frac{N-1}{2}\omega\)</span>
<img data-src="../images/post/2023-04-15-josh-dsp-part-7/2023-04-15-josh-dsp-part-7-140-Case3phi.png" width="120" alt="情况3-相位"></td>
<td style="text-align: center;">可实现<br>带通</td>
</tr>
<tr>
<td style="text-align: center;">情况 4</td>
<td style="text-align: center;">中心奇对称</td>
<td style="text-align: center;">偶数</td>
<td style="text-align: center;"><img data-src="../images/post/2023-04-15-josh-dsp-part-7/2023-04-15-josh-dsp-part-7-150-Case4h.png" width="200" alt="情况4-h"> <img data-src="../images/post/2023-04-15-josh-dsp-part-7/2023-04-15-josh-dsp-part-7-160-Case4d.png" width="150" alt="情况4-h"></td>
<td style="text-align: center;"><span class="math inline">\(\displaystyle
D\left(\omega\right)=\sum_{n=0}^{\frac{N}{2}}{d\left(n\right)\sin{\left[\omega\left(n-\frac{1}{2}\right)\right]}}\)</span>
<img data-src="../images/post/2023-04-15-josh-dsp-part-7/2023-04-15-josh-dsp-part-7-170-Case4D.png" width="200" alt="情况4-h"></td>
<td style="text-align: center;">同上</td>
<td style="text-align: center;">可实现<br>高通<br>带阻</td>
</tr>
</tbody>
</table>
<h2 id="线性相位-fir-滤波器的零点位置">3.3. 线性相位 FIR
滤波器的零点位置</h2>
<p>  由 <span class="math inline">\(h\left(n\right)\)</span>
的中心对称性，有</p>
<p><span class="math display">\[\begin{equation}
\begin{aligned}
H\left(z\right)&amp;=\sum_{n=0}^{N-1}{h\left(n\right)z^{-n}}=\sum_{n=0}^{N-1}{\pm
h\left(N-1-n\right)z^{-n}}=\sum_{m=0}^{N-1}{\pm
h\left(m\right)z^{-\left(N-1-m\right)}}\\
&amp;=\pm
z^{-\left(N-1\right)}\sum_{m=0}^{N-1}{h\left(m\right)\left(z^{-1}\right)^{-m}}=\pm
z^{-\left(N-1\right)}H\left(z^{-1}\right)
\end{aligned}
\end{equation}\]</span></p>
<p>由 <span class="math inline">\(h\left(n\right)\)</span>
的实值性，有</p>
<p><span class="math display">\[\begin{equation}
H^\ast\left(z\right)=\left[\sum_{n=0}^{N-1}{h\left(n\right)z^{-n}}\right]^\ast=\sum_{n=0}^{N-1}{h\left(n\right)\left(z^\ast\right)^{-n}}=H\left(z^\ast\right)
\end{equation}\]</span></p>
<p>由上两式可知，若 <span class="math inline">\(z=z_i\)</span> 是 <span class="math inline">\(H\left(z\right)\)</span> 的零点，则 <span class="math inline">\(z_i\)</span> 的倒数 <span class="math inline">\(z=z_i^{-1}、z_i\)</span> 的共轭 <span class="math inline">\(z=z_i^\ast\)</span>、<span class="math inline">\(z_i\)</span> 共轭的倒数 <span class="math inline">\(z=\left(z_i^\ast\right)^{-1}\)</span> 也一定是
<span class="math inline">\(H\left(z\right)\)</span>
的零点。因此线性相位FIR滤波器的零点位置有四种可能，如下表。</p>
<table>
<colgroup>
<col style="width: 33%">
<col style="width: 33%">
<col style="width: 33%">
</colgroup>
<thead>
<tr>
<th style="text-align: center;"><span class="math inline">\(z_i\)</span>
的位置</th>
<th style="text-align: center;">对应所有零点的位置</th>
<th style="text-align: center;">在下图中的对应点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">即不在实轴上又不在单位圆上</td>
<td style="text-align: center;">互为倒数的两组共轭对</td>
<td style="text-align: center;"><span class="math inline">\(z_1\)</span></td>
</tr>
<tr>
<td style="text-align: center;">即在实轴上又在单位圆上</td>
<td style="text-align: center;"><span class="math inline">\(z=+1\)</span> 或 <span class="math inline">\(z=-1\)</span></td>
<td style="text-align: center;"><span class="math inline">\(z_2,z_3\)</span></td>
</tr>
<tr>
<td style="text-align: center;">不在实轴上但在单位圆上</td>
<td style="text-align: center;">一组共轭对</td>
<td style="text-align: center;"><span class="math inline">\(z_4\)</span></td>
</tr>
<tr>
<td style="text-align: center;">在实轴上但不在单位圆上</td>
<td style="text-align: center;">一组互为倒数的实数对</td>
<td style="text-align: center;"><span class="math inline">\(z_5\)</span></td>
</tr>
<tr>
<td style="text-align: center;"><img data-src="../images/post/2023-04-15-josh-dsp-part-7/2023-04-15-josh-dsp-part-7-180-ZeroPointOfLinearPhaseFIR.png" width="300" alt="线性相位 FIR 滤波器的零点位置"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<h1 id="fir-数字滤波器的设计">4. FIR 数字滤波器的设计</h1>
<ul>
<li><p>需要掌握低通、带通、带阻、高通四种选频特性 FIR
滤波器的设计。</p></li>
<li><p>若要求 FIR 数字滤波器具有线性相位响应，只考虑第一种情形，即 <span class="math inline">\(h\left(n\right)\)</span>
为奇点数中心偶对称。</p></li>
<li><p>需要掌握窗函数法和频率取样法。</p></li>
</ul>
<h2 id="fir-数字滤波器设计的时域方法窗函数法windowing-method">4.1. FIR
数字滤波器设计的时域方法——窗函数法（Windowing Method）</h2>
<h3 id="窗函数法设计-fir-数字低通滤波器的步骤">4.1.1. 窗函数法设计 FIR
数字低通滤波器的步骤</h3>
<p>  窗函数设计法的基本思想为，首先选择一个适当的理想的滤波器 <span class="math inline">\(H_d\left(e^{j\omega}\right)\)</span>，然后用窗函数截取它的单位脉冲响应
<span class="math inline">\(h_d\left(n\right)\)</span>，平移后得到线性相位和因果的FIR滤波器。这种方法的重点是选择一个合适的窗函数和理想滤波器，使设计的滤波器的单位脉冲响应逼近理想滤波器的单位脉冲响应。</p>
<ol type="1">
<li><p>根据给定指标确定理想低通数字滤波器的截止频率，以及相应的理想频率响应
<span class="math inline">\(H_d\left(e^{j\omega}\right)\)</span>，其相位响应为零（或将相位响应设为
<span class="math inline">\(-\dfrac{\left(N-1\right)\omega}{2}\)</span>，而非零相位响应，这样即无需步骤
3 中的平移操作，直接加窗即可）。</p></li>
<li><p>利用 IDTFT 计算理想低通系统的单位脉冲响应序列 <span class="math inline">\(h_d\left(n\right)\)</span></p>
<p><span class="math display">\[\begin{equation}
h_d\left(n\right)=\frac{1}{2\pi}\int_{2\pi}{H_d\left(e^{j\omega}\right)e^{j\omega
n}\mathrm{d}\omega}
\end{equation}\]</span></p></li>
<li><p>确定滤波器阶数 <span class="math inline">\(N\)</span>，将 <span class="math inline">\(h_d\left(n\right)\)</span> 向右平移 <span class="math inline">\(\tau=\dfrac{\left(N-1\right)}{2}\)</span>，加窗得到
<span class="math inline">\(h\left(n\right)\)</span></p>
<p><span class="math display">\[\begin{equation}
h\left(n\right)=w\left(n\right)h_d\left[n-\tau\right]
\end{equation}\]</span></p>
<p>由此，实际频率响应为平移后的脉冲响应序列与窗函数频域卷积，即</p>
<p><span class="math display">\[\begin{equation}
H\left(e^{j\omega}\right)=H_d^\prime\left(e^{j\omega}\right)\ast
W\left(e^{j\omega}\right)=\frac{1}{2\pi}\int_{2\pi}{H_d\left(e^{j\omega}\right)e^{-j\frac{\left(N-1\right)\theta}{2}}W\left[e^{j\left(\omega-\theta\right)}\right]\mathrm{d}\theta}
\end{equation}\]</span></p></li>
<li><p>检验结果，如果不满足指标要求，则返回步骤
3，重新选择窗长或窗形进行设计，直到满足要求。</p></li>
</ol>
<h3 id="窗函数法设计高通带通带阻滤波器">4.1.2.
窗函数法设计高通、带通、带阻滤波器</h3>
<figure>
<img data-src="../images/post/2023-04-15-josh-dsp-part-7/2023-04-15-josh-dsp-part-7-190-WindowingMethod.png" width="900" alt="窗函数法设计高通、带通、带阻滤波器">
<figcaption aria-hidden="true">窗函数法设计高通、带通、带阻滤波器</figcaption>
</figure>
<table>
<colgroup>
<col style="width: 13%">
<col style="width: 33%">
<col style="width: 53%">
</colgroup>
<thead>
<tr>
<th style="text-align: center;">滤波器类型</th>
<th style="text-align: center;">理想滤波器的<br>频率响应</th>
<th style="text-align: center;">理想滤波器的<br>单位抽样响应</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">高通</td>
<td style="text-align: center;"><span class="math inline">\(H_d\left(e^{j\omega}\right)=\begin{aligned}\begin{cases}e^{-j\omega\tau},&amp;\omega_c\leqslant\begin{vmatrix}\omega\end{vmatrix}\leqslant\pi\\0,&amp;\text{otherwise}\end{cases}\end{aligned}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\begin{aligned}h_d\left(n\right)&amp;=\frac{1}{2\pi}\left[\int_{-\pi}^{-\omega_c}e^{j\omega\left(n-\tau\right)d\omega}+\int_{\omega_c}^{\pi}e^{j\omega\left(n-\tau\right)d\omega}\right]\\&amp;=\begin{aligned}\begin{cases}\dfrac{1}{\pi\left(n-\tau\right)}\left\{\sin{\pi\left(n-\tau\right)}-\sin{\left[\omega_c\left(n-\tau\right)\right]}\right\},&amp;n\neq\tau\\
\dfrac{\pi-\omega_c}{\pi},&amp;n=\tau\end{cases}\end{aligned}\end{aligned}\)</span></td>
</tr>
<tr>
<td style="text-align: center;">带通</td>
<td style="text-align: center;"><span class="math inline">\(H_d\left(e^{j\omega}\right)=\begin{aligned}\begin{cases}e^{-j\omega\tau},&amp;0&lt;\omega_1\leqslant\begin{vmatrix}\omega\end{vmatrix}\leqslant\omega_2&lt;\pi\
\\ 0,&amp;\text{otherwise} \end{cases}\end{aligned}\)</span>$</td>
<td style="text-align: center;"><span class="math inline">\(\begin{aligned}h_d\left(n\right)&amp;=\frac{1}{2\pi}\left[\int_{-\omega_2}^{-\omega_1}e^{j\omega\left(n-\tau\right)d\omega}+\int_{\omega_1}^{\omega_2}e^{j\omega\left(n-\tau\right)d\omega}\right]
\\
&amp;=\begin{aligned}\begin{cases}\dfrac{1}{\pi\left(n-\tau\right)}\left\{\sin{\omega_2\left(n-\tau\right)}-\sin{\left[\omega_1\left(n-\tau\right)\right]}\right\},&amp;n\neq\tau
\\
\dfrac{\omega_2-\omega_1}{\pi},&amp;n=\tau\end{cases}\end{aligned}\end{aligned}\)</span></td>
</tr>
<tr>
<td style="text-align: center;">带阻</td>
<td style="text-align: center;"><span class="math inline">\(H_d\left(e^{j\omega}\right)=\begin{aligned}\begin{cases}e^{-j\omega\tau},&amp;0\leqslant\begin{vmatrix}\omega\end{vmatrix}\leqslant\omega_1,\omega_2\leqslant\begin{vmatrix}\omega\end{vmatrix}\leqslant\pi\
\\ 0,&amp;\text{otherwise}\end{cases}\end{aligned}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\begin{aligned}h_d\left(n\right)&amp;=\frac{1}{2\pi}\left[\int_{-\pi}^{-\omega_2}e^{j\omega\left(n-\tau\right)d\omega}+\int_{-\omega_1}^{\omega_1}e^{j\omega\left(n-\tau\right)d\omega}+\int_{\omega_2}^{\pi}e^{j\omega\left(n-\tau\right)d\omega}\right]\\
&amp;=
\begin{aligned}\begin{cases}\dfrac{1}{\pi\left(n-\tau\right)}\left\{\sin{\pi\left(n-\tau\right)}+\sin{\left[\omega_1\left(n-\tau\right)\right]}-\sin{\left[\omega_2\left(n-\tau\right)\right]}\right\},&amp;n\neq\tau
\\
\dfrac{\pi+\omega_1-\omega_2}{\pi},&amp;n=\tau\end{cases}\end{aligned}\end{aligned}\)</span></td>
</tr>
</tbody>
</table>
<blockquote>
<p>说明：</p>
<ol type="1">
<li><p>表中理想频率 <span class="math inline">\(H_d\left(e^{j\omega}\right)\)</span>
具有线性相位，理想低通系统的单位抽样响应 <span class="math inline">\(h_d\left(n\right)\)</span>
无需平移即可加窗。</p></li>
<li><p>数字滤波器的单位抽样响应 <span class="math inline">\(h\left(n\right)=w\left(n\right)\cdot
h_d\left(n\right)\)</span>。</p></li>
<li><p><span class="math inline">\(\tau=\dfrac{\left(N-1\right)}{2}\)</span>。</p></li>
</ol>
</blockquote>
<h2 id="fir-数字滤波器设计的频域方法频率取样法frequency-sampling-method">4.2.
FIR 数字滤波器设计的频域方法——频率取样法（Frequency Sampling
Method）</h2>
<h3 id="取样原则">4.2.1. 取样原则</h3>
<ol type="1">
<li><p>预期频率特性的取样点数应等于滤波器阶数 <span class="math inline">\(N\)</span>，并在单位圆上等间隔分布；</p></li>
<li><p>为保证滤波器系数为实数，单位抽样序列应为实序列，取样频率特性应具有圆周共轭对称性；</p></li>
<li><p>为使预期频率特性具有线性相位，其幅度特性和傅氏反变换得到的序列应为中心对称或中心反对称结构。</p></li>
</ol>
<h3 id="取样值的确定hleftnright-为中心偶对称阶数-n-为奇数时">4.2.2.
取样值的确定（<span class="math inline">\(h\left(n\right)\)</span>
为中心偶对称，阶数 <span class="math inline">\(N\)</span>
为奇数时）</h3>
<p>  由 <a href="#3.2.1">3.2.1</a> <span class="math inline">\(h\left(n\right)\)</span> 中心偶对称，<span class="math inline">\(N\)</span> 为奇数情况的推导，有</p>
<p><span class="math display">\[\begin{equation}
H_d\left(e^{j\omega}\right)=e^{-j\omega\left(\frac{N-1}{2}\right)}H\left(\omega\right)
\end{equation}\]</span></p>
<p>其中符幅频率响应函数 <span class="math inline">\(H\left(\omega\right)\)</span> 是偶对称的，即</p>
<p><span class="math display">\[\begin{equation}
H\left(\omega\right)=H\left(2\pi-\omega\right)
\end{equation}\]</span></p>
<p>对 <span class="math inline">\(H\left(e^{j\omega}\right)\)</span> 在
<span class="math inline">\(0\sim2\pi\)</span> 之间等间隔取样 <span class="math inline">\(N\)</span> 点，得到 <span class="math inline">\(H\left(k\right)\)</span>，即</p>
<p><span class="math display">\[\begin{equation}
H\left(k\right)=\left.H_d\left(e^{j\omega}\right)\right|_{\omega=\frac{2\pi}{N}k}=H_ke^{j\theta_k},\
\ k=0,1,\cdots,N-1
\end{equation}\]</span></p>
<p>其中频率采样符幅满足</p>
<p><span class="math display">\[\begin{equation}
H_k=H_{\frac{2\pi}{N}k}=H_{\frac{2\pi}{N}\left(N-k\right)}=H_{N-k};\left|H_k\right|=\left|H\left(k\right)\right|
\end{equation}\]</span></p>
<p>频率采样相位</p>
<p><span class="math display">\[\begin{equation}
\theta_k=-\frac{N-1}{2}\cdot\frac{2\pi}{N}k=-k\pi\left(1-\frac{1}{N}\right);e^{j\theta_{\left(N-k\right)}}=-e^{j\theta_k}
\end{equation}\]</span></p>
<h3 id="系统单位脉冲响应传递函数和频率响应hleftnright-为中心偶对称阶数-n-为奇数时">4.2.3.
系统单位脉冲响应、传递函数和频率响应（<span class="math inline">\(h\left(n\right)\)</span> 为中心偶对称，阶数 <span class="math inline">\(N\)</span> 为奇数时）<a name="4.2.3"></a></h3>
<p>  由于 <span class="math inline">\(H\left(k\right)\)</span> 是 <span class="math inline">\(h\left(n\right)\)</span> 的 DFT</p>
<p><span class="math display">\[\begin{equation}
\begin{aligned}
h\left(n\right)&amp;=\mathrm{IDFT}\left[H\left(k\right)\right]=\frac{1}{N}\sum_{k=0}^{N-1}{H\left(k\right)e^{j\frac{2\pi}{N}kn}}=\frac{1}{N}\sum_{k=0}^{N-1}{H_ke^{j\theta_k}e^{j\frac{2\pi}{N}nk}}\\
&amp;=\frac{H_0e^{j\theta_0}}{N}+\frac{1}{N}\sum_{k=1}^{\frac{N-1}{2}}{H_k\left[e^{j\theta_k}e^{j\frac{2\pi}{N}nk}+e^{j\theta_{\left(N-k\right)}}e^{j\frac{2\pi}{N}n\left(N-k\right)}\right]}\\
&amp;=\frac{H_0}{N}+\frac{1}{N}\sum_{k=1}^{\frac{N-1}{2}}{H_k\left[e^{j\theta_k}e^{j\frac{2\pi}{N}nk}+e^{-j\theta_k}e^{-j\frac{2\pi}{N}nk}\right]}\\
&amp;=\frac{H_0}{N}+\frac{2}{N}\sum_{k=1}^{\frac{N-1}{2}}{H_k\cos{\left(\theta_k+\frac{2\pi}{N}nk\right)}}
\\
&amp;=\frac{H_0}{N}+\frac{2}{N}\sum_{k=1}^{\frac{N-1}{2}}{H_k\cos{\left[-\left(1-\frac{1}{N}\right)k\pi+\frac{2\pi}{N}nk\right]}}
\end{aligned}
\end{equation}\]</span></p>
<p>  由内插公式从 <span class="math inline">\(H\left(k\right)\)</span>
计算 <span class="math inline">\(H\left(z\right)\)</span></p>
<p><span class="math display">\[\begin{equation}
\begin{aligned}
H\left(z\right)&amp;=\frac{1-z^{-N}}{N}\sum_{k=0}^{N-1}\frac{H\left(k\right)}{1-W_N^{-k}z^{-1}}\\
&amp;=\frac{1-z^{-N}}{N}\left\{\frac{H_0}{1-z^{-1}}+\sum_{k=1}^{\frac{N-1}{2}}{H_k\left[\frac{e^{j\theta_k}}{1-W_N^{-k}z^{-1}}+\frac{e^{j\theta_{\left(N-k\right)}}}{1-W_N^{-\left(N-k\right)}z^{-1}}\right]}\right\}\\
&amp;=\frac{1-z^{-N}}{N}\left[\frac{H_0}{1-z^{-1}}+\sum_{k=1}^{\frac{N-1}{2}}{H_k\left(\frac{e^{j\theta_k}}{1-W_N^{-k}z^{-1}}+\frac{e^{-j\theta_k}}{1-W_N^kz^{-1}}\right)}\right]\\
&amp;=\frac{1-z^{-N}}{N}\left\{\frac{H_0}{1-z^{-1}}+\sum_{k=1}^{\frac{N-1}{2}}{H_k\frac{e^{j\theta_k}+\left(e^{j\theta_k}\right)^\ast-\left[e^{j\theta_k}W_N^k+\left(e^{j\theta_k}W_N^k\right)^\ast\right]z^{-1}}{1-z^{-1}\left(W_N^{-k}+W_N^k\right)+z^{-2}}}\right\}\\
&amp;=\frac{1-z^{-N}}{N}\left[\frac{H_0}{1-z^{-1}}+\sum_{k=1}^{\frac{N-1}{2}}{H_k\frac{2\cos{\theta_k}-2z^{-1}\Re{\left[e^{j\theta_k}W_N^k\right]}}{1-z^{-1}\left(W_N^{-k}+W_N^k\right)+z^{-2}}}\right]\\
&amp;\xlongequal{\theta_k=-k\pi\left(1-\frac{1}{N}\right)}\frac{1-z^{-N}}{N}\left[\frac{H_0}{1-z^{-1}}+\sum_{k=1}^{\frac{N-1}{2}}{H_k\frac{2\left(-1\right)^k\cos{\left(\dfrac{\pi}{N}k\right)}\left(1-z^{-1}\right)}{1-2\cos{\left(\dfrac{2\pi}{N}k\right)}z^{-1}+z^{-2}}}\right]
\end{aligned}
\end{equation}\]</span></p>
<p>由 <span class="math inline">\(H\left(z\right)\)</span> 和 <span class="math inline">\(H\left(e^{j\omega}\right)\)</span> 的关系</p>
<p><span class="math display">\[\begin{equation}
\begin{aligned}
H\left(e^{j\omega}\right)&amp;=\left.H\left(z\right)\right|_{z=e^{j\omega}}=\frac{1-e^{-j\omega
N}}{N}\sum_{k=0}^{N-1}\frac{H\left(k\right)}{1-W_N^{-k}e^{-j\omega}}=\frac{1-e^{-j\omega
N}}{N}\sum_{k=0}^{N-1}\frac{H\left(k\right)}{1-e^{-j\left(\omega-\frac{2\pi}{N}k\right)}}\\
&amp;=e^{-j\frac{\left(N-1\right)}{2}\omega}\frac{\left(e^{j\frac{N\omega}{2}}-e^{-j\frac{N\omega}{2}}\right)e^{-j\frac{\omega}{2}}}{N}\sum_{k=0}^{N-1}\frac{H\left(k\right)}{e^{-j\left(\frac{\omega}{2}-\frac{\pi}{N}k\right)}\left[e^{j\left(\frac{\omega}{2}-\frac{\pi}{N}k\right)}-e^{-j\left(\frac{\omega}{2}-\frac{\pi}{N}k\right)}\right]}\\
&amp;=e^{-j\frac{\left(N-1\right)}{2}\omega}\frac{2j\sin{\left(\dfrac{N\omega}{2}\right)}e^{-j\frac{\omega}{2}}}{N}\sum_{k=0}^{N-1}\frac{H\left(k\right)}{e^{-j\left(\frac{\omega}{2}-\frac{\pi}{N}k\right)}2j\sin{\left(\frac{\omega}{2}-\frac{\pi}{N}k\right)}}\\
&amp;\xlongequal{约分}e^{-j\frac{\left(N-1\right)}{2}\omega}\frac{\sin{\left(\dfrac{N\omega}{2}\right)}}{N}\sum_{k=0}^{N-1}\frac{H\left(k\right)e^{-j\frac{\pi}{N}k}}{\sin{\left(\dfrac{\omega}{2}-\dfrac{\pi}{N}k\right)}}\\
&amp;\xlongequal[将第1项分开]{H\left(k\right)=H_ke^{j\theta_k}}e^{-j\frac{\left(N-1\right)}{2}\omega}\left\{\frac{H_0}{N}\cdot\frac{\sin{\left(\dfrac{N\omega}{2}\right)}}{\sin{\left(\dfrac{\omega}{2}\right)}}+\sum_{k=1}^{N-1}{\frac{H_ke^{j\theta_k}}{N}\cdot\frac{e^{-j\frac{\pi}{N}k}\sin{\left(\dfrac{N\omega}{2}\right)}}{\sin{\left(\dfrac{\omega}{2}-\dfrac{\pi}{N}k\right)}}}\right\}\\
&amp;\xlongequal{合并}e^{-j\frac{\left(N-1\right)}{2}\omega}\left\{\frac{H_0}{N}\cdot\frac{\sin{\left(\dfrac{N\omega}{2}\right)}}{\sin{\left(\dfrac{\omega}{2}\right)}}+\sum_{k=1}^{\frac{N-1}{2}}{\frac{H_k}{N}\cdot\left[\frac{e^{j\theta_k}e^{-j\frac{\pi}{N}k}\sin{\left(\dfrac{N\omega}{2}\right)}}{\sin{\left(\dfrac{\omega}{2}-\dfrac{\pi}{N}k\right)}}+\frac{e^{j\theta_{\left(N-k\right)}}e^{-j\frac{\pi}{N}\left(N-k\right)}\sin{\left(\dfrac{N\omega}{2}\right)}}{\sin{\left[\dfrac{\omega}{2}-\dfrac{\pi}{N}\left(N-k\right)\right]}}\right]}\right\}\\
&amp;\xlongequal{\theta_k=-k\pi\left(1-\frac{1}{N}\right)}e^{-j\frac{\left(N-1\right)}{2}\omega}\left\{\frac{H_0}{N}\cdot\frac{\sin{\left(\dfrac{N\omega}{2}\right)}}{\sin{\left(\dfrac{\omega}{2}\right)}}+\sum_{k=1}^{\frac{N-1}{2}}{\frac{H_k}{N}\cdot\left[\frac{e^{-jk\pi}\sin{\left(\dfrac{N\omega}{2}\right)}}{\sin{\left(\dfrac{\omega}{2}-\dfrac{\pi}{N}k\right)}}+\frac{e^{jk\pi}\sin{\left(\dfrac{N\omega}{2}\right)}}{\sin{\left(\dfrac{\omega}{2}+\dfrac{\pi}{N}k\right)}}\right]}\right\}\\
&amp;=e^{-j\frac{\left(N-1\right)}{2}\omega}\left\{\frac{H_0}{N}\cdot\frac{\sin{\left(\dfrac{N\omega}{2}\right)}}{\sin{\left(\dfrac{\omega}{2}\right)}}+\sum_{k=1}^{\frac{N-1}{2}}{\frac{H_k}{N}\cdot\left[\frac{\sin{\left[N\left(\dfrac{\omega}{2}-\dfrac{\pi}{N}k\right)\right]}}{\sin{\left(\dfrac{\omega}{2}-\dfrac{\pi}{N}k\right)}}+\frac{\left[\sin{N\left(\dfrac{\omega}{2}+\dfrac{\pi}{N}k\right)}\right]}{\sin{\left(\dfrac{\omega}{2}+\dfrac{\pi}{N}k\right)}}\right]}\right\}
\end{aligned}
\end{equation}\]</span></p>
<p>其中最后一步化简</p>
<p><span class="math display">\[\begin{equation}
\begin{aligned}
\sin{\left[N\left(\frac{\omega}{2}+\frac{\pi}{N}k\right)\right]}&amp;=\frac{1}{2j}\left[e^{jN\left(\frac{\omega}{2}+\frac{\pi}{N}k\right)}-e^{-jN\left(\frac{\omega}{2}+\frac{\pi}{N}k\right)}\right]=\frac{e^{-jk\pi}}{2j}\left[e^{j\left(N\frac{\omega}{2}+2\pi
k\right)}-e^{-j\left(\frac{N\omega}{2}+\pi k\right)}\right]\\
&amp;\xlongequal{e^{j2\pi
k}=1}\frac{e^{-jk\pi}}{2j}\left[e^{j\left(N\frac{\omega}{2}\right)}-e^{-j\left(\frac{N\omega}{2}\right)}\right]=e^{-jk\pi}\sin{\left(\frac{N\omega}{2}\right)}
\end{aligned}
\end{equation}\]</span></p>
<h3 id="频率取样法设计滤波器的步骤">4.2.4.
频率取样法设计滤波器的步骤</h3>
<ol type="1">
<li><p>确定滤波器的技术指标，及预期频率响应（简单起见，可从理想选频特性开始）。</p></li>
<li><p>选择频率采样类型（Ⅰ型），确定采样频点</p>
<p><span class="math display">\[\begin{equation}
\omega_k=k\frac{f_s}{N}
\end{equation}\]</span></p></li>
<li><p>计算所需频率采样点数 <span class="math inline">\(N\)</span>
及对应的频域采样值 <span class="math inline">\(H\left(k\right)\)</span>，确定过渡带中频率采样点数
<span class="math inline">\(M\)</span> 以及对应的幅度。</p></li>
<li><p>利用 <a href="#4.2.3">4.2.3</a> 中推导的公式计算滤波器的参数</p>
<p><span class="math display">\[\begin{equation}
h\left(n\right)=\frac{H_0}{N}+\frac{2}{N}\sum_{k=1}^{\frac{N-1}{2}}{H_k\cos{\left[-\left(1-\frac{1}{N}\right)k\pi+\frac{2\pi}{N}nk\right]}}
\end{equation}\]</span></p>
<p><span class="math display">\[\begin{equation}
H\left(z\right)=\frac{1-z^{-N}}{N}\left[\frac{H_0}{1-z^{-1}}+\sum_{k=1}^{\frac{N-1}{2}}{H_k\frac{2\left(-1\right)^k\cos{\left(\frac{\pi}{N}k\right)}\left(1-z^{-1}\right)}{1-2\cos{\left(\frac{2\pi}{N}k\right)}z^{-1}+z^{-2}}}\right]
\end{equation}\]</span></p>
<p><span class="math display">\[\begin{equation}
H\left(e^{j\omega}\right)=e^{-j\frac{\left(N-1\right)}{2}\omega}\left\{\frac{H_0}{N}\cdot\frac{\sin{\left(\dfrac{N\omega}{2}\right)}}{\sin{\left(\dfrac{\omega}{2}\right)}}+\sum_{k=1}^{\frac{N-1}{2}}{\frac{H_k}{N}\cdot\left[\frac{\sin{\left[N\left(\dfrac{\omega}{2}-\dfrac{\pi}{N}k\right)\right]}}{\sin{\left(\dfrac{\omega}{2}-\dfrac{\pi}{N}k\right)}}+\frac{\left[\sin{N\left(\dfrac{\omega}{2}+\dfrac{\pi}{N}k\right)}\right]}{\sin{\left(\dfrac{\omega}{2}+\dfrac{\pi}{N}k\right)}}\right]}\right\}
\end{equation}\]</span></p></li>
<li><p>检验结果，如果不满足指标要求，则返回步骤 3 重新设计。</p></li>
</ol>
<h1 id="参考文献">参考文献</h1>
<p>王世一. <em>数字信号处理, 修订版.</em> 北京理工大学出版社, 1997.</p>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/css/markmap.css">

<script src="/js/markmap.js"></script>
]]></content>
      <categories>
        <category>Josh 的学习笔记</category>
        <category>数字信号处理</category>
      </categories>
      <tags>
        <tag>数字信号和处理</tag>
        <tag>DSP</tag>
        <tag>IIR</tag>
        <tag>FIR</tag>
        <tag>频率取样</tag>
        <tag>线性相位</tag>
        <tag>巴特沃斯</tag>
        <tag>数字滤波器</tag>
        <tag>窗函数</tag>
        <tag>通带波动</tag>
        <tag>阻带衰减</tag>
        <tag>截止频率</tag>
        <tag>系统函数</tag>
        <tag>脉冲响应不变</tag>
        <tag>双线性变换</tag>
      </tags>
  </entry>
  <entry>
    <title>Josh&#39;s Note — Verilog&lt;br&gt;Part 6 如何写好状态机</title>
    <url>/posts/d860a67e.html</url>
    <content><![CDATA[<h1 id="状态机的基本概念">1. 状态机的基本概念</h1>
<p>本节的重点在于理解状态机的基本概念和应用场合。</p>
<h2 id="状态机是一种思想方法">1.1.
状态机是一种思想方法<a id="toc.1.1"></a></h2>
<p>大多数工科生在学习数字电路时都学习过状态机的基本概念，了解一些使用状态机描述时序电路的基本方法。但是<strong>状态机不仅仅是一种时序电路设计工具，它更是一种思想方法</strong>。</p>
<span id="more"></span>
<p>先看一个简单的例子。在大学生活中，某同学的在校生活可以简单地概括为宿舍、教室、食堂之间的周而复始，可以用<a href="#fig.6-1">图 6-1</a>
形象地表现出来。这张图并不是要讨论这个学生是否是一个“乖乖”类型学生。</p>
<div class="note info"><p>请注意，如果将图中的“地点”认为是“状态”，将“功能“认为是状态的“输出”，这张图就是一张标准的状态转移图，也就是说，用状态机的方式清晰地描述了这个学生的在校生活方式。</p>
</div>
<p><a id="fig.6-1"></a></p>
<figure>
<img data-src="../images/post/2023-04-16-josh-verilog-part-6/2023-04-16-josh-verilog-part-6-010-SchoolLifeStateTransitionDiagramOfStudentA.png" width="600" alt="图 6-1 某学生在校生活状态转移图">
<figcaption aria-hidden="true">图 6-1
某学生在校生活状态转移图</figcaption>
</figure>
<p>如果你认为这张图描述的学生生活过于单调而怀疑状态机描述方法的能力，就再看另一位生活丰富多彩的同学的在校生活，他/她的在校生活方式可以用<a href="#fig.6-2">图 6-2</a> 表示。</p>
<p><a id="fig.6-2"></a></p>
<figure>
<img data-src="../images/post/2023-04-16-josh-verilog-part-6/2023-04-16-josh-verilog-part-6-020-SchoolLifeStateTransitionDiagramOfStudentB.png" width="600" alt="图 6-2 另一位学生在校生活状态转移图">
<figcaption aria-hidden="true">图 6-2
另一位学生在校生活状态转移图</figcaption>
</figure>
<div class="note info"><p>同样如果将图中的“地点”认为是“状态”，将“功能”认为是状态的“输出”，将“条件”认为是状态转移的“输入条件”，<a href="#fig.6-2">图 6-2</a>
也是一张标准的状态转移图，通过状态机的方式再次清晰地描述了另一个学生的在校生活方式。</p>
</div>
<p>事实上使用状态机可以细致入微地描述任何一位同学的在校生活方式。通过前面两个简单举例可以发现，<strong>状态机特别适合描述有发生有先后顺序，或者有逻辑规律的事情</strong>——这就是状态机的本质——对具有逻辑顺序或时序规律事件的一种描述方法。这个论断最重要的两个词就是“<strong>逻辑顺序</strong>”和“<strong>时序规律</strong>”，这两点就是状态机所要描述的核心和强项，换言之，<strong>所有具有逻辑顺序和时序规律的事情都适合用状态机描述</strong>。</p>
<p>很多初学者不知道何时应用状态机。这里介绍两种应用思路：第一种思路，<strong>从状态变量入手</strong>。如果一个电路具有时序规律或者逻辑顺序，就可以自然而然地规划出状态，从这些状态入手，分析每个状态的输入，状态转移和输出，从而完成电路功能。第二种思路，首先明确电路的输出关系，这些输出相当于状态的输出，<strong>回溯规划</strong>每个状态和状态转移条件与状态输入。无论哪种思路，使用状态机的目的都是要控制某部分电路，完成某种具有逻辑顺序或时序规律的电路设计。</p>
<p>其实对于逻辑电路而言，小到一个简单的时序逻辑，大到复杂的微处理器，都适合用状态机方法进行描述。请打开思路，不要仅仅局限于时序逻辑，发现电路的内在规律，确认电路的“状态变量”，大胆使用状态机描述电路模型。由于<strong>状态机不仅是一种电路描述工具，它更是一种思想方法</strong>，而且状态机的
HDL
语言表达方式比较规范，有章可循，所以很多有经验的设计者习惯用状态机思想进行逻辑设计，对各种复杂设计都套用状态机的设计理念，从而提高设计的效率和稳定性。</p>
<h2 id="状态机的基本要素与分类">1.2. 状态机的基本要素与分类</h2>
<p>状态机的基本要素有 3 个，其实在<a href="#toc.1.1">第一小节</a>的举例中都有涉及，只是没有点明，它们是：<strong>状态</strong>、<strong>输出</strong>和<strong>输入</strong>。</p>
<ul>
<li><p><strong>状态</strong>：也叫状态变量。在逻辑设计中，使用状态划分逻辑顺序和时序规律。比如，设计伪随机码发生器时，可以用移位寄存器序列作为状态；在设计电机控制电路时，可以以电机的不同转速作为状态；在设计通信系统时，可以用信号的状态作为状态变量等。</p></li>
<li><p><strong>输出</strong>：输出指<strong>在某一个状态时特定发生的事件</strong>。如设计电机控制电路中，如果电机转速过高，则输出为转速过高报警，也可以伴随减速指令或降温措施等。</p></li>
<li><p><strong>输入</strong>：指状态机中<strong>进入每个状态的条件</strong>，有的状态机没有输入条件，其中的状态转移较为简单，有的状态机有输入条件，当某个输入条件存在时才能转移到相应的状态。</p></li>
</ul>
<p>根据状态机的输出是否与输入条件相关，可将状态机分为两大类：摩尔（Moore）型状态机和米里
(Mealy) 型状态机。</p>
<ul>
<li><p><strong>摩尔型状态机</strong>：摩尔型状态机的<strong>输出仅仅依赖于当前状态，而与输入条件无关</strong>。例如<a href="#fig.6-1">图 6-1</a>
所示的例子，将图中的“地点”认为是“状态”，将“功能”认为是状态的“输出”，则每个输出仅仅与状态相关，所以它是一个摩尔型状态机。</p></li>
<li><p><strong>米里型状态机</strong>：米里型状态机的<strong>输出不仅依赖于当前状态，而且取决于该状态的输入条件</strong>。例如<a href="#fig.6-2">图 6-2</a>
所示的例子，将图中的“地点”认为是“状态”，将“功能”认为是状态的“输出”，将“条件”认为是状态转移的“输入条件”，可以发现，该学生到达什么地方，做什么事情都是由当前状态和输入条件共同决定，所以它是一个米里型状态机。</p></li>
</ul>
<p>根据状态机的数掀是否为有限个，可将状态机分为有限状态机 (Finite State
Machine, FSM) 和无限状态机 （Infinite State Machine,
ISM）。<strong>逻辑设计中一般所涉及的状态都是有限的，所以以后所说的状态机都指有限状态机</strong>，用
FSM 表示。</p>
<h2 id="状态机的基本描述方式">1.3. 状态机的基本描述方式</h2>
<p>逻辑设计中，状态机的基本描述方式有 3
种，分别是状态转移图、状态转移列表及 HDL 语言描述。</p>
<h3 id="状态转移图">1.3.1. 状态转移图</h3>
<p>状态转移图是状态机描述的最自然的方式。如<a href="#fig.6-1">图
6-1</a>、<a href="#fig.6-2">图 6-2</a>
都使用了状态转移图这一描述方式。状态转移图经常在设计规划阶段定义逻辑功能时使用，也可以在分析代码中状态机时使用，通过图形化的方式非常有助于理解设计意图。</p>
<p>另外值得一提的是目前有一些 EDA
工具支持状态转移图作为逻辑设计的输入，如
StateCAD。在该工具中设计者只要画出状态转移图就可以了， StateCAD
能自动将状态转移图翻译成 HDL
语言代码，而且翻译出来的代码规范、可读性较好、可综合、易维护。 StateCAD
还能自动检测状态机的完备性和正确性，对状态转移图中的冗余状态、自锁状态、歧义转移条件和不完备状态机等隐含错误都会报警，并协助设计者更正错误。最后
StateCAD
会自动生成设计的测试激励，并调用仿真程序，验证状态机的正确性，这个测试激励甚至可在后仿真中使用。总之，
StateCAD
提供了状态机的输入、翻译、检测、优化和测试等一条龙的服务，使状态机的设计变得安全、可靠、快速、便捷。这类自动转换状态转移图为
HDL
源代码的工具对设计、分析一些规模较小的状态机非常有效，但是由于自动反应的代码过于程式化，效率不是很高，所以对于较大规模的逻辑设计，一般还是推荐使用
HDL 语言描述。</p>
<div class="note info"><p>使用 Synplify Pro 的 RTL 视图配合 FSM Viewer 可以将源代码中描述的 FSM
用状态转移图显示出来，使用图形化的界面帮助用户分析、理解状态机。</p>
</div>
<h3 id="状态转移列表">1.3.2. 状态转移列表</h3>
<p>状态转移列表是用列表的方式描述状态机，是数字逻辑电路常用的设计方法之一，经常被用于对状态化简，对可编程逻辑设计，由于可用逻辑资源比较丰富，而且状态编码要考虑设计的稳定性、安全性等因素，所以并不经常使用状态转移列表优化状态。</p>
<h3 id="hdl-语言描述状态机">1.3.3. HDL 语言描述状态机</h3>
<p>使用 HDL 语言描述状态机是本文讨论的重点，使用 HDL
语言描述状态机有一定的灵活性，但不是天马行空，而是有章可循的。通过一些规范的描述方法，可以使
HDL 语言描述的状态机更安全、稳定、高效、易于维护。</p>
<h1 id="如伺写好状态机">2. 如伺写好状态机</h1>
<p>本节重点讨论可综合的状态机描述的一些基本规范，即如何在 RTL
级描述安全、高效的 FSM。</p>
<h2 id="什么是好的-rtl-级-fsm-描述">2.1. 什么是好的 RTL 级 FSM 描述</h2>
<p>首先介绍好的 RTL 级 FSM 的评判标准。其实评判 FSM
的标准很多，这里挑选最重要的几个方面讨论一 下。好的 RTL 级 FSM
的评判标准如下：</p>
<ol type="1">
<li><p><strong>FSM 要安全，稳定性高</strong></p>
<p>FSM 安全是指 FSM
<strong>不会进入死循环，特别是不会进入非预知的状态，而且由于某些扰动进入非设计状态，也能很快地恢复到正常的状态循环中来</strong>。这里面有两层含义，第一
，要求该 FSM
的综合实现结果<strong>无毛刺</strong>等异常扰动；第二，要求状态机要<strong>完备</strong>，即使收到异常扰动进入非设计状态，也能很快恢复到正常状态。</p></li>
<li><p>FSM 速度快，满足设计的频率要求</p>
<p>任何 RTL 设计都应该满足设计的频率要求。</p></li>
<li><p>FSM 面积小，满足设计的面积要求</p>
<p>同理任何 RTL 设计都应该满足设计的面积要求。</p></li>
<li><p>FSM 设计要清晰易懂、易维护</p>
<p>不规范的 FSM
写法很难让其他人解读，甚至过一段时间后设计者也发现很难维护。</p></li>
</ol>
<p>需要说明的是以上所列的各项标准，特别是前 3
项标准绝不是割裂的，它们直接有紧密的内在联系。前面花了相当长的篇幅论述
FPGA/CPLD
设计评判的两个基本标准：面积和速度。这里“面积”是指一个设计所消耗
FPGA/CPLD
的逻辑资源数量；“速度”指设计在芯片上稳定运行所能够达到的最高频率。两者是对立统一的矛盾体，要求一个设计同时具备设计面积最小，运行频率最高，这是不现实的。科学的设计目标应该是：<strong>在满足设计时序要求（包含对设计最高频率的要求）的前提下，占用最小的芯片面积，或者在所规定的面积下，使设计的时序余量更大，频率更高</strong>。</p>
<p>另外，如果要求 FSM 安全，则很多时候需要使用“full
case”的编码方式，即将状态转移变量的所有向量组合情况都在 FSM
中有相应的处理，这势必意味若要多花更多的设计资源，有时也会影响 FSM
的频率。</p>
<p>所以，各条标准要综合考虑，根据设计的要求进行权衡。但是如果各条评判标准发生冲突时，请按照标准的罗列顺序考虑，前文标准的罗列顺序是根据这些标准在设计中的重要性排列的，也就是说第
1 条“FSM 要安全，稳定性高”的优先级最高，最重要；第 4 条“FSM
设计要清晰易懂易维护”的优先级最低，是相对次要的标准。</p>
<h2 id="rtl-级状态机描述常用语法">2.2. RTL
级状态机描述常用语法<a id="2.2"></a></h2>
<p>在 <a href="https://josh-gao.top/posts/fd2ca242.html">Part 2——Verilog
语言基础</a>和 <a href="https://josh-gao.top/posts/fd117896.html">Part
3——描述方式和设计层次</a>中论述了 Verilog 的基本语法和常用关键字，其中
RTL 级设计可综合的FSM 相关的常用关键字如下：</p>
<ol type="1">
<li><p><code>wire</code>、<code>reg</code> 等</p>
<p>对 <code>wire</code>、<code>reg</code>
等变量、向量定义不加累述，需要补充的是<strong>状态编码时（也就是用某种编码描述各个状态）一般都要使用
<code>reg</code> 寄存器型向量</strong>。</p></li>
<li><p><code>parameter</code></p>
<p>用于描述状态名称，增强源代码可读性，简化描述。</p>
<p>例：某状态机使用初始值为 <code>0</code>
的<strong>独热码</strong>（one-hot）编码方式定义的 4 bit 宽度的状态变量
<code>NS</code>（代表 Next State，下一状态）和 <code>CS</code>（代表
Current State，当前状态），且状态机包含 5 个具体状态
<code>IDLE</code>（空闲状态）、<code>S1</code>（工作状态 1）、
<code>S2</code>（工作状态 2）、 <code>S3</code>（工作状态
3）、<code>ERROR</code>（告警状态），则代码如下：</p>
<p></p><figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span>         [<span class="number">3</span>:<span class="number">0</span>] NS,CS;</span><br><span class="line"><span class="keyword">parameter</span>   [<span class="number">3</span>:<span class="number">0</span>]             <span class="comment">// one hot with zero initial</span></span><br><span class="line">    IDLE    = <span class="number">4'b0000</span>,</span><br><span class="line">    S1      = <span class="number">4'b0001</span>,</span><br><span class="line">    S2      = <span class="number">4'b0010</span>,</span><br><span class="line">    S3      = <span class="number">4'b0100</span>,</span><br><span class="line">    ERROR   = <span class="number">4'b1000</span>;</span><br></pre></td></tr></tbody></table></figure><p></p></li>
<li><p><code>always</code></p>
<p>在 FSM 设计中有 3 种 <code>always</code> 的使用方法，第 1
种用法是根据<strong>主时钟沿</strong>，完成同步时序的状态迁移。</p>
<p>例：某状态机从当前状态 <code>CS</code> 迁移到下一个状态
<code>NS</code> 可以如下表述：</p>
<p></p><figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// sequential state transition</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> elk <span class="keyword">or</span> <span class="keyword">negedge</span> nrst)</span><br><span class="line">    <span class="keyword">if</span> (!nrst)</span><br><span class="line">        CS &lt;= IDLE;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        CS &lt;= NS;</span><br></pre></td></tr></tbody></table></figure><p></p>
<p><code>always</code> 的第 2
种用法是根据<strong>信号敏感表</strong>，完成组合逻辑的输出。</p>
<p><code>always</code> 的第 3
种用法是根据<strong>时钟沿</strong>，完成同步时序逻辑的输出。</p></li>
<li><p><code>case/endcase</code></p>
<p><code>case/endcase</code> 是 FSM 描述中最重要的语法关键字
，要详细讨论一下。 <code>case/endcase</code> 的基本语法结构如下：</p>
<p></p><figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> (case_expression)</span><br><span class="line">    case_item1 : case_item_statement1;</span><br><span class="line">    case_item2 : case_item_statement2;</span><br><span class="line">    case_item3 : case_item_statement3;</span><br><span class="line">    case_item4 : case_item_statement4;</span><br><span class="line">    <span class="keyword">default</span>    : case_item_statement5;</span><br><span class="line"><span class="keyword">endcase</span></span><br></pre></td></tr></tbody></table></figure><p></p>
<p>其中：</p>
<ul>
<li><code>case_expression</code> 就是 <code>case</code>
的判断条件表达式，在 FSM 描述中，它一般为当前状态寄存器；每个
<code>case_item</code> 是 <code>case</code> 语句的分支列表，在 FSM
描述中，它一般为 FSM
中的所有状态的罗列，从中还可以分析出状态的编码方式；</li>
<li><code>case_item_statement</code> 为进入每个 <code>case_item</code>
的对应操作，在 FSM 中，即为每个状态对应的状态转移或者输出，如果
<code>case_item_statement</code> 包含的操作不只一条，可以用
<code>begin/end</code> 嵌套多条操作；</li>
<li><code>default</code> 是可选的关键字，用以指明当所列的所有
<code>case_item</code> 与 <code>case_ex­pression</code>
都不匹配时的操作，在 FSM 设计中，为了提高设计的安全性，排除所设计的FSM
进入死循环，一般要求加上 <code>default</code> 关键字来描述 FSM
所需状态的补集状态下的操作。</li>
</ul>
<p>另外 Verilog 还支持 <code>casex</code> 和 <code>casez</code>
等不同关键字，但是由于综合器对这两个关键字的支持情况略有差异，所以建议初学者使用完整的
<code>case</code> 结构而不使用 <code>casex</code> 或
<code>casez</code>。</p>
<p>例：某 FSM 的状态转移用 <code>case/endcase</code> 结构描述如下：</p>
<p></p><figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> (CS)</span><br><span class="line">    IDLE:       <span class="keyword">begin</span></span><br><span class="line">                    IDLE_out;</span><br><span class="line">                    <span class="keyword">if</span> (~i1)             NS = IDLE;</span><br><span class="line">                    <span class="keyword">if</span> (i1 &amp;&amp; i2)         NS = S1;</span><br><span class="line">                    <span class="keyword">if</span> (i1 &amp;&amp; (~i2))     NS = ERROR;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">    S1:         <span class="keyword">begin</span></span><br><span class="line">                    S1_out;</span><br><span class="line">                    <span class="keyword">if</span> (~i2)            NS = S1;</span><br><span class="line">                    <span class="keyword">if</span> (i2 &amp;&amp; i1)        NS = S2;</span><br><span class="line">                    <span class="keyword">if</span> (i2 &amp;&amp; (~i))        NS = ERROR;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">    S2:         <span class="keyword">begin</span></span><br><span class="line">                    S2_out;</span><br><span class="line">                    <span class="keyword">if</span> (i2)                NS = S2;</span><br><span class="line">                    <span class="keyword">if</span> ((~i2) &amp;&amp; i1)    NS = IDLE;</span><br><span class="line">                    <span class="keyword">if</span> ((~i2) &amp;&amp; (~i1))    NS = ERROR;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">    ERROR:      <span class="keyword">begin</span></span><br><span class="line">                    ERROR_out;</span><br><span class="line">                    <span class="keyword">if</span> (i1)                NS = ERROR;</span><br><span class="line">                    <span class="keyword">if</span> (~i1)            NS = IDLE;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">default</span>:    <span class="keyword">begin</span></span><br><span class="line">                    Default_out;</span><br><span class="line">                    NS = ERROE;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endcase</span></span><br></pre></td></tr></tbody></table></figure><p></p>
<p></p><div class="note warning"><p>Verilog 的 <code>case</code> 结构虽然与 C 等高级语言的
<code>case</code> 结构形式相似，但是本质不同。Verilog 的
<code>case</code> 结构对应并行判断的硬件结构，而且当
<code>case_expression</code> 与任意一个 <code>case_item</code>
匹配后，将忽略对其他 <code>case_item</code> 的判断，执行完匹配的
<code>case_item_statement</code> 后直接跳出 <code>case</code> 结构。</p>
</div><p></p></li>
<li><p><code>task/endtask</code></p>
<p><code>task/endtask</code>
在描述状态机时主要用途是将不同状态对应的输出用 <code>task/endtask</code>
封装，增强了代码的可维护性和可读性。</p>
<p>例：某状态机 IDLE 状态的输出可以用 <code>task/endtask</code> 封装为
<code>IDLE_out</code> 任务：</p>
<p></p><figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">task</span> IDLE_out;</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        {w_ol, w_o2, w_err} = <span class="number">3'b000</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endtask</span></span><br></pre></td></tr></tbody></table></figure><p></p>
<p><code>endtask</code> 描述状态机时也会使用到其他一些常用的 RTL
级语法，如 <code>if/else</code>、<code>as­sign</code>
等，它们的功能和一般 RTL 描述方法一致，这里不在叙述。</p></li>
</ol>
<h2 id="推荐的状态机描述方法">2.3.
推荐的状态机描述方法<a id="2.3"></a></h2>
<p>状态机描述时关键是要描述清楚前面提到的几个状态机的要素，即如何进行状态转移；每个状态的输出是什么；状态转移是否和输入条件相关等。具体描述时方法各不相同。</p>
<ul>
<li><p>有的设计者习惯将整个状态机写到 1 个 always
模块里面，在该模块中既描述状态转移，又描述状态的输入和输出，这种写法一般被称为<strong>一段式
FSM 描述方法</strong>；</p></li>
<li><p>还有一种写法是将 2 个 <code>always</code> 模块中的一个
<code>always</code>
模块采用同步时序描述状态转移，另一个模块采用组合逻辑判断状态转移条件，描述状态转移规律，这种写法被称为<strong>两段式
FSM 描述方法</strong>；</p></li>
<li><p>还有一种写法是在两段式描述方法基础上发展出来的，这种写法使用 3 个
<code>always</code> 模块，第 1 个 <code>always</code>
模块采用同步时序描述状态转移；第 2
个采用组合逻辑判断状态转移条件，描述状态转移规律；第 3 个
<code>always</code>
模块使用同步时序电路描述每个状态的输出，这种写法在这里称为<strong>三段式写法</strong>。</p></li>
</ul>
<p>一般而言，推荐的 FSM 描述方法是后两种，即两段式和三段式 FSM
描述方法。其原因为：FSM
和其他设计一样，最好使用同步时序方式设计，以提高设计的稳定性，消除毛刺。状态机实现后，一般来说，<strong>状态转移部分是同步时序电路</strong>，而<strong>状态的转移条件的判断是组合逻辑</strong>。两段式之所以比一段式编码合理，就在于<strong>两段式编码将同步时序和组合逻辑分别放到不同的
<code>always</code>
程序块中实现</strong>。这样做的好处不仅是便于阅读、理解、维护，更重要的是利于综合器优化代码、利于用户添加合适的时序约束条件、利于布局布线器实现设计。而一段式
FSM 描述不利于时序约束、功能更改、调试等，而且不能很好的表示米里 FSM
的输出，容易写出 Latches，导致逻辑功能错误。</p>
<p>在一般两段式描述中，为了便于描述当前状态的输出，很多设计者习惯将当前状态的输出用组合逻辑实现。但是这种组合逻辑<strong>仍然有产生毛刺的可能性</strong>，而且不利于约束、不利于综合器和布局布线器实现高性能的设计。因此如果设计运行额外的一个时钟节拍的插入（latency），则要求尽量对状态机的输出用寄存器寄存一拍。但是很多<strong>实际情况不允许插入一个寄存节拍，此时则可以通过三段式描述方法进行解决</strong>。三段式与两段式相比，关键在于根据状态转移规律，在上一状态根据输入条件判断出当前状态的输出，从而在不插入额外时钟节拍的前提下，实现了寄存器输出。</p>
<p>为了便于理解，将通过一个使用不同的 FSM 描述风格描述状态机的实例讨论这
3 种不同的写法。</p>
<p>在这个范例中将用一段式、两段式、三段式分别描述例子的状态转移，如<a href="#fig.6-3">图 6-3</a>
所示。这里选用了一个非常典型的米里型状态机，共有 4 个状态：
<code>IDEL</code>、<code>S1</code>、<code>S2</code>、<code>ERROR</code>；输入信号为时钟
<code>clk</code>，低电平异步复位信号 <code>nrst</code>， 输入信号
<code>i1</code>、<code>i2</code>，输出信号为
<code>o1</code>、<code>o2</code> 和 <code>err</code>，状态关系如<a href="#fig.6-3">图 6-3</a> 所示。状态的输出如下：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line">IDLE        状态的输出为：    {o1, o2, err} = <span class="number">3'b000</span>；</span><br><span class="line">S1          状态的输出为：    {o1, o2, err} = <span class="number">3'b100</span>；</span><br><span class="line">S2          状态的输出为：    {o1, o2, err} = <span class="number">3'b010</span>；</span><br><span class="line">ERROR       状态的输出为：    {o1, o2, err} = <span class="number">3'b111</span>。</span><br></pre></td></tr></tbody></table></figure>
<p><a id="fig.6-3"></a></p>
<figure>
<img data-src="../images/post/2023-04-16-josh-verilog-part-6/2023-04-16-josh-verilog-part-6-030-StateTransitionDiagramOfExample.png" width="600" alt="图 6-3 例子的状态转移图">
<figcaption aria-hidden="true">图 6-3 例子的状态转移图</figcaption>
</figure>
<h3 id="一段式状态机描述方法应该避免的写法">2.3.1.
一段式状态机描述方法（应该避免的写法）</h3>
<p>该例的一段式描述代码如下：</p>
<figure class="highlight verilog"><figcaption><span>state1.v</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// state1.v</span></span><br><span class="line"><span class="comment">// 1-paragraph method to describe FSM</span></span><br><span class="line"><span class="comment">// Describe state transition, state output, state input condition in only 1</span></span><br><span class="line"><span class="comment">// always block</span></span><br><span class="line"><span class="comment">// Westor, Dec. 2006</span></span><br><span class="line"><span class="comment">// Verilog Usage Book</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> state1 (</span><br><span class="line">    nrst,clk,</span><br><span class="line">    i1,i2,</span><br><span class="line">    o1,o2,</span><br><span class="line">    err</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>          nrst,clk;</span><br><span class="line"><span class="keyword">input</span>          i1,i2;</span><br><span class="line"><span class="keyword">output</span>         o1,o2,err;</span><br><span class="line"><span class="keyword">reg</span>            o1,o2,err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span>    [<span class="number">2</span>:<span class="number">0</span>]   NS;      <span class="comment">// NextState</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">parameter</span> [<span class="number">2</span>:<span class="number">0</span>]         <span class="comment">// one hot with zero idle</span></span><br><span class="line">    IDLE   = <span class="number">3'b000</span>,</span><br><span class="line">    S1     = <span class="number">3'b001</span>,</span><br><span class="line">    S2     = <span class="number">3'b010</span>,</span><br><span class="line">    ERROR  = <span class="number">3'b100</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1 always block to describe state transition, state output, state input</span></span><br><span class="line"><span class="comment">// condition</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> nrst)</span><br><span class="line">    <span class="keyword">if</span> (!nrst) <span class="keyword">begin</span></span><br><span class="line">       NS         &lt;= IDLE;</span><br><span class="line">      {o1,o2,err} &lt;= <span class="number">3'b000</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        NS          &lt;=  <span class="number">3'bx</span>;</span><br><span class="line">        {o1,o2,err} &lt;=  <span class="number">3'b000</span>;</span><br><span class="line">        <span class="keyword">case</span> (NS)</span><br><span class="line">            IDLE:  <span class="keyword">begin</span></span><br><span class="line">                    <span class="keyword">if</span> (~i1)         <span class="keyword">begin</span>{o1,o2,err}&lt;=<span class="number">3'b000</span>;NS &lt;= IDLE; <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">if</span> (i1 &amp;&amp; i2)    <span class="keyword">begin</span>{o1,o2,err}&lt;=<span class="number">3'b100</span>;NS &lt;= S1;   <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">if</span> (i1 &amp;&amp; ~i2)   <span class="keyword">begin</span>{o1,o2,err}&lt;=<span class="number">3'b111</span>;NS &lt;= ERROR;<span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">            S1:     <span class="keyword">begin</span></span><br><span class="line">                    <span class="keyword">if</span> (~i2)         <span class="keyword">begin</span>{o1,o2,err}&lt;=<span class="number">3'b100</span>;NS &lt;= S1;   <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">if</span> (i2 &amp;&amp; i1)    <span class="keyword">begin</span>{o1,o2,err}&lt;=<span class="number">3'b010</span>;NS &lt;= S2;   <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">if</span> (i2 &amp;&amp; (~i1)) <span class="keyword">begin</span>{o1,o2,err}&lt;=<span class="number">3'b111</span>;NS &lt;= ERROR;<span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">            S2:     <span class="keyword">begin</span></span><br><span class="line">                    <span class="keyword">if</span> (i2)          <span class="keyword">begin</span>{o1,o2,err}&lt;=<span class="number">3'b010</span>;NS &lt;= S2;   <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">if</span> (~i2 &amp;&amp; i1)   <span class="keyword">begin</span>{o1,o2,err}&lt;=<span class="number">3'b000</span>;NS &lt;= IDLE; <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">if</span> (~i2 &amp;&amp; (~i1))<span class="keyword">begin</span>{o1,o2,err}&lt;=<span class="number">3'b111</span>;NS &lt;= ERROR;<span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">            ERROR:  <span class="keyword">begin</span></span><br><span class="line">                    <span class="keyword">if</span> (i1)          <span class="keyword">begin</span>{o1,o2,err}&lt;=<span class="number">3'b111</span>;NS &lt;= ERROR;<span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">if</span> (~i1)         <span class="keyword">begin</span>{o1,o2,err}&lt;=<span class="number">3'b000</span>;NS &lt;= IDLE; <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></tbody></table></figure>
<p>如前面介绍，一段式写法就是将状态的同步转移、状态输出和状态的输入条件都写在一个
<code>always</code> 模块中，一段式写法可以概括为<a href="#fig.6-4">图
6-4</a> 描述的结构。</p>
<p><a id="fig.6-4"></a></p>
<figure>
<img data-src="../images/post/2023-04-16-josh-verilog-part-6/2023-04-16-josh-verilog-part-6-040-OneStageFSM.png" width="900" alt="图 6-4 一段式 FSM 描述结构">
<figcaption aria-hidden="true">图 6-4 一段式 FSM 描述结构</figcaption>
</figure>
<p>一段式描述方法将状态转移判断的组合逻辑和状态寄存器转移的时序逻辑混写在同一个
always 模块中，<strong>不符合将时序和组合逻辑分开描述的 Coding
Style（代码风格）</strong>，而且在描述当前状态时要考虑下个状态的输出，整个代码不清晰，不利于维护修改，并且不利于附加约束，不利于综合器和布局布线器对设计的优化。</p>
<p>另外，这种描述相对于两段式描述比较<strong>冗长</strong>。本例为了便于初学者掌握，选择了一个非常简单的米里型状态机，不能很好的反应一段式比较冗长的缺点，但是如果状态机相对复杂些，一般来说，一段式代码长度会比两段式冗长大约
80%~150%。</p>
<p>所以一段式 FSM 描述是不推荐的 FSM 描述方式，请一定要避免。</p>
<h3 id="两段式状态机描述方法推荐写法">2.3.2.
两段式状态机描述方法（推荐写法）</h3>
<p>为了使 FSM
描述清晰简洁，易于维护，易于附加时序约束，使综合器和布局布线器更好的优化设计，推荐使用两段式
FSM 描述方法。</p>
<p>本例的两段式描述代码如下：</p>
<figure class="highlight verilog"><figcaption><span>state2.v</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// state2.v</span></span><br><span class="line"><span class="comment">// 2-paragraph method to describe FSM</span></span><br><span class="line"><span class="comment">// Describe sequential state transition in 1 sequential always block</span></span><br><span class="line"><span class="comment">// State transition conditions in the other combinational always block</span></span><br><span class="line"><span class="comment">// Package state output by task. Then register the output</span></span><br><span class="line"><span class="comment">// Westor, Dec. 2006</span></span><br><span class="line"><span class="comment">// Verilog Usage Book</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> state2 (</span><br><span class="line">    nrst,clk,</span><br><span class="line">    i1,i2,</span><br><span class="line">    o1,o2,</span><br><span class="line">    err</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>          nrst,clk;</span><br><span class="line"><span class="keyword">input</span>          i1,i2;</span><br><span class="line"><span class="keyword">output</span>         o1,o2,err;</span><br><span class="line"><span class="keyword">reg</span>            o1,o2,err;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span>    [<span class="number">2</span>:<span class="number">0</span>]   NS,CS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">parameter</span> [<span class="number">2</span>:<span class="number">0</span>]         <span class="comment">// one hot with zero idle</span></span><br><span class="line">    IDLE   = <span class="number">3'b000</span>,</span><br><span class="line">    S1     = <span class="number">3'b001</span>,</span><br><span class="line">    S2     = <span class="number">3'b010</span>,</span><br><span class="line">    ERROR  = <span class="number">3'b100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sequential state transition</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> nrst)</span><br><span class="line">    <span class="keyword">if</span> (!nrst)</span><br><span class="line">        CS &lt;= IDLE;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        CS &lt;= NS;</span><br><span class="line"></span><br><span class="line"><span class="comment">// combinational condition judgment</span></span><br><span class="line"><span class="keyword">always</span> @(nrst <span class="keyword">or</span> CS <span class="keyword">or</span> i1 <span class="keyword">or</span> i2) <span class="keyword">begin</span></span><br><span class="line">    NS = <span class="number">3'bx</span>;</span><br><span class="line">    ERROR_out;</span><br><span class="line">    <span class="keyword">case</span> (CS)</span><br><span class="line">        IDLE:   <span class="keyword">begin</span></span><br><span class="line">                    IDLE_out;</span><br><span class="line">                    <span class="keyword">if</span> (~i1)           NS = IDLE;</span><br><span class="line">                    <span class="keyword">if</span> (i1 &amp;&amp; i2)      NS = S1;</span><br><span class="line">                    <span class="keyword">if</span> (i1 &amp;&amp; ~i2)     NS = ERROR;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">        S1:     <span class="keyword">begin</span></span><br><span class="line">                    S1_out;</span><br><span class="line">                    <span class="keyword">if</span> (~i2)           NS = S1;</span><br><span class="line">                    <span class="keyword">if</span> (i2 &amp;&amp; i1)      NS = S2;</span><br><span class="line">                    <span class="keyword">if</span> (i2 &amp;&amp; (~i1))   NS = ERROR;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">        S2:     <span class="keyword">begin</span></span><br><span class="line">                    S2_out;</span><br><span class="line">                    <span class="keyword">if</span> (i2)            NS = S2;</span><br><span class="line">                    <span class="keyword">if</span> (~i2 &amp;&amp; i1)     NS = IDLE;</span><br><span class="line">                    <span class="keyword">if</span> (~i2 &amp;&amp; (~i1))  NS = ERROR;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">        ERROR:  <span class="keyword">begin</span></span><br><span class="line">                    ERROR_out;</span><br><span class="line">                    <span class="keyword">if</span> (i1)            NS = ERROR;</span><br><span class="line">                    <span class="keyword">if</span> (~i1)           NS = IDLE;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// output task</span></span><br><span class="line"><span class="keyword">task</span> IDLE_out;</span><br><span class="line">     {o1,o2,err} = <span class="number">3'b000</span>;</span><br><span class="line"><span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">task</span> S1_out;</span><br><span class="line">     {o1,o2,err} = <span class="number">3'b100</span>;</span><br><span class="line"><span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">task</span> S2_out;</span><br><span class="line">     {o1,o2,err} = <span class="number">3'b010</span>;</span><br><span class="line"><span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">task</span> ERROR_out;</span><br><span class="line">     {o1,o2,err} = <span class="number">3'b111</span>;</span><br><span class="line"><span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></tbody></table></figure>
<p>两段式写法是推荐的 FSM 描述方法之一，在此仔细讨论一下代码结构。两段式
FSM 的核心就是：<strong>一个 always
模块采用同步时序描述状态转移；另一个模块采用组合逻辑判断状态转移条件，描述状态转移规律</strong>。两段式写法可以概括为<a href="图6-5">图 6-5</a> 所示的结构。</p>
<p><a id="fig.6-5"></a></p>
<figure>
<img data-src="../images/post/2023-04-16-josh-verilog-part-6/2023-04-16-josh-verilog-part-6-050-TwoStageFSM.png" width="900" alt="图 6-5 两段式FSM描述结构图">
<figcaption aria-hidden="true">图 6-5 两段式FSM描述结构图</figcaption>
</figure>
<p>本例中，同步时序描述状态转移的 <code>always</code> 模块代码如下：</p>
<figure class="highlight verilog"><figcaption><span>state2.v</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> nrst)</span><br><span class="line">    <span class="keyword">if</span> (!nrst)</span><br><span class="line">        CS &lt;= IDLE;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        CS &lt;= NS;</span><br></pre></td></tr></tbody></table></figure>
<p>其实这是一种<strong>程式化的描述结构</strong>，无论具体到何种 FSM
设计，都可以定义两个状态寄存器 <code>CS</code> 和 <code>NS</code>,
分别代表当前状态和下一状态 ，
然后根据所需的复位方式（同步复位或异步复位），在时钟沿到达时将
<code>NS</code> 赋给 <code>CS</code>
。需要注意的是这个同步时序模块的赋值要<strong>采用非阻塞赋值</strong>
<code>&lt;=</code>。</p>
<p>本例中，另一个采用组合逻辑判断状态转移条件的 <code>always</code>
模块代码如下：</p>
<figure class="highlight verilog"><figcaption><span>state2.v</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// combinational condition judgment</span></span><br><span class="line"><span class="keyword">always</span> @(nrst <span class="keyword">or</span> CS <span class="keyword">or</span> i1 <span class="keyword">or</span> i2) <span class="keyword">begin</span></span><br><span class="line">    NS = <span class="number">3'bx</span>;</span><br><span class="line">    ERROR_out;</span><br><span class="line">    <span class="keyword">case</span> (CS)</span><br><span class="line">        IDLE:   <span class="keyword">begin</span></span><br><span class="line">                    IDLE_out;</span><br><span class="line">                    <span class="keyword">if</span> (~i1)           NS = IDLE;</span><br><span class="line">                    <span class="keyword">if</span> (i1 &amp;&amp; i2)      NS = S1;</span><br><span class="line">                    <span class="keyword">if</span> (i1 &amp;&amp; ~i2)     NS = ERROR;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">        S1:     <span class="keyword">begin</span></span><br><span class="line">                    S1_out;</span><br><span class="line">                    <span class="keyword">if</span> (~i2)           NS = S1;</span><br><span class="line">                    <span class="keyword">if</span> (i2 &amp;&amp; i1)      NS = S2;</span><br><span class="line">                    <span class="keyword">if</span> (i2 &amp;&amp; (~i1))   NS = ERROR;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">        S2:     <span class="keyword">begin</span></span><br><span class="line">                    S2_out;</span><br><span class="line">                    <span class="keyword">if</span> (i2)            NS = S2;</span><br><span class="line">                    <span class="keyword">if</span> (~i2 &amp;&amp; i1)     NS = IDLE;</span><br><span class="line">                    <span class="keyword">if</span> (~i2 &amp;&amp; (~i1))  NS = ERROR;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">        ERROR:  <span class="keyword">begin</span></span><br><span class="line">                    ERROR_out;</span><br><span class="line">                    <span class="keyword">if</span> (i1)            NS = ERROR;</span><br><span class="line">                    <span class="keyword">if</span> (~i1)           NS = IDLE;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<p>这个使用组合逻辑判断状态转移条件的 <code>always</code>
模块也<strong>可以看成格式化的书写结构</strong>。其中
<code>always</code> 的敏感列表为当前状态 <code>CS</code>,
复位信号和输入条件（<strong>如果是米里状态机，则必须有输入条件；如果是摩尔状态机，一般敏感表和后续逻辑判定没有输入</strong>），请大家注意<strong>电平敏感表必须列完整</strong>。本例中这段电平敏感列表为：</p>
<figure class="highlight verilog"><figcaption><span>state2.v</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(nrst <span class="keyword">or</span> CS <span class="keyword">or</span> i1 <span class="keyword">or</span> i2)</span><br></pre></td></tr></tbody></table></figure>
<p>一般来说，在这个组合 <code>always</code>
敏感表下先写一个默认的下一状态 <code>NS</code>
的描述，然后根据实际的状态转移条件由内部的 <code>case</code> 或者
<code>if ... else</code>
条件判断确定正确的转移。如本例中下面这段代码，</p>
<figure class="highlight verilog"><figcaption><span>state2.v</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    NS = <span class="number">3'bx</span>;</span><br><span class="line">    ERROR_out;</span><br><span class="line">    <span class="keyword">case</span> (CS)</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></tbody></table></figure>
<p>推荐<strong>在敏感表下的默认状态为不定状态 <code>X</code></strong>，
这样描述的好处有两个：第一在仿真时可以很好地考察所设计的 FSM
的完备性，如果所设计的 FSM
不完备，则会进入任意状态，仿真很容易发现；第二个好处是综合器对不定态
<code>X</code> 的处理是 “Don’t
Care”，即<strong>任何没有定义的状态寄存器向最都会被忽略</strong>。这里赋值不定态的效果和使用
<code>casez</code> 或 <code>casex</code> 替代 case 的效果非常相似。</p>
<p>在每个 <code>case</code>
模块内部的结构也非常相似，都是先描述当前状态的组合逻辑输出，然后根据输入条件（米里
FSM) 判定下一个状态。</p>
<p>该组合逻辑模块中所有的赋值推荐采用阻塞赋值 <code>=</code>。</p>
<div class="note warning"><p>请注意，虽然下一状态寄存器 <code>NS</code> 为寄存器类型，但是在两段式
FSM 的判断状态转移条件的 <code>always</code>
模块中，<strong>实际上对应的真实硬件电路是纯组合逻辑电路</strong>。</p>
</div>
<p>对于每个输出，一般用组合逻辑描述，比较简便的方法是用
<code>task/endtask</code>
将输出封装起来，这样不仅是写法简单，而且利于复用共同的输出。如本例中
<code>S1</code> 状态的输出被封装为 <code>S1_out</code>，在组合逻辑
<code>always</code> 模块中直接调用即可。</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">task</span> IDLE_out;</span><br><span class="line">     {o1,o2,err} = <span class="number">3'b000</span>;</span><br><span class="line"><span class="keyword">endtask</span></span><br></pre></td></tr></tbody></table></figure>
<p>组合逻辑容易产生毛刺，因此如果时序允许，请尽量<strong>对组合逻辑的输出插入一个寄存器节拍</strong>，这样可以很好地保证输出信号的稳定性。</p>
<h3 id="三段式状态机描述方法推荐写法">2.3.3.
三段式状态机描述方法（推荐写法）</h3>
<p>两段式 FSM
描述方法虽然有很多好处，但是它有一个明显的弱点就是其输出一般使用组合逻辑描述，而组合逻辑易产生毛刺等不稳定因素，并且在
FPGA/CPLD 等逻辑器件中过多的组合逻辑会影响实现的速率（这点与 ASIC
设计不同）。所以在上节特别提到了在两段式 FSM
描述方法中，如果时序允许插入一个额外的时钟节拍，则尽量在后级电路对 FSM
的组合逻辑输出用寄存器寄存一个节拍，则可以有效地消除毛刺。但是很多情况下，设计并不允许额外的节拍插入（Latency），此时，解决之道就是采用三段式
FSM
描述方法。三段式描述方法与两段式描述方法相比，关键在于使用同步时序逻辑寄存
FSM 的输出。</p>
<p>本例的三段式描述代码如下：</p>
<figure class="highlight verilog"><figcaption><span>state3.v</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// state3.v</span></span><br><span class="line"><span class="comment">// 3-paragraph method to describe FSM</span></span><br><span class="line"><span class="comment">// Describe sequential state transition in the 1st sequential always block</span></span><br><span class="line"><span class="comment">// State transition conditions in the 2nd combinational always block</span></span><br><span class="line"><span class="comment">// Describe the FSM out in the 3rd sequential always block</span></span><br><span class="line"><span class="comment">// Westor, Dec. 2006</span></span><br><span class="line"><span class="comment">// Verilog Usage Book</span></span><br><span class="line"><span class="keyword">module</span> state3 (</span><br><span class="line">    nrst,clk,</span><br><span class="line">    i1,i2,</span><br><span class="line">    o1,o2,</span><br><span class="line">    err</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>          nrst,clk;</span><br><span class="line"><span class="keyword">input</span>          i1,i2;</span><br><span class="line"><span class="keyword">output</span>         o1,o2,err;</span><br><span class="line"><span class="keyword">reg</span>            o1,o2,err;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span>    [<span class="number">2</span>:<span class="number">0</span>]   NS,CS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">parameter</span> [<span class="number">2</span>:<span class="number">0</span>]         <span class="comment">// one hot with zero idle</span></span><br><span class="line">    IDLE   = <span class="number">3'b000</span>,</span><br><span class="line">    S1     = <span class="number">3'b001</span>,</span><br><span class="line">    S2     = <span class="number">3'b010</span>,</span><br><span class="line">    ERROR  = <span class="number">3'b100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1st always block, sequential state transition</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> nrst)</span><br><span class="line">    <span class="keyword">if</span> (!nrst)</span><br><span class="line">        CS &lt;= IDLE;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        CS &lt;= NS;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2nd always block, combinational condition judgment</span></span><br><span class="line"><span class="keyword">always</span> @ (nrst <span class="keyword">or</span> CS <span class="keyword">or</span> i1 <span class="keyword">or</span> i2) <span class="keyword">begin</span></span><br><span class="line">    NS = <span class="number">3'bx</span>;</span><br><span class="line">    <span class="keyword">case</span> (CS)</span><br><span class="line">        IDLE:   <span class="keyword">begin</span></span><br><span class="line">                    <span class="keyword">if</span> (~i1)           NS = IDLE;</span><br><span class="line">                    <span class="keyword">if</span> (i1 &amp;&amp; i2)      NS = S1;</span><br><span class="line">                    <span class="keyword">if</span> (i1 &amp;&amp; ~i2)     NS = ERROR;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">        S1:     <span class="keyword">begin</span></span><br><span class="line">                    <span class="keyword">if</span> (~i2)           NS = S1;</span><br><span class="line">                    <span class="keyword">if</span> (i2 &amp;&amp; i1)      NS = S2;</span><br><span class="line">                    <span class="keyword">if</span> (i2 &amp;&amp; (~i1))   NS = ERROR;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">        S2:     <span class="keyword">begin</span></span><br><span class="line">                    <span class="keyword">if</span> (i2)            NS = S2;</span><br><span class="line">                    <span class="keyword">if</span> (~i2 &amp;&amp; i1)     NS = IDLE;</span><br><span class="line">                    <span class="keyword">if</span> (~i2 &amp;&amp; (~i1))  NS = ERROR;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">        ERROR:  <span class="keyword">begin</span></span><br><span class="line">                    <span class="keyword">if</span> (i1)            NS = ERROR;</span><br><span class="line">                    <span class="keyword">if</span> (~i1)           NS = IDLE;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3rd always block, the sequential FSM output</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> nrst)</span><br><span class="line">    <span class="keyword">if</span> (!nrst)</span><br><span class="line">        {o1,o2,err} &lt;= <span class="number">3'b000</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        {o1,o2,err} &lt;=  <span class="number">3'b000</span>;</span><br><span class="line">    <span class="keyword">case</span> (NS)</span><br><span class="line">        IDLE:   {o1,o2,err} &lt;= <span class="number">3'b000</span>;</span><br><span class="line"></span><br><span class="line">        S1:     {o1,o2,err} &lt;= <span class="number">3'b100</span>;</span><br><span class="line">        S2:     {o1,o2,err} &lt;= <span class="number">3'b010</span>;</span><br><span class="line">        ERROR:  {o1,o2,err} &lt;= <span class="number">3'b111</span>;</span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></tbody></table></figure>
<p>三段式写法可以概括为<a href="#fig.6-6">图 6-6</a> 描述的结构。</p>
<p><a id="fig.6-6"></a></p>
<figure>
<img data-src="../images/post/2023-04-16-josh-verilog-part-6/2023-04-16-josh-verilog-part-6-060-ThreeStageFSM.png" width="1000" alt="图 6-6 三段式FSM描述结构图">
<figcaption aria-hidden="true">图 6-6 三段式FSM描述结构图</figcaption>
</figure>
<p>对比上节两段式 FSM 的描述，可以清晰发现三段式与两段式 FSM
描述的最大区别在于<strong>两段式采用了组合逻辑输出</strong>，而<strong>三段式巧妙地根据下一状态的判断，用同步时序逻辑寄存
FSM 的输出</strong>。本例中就是下面一段代码，</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> nrst)</span><br><span class="line">    <span class="keyword">if</span> (!nrst)</span><br><span class="line">        {o1,o2,err} &lt;= <span class="number">3'b000</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        {o1,o2,err} &lt;=  <span class="number">3'b000</span>;</span><br><span class="line">    <span class="keyword">case</span> (NS)</span><br><span class="line">        IDLE:   {o1,o2,err} &lt;= <span class="number">3'b000</span>;</span><br><span class="line"></span><br><span class="line">        S1:     {o1,o2,err} &lt;= <span class="number">3'b100</span>;</span><br><span class="line">        S2:     {o1,o2,err} &lt;= <span class="number">3'b010</span>;</span><br><span class="line">        ERROR:  {o1,o2,err} &lt;= <span class="number">3'b111</span>;</span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<p>大家可能会问，一段式写法也是用寄存器同步了 FSM
的输出，为什么前面介绍一段式的输出代码容易混淆，不利于维护呢？请大家对比一下这段一段式输出的代码，</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">case</span>(NS)</span><br><span class="line">    IDLE:   <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span> (~i1)         <span class="keyword">begin</span>{o1,o2,err}&lt;=<span class="number">3'b000</span>;NS &lt;= IDLE; <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">if</span> (i1 &amp;&amp; i2)    <span class="keyword">begin</span>{o1,o2,err}&lt;=<span class="number">3'b100</span>;NS &lt;= S1;   <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">if</span> (i1 &amp;&amp; ~i2)   <span class="keyword">begin</span>{o1,o2,err}&lt;=<span class="number">3'b111</span>;NS &lt;= ERROR;<span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<p>通过对比，可以清晰地看到：使用一段式建模 FSM
的寄存器输出的时候，<strong>必须要综合考虑现态在何种状态转移条件下会进入哪些次态</strong>，然后在每个现态的
<code>case</code>
分支下分别描述每个次态的输出，这显然不符合思维习惯；而三段式建模描述 FSM
的状态机输出时，<strong>只需指定 <code>case</code>
敏感表为次态寄存器，然后直接在每个次态的 <code>case</code>
分支中描述该状态的输出即可</strong>，根本不用考虑状态转移条件。本例的
FSM 很简单，如果设计的 FSM 相对复杂，三段式的描述优势就会凸显出来。</p>
<p>另一方面，三段式描述方法与两段式描述相比，虽然代码结构复杂了一些，但是换来的优势是使
FSM
做到了同步寄存器输出，消除了组合逻辑输出的不稳定与毛刺的隐患，而且更利于时序路径分组，一般来说在
FPGA/CPLD 等可编程逻辑器件上的综合与布局布线效果更佳。</p>
<div class="note warning"><p>请注意，在三段式 FSM 描述方法中，<strong>判断状态转移的
<code>always</code> 模块的 <code>case</code> 语句判断的条件是当前状态
<code>CS</code></strong>，而<strong>在同步时序 FSM 输出的
<code>always</code> 模块的 <code>case</code> 语句判断的条件是下一状态
<code>NS</code></strong>。</p>
</div>
<h3 id="种描述方法与状态机建模问题的引申">2.3.4. 3
种描述方法与状态机建模问题的引申</h3>
<p>可以说合理的状态机描述与状态机的建模技巧是本章的重中之重。这里需要引申讨论几个问题。</p>
<h4 id="n-段式描述方法和-always-语法块的个数">2.3.4.1. n 段式描述方法和
<code>always</code> 语法块的个数</h4>
<p>通过学习，大家知道标准的一段式、两段式、三段式 FSM 描述方法分别使用了
1、2、3 个 <code>always</code>
语法块。但是请注意，这个命题的反命题不成立，不能说一段 FSM
的描述中使用了 n 个 <code>always</code> 语法块，就是 n
段式描述方法。这是因为<strong>特指的一段式、两段式、三段式 FSM
描述方法中每个 <code>always</code>
语法块都有固定的描述内容和格式化的结构</strong>，其实也就是通过这些特定的描述内容和格式化的结构，确立了
3 种 FSM 建模方式。</p>
<p>例如两段式写法中，第一个 <code>always</code>
模块格式化地使用同步时序电路描述次态寄存器到现态寄存器的转移；而第二个
<code>always</code> 模块格式化地使用纯组合逻辑描述状态转移条件。
也就是说两段式描述对应的建模方式的硬件电路就是<a href="#fig.6-5">图
6-5</a> 所示的电路结构。其实从语法角度说，可以将一个 <code>always</code>
模块拆分成多个 <code>always</code> 模块，或者反之将多个
<code>always</code> 模块合并为一个 <code>always</code>
模块。所以请注意，<strong>n 段式 FSM
描述方法强调的是一种建模思路，绝不是简单的 <code>always</code>
语法块个数</strong>。</p>
<h4 id="fsm-的建模方式">2.3.4.2. FSM 的建模方式</h4>
<p>反复强调的 n 段式描述方法其实是 FSM 的 3
种建模方式。大家回顾一下状态<a href="#fig.6-3">转移图 6-3</a> 描述的
FSM，在学习本节之前，大家可能会产生各种不同的描述思路，通过本节的学习，希望大家能够自然而然地想到用<a href="#fig.6-5">图 6-5</a>（对应两段式思路）和<a href="#fig.6-6">图
6-6</a>（对应三段式思路）的结构建模。其实对于绝大多数 FSM，都可以采用<a href="#fig.6-4">图 6-4</a>、<a href="#fig.6-5">图 6-5</a> 或<a href="#fig.6-6">图 6-6</a>
的结构建模。一般来说，推<strong>荐使用后两种结构建模</strong>。这是因为：两段式思路建模结构清晰，描述简洁，便于约束，而且如果允许输出逻辑、允许插入一个节拍，就可以通过插入输出寄存器改善输出逻辑的时序并避免组合逻辑的毛刺；三段式思路建模结构清晰，结构格式化，解决了不改变时序要求的前提下用寄存器做状态输出的问题。请大家仔细研究<a href="#fig.6-4">图 6-4</a>、<a href="#fig.6-5">图 6-5</a> 和<a href="#fig.6-6">图 6-6</a> 体会 3 种建模方式。</p>
<h4 id="一段式建模和三段式建模的关系">2.3.4.3.
一段式建模和三段式建模的关系</h4>
<p>引申比较一下 3 种 FSM 建模的关系。请比较<a href="#fig.6-4">图 6-4</a>
与<a href="#fig.6-6">图 6-6</a>，如果将<a href="#fig.6-4">图 6-4</a>
的两部分组合逻辑合并起来，则三段式建模电路与一段式建模电路的结构完全一致了，如<a href="#fig.6-7">图 6-7</a>
所示。反过来，可以看到三段式与一段式的最大区别在于：<strong>使用一段式建模
FSM
的寄存器输出的时候，必须要综合考虑现态在何种状态转移条件下会进入哪些次态，然后在每个现态的
<code>case</code>
分支下分别描述每个次态的输出</strong>，这显然不符合思维习惯；而<strong>三段式建模校描述
FSM 的状态机输出时，只需指定 <code>case</code>
敏感表为次态寄存器，然后直接在每个次态的 <code>case</code>
分支中描述该状态的输出即可，根本不用考虑状态转移条件</strong>。对于简单的
FSM，三段式建模的寄存器输出的优势还不是十分明显，但是对于复杂一些的
FSM，三段式建模的优势就会十分显著。</p>
<p><a id="fig.6-7"></a></p>
<figure>
<img data-src="../images/post/2023-04-16-josh-verilog-part-6/2023-04-16-josh-verilog-part-6-070-ComparisonOfOneAndThreeStageFSM.png" width="1000" alt="图 6-7 三段式建模结构与一段式建模结构的关系图">
<figcaption aria-hidden="true">图 6-7
三段式建模结构与一段式建模结构的关系图</figcaption>
</figure>
<h4 id="两段式建模和三段式建模的关系">2.3.4.4.
两段式建模和三段式建模的关系</h4>
<p>从代码上看，三段式建模的前两段与两段式建模完全相同，仅仅多了一段寄存器
FSM
输出。一般来说，使用寄存器输出可以改善输出的时序条件，还能避免组合电路的毛刺，所以是更为推荐的描述方式。但是电路设计不是一成不变的，存某些情况下，两段式结构比三段式结构更有优势。请大家再分析一下<a href="#fig.6-5">图 6-5</a> 和<a href="#fig.6-6">图 6-6</a>
的结构，细心的读者会发现，<strong>两段式用状态寄存器分割了两部分组合逻辑（状态转移条件组合逻辑和输出组合逻辑）</strong>；而<strong>三段式结构中，从输入到寄存器状态输出的路径上，要经过两部分组合逻辑（状态转移条件组合逻辑和输出组合逻辑）</strong>，从时序上，这两部分组合逻辑完全可以看为一体。这样<strong>这条路径的组合逻辑就比较繁杂，该路径的时序相对紧张</strong>。也就是说，两段式建模中用状态寄存器分割了组合逻辑，而三段式将寄存器移到组合逻辑的最后端。<strong>如果寄存器前的组合逻辑过于复杂，势必会成为整个设计的关键路径，此时就不宜再使用三段式建模，而要使用两段式建模</strong>。解决两段式建模组合逻辑输出产生毛刺的方法是，额外的在
FSM 后级电路插入寄存器，调整时序，完成功能。</p>
<h4 id="种描述-fsm-方法的比较">2.3.4.5. 3 种描述 FSM 方法的比较</h4>
<p>一般来说，3 种 FSM
描述方法可以用下表进行比较。但是请注意，任何一种描述的优劣只是一般规律，而不是绝对性规律。例如，一般来说不推荐一段式描述，但是如果
FSM
的结构十分简单，状态很少，状态转移条件和状态输出都十分简化，则使用一段式建模的效率很高。这些经验需要逐步积累，但是在这里推荐的是一般性规律，请结合电路，体会这几种
FSM 建模方法。</p>
<table>
<colgroup>
<col style="width: 35%">
<col style="width: 21%">
<col style="width: 21%">
<col style="width: 21%">
</colgroup>
<tbody>
<tr>
<td style="text-align: left;">推荐等级</td>
<td style="text-align: left;">不推荐</td>
<td style="text-align: left;">推荐</td>
<td style="text-align: left;">推荐</td>
</tr>
<tr>
<td style="text-align: left;">代码简洁程度<br>（对于相对复杂的 FSM
而言）</td>
<td style="text-align: left;">冗长</td>
<td style="text-align: left;">最简洁</td>
<td style="text-align: left;">简洁</td>
</tr>
<tr>
<td style="text-align: left;"><code>always</code> 模块个数</td>
<td style="text-align: left;">1</td>
<td style="text-align: left;">2</td>
<td style="text-align: left;">3</td>
</tr>
<tr>
<td style="text-align: left;">是否利于时序约束</td>
<td style="text-align: left;">不利于</td>
<td style="text-align: left;">利于</td>
<td style="text-align: left;">利于</td>
</tr>
<tr>
<td style="text-align: left;">是否有组合逻辑输出</td>
<td style="text-align: left;">可以无组合逻辑输出</td>
<td style="text-align: left;">多数情况有组合逻辑输出</td>
<td style="text-align: left;">无组合逻辑输出</td>
</tr>
<tr>
<td style="text-align: left;">是否利于综合与布局布线</td>
<td style="text-align: left;">不利于</td>
<td style="text-align: left;">利于</td>
<td style="text-align: left;">利于</td>
</tr>
<tr>
<td style="text-align: left;">代码的可靠性与可维护度</td>
<td style="text-align: left;">低</td>
<td style="text-align: left;">高</td>
<td style="text-align: left;">最好</td>
</tr>
<tr>
<td style="text-align: left;">代码风格的规范性</td>
<td style="text-align: left;">低，任意度大</td>
<td style="text-align: left;">格式化，规范</td>
<td style="text-align: left;">格式化，规范</td>
</tr>
</tbody>
</table>
<h2 id="状态机设计的其他技巧">2.4. 状态机设计的其他技巧</h2>
<p>本小节讨论 FSM 设计的其他技巧。</p>
<h3 id="fsm-的编码">2.4.1. FSM 的编码</h3>
<p>Binary（二进制编码）、gray-code（格雷码）编码使用最少的触发器，较多的组合逻辑，而
one-hot（独热码）编码反之。one-hot
编码的最大优势在于状态比较时仅仅需要比较一个位，一定程度上简化了比较逻辑，减少了毛刺产生的概率。由于
CPLD 更多地提供组合逻辑资源，而 FPGA 更多地提供触发器资源，所以
<strong>CPLD 多使用 gray-code</strong>，而 <strong>FPGA 多使用 one-hot
编码</strong>。另一方面，<strong>对于小型设计使用 gray-code 和 binary
编码更有效</strong>，而<strong>大型状态机使用 one-hot
更高效</strong>。</p>
<p>在代码中添加综合器的综合约束属性或者在图形界面下设置综合约束属性可以比较方便地改变状态的编码。需要注意的是：
Synplicity、Synopsys、Exemplar 等综合工具关于 FSM
的综合约束属性的语法格式各不相同。</p>
<h3 id="fsm-初始化状态">2.4.2. FSM 初始化状态</h3>
<p>一个完备的状态机（健壮性强）应该具备初始化状态和默认状态。当芯片加电或者复位后，状态机应该能够自动将所有判断条件复位，并进入初始化状态。需要注明的一点是，大多数
FPGA 有 GSR（Global Set/Reset）信号，当 FPGA 加电后， GSR
信号拉高，对所有的寄存器、RAM 等单元复位/置位，这时配置于 FPGA
的逻辑并未生效，所以不能保证正确地进入初始化状态。所以使用 GSR 企图进入
FPGA
的初始化状态，常常会产生种种不必要的麻烦。<strong>一般的方法是采用异步复位信号</strong>，当然也可以使用同步复位，但是要注意同步复位逻辑的设计。解决这个问题的<strong>另一种方法是将默认的初始状态的编码设为全零</strong>，这样
GSR 复位后，状态机自动进入初始状态。如 <a href="#2.3">2.3
小节</a>所示的编码方法就是初始状态全零的 one-hot 编码方式。</p>
<h3 id="fsm-状态编码定义">2.4.3. FSM 状态编码定义</h3>
<p><strong>状态机的定义可以用 <code>parameter</code>
定义，但是不推荐使用 <code>`define</code> 宏定义的方式</strong>，因为
<code>`define</code> 宏定义在编译时自动替换整个设计中所定义的宏，而
<code>parameter</code> 仅定义模
块内部的参数，定义的参数不会与模块外的其他状态机混淆。例如，一个工程里面有两个
<code>module</code>，各包含一个 FSM，如果设计时都有 <code>IDLE</code>
这一名称的状态，使用 <code>`define</code> 宏定义就会混淆起来，而使用
<code>parameter</code> 则不会造成任何不良影响。</p>
<h3 id="fsm-输出">2.4.4. FSM 输出</h3>
<p>如果使用二段式 FSM 描述 Mealy 状态机，输出逻辑可以用 <code>?</code>
语句描述，或者使用 <code>case</code>
语句判断转移条件与输入信号即可。如果输出条件比较复杂，而且多个状态共用某些输出，则建议使用
<code>task/endtask</code>
将输出封装起来，达到<strong>模块复用</strong>的目的。</p>
<h3 id="阻塞和非阻塞赋值">2.4.5. 阻塞和非阻塞赋值</h3>
<p>为了避免不必要的竞争冒险，不论是做两段式还是三段式 FSM
描述时，必须遵<strong>循时序逻辑 <code>always</code> 模块使用非阻塞赋值
<code>&lt;=</code></strong>，即当前状态向下一状态时序转移， 和寄存 FSM
输出等时序 <code>always</code>
模块中都要使用非阻塞赋值；而<strong>组合逻辑 <code>always</code>
模块使用阻塞赋值
<code>=</code></strong>，即状态转移条件判断，组合逻辑输出等
<code>always</code> 模块中都要使用阻塞赋值。</p>
<h3 id="fsm-的默认状态">2.4.6. FSM 的默认状态</h3>
<p><strong>完整的状态机应该包含一个默认（default）状态</strong>，当转移条件不满足，或者状态发生了突变时，要能保证逻辑不会陷入“死循环”。这是对状态机<strong>健壮性</strong>的一个重要要求，也就是常说的要具备“自恢复”功能。对编码
<code>case</code> 和 <code>if ... else</code> 语句要特别注意，
<strong>尽量使用完备的条件判断语句</strong>。 Verilog 中，使用
<code>case</code> 语句的时候要用 <code>default</code> 建立默认状态。</p>
<p>大家可能注意到，在上节举例的 <code>case</code> 语句中，没有写
<code>default</code> 默认状态，
其实<strong>可以将其中一个状态不编码，指定其为 <code>default</code>
默认状态</strong>，则任何与所列状态机不匹配的状态都会转到
<code>default</code> 状态，从而增强了 FSM
的健壮性，另外<strong>也可以添加一个额外的 <code>default</code>
状态</strong>，一旦进入这个状态就会自动转到 <code>IDLE</code>
状态，从新启动状态机，这样做也增强了状态机的健壮性。</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> (CS)</span><br><span class="line">    IDLE:   <span class="keyword">begin</span></span><br><span class="line">                IDLE_out;</span><br><span class="line">                <span class="keyword">if</span> (~i1)           NS = IDLE;</span><br><span class="line">                <span class="keyword">if</span> (i1 &amp;&amp; i2)      NS = S1;</span><br><span class="line">                <span class="keyword">if</span> (i1 &amp;&amp; ~i2)     NS = ERROR;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">    S1:     <span class="keyword">begin</span></span><br><span class="line">                S1_out;</span><br><span class="line">                <span class="keyword">if</span> (~i2)           NS = S1;</span><br><span class="line">                <span class="keyword">if</span> (i2 &amp;&amp; i1)      NS = S2;</span><br><span class="line">                <span class="keyword">if</span> (i2 &amp;&amp; (~i1))   NS = ERROR;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">    S2:     <span class="keyword">begin</span></span><br><span class="line">                S2_out;</span><br><span class="line">                <span class="keyword">if</span> (i2)            NS = S2;</span><br><span class="line">                <span class="keyword">if</span> (~i2 &amp;&amp; i1)     NS = IDLE;</span><br><span class="line">                <span class="keyword">if</span> (~i2 &amp;&amp; (~i1))  NS = ERROR;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">    ERROR:  <span class="keyword">begin</span></span><br><span class="line">                ERROR_out;</span><br><span class="line">                <span class="keyword">if</span> (i1)            NS = ERROR;</span><br><span class="line">                <span class="keyword">if</span> (~i1)           NS = IDLE;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">default</span>:<span class="keyword">begin</span></span><br><span class="line">                IDLE_out;</span><br><span class="line">                NS = IDLE;</span><br><span class="line">               <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endcase</span></span><br></pre></td></tr></tbody></table></figure>
<div class="note info"><p>在 <code>case</code> 语句结构中增加 <code>default</code>
默认状态是推荐的代码风格。</p>
</div>
<h3 id="full-case-与-parallel-case-综合属性">2.4.7. Full Case 与
Parallel Case 综合属性</h3>
<p>所谓 Full Case 是指：FSM 的所有编码向量都可以与 <code>case</code>
结构的某个分支或 <code>default</code> 默认情况匹配起来。如果一个 FSM
的状态编码是 8 bit，则对应的 256 个状态编码（全状态编码是 2<sup>n</sup>
个）都可以与 <code>case</code> 的某个分支或者 <code>default</code>
映射起来。</p>
<p>所谓 Parallel Case 是指：在 <code>case</code> 结构中，每个
<code>case</code> 的判断条件表达式（即 <a href="#2.2">2.2 小节</a>
描述的 <code>case_ expression</code>），有且仅有唯一的 <code>case</code>
语句的分支（即 <a href="#2.2">2.2 小节</a> 描述的每个
<code>case_item</code>）与之对应，即两者关系是一一对应关系。</p>
<p>目前知名综合器如 Synplify Pro、 Precision RTL 和 Synopys
综合工具等都支持 “synthesis full_case”和“synthesis
parallel_case”这些综合约束属性，<strong>合理使用 Full Case
约束属性，可以增强设计的安全性</strong>；<strong>合理使用 Parallel Case
约束属性，可以改善状态机译码逻辑</strong>。但是设计者必须具体情况具体分析，对于有的设计，这两条语句使用不当，会占用大量逻辑资源，并恶化
FSM 的时序表现。</p>
<h1 id="小结">3. 小结</h1>
<p>状态机不仅是一种时序电路设计工具，它更是一种思想方法。状态机的本质就是对具有逻辑顺序或时序规律事件的一种描述方法。这个论断最重要的两个词就是“逻辑顺序”和“时序规律”，这两点就是状态机所要描述的核心和强项，换言之，所有具有逻辑顺序和时序规律的事情都适合用状态机描述。</p>
<p>根据 FSM 描述使用的 <code>always</code> 模块数和功能可以将 FSM
的描述分为 3 种写法：</p>
<ul>
<li><p>不推荐使用一段式描述方法。因为一段式描述方法将状态转移判断的组合逻辑和状态寄存器转移的时序逻辑混写在同一个
<code>always</code> 模块中，不符合将时序和组合逻辑分开描述的 Coding
Style（代码风格），而且在描述当前状态时要考虑下个状态的输出，整个代码不清晰，不利于维护、修改，不利于附加约束，并且不利于综合器和布局布线器对设计的优化。</p></li>
<li><p>推荐使用两段式状态机描述方法。两段式描述方法用 2 个
<code>always</code> 模块，其中一个 <code>always</code>
模块采用同步时序描述状态转移；另一个 <code>always</code>
模块采用组合逻辑判断状态转移条件，描述状态转移规律。这种方法使 FSM
描述清晰、简洁，易于维护，易于附加时序约束，使综合器和布局布线器更好的优化设计。</p></li>
<li><p>强烈推荐使用三段式描述方法。与一段式描述方法相比较，三段式 FSM
描述方法对 FSM
寄存器输出的描述只需判断下一状态，然后直接将下一状态的输出用寄存器输出即可，根本不用考虑状态转移条件（米里状态机）。与两段式描述相比，三段式虽然代码结构复杂了一些，但是换来的优势是使
FSM
做到了同步寄存器输出，消除了组合逻辑输出的不稳定与毛刺的隐患，而且更利于时序路径分组，一般来说在
FPGA/CPLD 等可编程逻辑器件上的综合与布局布线效果更佳。</p></li>
</ul>
<h1 id="参考文献">参考文献</h1>
<p>EDA 先锋工作室. <em>轻松成为设计高手——Verilog HDL 实用精解.</em>
北京航空航天大学出版社, 2012.</p>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/css/markmap.css">

<script src="/js/markmap.js"></script>
]]></content>
      <categories>
        <category>Josh 的学习笔记</category>
        <category>Verilog</category>
      </categories>
      <tags>
        <tag>Verilog</tag>
        <tag>HDL</tag>
        <tag>RTL</tag>
        <tag>状态机</tag>
        <tag>摩尔型</tag>
        <tag>米里型</tag>
        <tag>两段式</tag>
        <tag>三段式</tag>
      </tags>
  </entry>
  <entry>
    <title>Josh&#39;s Note — 最优阵列处理&lt;br&gt;Part 1.1 频率-波数响应和波束方向图</title>
    <url>/posts/8b61f5a7.html</url>
    <content><![CDATA[<p>  假设空时场（space-time
field）同时存在信号（signal）、噪声（noise）和/或干扰（interference），这些信号/干扰空时场中可能是重叠的。阵列（Array）可以利用信号的空域特征，对空时场域内的信号进行滤波，过滤的过程可以用角度或波数的函数来表示（in
terms of a dependence upon angle or
wavenumber）。从频域看，这种滤波通过使用复增益（complex
gain）对阵列输出进行加权，可以根据信号的空域相关性对信号进行增强或抑制。对空时场进行空域滤波的目的是：使从一个或一组特定角度到来的信号通过有效的组合得到增强，抑制从其他角度到来的噪声或干扰。</p>
<p><a id="fig.1-1-1"></a></p>
<figure>
<img data-src="../images/post/2023-04-18-josh-oap-part-1-1/2023-04-18-josh-oap-part-1-1-010-SphericalCoordinareSystem.png" width="600" alt="图 1-1-1 球坐标系">
<figcaption aria-hidden="true">图 1-1-1 球坐标系</figcaption>
</figure>
<p>  在分析之前首先需要明确采用的坐标系，如<a href="#fig.1-1-1">图
1-1-1</a> 所示，直角坐标系和球坐标系的关系也在其中标明：</p>
<p><span class="math display">\[\begin{equation}
\begin{aligned}
x &amp;= r \sin\theta\cos\varphi \\
y &amp;= r \sin\theta\sin\varphi \\
z &amp;= r \cos\theta
\end{aligned}
\end{equation}\]</span></p>
<span id="more"></span>
<h1 id="阵列的基本模型">阵列的基本模型</h1>
<p><a id="fig.1-1-2"></a></p>
<figure>
<img data-src="../images/post/2023-04-18-josh-oap-part-1-1/2023-04-18-josh-oap-part-1-1-020-NElementArray.png" width="600" alt="图 1-1-2 N 阵元阵列">
<figcaption aria-hidden="true">图 1-1-2 <span class="math inline">\(N\)</span> 阵元阵列</figcaption>
</figure>
<p>  下面分析一个阵列对外部信号场的响应。阵列由一组全向阵元组成，阵元的位置为
<span class="math inline">\(\left\{ \boldsymbol{p}_n
\right\}_{n=0}^{N-1}\)</span>，如<a href="#fig.1-1-2">图 1-1-2</a>
所示。阵列在各阵元处对信号场进行采样，产生一组信号，记为矢量 <span class="math inline">\(\boldsymbol{f}\left(t,
\boldsymbol{p}\right)\)</span></p>
<p><span class="math display">\[\begin{equation}
\boldsymbol{f}(t, \boldsymbol{p}) = \left[
  \begin{array}{c}
    f\left(t, \boldsymbol{p}_0\right) \\
    f\left(t, \boldsymbol{p}_1\right) \\
    \vdots \\
    f\left(t, \boldsymbol{p}_{N-1}\right) \\
  \end{array}
\right]
\end{equation}\]</span></p>
<div class="note warning"><p>注意，这里并没有规定阵列的几何排布，因此下面的分析适用于所有阵列结构。</p>
</div>
<p><a id="fig.1-1-3"></a></p>
<figure>
<img data-src="../images/post/2023-04-18-josh-oap-part-1-1/2023-04-18-josh-oap-part-1-1-030-ArrayWithLinearProcessing.png" width="600" alt="图 1-1-3 线性处理阵列">
<figcaption aria-hidden="true">图 1-1-3 线性处理阵列</figcaption>
</figure>
<p>  将每个阵元的输出（即采样结果）通过冲激响应为 <span class="math inline">\(h_n(t)\)</span>
的线性时不变滤波器，求和可得阵列的输出 <span class="math inline">\(y(t)\)</span>，如<a href="#fig.1-1-3">图 1-1-3</a>
所示。假设观察间隔足够长（可以考虑为无限长），则阵列输出 <span class="math inline">\(y(t)\)</span> 可以写成卷积积分的形式：</p>
<p><span class="math display">\[\begin{equation}
y(t) = \sum_{n=0}^{N-1} \int_{-\infty}^{\infty} h_n
(t-\tau)f\left(\tau,\boldsymbol{p}_n\right) \mathrm{d} \tau
\end{equation}\]</span></p>
<p>用矢量符号表示为（即将标量结果向矢量模型进行直接扩展，a
straightforward extension of scalar results to the vector model）</p>
<p><a id="VectorFormOfLinearArrayOutputInTimeDomain"></a></p>
<p><span class="math display">\[\begin{equation}
\label{VectorFormOfLinearArrayOutputInTimeDomain}
y(t) = \int_{-\infty}^{\infty} \boldsymbol{h}^\mathrm{T} (t-\tau)
\boldsymbol{f}\left(\tau,\boldsymbol{p}\right) \mathrm{d} \tau
\end{equation}\]</span></p>
<p>其中</p>
<p><span class="math display">\[\begin{equation} \label{ImpulseResponse}
\boldsymbol{h}(t) = \left[ \begin{array}{c}
  h_0(t) \\
  h_1(t) \\
  \vdots \\
  h_{N-1}(t)
\end{array}
\right]
\end{equation}\]</span></p>
<p>也可以把式 <span class="math inline">\(\eqref{VectorFormOfLinearArrayOutputInTimeDomain}\)</span>
给出的阵列输出在变换域表示为</p>
<p><span class="math display">\[\begin{equation}
  Y(\omega) = \boldsymbol{H}^\mathrm{T}(\omega) \boldsymbol{F}(\omega)
\end{equation}\]</span></p>
<p>其中</p>
<p><span class="math display">\[\begin{equation}
\boldsymbol{H} (\omega) = \int_{-\infty}^{\infty}
\boldsymbol{h}(t)  e^{-j\omega t} \mathrm{d} t
\end{equation}\]</span></p>
<p><span class="math display">\[\begin{equation}
\label{SampleVectorInFreqDomain}
\boldsymbol{F} \left(\omega,\boldsymbol{p}\right) =
\int_{-\infty}^{\infty}
\boldsymbol{f}\left(t,\boldsymbol{p}\right)  e^{-j\omega t} \mathrm{d} t
\end{equation}\]</span></p>
<p>在大多数情况下，可以去掉式 <span class="math inline">\(\eqref{SampleVectorInFreqDomain}\)</span> 中左边的
<span class="math inline">\(\boldsymbol{p}\)</span>，直接使用 <span class="math inline">\(\boldsymbol{F}(\omega)\)</span> 。</p>
<h1 id="信号到达不同阵元的时延">信号到达不同阵元的时延</h1>
<p>  下面考虑如<a href="#fig.1-1-4">图 1-1-4</a>
所示的简单的波束形成操作。假设外部信号是方向为 <span class="math inline">\(\boldsymbol{a}\)</span>、时域频率（弧度）为 <span class="math inline">\(\omega\)</span>
的平面波，则在时域上每个阵元的输入信号可以用两种等效的方式进行表示。</p>
<p><a id="fig.1-1-4"></a></p>
<figure>
<img data-src="../images/post/2023-04-18-josh-oap-part-1-1/2023-04-18-josh-oap-part-1-1-040-ArrayWithPlaneWaveInput.png" width="600" alt="图 1-1-4 具有平面波输入的阵列">
<figcaption aria-hidden="true">图 1-1-4
具有平面波输入的阵列</figcaption>
</figure>
<p>  由于信号到达不同阵元的时间不同，设 <span class="math inline">\(f(t)\)</span>
是<strong>在坐标系原点接收到的信号</strong>，其在变换域表示为 <span class="math inline">\(F (\omega)\)</span>，则</p>
<p><span class="math display">\[\begin{equation} \label{DelayedSignal}
  \boldsymbol{f}(t, \boldsymbol{p}) = \left[
    \begin{array}{c}
      f\left(t - \tau_0\right) \\
      f\left(t - \tau_1\right) \\
      \vdots \\
      f\left(t - \tau_{N-1}\right) \\
    \end{array}
  \right]
\end{equation}\]</span></p>
<p>其中时延（距离除以速度得到时间）</p>
<p><span class="math display">\[\begin{equation}
\label{ExpressionOfDelayByDirection}
  \tau_n = \frac{\boldsymbol{a}^\mathrm{T}\boldsymbol{p}_n}{c}
\end{equation}\]</span></p>
<p>其中 <span class="math inline">\(c\)</span>
是信号在介质中的传播速度，<span class="math inline">\(\boldsymbol{a}\)</span> 是一个单位矢量，表示为</p>
<p><span class="math display">\[\begin{equation}
  \boldsymbol{a} = \left[ \begin{array}{c}
    -\sin\theta\cos\varphi \\
    -\sin\theta\sin\varphi \\
    -\cos\theta
  \end{array} \right]
\end{equation}\]</span></p>
<p>上式中的负号是考虑了 <span class="math inline">\(\boldsymbol{a}\)</span> 的方向。则 <span class="math inline">\(\tau_n\)</span> 可以进一步表示为：</p>
<p><span class="math display">\[\begin{equation} \label{RelativeDelay}
  \tau_n = -\frac{1}{c}\left(\sin\theta\cos\varphi \cdot p_{x_n} +
\sin\theta\sin\varphi \cdot p_{y_n} + \cos\theta \cdot p_{z_n} \right)
\end{equation}\]</span></p>
<p>如果定义对于每个轴的方向余弦（direction cosine）为</p>
<p><span class="math display">\[\begin{align}
  u_x &amp;= \sin\theta\cos\varphi \\
  u_y &amp;= \sin\theta\sin\varphi \\
  u_z &amp;= \cos\theta
\end{align}\]</span></p>
<p>则有</p>
<p><span class="math display">\[\begin{equation}
  \boldsymbol{u} = -\boldsymbol{a}
\end{equation}\]</span></p>
<p>则式 <span class="math inline">\(\eqref{RelativeDelay}\)</span>
给出的相对时延可以写成</p>
<p><span class="math display">\[\begin{equation}
\label{RelativeDelayWithDirectionCosine}
   \tau_n = -\frac{1}{c}\left(u_x p_{x_n} + u_y p_{y_n} + u_z p_{z_n}
\right) = -\frac{\boldsymbol{u}^\mathrm{T}\boldsymbol{p}_n}{c}
\end{equation}\]</span></p>
<p>根据式 <span class="math inline">\(\eqref{DelayedSignal}\)</span>，<span class="math inline">\(\boldsymbol{F}(\omega)\)</span> 的第 <span class="math inline">\(n\)</span> 个分量为（利用 Fourier
变换的时移性质）</p>
<p><span class="math display">\[\begin{equation}
  F_n(\omega) = \int_{-\infty}^{\infty} e^{j \omega t} f_n(t - \tau_n)
\mathrm{d} t = e^{j \omega \tau_n} F (\omega)
\end{equation}\]</span></p>
<p>其中</p>
<p><span class="math display">\[\begin{equation}
  \omega \tau_n = \frac{\omega}{c}
\boldsymbol{a}^\mathrm{T}\boldsymbol{p}_n = -\frac{\omega}{c}
\boldsymbol{u}^\mathrm{T}\boldsymbol{p}_n
\end{equation}\]</span></p>
<p>对于在局部均匀的介质（locally homogeneous
medium）里传播的平面波，定义波数 <span class="math inline">\(\boldsymbol{k}\)</span>
（在波传播的方向上单位长度内的周期数目）为</p>
<p><span class="math display">\[\begin{equation}
\label{DefinitionOfWavenumber}
  \boldsymbol{k} = \frac{\omega}{c} \boldsymbol{a} =
\frac{2\pi}{\lambda} \boldsymbol{a} = -\frac{2\pi}{\lambda} \left[
    \begin{array}{c}
    \sin\theta\cos\varphi \\
    \sin\theta\sin\varphi \\
    \cos\theta
    \end{array}
  \right]
  = -\frac{2\pi}{\lambda} \boldsymbol{u}
\end{equation}\]</span></p>
<p>其中，<span class="math inline">\(\lambda\)</span> 是对应于频率 <span class="math inline">\(\omega\)</span>
的波长，且波数的幅度由波动方程限定</p>
<p><span class="math display">\[\begin{equation} \label{WaveEquation}
  \left| \boldsymbol{k} \right| = \frac{\omega}{c} =
\frac{2\pi}{\lambda}
\end{equation}\]</span></p>
<p>所以，仅 <span class="math inline">\(\boldsymbol{k}\)</span>
的方向是变化的。比较式 <span class="math inline">\(\eqref{ExpressionOfDelayByDirection}\)</span> 和式
<span class="math inline">\(\eqref{DefinitionOfWavenumber}\)</span>，有</p>
<p><span class="math display">\[\begin{equation}
  \omega \tau_n = \boldsymbol{k}^\mathrm{T}\boldsymbol{p}_n
\end{equation}\]</span></p>
<p>定义</p>
<p><a id="DefinitionOfArrayManifoldVector"></a></p>
<p><span class="math display">\[\begin{equation}
\label{DefinitionOfArrayManifoldVector}
  \boldsymbol{v}_{\boldsymbol{k}}\left(\boldsymbol{k}\right) = \left[
\begin{array}{c}
    e^{-j \boldsymbol{k}^\mathrm{T}\boldsymbol{p}_0} \\
    e^{-j \boldsymbol{k}^\mathrm{T}\boldsymbol{p}_1} \\
    \vdots \\
    e^{-j \boldsymbol{k}^\mathrm{T}\boldsymbol{p}_{N-1}} \\
  \end{array} \right]
\end{equation}\]</span></p>
<p>则 <span class="math inline">\(\boldsymbol{F}(\omega)\)</span>
可写为</p>
<p><span class="math display">\[\begin{equation}
  \boldsymbol{F}(\omega) = F(\omega)
\boldsymbol{v}_{\boldsymbol{k}}\left(\boldsymbol{k}\right)
\end{equation}\]</span></p>
<p>矢量 <span class="math inline">\(\boldsymbol{v}_{\boldsymbol{k}}\left(\boldsymbol{k}\right)\)</span>
包含了阵列的所有空间特征，称为<strong><mark class="label primary">阵列流形矢量（array manifold vector）</mark></strong>，在阵列信号处理理论中具有非常核心的作用。下标
<span class="math inline">\(\boldsymbol{k}\)</span> 表示参数属于 <span class="math inline">\(\boldsymbol{k}\)</span>
空间。这个下标的作用是把它和以后将在阵列流形矢量中使用的其他变量相区分。</p>
<p><a id="fig.1-1-5"></a></p>
<figure>
<img data-src="../images/post/2023-04-18-josh-oap-part-1-1/2023-04-18-josh-oap-part-1-1-050-DelayAndSumBeamformer.png" width="600" alt="图 1-1-5 延时-求和波束形成器">
<figcaption aria-hidden="true">图 1-1-5 延时-求和波束形成器</figcaption>
</figure>
<p>  如<a href="#fig.1-1-5">图 1-1-5</a>
所示，把每个阵元的输入信号进行时移、相加、归一化，使得输出为 <span class="math inline">\(f(t)\)</span>，其中</p>
<p><span class="math display">\[\begin{equation}
\label{DelayAndSumBeamformer}
  h_n(\tau) = \frac{1}{N} \delta(\tau + \tau_n)
\end{equation}\]</span></p>
<p>且</p>
<p><span class="math display">\[\begin{equation}
  y(t) = f(t)
\end{equation}\]</span></p>
<p>上述处理器称为<strong><mark class="label primary">延时求和波束形成器（delay-and-sum beamformer）</mark></strong>或<strong><mark class="label primary">常规波束形成器（conventional beamformer）</mark></strong>。在实际中会在每个通道中加上一个共同的延时，使得<a href="#fig.1-1-5">图 1-1-5</a> 中的操作是物理可实现的。</p>
<p>  此外，还可以把式 <span class="math inline">\(\eqref{DelayAndSumBeamformer}\)</span>
在频域内写成简洁的矩阵形式。如果 <span class="math inline">\(\boldsymbol{k}_\mathrm{s}\)</span>
是我们所感兴趣的平面波信号的波数，则</p>
<p><span class="math display">\[\begin{equation}
  \boldsymbol{H}^\mathrm{T} (\omega) = \frac{1}{N}
\boldsymbol{v}_{\boldsymbol{k}}^\mathrm{H} \left(
\boldsymbol{k}_\mathrm{s} \right)
\end{equation}\]</span></p>
<h1 id="单位平面波模型">单位平面波模型</h1>
<p>  更一般的，要确定阵列对一个输入信号场 <span class="math inline">\(\boldsymbol{f}(t, \boldsymbol{p})\)</span>
的响应，可以通过之前给出的卷积求和操作来实现，但更有用的方法是确定阵列对单位平面波（unit
plane wave）的响应，将响应表示为时域（弧度）频率 <span class="math inline">\(\omega\)</span> 和波数 <span class="math inline">\(\boldsymbol{k}\)</span>
的函数，然后将线性时不变系统中复指数基函数叠加分析的系统理论方法扩展到空时信号的情况。</p>
<p>  取基函数</p>
<p><span class="math display">\[\begin{equation}
  f_n\left( t, \boldsymbol{p}_n \right) = \exp \left[ j \left( \omega t
- \boldsymbol{k}^\mathrm{T} \boldsymbol{p}_n\right) \right], \, n = 0,
1, \cdots, N-1
\end{equation}\]</span></p>
<p>或</p>
<p><span class="math display">\[\begin{equation}
  \boldsymbol{f} \left( t, \boldsymbol{p} \right) = e^{j\omega t}
\boldsymbol{v}_{\boldsymbol{k}}\left(\boldsymbol{k}\right)
\end{equation}\]</span></p>
<p>  式 <span class="math inline">\(\eqref{VectorFormOfLinearArrayOutputInTimeDomain}\)</span>
中的阵列处理器对于一个平面波的响应为</p>
<p><span class="math display">\[\begin{equation}
\label{ArrayResponseToUnitPlaneWaveInTimeDomain}
  y \left( t, \boldsymbol{k} \right) = \boldsymbol{H}^\mathrm{T}
(\omega) \boldsymbol{v}_{\boldsymbol{k}}\left(\boldsymbol{k}\right)
e^{j\omega t}
\end{equation}\]</span></p>
<p>其中 <span class="math inline">\(\boldsymbol{H} (\omega)\)</span>
是式 <span class="math inline">\(\eqref{ImpulseResponse}\)</span> 中
<span class="math inline">\(\boldsymbol{h}(t)\)</span>
的傅里叶变换。</p>
<p>  这里使用 <span class="math inline">\(y \left( t, \boldsymbol{k}
\right)\)</span> 来强调输出和输入波数 <span class="math inline">\(\boldsymbol{k}\)</span>
的关系。时域上的相关性体现在输出是一个复指数，和输入平面波具有相同的频率。在频域内，<span class="math inline">\(\eqref{ArrayResponseToUnitPlaneWaveInTimeDomain}\)</span>
可以写成下面的形式：</p>
<p><span class="math display">\[\begin{equation}
\label{ArrayResponseToUnitPlaneWaveInFreqDomain}
  Y \left( \omega, \boldsymbol{k} \right) = \boldsymbol{H}^\mathrm{T}
(\omega) \boldsymbol{v}_{\boldsymbol{k}}\left(\boldsymbol{k}\right)
\end{equation}\]</span></p>
<p>  注意，<span class="math inline">\(\omega\)</span>
是对应输入频率的单一频率。阵列的空时处理完全可以由式 <span class="math inline">\(\eqref{ArrayResponseToUnitPlaneWaveInFreqDomain}\)</span>
的右端描述。把这一项定义为</p>
<p><span class="math display">\[\begin{equation}
\label{FrequencyWavenumberResponse}
  \boxed{\boldsymbol{\varUpsilon} \left( \omega, \boldsymbol{k} \right)
\triangleq \boldsymbol{H}^\mathrm{T} (\omega)
\boldsymbol{v}_{\boldsymbol{k}}\left(\boldsymbol{k}\right)}
\end{equation}\]</span></p>
<p>称之为阵列的<strong><mark class="label primary">频率-波数响应函数（frequency-wavenumber response function）</mark></strong>。它描述了一个阵列对于波数为
<span class="math inline">\(\boldsymbol{k}\)</span>、时域频率为 <span class="math inline">\(\omega\)</span>
的输入平面波的复增益，具有与线性、时不变系统的传递函数相同的解释（这里我们用了
<span class="math inline">\(\boldsymbol{\varUpsilon} \left( \omega,
\boldsymbol{k} \right)\)</span>, 是因为 <span class="math inline">\(Y
\left( \omega, \boldsymbol{k} \right)\)</span>
在后面将要用于描述对任意输入的输出）。 <span class="math inline">\(\boldsymbol{\varUpsilon} \left( \omega,
\boldsymbol{k} \right)\)</span> 是定义在整个 <span class="math inline">\(\boldsymbol{k}\)</span> 空间上的。<span class="math inline">\(\eqref{FrequencyWavenumberResponse}\)</span>
中的第二项 <span class="math inline">\(\boldsymbol{v}_{\boldsymbol{k}}\left(\boldsymbol{k}\right)\)</span>
是在式 <span class="math inline">\(\eqref{DefinitionOfArrayManifoldVector}\)</span>
中定义的阵列流形矢量。</p>
<p>  频率-波数响应函数描述了阵列对任意一个平面波的响应。在大多数的实际物理应用中，时域频率
<span class="math inline">\(\omega\)</span> 和空域波数 <span class="math inline">\(\boldsymbol{k}\)</span>
通过平面波传播的波动方程形成了耦合关系。有时这是一个非常简单的关系，例如当一个平而波在均匀（且无限）的空间中传播时。在其他的情况下，可能是非常复杂的耦合关系，例如在水下声学和地震学中的分层介质模型中的情况。</p>
<p>  一个阵列的<strong><mark class="label primary">波束方向图（beam pattern）</mark></strong>定义的背景是平面波在局部均匀的介质中传播，约束的波动方程见式
<span class="math inline">\(\eqref{WaveEquation}\)</span>。如式 <span class="math inline">\(\eqref{WaveEquation}\)</span> 所示，这约束了波数
<span class="math inline">\(\boldsymbol{k}\)</span>
的幅度。波束方向图是用入射方向表示的频率-波数响应函数，或者可以写成</p>
<p><span class="math display">\[\begin{equation}
  B(\omega:\theta,\varphi) = \left. \boldsymbol{\varUpsilon} \left(
\omega, \boldsymbol{k} \right)
\right|_{\boldsymbol{k}=\frac{2\pi}{\lambda}\boldsymbol{a}(\theta,\varphi)}
\end{equation}\]</span></p>
<p>其中 <span class="math inline">\(\boldsymbol{a}(\theta,\varphi)\)</span>
是一个单位矢量，在球坐标系中对应的角度为 <span class="math inline">\(\theta\)</span> 和 <span class="math inline">\(\varphi\)</span>。可以看到，<strong>波束方向图是频率-波数响应在一个半径为
<span class="math inline">\(2\pi /\lambda\)</span>
的球上的值</strong>。</p>
<p>  阵列的波束方向图是确定阵列性能的关键要素。后续将会研究均匀加权线阵（uniformly
weighted linear array）的波束方向图。</p>
<h1 id="窄带假设">窄带假设</h1>
<p>  下面讨论 <span class="math inline">\(f\left( t,\boldsymbol{p}_n
\right)\)</span> 是带通信号的情况，即</p>
<p><span class="math display">\[\begin{equation}
\label{BandpassConstraint}
  f\left( t,\boldsymbol{p}_n \right) = \sqrt{2} \Re\left\{ \tilde{f}
\left( t,\boldsymbol{p}_n \right)  e^{j \omega_c t}\right\}, \, n = 0,
\cdots, N-1
\end{equation}\]</span></p>
<p>其中，<span class="math inline">\(\omega_c\)</span> 是载波频率，<span class="math inline">\(\tilde{f} \left( t,\boldsymbol{p}_n
\right)\)</span> 是复包络。假设复包络的带限区域为</p>
<p><span class="math display">\[\begin{equation}
  \left| \omega_L \right| \leqslant 2\pi B_s /2
\end{equation}\]</span></p>
<p>其中</p>
<p><span class="math display">\[\begin{equation}
  \omega_L \triangleq \omega - \omega_c
\end{equation}\]</span></p>
<p>且 <span class="math inline">\(\pi B_s\)</span>
是一个常数，确定了复包络的最大带宽。</p>
<p>  对于式 <span class="math inline">\(\eqref{DelayedSignal}\)</span>
中的平面波，式 <span class="math inline">\(\eqref{BandpassConstraint}\)</span> 成为</p>
<p><span class="math display">\[\begin{equation}
\label{BandpassConstraintApproximation}
  f\left( t,\boldsymbol{p}_n \right) = \sqrt{2} \Re\left\{ \tilde{f}
\left( t - \tau_n \right)  e^{j \omega_c \left( t - \tau_n
\right)}\right\}, \, n = 0, \cdots, N-1
\end{equation}\]</span></p>
<p>其中，<span class="math inline">\(\tau_n\)</span> 由式 <span class="math inline">\(\eqref{RelativeDelayWithDirectionCosine}\)</span>
给出。</p>
<p>  现在考虑信号跨越阵列传播的时间（the travel time across the
array）。定义 <span class="math inline">\(\Delta T_{nm} \left(
\boldsymbol{u} \right)\)</span> 为一个方向余弦为 <span class="math inline">\(\boldsymbol{u}\)</span> 的平面波在第 <span class="math inline">\(n\)</span> 个阵元和第 <span class="math inline">\(m\)</span> 个阵元之间的传播时间。则，</p>
<p><span class="math display">\[\begin{equation}
  \Delta T_{\max} \triangleq \max_{n,m=0,\cdots,N-1;\boldsymbol{u}}
\{\Delta T_{nm} \left( \boldsymbol{u} \right)\}
\end{equation}\]</span></p>
<p>是阵列的任意两个阵元之间的最大传播时间。对于一个线阵，这个最大值是当一个信号沿着阵列的轴线传播时（endfire），阵列两端阵元之间的传播时间。</p>
<p>  假设原点位于阵列的重心，即</p>
<p><span class="math display">\[\begin{equation}
  \sum_{n=0}^{N-1} \boldsymbol{p}_n = 0
\end{equation}\]</span></p>
<p>则式 <span class="math inline">\(\eqref{RelativeDelayWithDirectionCosine}\)</span>
给出的所有 <span class="math inline">\(\tau_n\)</span> 均满足</p>
<p><span class="math display">\[\begin{equation}
  \tau_n \leqslant \Delta T_{\max},\, n = 0, \cdots, N-1
\end{equation}\]</span></p>
<p>  在我们感兴趣的大多数情况下，复包络的带宽非常小，满足</p>
<p><span class="math display">\[\begin{equation}
  \tilde{f}(t - \tau_n) \simeq \tilde{f}(t),\, n = 0, \cdots, N-1
\end{equation}\]</span></p>
<p>为了使上述近似有效，需要有</p>
<p><span class="math display">\[\begin{equation}
\label{NarrowBandConstraint}
  B_\mathrm{s}\cdot \Delta T_{\max} \ll 1
\end{equation}\]</span></p>
<p>定义复包络满足式 <span class="math inline">\(\eqref{NarrowBandConstraint}\)</span>
的带通信号为<strong><mark class="label primary">窄带信号</mark></strong>。后面我们会在有关最优处理器的内容中重新研究这个定义，并给出一个更好的量化的讨论。现在，直接采用式
<span class="math inline">\(\eqref{NarrowBandConstraint}\)</span> 。则式
<span class="math inline">\(\eqref{BandpassConstraintApproximation}\)</span>
简化为</p>
<p><span class="math display">\[\begin{equation}
  f\left( t,\boldsymbol{p}_n \right) = \sqrt{2} \Re\left\{ \tilde{f}
\left( t \right)  e^{-j \omega_c \tau_n} e^{j \omega_c t } \right\}
\end{equation}\]</span></p>
<p>可以看到，在窄带的情况下，信号的延时可以用一个相移来近似。所以延时-求和波束形成器可以用一组移相器来代替延时线。结果得到的波束形成器在<a href="#fig.1-1-6">图 1-1-6</a>
中给出。这种实现方式通常称为<strong><mark class="label primary">相控阵</mark></strong>，并在实际中得到了广泛的应用。</p>
<p><a id="fig.1-1-6"></a></p>
<figure>
<img data-src="../images/post/2023-04-18-josh-oap-part-1-1/2023-04-18-josh-oap-part-1-1-060-NarrowbandBeamformerImplementedUsingPhaseShifters.png" width="600" alt="图 1-1-6 利用移相器实现的窄带波束形成器">
<figcaption aria-hidden="true">图 1-1-6
利用移相器实现的窄带波束形成器</figcaption>
</figure>
<p>  可以发现，在很多的应用中，我们都想要调整每个传感器输出的增益和相位，以得到一个理想的波束方向图。这就产生了在<a href="#fig.1-1-6">图 1-1-6(a)</a> 中给出的窄带模型。<span class="math inline">\(w_n^\ast\)</span>
是复权值，可以用一个增益和移相器的级联来实现，如<a href="#fig.1-1-6">图
1-1-6(b)</a> 所示。</p>
<p><a id="fig.1-1-7"></a></p>
<figure>
<img data-src="../images/post/2023-04-18-josh-oap-part-1-1/2023-04-18-josh-oap-part-1-1-070-GeneralNarrowbandBeamformer.png" width="600" alt="图 1-1-7 一般窄带波束形成器">
<figcaption aria-hidden="true">图 1-1-7 一般窄带波束形成器</figcaption>
</figure>
<p>  另外一种实现的结构见<a href="#fig.1-1-6">图
1-1-6(c)</a>。在一些情况下，我们利用正交解调，并在对基带信号进行复加权来实现波束形成器，实际是在一个正交分量上使用
<span class="math inline">\(\Re[w_n^\ast]\)</span>
进行加权，在另外一个正交分量上使用 <span class="math inline">\(\Im[w_n^\ast]\)</span>
进行加权，结果是相等的。</p>
<p>  定义一个复数权矢量为</p>
<p><a id="ComplexWeightVector"></a></p>
<p><span class="math display">\[\begin{equation}
\label{ComplexWeightVector}
  \boldsymbol{w}^\mathrm{H} = [w_0^\ast, w_1^\ast, \cdots, w_{N-1}^\ast]
\end{equation}\]</span></p>
<p>则式 <span class="math inline">\(\eqref{ArrayResponseToUnitPlaneWaveInTimeDomain}\)</span>
成为</p>
<p><a id="FrequencyWavenumberResponseWithComplexWeigh"></a></p>
<p><span class="math display">\[\begin{equation}
  y\left( t,\boldsymbol{k} \right) = \boldsymbol{w}^\mathrm{H}
\boldsymbol{v}_{\boldsymbol{k}}\left( \boldsymbol{k} \right) e^{j\omega
t}
\end{equation}\]</span></p>
<p>且</p>
<p><span class="math display">\[\begin{equation}
  \varUpsilon \left(\omega, \boldsymbol{k} \right) =
\boldsymbol{w}^\mathrm{H} \boldsymbol{v}_{\boldsymbol{k}}\left(
\boldsymbol{k} \right)
\end{equation}\]</span></p>
<p>式 <span class="math inline">\(\eqref{ComplexWeightVector}\)</span>
中的定义等价于</p>
<p><a id="NarrowBandComplexWeightVector"></a></p>
<p><span class="math display">\[\begin{equation}
  \boldsymbol{w}^\mathrm{H} = \boldsymbol{H}^\mathrm{T}(\omega_c)
\end{equation}\]</span></p>
<p>这里主要关注的是窄带模型，对于宽带信号，一种处理方法是利用离散傅里叶变换（DFT）把信号分解到更窄的频率柜
（frequency
bin），每个频率柜内的信号是满足窄带条件的，因此所有的窄带结果可以直接得到应用。</p>
<h1 id="参考文献">参考文献</h1>
<ol type="1">
<li>Harry L. Van Trees. <em>Optimum array processing: Part IV of
detection, estimation, and modulation theory.</em> New York, NY, USA:
John Wiley &amp; Sons, 2002.</li>
<li>Harry L. Van Trees, 汤俊. <em>最优阵列处理技术.</em>
北京：清华大学出版社. 2008.</li>
</ol>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/css/markmap.css">

<script src="/js/markmap.js"></script>
]]></content>
      <categories>
        <category>Josh 的学习笔记</category>
        <category>最优阵列处理</category>
        <category>阵列和空域滤波器</category>
      </categories>
      <tags>
        <tag>阵列信号处理</tag>
        <tag>频率-波数响应</tag>
        <tag>波束方向图</tag>
      </tags>
  </entry>
  <entry>
    <title>Josh&#39;s Note — Verilog&lt;br&gt;Part 7 逻辑验证与 testbench 编写</title>
    <url>/posts/e060f513.html</url>
    <content><![CDATA[<h1 id="概述">1. 概述</h1>
<h2 id="仿真和验证">1.1. 仿真和验证</h2>
<p>验证是要保证设计在功能上正确的一个过程。通常，设计和验证都有一个起点和一个终点。</p>
<p>设计的过程实际上是从一种形式到另一种形式的转换，比如从设计规格（通常讲的
Specification 或 SPEC）到 RTL 代码；从 RTL
代码到门级网表；从网表到版图（Layout）等。验证则是要保证每一步的设计转换过程准确无误。设计和验证的关
系如<a href="#fig.7-1">图 7-1</a> 所示。</p>
<p><a id="fig.7-1"></a></p>
<figure>
<img data-src="../images/post/2023-04-16-josh-verilog-part-7/2023-04-16-josh-verilog-part-7-010-DesignVersusVerification.png" width="300" alt="图 7-1 设计和验证的关系">
<figcaption aria-hidden="true">图 7-1 设计和验证的关系</figcaption>
</figure>
<span id="more"></span>
<p>设计与验证过程如<a href="#fig.7-2">图 7-2</a>
所示。图中说明了一个设计从设计规格到门级网表的转换和验证过程。</p>
<p><a id="fig.7-2"></a></p>
<figure>
<img data-src="../images/post/2023-04-16-josh-verilog-part-7/2023-04-16-josh-verilog-part-7-020-ProcessOfDesignAndVerification.png" width="550" alt="图 7-2 设计和验证的过程">
<figcaption aria-hidden="true">图 7-2 设计和验证的过程</figcaption>
</figure>
<p>其中，从设计规格到 RTL 的代码是由设计工程师手动完成的，而从 RTL
代码到门级网表则<strong>由逻辑综合工具自动完成</strong>。</p>
<p>相对应的是，要验证从设计规格到 RTL
代码的过程，就需要进行<strong>功能验证</strong>。功能验证一般是指验证
RTL 代码是否符合原始的设计需求和规格。这也是本篇笔记讨论的重点。</p>
<p>仿真的一般性含义是：使用 EDA
工具，通过对设计实际工作情况的模拟，验证设计的正确性。由此可见，仿真的重点在于使用
EDA 软件工具模拟设计的实际工作情况。在 FPGA/CPLD
设计领域最通用的仿真工具是 ModelSim。</p>
<p>目前，业界主流的功能验证方法是对 RTL
级代码的仿真。给设计加一定的激励，观察响应结果。当然，这些仿真激励必须完整的体现设计规格，验证的覆盖率要尽可能高。</p>
<p>在传统 ASIC 设计领域，验证是最费时、耗力的一个环节。而对于 FPGA/CPLD
等可编程逻辑器件，验证的问题就相对简单一些。可以使用如 ModelSim 或
ActiveHDL 等 HDL
仿真工具对设计进行功能上的仿真；也可以将一些仿真硬件与仿真工具相结合，通过软硬件联合仿真，加速仿真速度；还可以在硬件上直接使用逻辑分析仪、示波器等测量手段直接观察设计的工作情况。</p>
<p><a href="https://josh-gao.top/categories/Josh-%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Verilog/">《Josh
的学习笔记之 Verilog》</a> 系列文章的重点将放在 Verilog
语言本身的仿真上，至于门级网表和布线结果的功能（时序）仿真以及硬件加速、逻辑分析仪等验证手段，请参考其他文献。</p>
<h2 id="什么是-testbench">1.2. 什么是 testbench</h2>
<p>testbench，顾名思义就是测试平台的意思。简单地讲，在仿真的时候
testbench 用来产生测试激励给待验证设计（Design Under Verification,
DUV）或者称为待测设计（Design Under Test, DUT），同时检查 DUV
的输出是否与预期的一致，达到验证设计功能的目的。testbench 的概念如<a href="#fig.7-3">图 7-3</a> 所示。</p>
<p><a id="fig.7-3"></a></p>
<figure>
<img data-src="../images/post/2023-04-16-josh-verilog-part-7/2023-04-16-josh-verilog-part-7-030-TheIdeaOfTestbench.png" width="500" alt="图 7-3 testbench的概念">
<figcaption aria-hidden="true">图 7-3 testbench的概念</figcaption>
</figure>
<p>testbench 概念提供了一个很好的验证芯片的平台。</p>
<p>仿真因 EDA
工具和设计复杂度略有不同，对于简单的设计，特别是一些小规模的 CPLD
设计，可以直接使用开发工具内嵌的仿真波形工具绘制激励，然后进行功能仿真；更普遍的情况是，<strong>使用
HDL（硬件描述语言）编制
testbench（仿真文件），通过波形或自动比较工具，分析设计正确性，并分析
testbench 自身的覆盖率与正确性</strong>。</p>
<p>基于 testbench 的仿真流程如<a href="#fig.7-4">图 7-4</a> 所示。</p>
<p><a id="fig.7-4"></a></p>
<figure>
<img data-src="../images/post/2023-04-16-josh-verilog-part-7/2023-04-16-josh-verilog-part-7-040-SimulationFlowBasedOnTestbench.png" width="800" alt="图 7-4 基于testbench的仿真流程">
<figcaption aria-hidden="true">图 7-4
基于testbench的仿真流程</figcaption>
</figure>
<p>从图中可以清晰地看出 testbench 的主要功能：</p>
<ul>
<li>为 DUT 提供激励信号；</li>
<li>正确实例化 DUT；</li>
<li>将仿真结果的数据显示在终端，或者存为文件，或者显示在波形窗口以供分析检查；</li>
<li>复杂设计可以使用 EDA
工具，或者通过用户接口自动比较仿真结果与理想值，实现结果的自动检查。</li>
</ul>
<p>前两点功能主要和 testbench 的编写方法或 Coding Style
相关，后两点功能主要和仿真工具的功能特性与支持的用户接口相关。<strong>如何编写规范、高效、合理的测试激励，正是本篇笔记重点论述的问题</strong>。</p>
<p>另外，一个 testbench
设计好以后，可以为芯片设计的各个阶段所服务。比如在对 RTL
代码、综合网表、布线之后的网表进行仿真的时候，都可以采用同一个 testbench
。</p>
<h1 id="建立-testbench仿真设计">2. 建立 testbench，仿真设计</h1>
<p>在前面已经叙述过，要仿真设计的功能，必须为其建立一个
testbench，也叫仿真平台。</p>
<p>为了验证设计模块功能的正确性，通常需要在 testbench
中编写一些激励给设计模块。同时观察这些激励在设计模块（DUV）中的响应是否与期望值一致。</p>
<p>要充分验证一个设计，需要模拟各种外部的可能情况，特别是一些边界情况（corner
cases），因为这些边界情况最容易出问题。</p>
<p>如<a href="#fig.7-5">图 7-5</a> 中显示了一个用户验证 MPI
接口功能的仿真平台。不仅需要产生时钟信号和复位信号，还需要编写一系列的仿真向最．还要观察
DUV 的响应，确认仿真结果。</p>
<p><a id="fig.7-5"></a></p>
<figure>
<img data-src="../images/post/2023-04-16-josh-verilog-part-7/2023-04-16-josh-verilog-part-7-050-MPITestbench.png" width="700" alt="图 7-5 用户验证MPI接口功能的仿真平台">
<figcaption aria-hidden="true">图 7-5
用户验证MPI接口功能的仿真平台</figcaption>
</figure>
<p>关于这个设计的验证，在后续笔记将重点介绍。</p>
<h2 id="编写仿真激励">2.1. 编写仿真激励<a id="toc.2.1"></a></h2>
<p>对于初学者来说，迅速掌握一些常用测试激励的写法非常重要。这样可以有效提高代码的质量，减少错误的产生。</p>
<p>下面，将说说如何产生一些基本的仿真激励。</p>
<h3 id="仿真激励与被测对象的连接">2.1.1. 仿真激励与被测对象的连接</h3>
<p>在 <a href="https://josh-gao.top/posts/fd117896.html#toc.5.1">Part
3——描述方式和设计层次的 5.1
系统级和行为级</a>中介绍了结构化描述方法的模块实例端口连接关系。</p>
<p>同样，在 testbench 中，需要实例化被测试模块（DUV），DUV 的端口和
test­bench 中的信号互连也遵循同样的规则。请参考模块实例端口连接规则，如<a href="#fig.7-6">图 7-6</a> 所示。</p>
<p><a id="fig.7-6"></a></p>
<figure>
<img data-src="../images/post/2023-04-16-josh-verilog-part-7/2023-04-16-josh-verilog-part-7-060-ModuleInstancePortConnection.png" width="800" alt="图 7-6 模块实例端口连接规则">
<figcaption aria-hidden="true">图 7-6 模块实例端口连接规则</figcaption>
</figure>
<p>这里，需要提醒初学者注意的是，<strong>对于双向信号，驱动它的也一定是一个三态的线网</strong>。不能是寄存器类型，否则就会发生冲突。</p>
<h3 id="使用-initial-语句和-always-语句">2.1.2. 使用
<code>initial</code> 语句和 <code>always</code> 语句</h3>
<p><code>initial</code> 和 <code>always</code> 是 2
个基本的过程结构语句，<strong>在仿真的一开始即开始相互并行执行</strong>。通常来说，被动的检测响应使用
<code>always</code> 语句，而主动的产生激励使用 <code>initial</code>
语句。</p>
<p><code>initial</code> 和 <code>always</code> 的区别是：
<code>initial</code> 语句只执行一次，而 <code>always</code>
语句不断地重复执行。但是，如果希望在 <code>initial</code>
里多次运行一个语句块，可以在 <code>initial</code>
里嵌人循环语句（<code>while</code>、<code>repeat</code>、<code>for</code>
和 <code>forever</code> 等），比如：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">forever</span> <span class="comment">/* 永远执行 */</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<p>而 <code>always</code> 语句通常只在一些条件发生时完成操作，比如：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> Clock) <span class="keyword">begin</span></span><br><span class="line">    SigA = Sig B;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<p>当发生 <code>Clock</code> 上升沿时，执行 <code>always</code>
操作，<code>begin... end</code> 中的语句顺序执行。</p>
<h3 id="时钟复位的写法">2.1.3. 时钟、复位的写法</h3>
<h4 id="普通时钟信号">2.1.3.1. 普通时钟信号</h4>
<p>用 <code>initial</code> 语句产生时钟的方法如下：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 用 initial 产生一个周期为 10 的时钟</span></span><br><span class="line"><span class="keyword">parameter</span> FAST_PERIOD = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">reg</span> Clock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    Clock= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">forever</span></span><br><span class="line">        # (FAST_PERIOD/<span class="number">2</span>) Clock = ~Clock;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<p>用 <code>always</code> 语句产生时钟的方法如下：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 用 always 产生一个周期为 10 的时钟</span></span><br><span class="line"><span class="keyword">parameter</span> FAST_PERIOD = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">reg</span> Clock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span></span><br><span class="line">  Clock= <span class="number">0</span>; <span class="comment">// 将 Clock 初始化为 0</span></span><br><span class="line"><span class="keyword">always</span></span><br><span class="line">  # (FAST_PERIOD/<span class="number">2</span>) Clock = ~Clock;</span><br></pre></td></tr></tbody></table></figure>
<p>以上的写法产生的波形如<a href="#fig.7-7">图 7-7</a> 所示。</p>
<p><a id="fig.7-7"></a></p>
<figure>
<img data-src="../images/post/2023-04-16-josh-verilog-part-7/2023-04-16-josh-verilog-part-7-070-GeneratedClockStimulus.png" width="450" alt="图 7-7 产生的时钟测试激励">
<figcaption aria-hidden="true">图 7-7 产生的时钟测试激励</figcaption>
</figure>
<h4 id="非-50-占空比时钟信号">2.1.3.2. 非 <code>50%</code>
占空比时钟信号</h4>
<p>有时候在设计中会用到占空比不是 <code>50%</code> 的时钟。比如可以用
<code>always</code> 语句实现占空比为 <code>40%</code>
的时钟，代码如下：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 占空比为 40% 的时钟</span></span><br><span class="line"><span class="keyword">parameter</span>   Hi_Time = <span class="number">4</span>,</span><br><span class="line">    Lo_Tirne = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span> Clock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> <span class="keyword">begin</span></span><br><span class="line">    # Hi_Tiroe Clock = <span class="number">0</span>;</span><br><span class="line">    # Lo_Tiroe Clock = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<p>以上代码产生的占空比不是 50% 的时钟波形，如<a href="#fig.7-8">图
7-8</a> 所示。</p>
<p><a id="fig.7-8"></a></p>
<figure>
<img data-src="../images/post/2023-04-16-josh-verilog-part-7/2023-04-16-josh-verilog-part-7-080-ClockWithOtherDutyCycle.png" width="350" alt="图 7-8 占空比不是50%的时钟">
<figcaption aria-hidden="true">图 7-8 占空比不是50%的时钟</figcaption>
</figure>
<p>由于 <code>Clock</code> 在 <code>0</code> 时刻没有被初始化，而且
<code>Clock</code> 是寄存器类型变量， 因此在该信号的前
<code>5 ns</code>, 在仿真器中的值为 <code>x</code>。</p>
<p>当然，也可以在 <code>initial</code> 语句中使用 <code>forever</code>
语句来描述同样的波形。</p>
<h4 id="固定数目时钟信号">2.1.3.3. 固定数目时钟信号</h4>
<p>如果需要产生固定数目的时钟脉冲，可以在 <code>initial</code>
语句中使用 <code>repeat</code> 语句来实 现，代码如下：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 2 个高脉冲的时钟</span></span><br><span class="line"><span class="keyword">parameter</span>   PulseCount = <span class="number">4</span>,</span><br><span class="line">    FAST_PERIOD = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span> Clock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    Clock= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">repeat</span> (PulseCount)</span><br><span class="line">        # (FAST_PERIOD/<span class="number">2</span>) Clock =~ Clock;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<p>以上代码产生了有 <code>2</code> 个高脉冲的时钟。</p>
<h4 id="相移时钟信号">2.1.3.4. 相移时钟信号</h4>
<p>另外一种应用较广的时钟是相移时钟。先看一看如下的代码：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 相移时钟产生</span></span><br><span class="line"><span class="keyword">parameter</span>   HI_TIME = <span class="number">5</span> ,</span><br><span class="line">    LO_TIME = <span class="number">10</span> ,</span><br><span class="line">    PHASE_SHIFr = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span> Absolute_clock;     <span class="comment">// 寄存器变量</span></span><br><span class="line"><span class="keyword">wire</span> Derived_clock;     <span class="comment">// 线网变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> <span class="keyword">begin</span></span><br><span class="line">  # HI_TIME Absolute_clock = <span class="number">0</span>;</span><br><span class="line">  # LO_TIME Absolute_clock = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> # PHASE_SHIFT Derived_clock = Absolute_clock;</span><br></pre></td></tr></tbody></table></figure>
<p>这里，首先用 <code>always</code> 产生一个 <code>Absolute_clock</code>
时钟，然后用 <code>assign</code> 语句将该时钟延时，产生一个相移
<code>2</code> 的 <code>Derived_clock</code> 时钟。</p>
<p>实现波形请参考<a href="#fig.7-9">图 7-9</a>。</p>
<p><a id="fig.7-9"></a></p>
<figure>
<img data-src="../images/post/2023-04-16-josh-verilog-part-7/2023-04-16-josh-verilog-part-7-090-AbsoluteAndDerivedClock.png" width="400" alt="图 7-9 绝对时钟和派生时钟">
<figcaption aria-hidden="true">图 7-9 绝对时钟和派生时钟</figcaption>
</figure>
<p>值得注意的是，图中的 <code>Absolute_Clock</code> 为
<code>register</code>（寄存器）型变量，初始值为 <code>x</code>；而
<code>Derived_clock</code> 为 <code>net</code>（线网）型变量，初始值为
<code>z</code>。</p>
<h4 id="异步复位信号">2.1.3.5. 异步复位信号</h4>
<p>由于复位信号不是周期信号，可以用 <code>initial</code>
来产生一个值序列。</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 异步复位信号</span></span><br><span class="line"><span class="keyword">parameter</span> PERIOD = <span class="number">10</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span> Rst_n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">  Rst_n=l;</span><br><span class="line">  # PERIOD Rst_n = <span class="number">0</span>;</span><br><span class="line">  # (<span class="number">5</span> * PERIOD) Rst_n= <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<p><code>Rst_n</code> 是低有效，以上代码在 <code>10 ns</code>
时开始复位，复位持续时间是 <code>50 ns</code>。</p>
<h4 id="同步复位信号">2.1.3.6. 同步复位信号</h4>
<p>同步复位信号产生的代码如下：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 同步复位信号</span></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    Rst_n = <span class="number">1</span>;</span><br><span class="line">    @ (<span class="keyword">negedge</span> Clock) ; <span class="comment">// 等待时钟下降沿</span></span><br><span class="line">    Rst_n=<span class="number">0</span>;</span><br><span class="line">    # <span class="number">30</span>;</span><br><span class="line">    @ (<span class="keyword">negedge</span> Clock) ; <span class="comment">// 等待时钟下降沿</span></span><br><span class="line">    Rst_n = l;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<p>该代码首先将 <code>Rst_n</code> 初始化为 <code>1</code>，然后在第一个
<code>Clock</code> 的下降沿开始复位。再延时
<code>30 ns</code>，然后在下一个时钟下降沿时撤销复位。
这样，<strong>复位的产生和撤销都避开了时钟的有效上升沿</strong>。因此，这种复位可以认为是同步复位，如<a href="#fig.7-10">图 7-10</a> 所示。</p>
<p><a id="fig.7-10"></a></p>
<figure>
<img data-src="../images/post/2023-04-16-josh-verilog-part-7/2023-04-16-josh-verilog-part-7-100-SynchronousReset.png" width="500" alt="图 7-10 同步复位">
<figcaption aria-hidden="true">图 7-10 同步复位</figcaption>
</figure>
<p>另一种同步复位信号产生的方法如下：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 同步复位信号</span></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    Rst_n = <span class="number">1</span>;</span><br><span class="line">    @ (<span class="keyword">negedge</span> Clock) ;             <span class="comment">// 等待时钟下降沿</span></span><br><span class="line">    Rst_n = <span class="number">0</span>;                      <span class="comment">// 复位开始</span></span><br><span class="line">    <span class="keyword">repeat</span> (<span class="number">3</span>) @(<span class="keyword">negedge</span> Clock);    <span class="comment">// 经过 3 个时钟下降沿</span></span><br><span class="line">    Rst_n = <span class="number">1</span>;                      <span class="comment">// 复位撤销</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<p>首先将 <code>Rst_n</code> 初始化为 <code>1</code>，在第一个
<code>Clock</code> 的下降沿开始复位。然后经过 <code>3</code>
个时钟下降沿，在第 3 个时钟下降沿处撤销复位信号
<code>Rst_n</code>。另一种同步复位，如<a href="#fig.7-11">图 7-11</a>
所示。</p>
<p><a id="fig.7-11"></a></p>
<figure>
<img data-src="../images/post/2023-04-16-josh-verilog-part-7/2023-04-16-josh-verilog-part-7-110-AnotherSynchronousReset.png" width="500" alt="图 7-11 另一种同步复位">
<figcaption aria-hidden="true">图 7-11 另一种同步复位</figcaption>
</figure>
<h3 id="产生值序列">2.1.4. 产生值序列</h3>
<p><a id="fig.7-12"></a></p>
<figure>
<img data-src="../images/post/2023-04-16-josh-verilog-part-7/2023-04-16-josh-verilog-part-7-120-SignalWaveDiagram.png" width="500" alt="图 7-12 一个波形图">
<figcaption aria-hidden="true">图 7-12 一个波形图</figcaption>
</figure>
<p>下面用 Verilog 来描述如<a href="#fig.7-12">图 7-12</a>
中的一个波形。</p>
<p>在该时序图中，是以 <code>24 ns</code> 为刻度的。<code>MY_ADDR</code>
和 <code>MY_DATA</code> 都代表参数值。</p>
<p>用 <code>initial</code> 语句块来产生这样一组值序列，代码如下：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 值序列模型</span></span><br><span class="line">Parameter SLOW_PERIOD = <span class="number">24</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span>     [<span class="number">5</span>:<span class="number">0</span>]   Mpi_addr;</span><br><span class="line"><span class="keyword">reg</span>             Mpi_cs_n;</span><br><span class="line"><span class="keyword">reg</span>             Mpi_rw;</span><br><span class="line"><span class="keyword">reg</span>             Mpi_oe;</span><br><span class="line"><span class="keyword">tri</span>     [<span class="number">7</span>:<span class="number">0</span>]   Mpi_data;</span><br><span class="line"><span class="keyword">reg</span>     [<span class="number">7</span>:<span class="number">0</span>]   Data_out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> Mpi_data = (Mpi_oe) ? Data_out : <span class="number">8'bz</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span>           <span class="comment">// 在 initial 语句块中产生值序列</span></span><br><span class="line">    Mpi_addr = <span class="number">0</span>;</span><br><span class="line">    Mpi_cs_n = <span class="number">1</span>;</span><br><span class="line">    Mpi_rw = <span class="number">1</span>;</span><br><span class="line">    Mpi_oe = <span class="number">0</span>;</span><br><span class="line">    Data_out=O;</span><br><span class="line">    # SLOW_PERIOD;</span><br><span class="line">    Data_out = MY_DATA;</span><br><span class="line">    Mpi_addr = MY_ADDR;</span><br><span class="line">    Mpi_rw=<span class="number">0</span>;</span><br><span class="line">    # SLOW_PERIOD;</span><br><span class="line">    Mpi_oe= <span class="number">1</span>;</span><br><span class="line">    # (SLOW_PERIOD/<span class="number">4</span>);</span><br><span class="line">    Mpi_cs_n=O;</span><br><span class="line">    # ((<span class="number">2</span> * SLOW_PERIOD) + (SLOW_PERIOD/<span class="number">2</span>));</span><br><span class="line">    Mpi_cs_n= <span class="number">1</span>;</span><br><span class="line">    # (SLOW_PERIOD/<span class="number">4</span>);</span><br><span class="line">    Mpi_addr = O;</span><br><span class="line">    Mpi_rw = <span class="number">1</span>;</span><br><span class="line">    Mpi_oe = <span class="number">0</span>;</span><br><span class="line">    # SLOW_PERIOD;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<p>这里，采用<strong>阻塞赋值</strong>的方法产生一系列的值变化。</p>
<p>值得注意的是，在输出 <code>Mpi_data</code> 的时候，并没有采用在
<code>initial</code>
中赋值，直接输出的方式，而是采用了输出使能控制的方式，用一个三态门输出。这样，将
<code>Mpi_data</code> 定 义成一个 <code>tri</code>
类型变量（<code>Net</code>
中的一种）。这是<strong>便于和被验证模块中三态双向总线互连</strong>，将在后续笔记中详细介绍这种用法。</p>
<h3 id="利用系统函数和系统任务">2.1.5. 利用系统函数和系统任务</h3>
<p>在编写 testbench
时，一些系统函数和系统任务可以产生测试激励，显示调试信息，协助定位问题。</p>
<p>比如在使用 <code>display</code> 语句在仿真器中打印出地址和数据：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">$display</span> (<span class="string">"Addr: %b -&gt; DataWrite: %d"</span>, Mpi_addr, Data_out);</span><br></pre></td></tr></tbody></table></figure>
<p>同时，也可以用时序检查的系统任务来检查时序。例如：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line">$setup(Sig_D,<span class="keyword">posedge</span> Clock,<span class="number">1</span>);  <span class="comment">// 如果在 Clock 上升沿到达之前的 1 ns 时间内，</span></span><br><span class="line">                                <span class="comment">// Sig_D 发生跳变，将给出建立时间违反告警</span></span><br><span class="line">$setup(<span class="keyword">posedge</span> Clock,Sig_D,<span class="number">0</span><span class="variable">.1</span>);<span class="comment">// 如果在 Clock 上升沿到达之后的 0.1 ns 时间内</span></span><br><span class="line">                                <span class="comment">// Sig_D 发生跳变，将给出保持时间违反告警</span></span><br></pre></td></tr></tbody></table></figure>
<p>另外，也可以用
<code>$random()</code>系统函数来产生测试激励数据。例如：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line">Data_out = {<span class="built_in">$random</span>} % <span class="number">256</span>;     <span class="comment">// 产生 0~255 的数据</span></span><br></pre></td></tr></tbody></table></figure>
<p><code>$time</code> 系统函数可以用来返回当前的仿真时间，协助仿真。
能够用于 testbench
中的系统任务和函数有很多，它们的使用方法大同小异，非常简单。感兴趣的读者可以参考其他
Verilog 的语法资料。</p>
<h3 id="从文本文件中读出和写入数据">2.1.6.
从文本文件中读出和写入数据</h3>
<p>在编写测试激励时，往往需要从已有的文件中读入数据，或者把数据写入文件中，做进一步分析。那么在
Verilog 语言中如何实现呢？</p>
<p>看看如下代码：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] DataSource [<span class="number">0</span>:<span class="number">47</span>];                   <span class="comment">// 定义一个二维数组</span></span><br><span class="line"><span class="built_in">$readmemh</span> (<span class="string">"Read_In_File.txt"</span>, DataSource) ;</span><br></pre></td></tr></tbody></table></figure>
<p>就是将 <code>Read_ln_File</code> 文件中数据读入到
<code>DataSource</code> 数组中，然后就可以直接使用。</p>
<p>往文件中写入内容的代码如下：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span> Write_Out_File;                     <span class="comment">// 定义一个整数的文件指针</span></span><br><span class="line">Write_Out_File = <span class="built_in">$fopen</span>(<span class="string">"Write_Out_File.txt"</span>);          <span class="comment">// 打开文件</span></span><br><span class="line"><span class="built_in">$fdisplay</span> (Write_Out_File, <span class="string">"@ %h\n %h"</span>, Mpi_addr, Data_in);   <span class="comment">// 往文件中写人内容</span></span><br><span class="line"><span class="built_in">$fclose</span> (Write Out File);                     <span class="comment">// 关闭文件</span></span><br></pre></td></tr></tbody></table></figure>
<p>这里，关于写入和写出文件的具体格式和用法，请参考本篇笔记实例部分的内容。</p>
<h3 id="写并行激励">2.1.7. 写并行激励</h3>
<p>如果希望在仿真的某一时刻同时启动多个任务可以采用
<code>fork ... join</code> 语法结构。 例如，在仿真开始的
<code>100 ns</code>
后，希望同时启动发送和接收任务，而不是发送完毕后再进行接收，可以采用如下代码：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 并行激励</span></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">  # <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">fork</span>         <span class="comment">// 并行操作</span></span><br><span class="line">    Send_task;</span><br><span class="line">    Receive_task;</span><br><span class="line">  <span class="keyword">join</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<p>这是产生并行激励的一个好办法。</p>
<h3 id="for-语句实现遍历测试">2.1.8. <code>for</code>
语句实现遍历测试</h3>
<p>如果设计的工作模式很多，就需要做各种模式的遍历测试，而遍历测试则需要非常大的工作量。</p>
<p>在很多时候，各种模式之间仅仅是部分寄存器配置的内容不同，而各种模式之间的测试都是一样的。有什么方法可以减轻这种遍历测试的工作量呢？可以<strong>采用
<code>for</code>
循环语句，用循环索引来传递各种模式的配置值，会帮助减少很多代码书写的工作量，而不会漏掉任何一种模式</strong>。</p>
<p>如下代码所示：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; m; i = i + <span class="number">1</span>)        <span class="comment">// 遍历模式 1 至 m-1</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j = j + <span class="number">1</span>) <span class="keyword">begin</span>    <span class="comment">// 遍历子模式 1 至 n-1</span></span><br><span class="line">            <span class="keyword">case</span>(j)</span><br><span class="line">                <span class="number">0</span>: Conf_Value = a;</span><br><span class="line">                <span class="number">1</span>: Conf_Value = b;</span><br><span class="line">                <span class="number">2</span>; Conf_Value = c;</span><br><span class="line">                ...</span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">            <span class="comment">// 共用的测试向量</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<p>在设计 Verilog 代码时灵活使用 <code>for</code>
语句，可以使得代码更简洁。</p>
<h3 id="高级语句force-和-release">2.1.9. 高级语句：<code>force</code> 和
<code>release</code></h3>
<p>顾名思义，<code>force</code> 就是可以对变最强制性的赋予确定的值，而
<code>release</code> 就是解除 <code>force</code>
的作用，将变量恢复为驱动源的值。例如：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// force 和 release</span></span><br><span class="line"><span class="keyword">wire</span> a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> a = <span class="number">1'b0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    # <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">force</span> a = <span class="number">1'b1</span>;</span><br><span class="line">    # <span class="number">10</span></span><br><span class="line">    <span class="keyword">release</span> a;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<p>在 <code>10 ns</code> 时，<code>a</code> 的值由 <code>0</code>
被强制为 <code>1</code>，在 <code>20 ns</code> 时，<code>a</code>
的值又恢复为 <code>0</code>。</p>
<p><code>force</code> 和 <code>release</code>
并不常用。有时，可以利用它们和仿真工具做简单的交互操作。例如，VerilogXL
的图形界面可以很方便的将一个变量 <code>force</code> 为 <code>0</code> 或
<code>1</code>。而在 testbench 里，可以检测变量是否被 <code>force</code>
为固定的值，当被 <code>force</code>
为固定的值时就执行预定的操作，实现了简单交互操作。</p>
<h3 id="封装功能模块">2.1.10. 封装功能模块<a id="toc.2.1.10"></a></h3>
<p>与 C 语言类似，在编写 testbench
的时候，可以将固定的一些操作封装成任务或者函数。</p>
<h4 id="任务">2.1.10.1. 任务</h4>
<p>任务的格式如下：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line">tast 任务名称;</span><br><span class="line">    输入, 输出声明;</span><br><span class="line">    语句;</span><br><span class="line"><span class="keyword">endtask</span></span><br></pre></td></tr></tbody></table></figure>
<p>例如，一个读 CPU 接口的任务：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">task</span> Read;</span><br><span class="line">    <span class="keyword">output</span>  [<span class="number">7</span>:<span class="number">0</span>]  Rtask_Data;    <span class="comment">// data read out</span></span><br><span class="line">    <span class="keyword">input</span>  [<span class="number">7</span>:<span class="number">0</span>]  Rtask_Addr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        uP_rw = <span class="number">0</span>;</span><br><span class="line">        # SLOW_PERIOD;</span><br><span class="line">        uP_addr = Rtask_Addr;</span><br><span class="line">        uP_rw = <span class="number">1</span>;</span><br><span class="line">        # SLOW_PERIOD;</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endtask</span></span><br></pre></td></tr></tbody></table></figure>
<p>其中，<code>input</code> 是任务的输入，可以用 <code>output</code>
来向任务外部传递计算结果。当然，也可以在任务中直接修改仿真中的全局变量，来传递数值。调用
<code>task</code> 的格式如下：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line">Read (Data,Addr);        <span class="comment">// Addr 是需要读的地址, 而 Data 是读出的数据</span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="函数">2.1.10.2. 函数</h4>
<p>函数的格式如下：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> [BITWIDTH - <span class="number">1</span>:<span class="number">0</span>] 函数名称</span><br><span class="line">  输入声明;</span><br><span class="line">  语句;</span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></tbody></table></figure>
<p>与任务不同的是，函数将返回一个值。以上代码会<strong>返回一个
<code>BITWIDTH</code> 宽度的值</strong>。</p>
<p>例如：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>    [<span class="number">7</span>:<span class="number">0</span>]   Product;</span><br><span class="line">  <span class="keyword">input</span>   [<span class="number">3</span>:<span class="number">0</span>]   Sig_A;</span><br><span class="line">  <span class="keyword">input</span>   [<span class="number">3</span>:<span class="number">0</span>]   Sig_B;</span><br><span class="line">  <span class="keyword">begin</span></span><br><span class="line">    Product = Sig_A * Sig_B;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></tbody></table></figure>
<p>调用的格式如下：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line">ProductResult = Product(A,B);    <span class="comment">// 将 A 和 B 的乘积赋给 ProductResult 变量</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="波形编辑器">2.1.11. 波形编辑器</h3>
<p>在一些工具中，可以使用波形编译器来产生仿真激励。例如，在 Quartus II
开发软件中，就可以使用波形编辑器来产生仿真激励。</p>
<p>波形编辑器不在系列笔记的重点讨论范畴内，因此这里不再过多累述。</p>
<h2 id="搭建仿真环境">2.2. 搭建仿真环境</h2>
<p>通常，为一个设计建立仿真平台，将这个设计在该平台中实例化，然后将在平台中产生各种各样的测试激励输入给设计模块，然后再观察
DUV 的响应是否与期望值相同。</p>
<p>那么，如何将待测设计和仿真激励连接起来，是对设计进行仿真的重要一步。</p>
<p>在<a href="https://josh-gao.top/posts/fd117896.html#toc.5.1">Part
3——描述方式和设计层次的 5.1 系统级和行为级</a>小节和本文的 <a href="#toc.2.1">2.1
小节</a>中，都提到了如何在模块中实例化其他模块的方法。大家可以参考这些内容，掌握如何在
testbench 中实例化 DUV 或其他模块。</p>
<p>将以<a href="#fig.7-13">图 7-13</a> 中的 testbench
为实例，介绍端口的连接关系。</p>
<p><a id="fig.7-13"></a></p>
<figure>
<img data-src="../images/post/2023-04-16-josh-verilog-part-7/2023-04-16-josh-verilog-part-7-130-BuildTestbench.png" width="700" alt="图 7-13 搭建仿真环境">
<figcaption aria-hidden="true">图 7-13 搭建仿真环境</figcaption>
</figure>
<p>图中的仿真平台是<strong>单顶层</strong>的
testbench，在后面还将介绍多顶层的 testbench 。</p>
<p>下面的部分代码是介绍如何搭建 testbench 的：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> Testbench;           <span class="comment">// 测试平台顶层</span></span><br><span class="line"><span class="comment">// 时钟激励产生</span></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 复位激励产生</span></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 各种测试用例</span></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设计模块实例</span></span><br><span class="line">MPI u_MPI(</span><br><span class="line">    <span class="variable">.Clock</span>      (Clock      ),</span><br><span class="line">    <span class="variable">.Rst_n</span>      (Rst_n      ),</span><br><span class="line">    <span class="variable">.Mpi_data</span>   (Mpi_data   ),</span><br><span class="line">    <span class="variable">.Mpi_addr</span>   (Mpi_addr   ),</span><br><span class="line">    <span class="variable">.Mpi_cs_n</span>   (Mpi_cs_n   ),</span><br><span class="line">    <span class="variable">.Mpi_rw</span>     (Mpi_rw     )</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></tbody></table></figure>
<p>另外，在Verilog 语言中，也支持多顶层结构。关于多顶层的
testbench，请参考 <a href="#toc.4.5.2">4.5.2 小节</a>的叙述。</p>
<p>将仿真平台建好以后，就可以开始仿真了。</p>
<p>在下面小节中将叙述如何进行仿真结果确认。</p>
<h2 id="确认仿真结果">2.3. 确认仿真结果</h2>
<h3 id="直接观察波形">2.3.1. 直接观察波形</h3>
<p>最简单确认仿真结果的方法就是用眼睛观察输出波形。</p>
<h3 id="观察文本输出">2.3.2. 观察文本输出</h3>
<p>用户也可以依靠一些系统任务打印的信息，来协助查看仿真结果。例如：</p>
<ul>
<li><code>$display</code>，直接输出到标准输出设备</li>
<li><code>$monitor</code>，监控参数的变化</li>
<li><code>$display</code>，输出到文件</li>
</ul>
<p>在后面的实例部分将重点介绍前面两种确认仿真结果的方法：</p>
<ul>
<li>直接观察波形；</li>
<li>观察仿真器输出。</li>
</ul>
<h3 id="自动检查仿真结果">2.3.3. 自动检查仿真结果</h3>
<p>对于一些大型设计，测试向量成千上万，每条都用手动方式比较已经不现实，这时就必须<strong>借助仿真软件接口进行自动比较</strong>。常用的自动比较方法有如下
3 种：</p>
<ul>
<li><p>数据库比较法。首先需要生成一个标准向量数据库（Golden Vector
Database），它存储的是期望得到的仿真结果，是比较的基础。然后<strong>自动将每条仿真输出的响应向量与标准向量进行比较</strong>，记录不一致向量的位置和内容。这种方法的优点是简单易行；主要缺点在于，<strong>根据输出的响应向量回溯并定位输入激励不是十分方便，也不够直观</strong>。</p></li>
<li><p>波形比较法。与数据库比较法的思路基本一致，只是<strong>比较的对象是仿真输出波形</strong>，首先存储标准波形文件（Golden
Wave
File），然后通过仿真软件手动或者自动进行将仿真的输出波形与标准波形文件进行比较，用图标（marker）定位比较结果相异的地方。这种方法的优点是直观明了。ModelSim
等仿真工具通常都支持波形比较（Wave Compare）功能。</p></li>
<li><p>动态自检测法。前面两种自动比较方法的本质都是将仿真结果与事先存储好的标准向量（Golden
Vector）进行比较，对于复杂设计，仿真系统的输出不仅和当前输入相关，还和历史输入甚至反馈值相关，对于前两种方法，即使发现了输出的响应向量和标准向量不一致，要定位造成不一致的原因，特别是追溯哪些输入造成的输出不一致是比较困难。前两种方法统称为<strong>静态分析方法</strong>。与之相反，动态分析方法就能实时地定位哪些激励造成响应不一致。其基本思路如<a href="#fig.7-14">图 7-14</a>
所示。首先可以在不同的抽象层次（如行为级或者混合层次）描述出与 DUT
功能一致的仿真模型，然后读入测试激励向量（Test
Vectors），将测试激励向量同时送到实例化的 DUT
和前面提到的仿真模型中，实时地观察、判断、存储两者的输出响应，比较输出结果。这样一旦发现了输出响应不一致，即可暂停仿真过程，观察
DUT
和仿真模型的每个中间状态的值，记录输入的激励向量，定位设计错误。</p></li>
</ul>
<p><a id="fig.7-14"></a></p>
<figure>
<img data-src="../images/post/2023-04-16-josh-verilog-part-7/2023-04-16-josh-verilog-part-7-140-DynamicSelfTest.png" width="800" alt="图 7-14 动态自检测仿真方法">
<figcaption aria-hidden="true">图 7-14 动态自检测仿真方法</figcaption>
</figure>
<p>由于自动比较法通常用在非常庞大的设计验证中，在系列笔记中不重点介绍这种方式。</p>
<h3 id="使用-vcd-文件">2.3.4. 使用 VCD 文件</h3>
<p>VCD
文件是一种标准格式的波形记录文件。该文件只记录发生变化的波形。</p>
<p>设计在仿真器中的仿真结果，可以输出成一个 VCD 文件。然后将该 VCD
文件输入给其他第三方的分析工具进行分析。<a href="#fig.7-15">图 7-15</a>
是 VCD 文件调试和分析仿真过程。</p>
<p><a id="fig.7-15"></a></p>
<figure>
<img data-src="../images/post/2023-04-16-josh-verilog-part-7/2023-04-16-josh-verilog-part-7-150-SimulationWithVCD.png" width="400" alt="图 7-15 VCD文件调试和分析仿真过程">
<figcaption aria-hidden="true">图 7-15
VCD文件调试和分析仿真过程</figcaption>
</figure>
<p>在系列笔记中，不对 VCD 文件进行过多的介绍。</p>
<h2 id="写-testbench-要注意什么">2.4. 写 testbench 要注意什么</h2>
<h3 id="testbench-不是硬件">2.4.1. testbench 不是硬件</h3>
<p>在前述其他笔记中提到过，设计硬件的时候，要尽量使用硬件的思维方式，时刻记住是在设计硬件，每一句语句都有明确的硬件定义，可以被综合工具理解。</p>
<p>要注意的是，在写 testbench 的时候，情况就大不相同了。</p>
<p>通常，testbench
不会被实现成具体的电路，不需要有可综合性。只要它能在仿真器中模拟出相应的功能即可。</p>
<p>因此，在写 testbench
的时候，需要<strong>尽量使用抽象层次较高的语句</strong>，这样编写
testbench 的效率比较高，同样仿真的效率也较高。</p>
<h3 id="使用行为级描述方式描述-testbench">2.4.2. 使用行为级描述方式描述
testbench</h3>
<p>必须明确，可综合的硬件电路一般要求用 RTL（寄存器传输级）方法描述，而
testbench 则需要用行为级甚至更高层次的 HDL 语言描述。在讲述行为级描述
testbench 的好处之前，首先引入 HDL 语言的层次概念， HDL
语言的适用层次如<a href="#fig.7-16">图 7-16</a> 所示。</p>
<p><a id="fig.7-16"></a></p>
<figure>
<img data-src="../images/post/2023-04-16-josh-verilog-part-7/2023-04-16-josh-verilog-part-7-160-HDLDesignEntry.png" width="600" alt="图 7-16 HDL语言的使用层次示意图">
<figcaption aria-hidden="true">图 7-16
HDL语言的使用层次示意图</figcaption>
</figure>
<p>上图说明了不同的 HDL 语言种类对应的 HDL
描述层次的关系，图中实线框表示适用程度较高，虚线框表示适用程度较低。常用的
HDL 描述层次有门级、寄存器传输级和行为级等。</p>
<p>使用行为级或者更高层次的描述方法好处主要有：</p>
<ul>
<li><p>编写 testbench
时<strong>仅需要关注电路的功能</strong>，而不需要理解电路结构与实现方式，从而降低了设计
testbench 的难度，节约了设计时间。</p></li>
<li><p><strong>可以使用高级数据结构和运算</strong>。在行为级描述中，比较容易将某种运算封装起来，便于调用。另外如果使用可编程用户接口（PLI,
Programmable Language Interface) ，还可以在 testbench 中嵌入 C 和 C++
语言。另外越来越多的仿真工具支持诸如
SystemVerilog、Superlog、SystemC、CoWare C 等高级语言。C、C++
、SystemVerilog、Superlog、SystemC、CoWare C
等高级语言的引入，强有力地支持了用户自定义的数据结构，<strong>通过对象的封装，支持进程与事件之间通讯</strong>，有效的提高了
testbench 设计效率，并加强了 testbench 的安全性。</p></li>
<li><p><strong>行为级描述便于根据需要从不同层次抽象设计</strong>。与第二点相似，使用行为级或者更高层次的描述方式，可以将设计抽象到不同层次，在高层次描述设计更加简便高效，只有需要解析某个部分的详细结构时，才使用低层次的详细描述，这样可以有效地节约设计时间，提高仿真效率。</p></li>
<li><p><strong>行为级仿真速度更快</strong>。行为级仿真速度更快有两个原因，一方面仿真工具对于某些高级算法支持更有效，编译和运行速度快，更主要的是，<strong>行为级描述的抽象层次高，本身就是对运算处理的一种简化</strong>。例如，在
RTL 级描述一个 <code>32 bit</code>
乘法器，需要反复地选择、移位、与或非等运算，而在行为级描述这个
<code>32 bit</code> 乘法器，直接写 <code>A × B</code>
即可，仿真工具在仿真时也可以直接得到乘法的结果，大大地提高了效率，节约了时间。</p></li>
</ul>
<h3 id="设计高效的-testbench">2.4.3. 设计高效的 testbench</h3>
<p>在上一小节中，使用行为级描述方法是从宏观上论述的。具体到代码编写层次，希望大家能够注意积累一些标准、规范、高效的
testbench 描述方法。这里，总结如下：</p>
<ul>
<li><p><strong>避免使用无限循环</strong>。一般来说，testbench
里面每个事件都应该是可控制和有限的，否则会增加仿真器的 CPU 和 Memory
资源消耗，降低仿真速度。这条原则的一个特例是时钟产生电路，例如使用
<code>forever</code> 或无条件的 <code>always</code>
语句产生周期性时钟信号。</p></li>
<li><p><strong>使用逻辑模块划分激励</strong>。在 testbench 中，所有
<code>initial</code>、<code>always</code>、<code>assign</code>
等语法块是并行执行的，其中描述的每个事件都是基于时间 “0”
点安排的，这样通过这些语法结构将不同的激励划分开，有利于设计维护测试激励。</p></li>
<li><p><strong>避免不必要的输出显示</strong>。常用仿真工具都支持将信息显示在终端上或者存储在文件中，这种功能对分析仿真结构十分有用。但是对于复杂设计，一定要避免不必要的输出显示，因为这类进程非常耗费
CPU 和 Memory 资源，极大地降低仿真速度。</p></li>
<li><p><strong>掌握程式化的仿真结构描述方法</strong>。诸如产生时钟信号、仿真双向总线、仿真
CPU 读/写寄存器、定义事件的延时与顺序、RAM
等常用模块的初始化、读/写过程等，都是常用的仿真结构，大家已经形成了比较程式化的标准写法，初学者多读一些好的仿真代码，积累这些程式化的描述方法，将有效地提高自己
testbench 的质量。</p></li>
</ul>
<p>上述仅仅是一些基本的仿真原则，限于篇幅，不能展开论述，希望大家带着问题，在后续学习笔记中作为重点去理解。</p>
<h1 id="cpu-接口仿真实例">3. CPU 接口仿真实例<a id="toc.3"></a></h1>
<p>前面介绍了许多编写 testbench
的方法和技巧，现在轮到如何利用这些技巧了。所谓实践出真知，下面就一个常用的实例，帮助大家继续深入体会如何编写
testbench, 如何验证设计。</p>
<h2 id="设计简介">3.1. 设计简介</h2>
<p><a href="#fig.7-17">图 7-17</a> 是一个 PowerPC 和 FPGA
的接口模型。FPGA 被当成处理器的一个简单的异步外设处理。</p>
<p><a id="fig.7-17"></a></p>
<figure>
<img data-src="../images/post/2023-04-16-josh-verilog-part-7/2023-04-16-josh-verilog-part-7-170-PortConnectionDemo.png" width="400" alt="图 7-17 PowerPc和FPGA接口示意图">
<figcaption aria-hidden="true">图 7-17
PowerPc和FPGA接口示意图</figcaption>
</figure>
<p>所有的总线操作都由 PowerPC
发起。共分为两种总线操作方式：读操作和写操作。</p>
<p>读操作的时序如<a href="#fig.7-18">图 7-18</a> 所示。写操作的时序如<a href="#fig.7-19">图 7-19</a> 所示。</p>
<p><a id="fig.7-18"></a></p>
<figure>
<img data-src="../images/post/2023-04-16-josh-verilog-part-7/2023-04-16-josh-verilog-part-7-180-ReadTiming.png" width="600" alt="图 7-18 读操作时序">
<figcaption aria-hidden="true">图 7-18 读操作时序</figcaption>
</figure>
<p><a id="fig.7-19"></a></p>
<figure>
<img data-src="../images/post/2023-04-16-josh-verilog-part-7/2023-04-16-josh-verilog-part-7-190-WriteTiming.png" width="600" alt="图 7-19 写操作时序">
<figcaption aria-hidden="true">图 7-19 写操作时序</figcaption>
</figure>
<p>要注意的是，PowerPC
的读/写时序与许多配置参数有关，而且处理器使用不同的主频，时序也不太一样。这里为了简单明了，采用了特定的设置和主频。在实际系统中，如果采用不同的设置，需要参考
PowerPC 的数据手册。但是，这里的设计思想是可以借鉴的。</p>
<p>假设，已有了一个设计模块名叫 <code>MPI</code>，对应<a href="#fig.7-17">图 7-17</a> 中的
FPGA，它的接口定义如下。详细的设计代码请参考本文<a href="https://download.csdn.net/download/weixin_43870101/12451000">附带资源</a>中的
<code>Example-7-1</code>。</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// MPI.v</span></span><br><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/100ps</span></span><br><span class="line"><span class="keyword">module</span> MPI(</span><br><span class="line">    Clock ,</span><br><span class="line">    Rst_n ,</span><br><span class="line">    <span class="comment">// uP interface</span></span><br><span class="line">    Mpi_data ,</span><br><span class="line">    Mpi_addr ,</span><br><span class="line">    Mpi_cs_n ,  <span class="comment">// Chip Select</span></span><br><span class="line">    Mpi_rw      <span class="comment">// 1:read; 0:write</span></span><br><span class="line">    <span class="comment">// to/from Storage Part</span></span><br><span class="line">    ) ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// clock and reset</span></span><br><span class="line"><span class="keyword">input</span>            Clock ;</span><br><span class="line"><span class="keyword">input</span>            Rst_n ;</span><br><span class="line"><span class="keyword">inout</span>  [<span class="number">7</span>:<span class="number">0</span>]     Mpi_data ;</span><br><span class="line"><span class="keyword">input</span>  [<span class="number">5</span>:<span class="number">0</span>]     Mpi_addr ;</span><br><span class="line"><span class="keyword">input</span>            Mpi_cs_n ;     <span class="comment">// Chip Select</span></span><br><span class="line"><span class="keyword">input</span>            Mpi_rw ;       <span class="comment">// 1:read; 0:write</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></tbody></table></figure>
<p>该设计中，采用了一个全局时钟 <code>Clock</code> 来处理与 PowerPC
之间的接口，<strong>将异步接口同步化</strong>。这是一种非常可靠的设计方法，这里不再过多叙述设计的细节，希望大家能够领会其中的奥妙。</p>
<p>该设计中，输入地址采用 <code>6</code> 位，地址 <code>0~31</code>
为设计中的块状 RAM（<code>8</code> 位宽，<code>32</code>
字节深度），地址 <code>32~47</code> 为设计中的 D 触发器实现的
<code>8</code> 位寄存器，地址 <code>48~63</code> 保留未使用。</p>
<h2 id="一种-testbench">3.2. 一种 testbench<a id="toc.3.2"></a></h2>
<p>以下介绍一种 testbench，供大家学习使用。使用 <code>$random</code>
产生激励，用 <code>$display</code> 输出仿真结果。</p>
<p>要验证上一小节介绍的 MPI
模块的功能，首先需要为其产生激励，将数据写入到指定的地址。然后将该地址的数据读出后，与写入的数据比较，如果一致，说明设计正确，如果不一致，说明设计有缺陷。</p>
<p><a id="fig.7-20"></a></p>
<figure>
<img data-src="../images/post/2023-04-16-josh-verilog-part-7/2023-04-16-josh-verilog-part-7-200-TestbenchStructure.png" width="600" alt="图 7-20 testbench结构">
<figcaption aria-hidden="true">图 7-20 testbench结构</figcaption>
</figure>
<p>根据<a href="#fig.7-20">图 7-20</a> 中的 testbench 结构，设计
testbench 顶层如下：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// NorTestBench.v</span></span><br><span class="line"><span class="keyword">module</span> NorTestBench;      <span class="comment">// testbench 顶层模块</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// 始终激励产生</span></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    Clock = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">forever</span> <span class="keyword">begin</span></span><br><span class="line">         # (FAST_PERIOD/<span class="number">2</span>) Clock = ~Clock ;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// 复位激励产生</span></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    Rst_n = <span class="number">1</span>;</span><br><span class="line">    # FAST_PERIOD Rst_n = <span class="number">0</span>;</span><br><span class="line">    # (<span class="number">5</span> * FAST_PERIOD) Rst_n = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// 输出三态 Buffer, 用于和 MPI 接口的数据总线相连</span></span><br><span class="line"><span class="keyword">assign</span> Mpi_data = ( Mpi_oe )? Data_out : <span class="number">8'bz</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仿真向量产生</span></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span> : ACCESS</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 根据前面介绍的方法, 生读/写的序列</span></span><br><span class="line">    <span class="keyword">for</span> ( i=<span class="number">6'b101111</span>; i&gt;= <span class="number">0</span>; i=i-<span class="number">1</span> ) <span class="keyword">begin</span>  <span class="comment">// 遍历 47~0 地址</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 用 $random 系统函数产生写入的数据</span></span><br><span class="line">        Data_out = {<span class="built_in">$random</span>} % <span class="number">256</span>;     <span class="comment">// data between 0~255</span></span><br><span class="line">        <span class="comment">// 用 $display 系统函数打印出写入的地址数据信息</span></span><br><span class="line">        <span class="built_in">$display</span> (<span class="string">"Addr: %b -&gt; DataWrite: %d"</span>, Mpi_addr, Data_out);</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 用 $display 系统函数打印出读出的地址数据信息</span></span><br><span class="line">        <span class="built_in">$display</span> (<span class="string">"Addr: %b -&gt; DataRead: %d"</span>, Mpi_addr, Data_in);</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">$stop</span>;  <span class="comment">// 仿真停止</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设计模块实例</span></span><br><span class="line">MPI u_MPI (</span><br><span class="line">    <span class="variable">.Clock</span>      (Clock      ),      <span class="comment">// Clock 是寄存器型变量</span></span><br><span class="line">    <span class="variable">.Rst_n</span>      (Rst_n      ),      <span class="comment">// Rst_n 是寄存器型变量</span></span><br><span class="line">    <span class="variable">.Mpi_data</span>   (Mpi_data   ),      <span class="comment">// Mpi_data 是 tri 型变量</span></span><br><span class="line">    <span class="variable">.Mpi_addr</span>   (Mpi_addr   ),      <span class="comment">// Mpi_addr 是寄存器型变量</span></span><br><span class="line">    <span class="variable">.Mpi_cs_n</span>   (Mpi_cs_n   ),      <span class="comment">// Mpi_cs_n 是寄存器型变量</span></span><br><span class="line">    <span class="variable">.Mpi_rw</span>     (Mpi_rw     )       <span class="comment">// Mpi_rw 是寄存器型变量</span></span><br><span class="line">    ) ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></tbody></table></figure>
<p>以上是 testbench 顶层的结构示意，关于完全的代码，请参考本文<a href="https://download.csdn.net/download/weixin_43870101/12451000">附带资源</a>中的
<code>Example-7-1</code>。</p>
<p>在该 testbench 中，用系统函数 <code>$random</code> 产生
<code>0~255</code> 之间的随机数，然后从地址 <code>47~0</code>
写入，并在同一地址读出。</p>
<p>将写入的地址和数据，以及读出的地址和数据用系统函数
<code>$display</code> 输出到仿真标准输出设备，进行手动比较。</p>
<p>有了以上的 testbench 和设计模块，就可以对设计进行仿真验证了。</p>
<blockquote>
<p>使用 testbench 仿真，参考示例详见本文<a href="https://download.csdn.net/download/weixin_43870101/12451000">附带资源</a>中的
<code>Example-7-1</code>。</p>
</blockquote>
<h3 id="进入工程目录">3.2.1. 进入工程目录</h3>
<p>把<a href="https://download.csdn.net/download/weixin_43870101/12451000">附带资源</a>中的
<code>Example-7-1</code> 目录复制到本地硬盘。例如，复制到
<code>D:</code> 盘的根目录下。运行 ModelSim 仿真器。在 ModelSim
仿真器的菜单中选择 <code>File -&gt; Change Directory</code>
菜单项，然后选择目录<code>D:\Example-7-1\Proj</code> 或者直接在 ModelSim
<code>&gt;</code> 提示符后输入 <code>cd D:/Example-7-1/Proj</code>
回车。这样，就将目录切换到工程目录下。这里采用的是 ModelSim SE
10.5版本，其他版本一样适用。</p>
<h3 id="运行仿真">3.2.2. 运行仿真</h3>
<p>在 ModelSim <code>&gt;</code> 提示符后输入
<code>do sim.do</code>，然后回车。仿真就开始了。<code>do</code> 是
ModelSim 中的命令，而 <code>sim. do</code> 文件是事先编写好的 ModelSim
自动运行脚本。其中包含了编译库文件、编译设计文件、载入仿真、开始运行仿真等命令，使得整个仿真过程自动完成。ModelSim
窗口如<a href="#fig.7-21">图 7-21</a> 所示。</p>
<p><a id="fig.7-21"></a></p>
<figure>
<img data-src="../images/post/2023-04-16-josh-verilog-part-7/2023-04-16-josh-verilog-part-7-210-ModesimWindow.png" width="900" alt="图 7-21 ModelSim窗口">
<figcaption aria-hidden="true">图 7-21 ModelSim窗口</figcaption>
</figure>
<h3 id="查看仿真结果">3.2.3. 查看仿真结果</h3>
<p>由于在这个 testbench
中，采用随机数作为写入数据，将写入和读出的数据都打印到标准的输出设备。因此，读者可以在
Mode!Sim 窗口中手动查看仿真结果。仿真器将 testbench 中的
<code>$display</code> 显示函数显示如<a href="#fig.7-22">图 7-22</a>
所示。</p>
<p><a id="fig.7-22"></a></p>
<figure>
<img data-src="../images/post/2023-04-16-josh-verilog-part-7/2023-04-16-josh-verilog-part-7-220-ModesimSimulationResult.png" width="900" alt="图 7-22 ModelSim仿真结果">
<figcaption aria-hidden="true">图 7-22 ModelSim仿真结果</figcaption>
</figure>
<p>为了检查读/写数据是否一致，只需要查看以上的显示内容即可。另外，还可以通过查看具体的波形来调试。</p>
<h2 id="另一种-testbench">3.3. 另一种 testbench<a id="toc.3.3"></a></h2>
<p>在本小节中，采用另一种 testbench 。与 <a href="#toc.3.2">3.2
小节</a>中的 testbench 对比，这里有两点不同：</p>
<ul>
<li><p>写数据源是从文件 <code>Read_In_File.txt</code> 中读入的，不再是由
<code>$random</code> 系统函数产生的随机数；</p></li>
<li><p>读出数据被写人到另一个文件 <code>Write_Out_File</code>
中，不仅向标准输出设备输出。</p></li>
</ul>
<p>这种新的测试平台顶层结构如下：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// NorTestBench.v</span></span><br><span class="line"><span class="keyword">module</span> NorTestBench;                <span class="comment">// testbench 顶层模块</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">reg</span>     [<span class="number">7</span>:<span class="number">0</span>]   DataSource [<span class="number">0</span>:<span class="number">47</span>];  <span class="comment">// 定义一个数组</span></span><br><span class="line"><span class="keyword">integer</span> Write_Out_File;             <span class="comment">// 定义文件指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 仿真向量产生</span></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span> : ACCESS</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 将 Read_In_File.txt 文件中的数据读出, 并写人到 DataSource 数组中</span></span><br><span class="line">    <span class="built_in">$readmemh</span> ( <span class="string">"Read_In_File.txt"</span>, DataSource );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 Write_Out_File.txt 文件打开, 并将文件指针赋给 write_Out_file</span></span><br><span class="line">    Write_Out_File = <span class="built_in">$fopen</span>(<span class="string">"Write_Out_File.txt"</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> ( i=<span class="number">6'b101111</span>; i&gt;= <span class="number">0</span>; i=i-<span class="number">1</span> ) <span class="keyword">begin</span>  <span class="comment">// 遍历 47~0 地址</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 从 DataSource 数组中读取数据源</span></span><br><span class="line">        Data_out = DataSource[i] ;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 将读出的地址和数据信息写入到 Write_Out_File 指定的文件中</span></span><br><span class="line">        <span class="built_in">$fdisplay</span> (Write_Out_File, <span class="string">"@%h\n%h"</span>, Mpi_addr, Data_in);</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">$fclose</span> (Write_Out_File);               <span class="comment">// 关闭 Write_OUt_File 文件, 释放指针</span></span><br><span class="line">    <span class="built_in">$stop</span>;                                  <span class="comment">// 仿真停止</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></tbody></table></figure>
<p>在 <code>Read_In_File.txt</code> 文件中，根据 Verilog
的语法，存储的数据如下：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line">@<span class="number">2</span>f</span><br><span class="line"><span class="number">24</span></span><br><span class="line">@<span class="number">2</span>e</span><br><span class="line"><span class="number">81</span></span><br><span class="line">@<span class="number">2</span>d</span><br><span class="line"><span class="number">09</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></tbody></table></figure>
<p>地址由 <code>2f</code> 到 <code>0</code> 递减。</p>
<p>读出的地址和数据用系统函数 <code>$display</code>
输出到仿真标准输出设备。同时，也将输出数据和地址按照与
<code>Read_In_File.txt</code> 文件中一样格式写入到文件
<code>Write_Out_File. txt</code>
中，以便于比较。运行仿真以后，在仿真目录下，会生成一个
<code>Write_Out_File.txt</code>
文件，用来存储读出的地址和数据。因此只要将这两个文件打开，手动比
较，或者利用一些自动比较工具比较，就可以知道仿真结果正确与否。</p>
<p>关于具体的仿真步骤请参考 <a href="#toc.3.2">3.2
小节</a>中的操作步骤。工程文件在本文<a href="https://download.csdn.net/download/weixin_43870101/12451000">附带资源</a>中的
<code>Example-7-2</code> 中。</p>
<p>大家将发现，运行完仿真后，在工程目录下会生成一个文件：
<code>Write_Out _File.txt</code>。可以拿它与文
<code>Read_In_File.txt</code>
比较，如果两者一致说明仿真结果正确，否则结果错误。此外，还可以手动查看仿真波形调试问题。</p>
<h1 id="结构化-testbench-思想">4. 结构化 testbench 思想</h1>
<p>在<a href="#toc.3">第 3 节</a>中，介绍了两种验证 MPI 模块的
testbench。</p>
<p>在这些平台中，在 testbench
的顶层直接描述接口的时序，将测试数据加上去。</p>
<p>实际上，在 testbench 中，对 MPI
接口主要只有两种操作：写操作和读操作。</p>
<p>如果，把产生这两种操作的时序功能模块作为一种标准功能模块，而将要操作的地址和数据等作为参数去调用这种总线功能模块，那有什么好处呢？</p>
<p>这样的话，无论对 MPI
进行什么样的读/写操作，只需要调用这种通用的总线模块（就是后面要介绍的总线功能模型
BFM（Bus Functional Model）），
同时将读/写的地址和数据代入即可，操作简单，代码容易维护，同时读与写的功能模块得到了重用，这就是结构化
testbench 出现的原因。</p>
<p>结构化 testbench 不仅使得 BFM
和测试用例分离，而且将测试套具和测试用例也分离开了，不同的测试用例之间也是相互独立的。结构化
testbench 如 <a href="#fig.7-23">图 7-23</a> 所示。</p>
<p><a id="fig.7-23"></a></p>
<figure>
<img data-src="../images/post/2023-04-16-josh-verilog-part-7/2023-04-16-josh-verilog-part-7-230-StructuralTestbench.png" width="600" alt="图 7-23 结构化testbench示意">
<figcaption aria-hidden="true">图 7-23 结构化testbench示意</figcaption>
</figure>
<p>结构化test bench 的好处是：</p>
<ul>
<li>总线功能模块（BFM）重用；</li>
<li>结构清晰，易于设计，减小testbench 设计工作量；</li>
<li>将 testcase 的抽象程度提高，无须关心底层细节；</li>
<li>适用于复杂的设计模块。</li>
</ul>
<p>为了进一步说明结构化 testbench，来看看几个基本的概念。</p>
<h2 id="任务和函数">4.1. 任务和函数</h2>
<p>在 <a href="#toc.2.1.10">2.1.10 小节</a>中，介绍了在 Verilog
中的两种功能封装方法：</p>
<ul>
<li>任务：<code>task</code>;</li>
<li>函数：<code>function</code>。</li>
</ul>
<p>在下一小节中的 BFM 设计部分，正是利用了这种功能封装的概念。</p>
<h2 id="总线模型重用">4.2. 总线模型重用</h2>
<p>BFM 是一种将物理的接口时序操作转化成更高抽象层次接口的总线模型。</p>
<p>以<a href="#toc.3">第 3 节</a>中的设计为例，BFM 结构如<a href="#fig.7-17">图 7-17</a> 所示。</p>
<p>为了验证 FPGA 中 MPI 接口的功能，需要给 MPI
接口加各种各样的激励，仿真激励的种类越多，仿真越完备。</p>
<p>这里，需要在 testbench 中模拟 PowerPC 接口的时序和功能。</p>
<p><a id="fig.7-24"></a></p>
<figure>
<img data-src="../images/post/2023-04-16-josh-verilog-part-7/2023-04-16-josh-verilog-part-7-240-BFMDiagram.png" width="800" alt="图 7-24 BFM示意图">
<figcaption aria-hidden="true">图 7-24 BFM示意图</figcaption>
</figure>
<p>在<a href="#fig.7-24">图 7-24</a> 中，<code>uP_BFM</code> 是作为一个
Verilog HDL 中的 <code>module</code> 出现的。其中，在 BFM 面对 DUV
的一边将模拟 PowerPC
的访问时序，这是一个延时非常精确的总线模型。在该模型内部有两个用户定义的任务：
<code>write</code> 和
<code>read</code>，供其他模块（如测试激励）调用。</p>
<p>这样测试激励（testcases）就不需要关心接口时序，它们需要能调用
<code>write</code> 和 <code>read</code>
两个任务即可，实现底层时序的功能就交给了 <code>uP_BFM</code>。</p>
<h2 id="测试套具">4.3. 测试套具</h2>
<p>测试套具就是
harness。从系统测试角度说，也就是将被测模块固定，以方便测试。而从验证
Verilog
代码来说，就是<strong>将被测试模块封装起来，留出简单易用的访问接口</strong>，以利于各种测试用例来调用、测试设计模块。</p>
<p>如<a href="#fig.7-25">图 7-25</a>，harness 中实例化了
<code>uP _BFM</code> 和 DUV，以及一些基本的激励，如 <code>Clock</code>
和复位的产生。另外，测试激励可以通过 harness 中 <code>uP _BFM</code>
的任务，来对 DUV 施加各种激励。</p>
<p><a id="fig.7-25"></a></p>
<figure>
<img data-src="../images/post/2023-04-16-josh-verilog-part-7/2023-04-16-josh-verilog-part-7-250-Harness.png" width="600" alt="图 7-25 harness测试套具">
<figcaption aria-hidden="true">图 7-25 harness测试套具</figcaption>
</figure>
<h2 id="测试用例">4.4. 测试用例</h2>
<p>在上一小节中，介绍了测试套具，即
harness。当把被测模块固定好以后，就需要各种各样的测试用例来进行测试，尽量考虑多一些边界条件，保证测试的覆盖率。</p>
<p>测试激励被称为 testcase，如<a href="#fig.7-26">图 7-26</a> 所示。</p>
<p><a id="fig.7-26"></a></p>
<figure>
<img data-src="../images/post/2023-04-16-josh-verilog-part-7/2023-04-16-josh-verilog-part-7-260-Testcase.png" width="700" alt="图 7-26 testcase测试用例">
<figcaption aria-hidden="true">图 7-26 testcase测试用例</figcaption>
</figure>
<p>testcase 中的各种用例可以通过图中的虚线箭头来调用 harness
中的任务。关于测试用例和 harness
之间的层次关系，请参考下一小节的内容。</p>
<p>另外，设计测试用例时需要考虑测试用例的可扩展性和独立性。</p>
<h2 id="结构化-testbench">4.5. 结构化 testbench</h2>
<p>在这一小节中，将讨论测试用例、harness 的层次关系。</p>
<h3 id="单顶层-testbench">4.5.1. 单顶层 testbench</h3>
<p>在单顶层的 testbench 中，只有一个顶层。harness
的实例，以及各种测试用例都在顶层中。单顶层的testbench 结构如<a href="#fig.7-27">图 7-27</a> 所示。</p>
<p><a id="fig.7-27"></a></p>
<figure>
<img data-src="../images/post/2023-04-16-josh-verilog-part-7/2023-04-16-josh-verilog-part-7-270-SingleTopTestbench.png" width="650" alt="图 7-27 单顶层的testbench结构">
<figcaption aria-hidden="true">图 7-27
单顶层的testbench结构</figcaption>
</figure>
<p>假设 harness 在 testbench 顶层中的实例名叫
<code>inst_harness</code>，harness 实例化进来的模块 <code>uP_BFM</code>
里面有一个任务 <code>SEND_DATA</code>，该任务可以产生激励输入到 DUV，在
testcase 里调用该任务就可写为：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    ...</span><br><span class="line">    inst_harness<span class="variable">.uP_BFM</span><span class="variable">.SEND_DATA</span>(...);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="多顶层-testbench">4.5.2. 多顶层
testbench<a id="toc.4.5.2"></a></h3>
<p>Verilog 语言支持多顶层结构。</p>
<p>在多顶层的 testbench 中，通常有一个 harness
顶层，用来实例化设计模块，实例化 BFM，以及提供一些基本的激励，如
<code>clock</code>
和复位等。而多个测试用例都可以作为顶层，不同的测试用例用来测试不同的特性或者边界条件。这样的话，如果要增加或减少用例，只需要增加文件或减少文件即可，对现有文件的修改非常少，防止引入人为的错误。多顶层的
testbench 结构如<a href="#fig.7-28">图 7-28</a> 所示。</p>
<p><a id="fig.7-28"></a></p>
<figure>
<img data-src="../images/post/2023-04-16-josh-verilog-part-7/2023-04-16-josh-verilog-part-7-280-MultiTopTestbench.png" width="750" alt="图 7-28 多顶层的testbench结构">
<figcaption aria-hidden="true">图 7-28
多顶层的testbench结构</figcaption>
</figure>
<p>harness 顶层由 DUV
和一些接口模型（BFM）构成一个狭义上的测试平台，其他测试用例模块可以调用
BFM 里面的 <code>task</code>、<code>function</code> 等，向 DUV
施加激励。</p>
<p>注意这些顶层之间是没有端口映射的，它们之间的互相调用和访问是通过层次路径名的方式来访问，<strong>上图的虚线表示层次路径名的访问</strong>。</p>
<p>下面举例说明层次路径是如何访问的。</p>
<p>由于大部分人对 C 都有所认识，在这里做个比较，便于了解。Verilog HDL
的顶层类似于 C
的结构体，而实例化的模块、任务、函数、变量等就是结构体里的成员，可以通过点
<code>.</code> 隔开的方式访问结构体里面的每一个成员。</p>
<p>顶层 harness 实例化进来的模块 <code>uP_BFM</code> 里面有一个任务
<code>SEND_DATA</code>，该任务可以产生激励输入到 DUV，在每个 testcase 的
module 文件中调用该任务就可写为：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    ...</span><br><span class="line">    Harness<span class="variable">.uP_BFM</span><span class="variable">.SEND_DATA</span>(...);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>多顶层结构的可扩展和重用性比单顶层结构强得多</strong>。层次路径的访问方式非常有用，希望大家都能掌握它的用法。</p>
<h3 id="testbench-设计思想">4.5.3. testbench 设计思想</h3>
<p>验证的完备性对于 testbench 的设计意义非常重大。因此，设计 testbench
时需要清楚究竟要验证什么特性，怎么才能将各种设计的特性转化为设计的激励。</p>
<p>以下是设计一个 testbench 的基本思想和步骤，仅供参考：</p>
<ul>
<li>从需求（SPEC）规格到特性（features）：从设计的规格提取设计的特性；</li>
<li>从特性到用例（testcase）：根据设计特性，编写出相应的测试用例来验证该特性；</li>
<li>从用例到
testbench：用例测试用例，就可以搭建测试平台（testbench）。</li>
</ul>
<p>testbench
不是凭空设计的，它的根本起点还是一个设计的需求规格。验证工程师的基本工作，正是要验证逻辑设计工程师的设计是否满足需求规格。</p>
<h1 id="实例结构化-testbench-的编写">5. 实例：结构化 testbench
的编写</h1>
<p>以上重点介绍了结构化 testbench
的思想、基本组成部分和优点。在这里，通过两个实例，从理论到实战过渡。</p>
<h2 id="单顶层-testbench-1">5.1. 单顶层 testbench<a id="toc.5.1"></a></h2>
<p>单顶层 testbench 结构如<a href="#fig.7-29">图 7-29</a> 所示。</p>
<p><a id="fig.7-29"></a></p>
<figure>
<img data-src="../images/post/2023-04-16-josh-verilog-part-7/2023-04-16-josh-verilog-part-7-290-SingleTopTestbenchDemo.png" width="600" alt="图 7-29 单顶层testbench结构">
<figcaption aria-hidden="true">图 7-29 单顶层testbench结构</figcaption>
</figure>
<p>在单顶层 testbench 中，实例化 harness，同时写了两个测试用例来调用
<code>uP_BFM</code> 实例中的读/写任务。</p>
<p>其中 harness 中包括 <code>uP_BFM</code> 和 <code>MPI</code>
设计的实例化模块，以及一些基本的激励。</p>
<p>testcase 顶层代码如下：</p>
<figure class="highlight verilog"><figcaption><span>testcase.v</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// testcase.v</span></span><br><span class="line"><span class="comment">// - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span></span><br><span class="line"><span class="comment">//            Verilog Design &amp; Verification</span></span><br><span class="line"><span class="comment">//            EDA Pioneer</span></span><br><span class="line"><span class="comment">// - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span></span><br><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/100ps</span></span><br><span class="line"><span class="keyword">module</span> testcase ;</span><br><span class="line"></span><br><span class="line">harness inst_harness ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span>    [<span class="number">7</span>:<span class="number">0</span>] Data_out;</span><br><span class="line"><span class="keyword">reg</span>    [<span class="number">7</span>:<span class="number">0</span>] Data_in;</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span>    [<span class="number">7</span>:<span class="number">0</span>] DataSource [<span class="number">0</span>:<span class="number">47</span>];</span><br><span class="line"><span class="keyword">integer</span>      Write_Out_File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span>: MYCASE</span><br><span class="line">    <span class="keyword">integer</span> i;</span><br><span class="line">    # <span class="number">222</span> ;</span><br><span class="line">    <span class="comment">// testcase 1:</span></span><br><span class="line">    <span class="keyword">for</span> ( i=<span class="number">6'b101111</span>; i&gt;= <span class="number">0</span>; i=i-<span class="number">1</span> ) <span class="keyword">begin</span></span><br><span class="line">        Data_out = {<span class="built_in">$random</span>} % <span class="number">256</span>; <span class="comment">//data between 0~255</span></span><br><span class="line">        inst_harness<span class="variable">.inst_BFM</span><span class="variable">.Write</span>(Data_out, i);</span><br><span class="line">        <span class="built_in">$display</span> (<span class="string">"case1, Addr: %h -&gt; DataWrite: %h"</span>, i, Data_out);</span><br><span class="line">        inst_harness<span class="variable">.inst_BFM</span><span class="variable">.Read</span>(Data_in, i);</span><br><span class="line">        <span class="built_in">$display</span> (<span class="string">"case1, Addr: %h -&gt; DataRead: %h"</span>, i, Data_in);</span><br><span class="line">        <span class="built_in">$display</span> (<span class="string">"------------------------"</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">$readmemh</span> ( <span class="string">"Read_In_File.txt"</span>, DataSource );</span><br><span class="line">    Write_Out_File = <span class="built_in">$fopen</span>(<span class="string">"Write_Out_File.txt"</span>);</span><br><span class="line">    <span class="comment">// testcase 2</span></span><br><span class="line">    <span class="keyword">for</span> ( i=<span class="number">6'b101111</span>; i&gt;= <span class="number">0</span>; i=i-<span class="number">1</span> ) <span class="keyword">begin</span></span><br><span class="line">        Data_out = DataSource[i] ;</span><br><span class="line">        inst_harness<span class="variable">.inst_BFM</span><span class="variable">.Write</span>(Data_out, i);</span><br><span class="line">        <span class="built_in">$display</span> (<span class="string">"case2, Addr: %h -&gt; DataWrite: %h"</span>, i, Data_out);</span><br><span class="line">        inst_harness<span class="variable">.inst_BFM</span><span class="variable">.Read</span>(Data_in, i);</span><br><span class="line">        <span class="built_in">$display</span> (<span class="string">"case2, Addr: %h -&gt; DataRead: %h"</span>, i, Data_in);</span><br><span class="line">        <span class="built_in">$display</span> (<span class="string">"------------------------"</span>);</span><br><span class="line">        <span class="built_in">$fdisplay</span> (Write_Out_File, <span class="string">"@%h\n%h"</span>, i, Data_in);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">$fclose</span> ( Write_Out_File );</span><br><span class="line">    <span class="built_in">$display</span> (<span class="string">"Simulation Finished!"</span>);</span><br><span class="line">    <span class="built_in">$stop</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></tbody></table></figure>
<p>harness 的模块结构如下：</p>
<figure class="highlight verilog"><figcaption><span>harness.v</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// harness.v</span></span><br><span class="line"><span class="comment">// - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span></span><br><span class="line"><span class="comment">//            Verilog HDL Design &amp; Verification</span></span><br><span class="line"><span class="comment">//            EDA Pioneer</span></span><br><span class="line"><span class="comment">// - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span></span><br><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/100ps</span></span><br><span class="line"><span class="keyword">module</span> harness ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Clock Stimulus generation</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// Reset Stimulus generation</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">tri</span>  [<span class="number">7</span>:<span class="number">0</span>] Mpi_data;</span><br><span class="line"><span class="keyword">wire</span> [<span class="number">5</span>:<span class="number">0</span>] Mpi_addr ;</span><br><span class="line"><span class="keyword">wire</span>       Mpi_cs_n;</span><br><span class="line"><span class="keyword">wire</span>       Mpi_rw;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BFM模块实例</span></span><br><span class="line">uP_BFM inst_BFM (</span><br><span class="line">    <span class="variable">.uP_data</span>    (Mpi_data   ),</span><br><span class="line">    <span class="variable">.uP_addr</span>    (Mpi_addr   ),</span><br><span class="line">    <span class="variable">.uP_cs_n</span>    (Mpi_cs_n   ),</span><br><span class="line">    <span class="variable">.uP_rw</span>      (Mpi_rw     )</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"><span class="comment">// MPI设计模块实例</span></span><br><span class="line">MPI u_MPI (</span><br><span class="line">    <span class="variable">.Clock</span>      (Clock      ),</span><br><span class="line">    <span class="variable">.Rst_n</span>      (Rst_n      ),</span><br><span class="line">    <span class="variable">.Mpi_data</span>   (Mpi_data   ),</span><br><span class="line">    <span class="variable">.Mpi_addr</span>   (Mpi_addr   ),</span><br><span class="line">    <span class="variable">.Mpi_cs_n</span>   (Mpi_cs_n   ),</span><br><span class="line">    <span class="variable">.Mpi_rw</span>     (Mpi_rw )</span><br><span class="line">    ) ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></tbody></table></figure>
<p>注意到，在 testcase 顶层中，harness 的实例名为
<code>inst_harness</code>，而在 harness 中，<code>uP_BFM</code>
的实例名为 <code>inst_BFM</code>。因此，测试用例中调用
<code>uP_BFM</code> 中的 <code>Write</code> 和 <code>Read</code>
任务时，采用如下方法：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line">inst_harness<span class="variable">.inst_BFM</span><span class="variable">.Write</span>(Data_out, i);   <span class="comment">// Data_out 为写数据, i 为写地址</span></span><br><span class="line">inst_harness<span class="variable">.inst_BFM</span><span class="variable">.Read</span>(Data_in, i);   <span class="comment">// Data_in 为读数据, i 为读地址</span></span><br></pre></td></tr></tbody></table></figure>
<p>关于具体的仿真步骤请参考 <a href="#toc.3.2">3.2
小节</a>中的操作步骤。工程文件在本文<a href="https://download.csdn.net/download/weixin_43870101/12451000">附带资源</a>中的
<code>Example-7-3</code> 目录中。仿真运行结果打印如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"># case1, Addr: 0000002f -&gt; DataWrite: 24</span><br><span class="line"># case1, Addr: 0000002f -&gt; DataRead: 24</span><br><span class="line"># ------------------------</span><br><span class="line"># case1, Addr: 0000002e -&gt; DataWrite: 81</span><br><span class="line"># case1, Addr: 0000002e -&gt; DataRead: 81</span><br><span class="line"># ------------------------</span><br><span class="line">...</span><br><span class="line"># case2, Addr: 0000002f -&gt; DataWrite: 24</span><br><span class="line"># case2, Addr: 0000002f -&gt; DataRead: 24</span><br><span class="line"># ------------------------</span><br><span class="line"># case2, Addr: 0000002e -&gt; DataWrite: 81</span><br><span class="line"># case2, Addr: 0000002e -&gt; DataRead: 81</span><br><span class="line"># ------------------------</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure>
<p>这里的 <code>case1</code> 就是延用 <a href="#toc.3.2">3.2
小节</a>中的测试激励，数据源为随机数。而 <code>case2</code> 就是 <a href="#toc.3.3">3.3 小节</a>中的测试激励，数据源是从文件
<code>Read_In_File.txt</code>
中读出的。这里将两种数据的测试用例合并到一个文件的不同用例下，检查仿真结果的方法也相同。</p>
<h2 id="多顶层-testbench-1">5.2. 多顶层 testbench</h2>
<p>多顶层 testbench 结构如<a href="#fig.7-30">图 7-30</a> 所示，多个
testcase 文件都可以调用 harness 中的读/写任务。</p>
<p><a id="fig.7-30"></a></p>
<figure>
<img data-src="../images/post/2023-04-16-josh-verilog-part-7/2023-04-16-josh-verilog-part-7-300-MultiTopTestbenchDemo.png" width="600" alt="图 7-30 多顶层testbench结构">
<figcaption aria-hidden="true">图 7-30 多顶层testbench结构</figcaption>
</figure>
<p>在 testcase 代码中，如果需要调用 harness 下 <code>uP_BFM</code>
实例中的读/写任务，则需要在 testcase 中写类似如下代码：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line">harness<span class="variable">.inst_BFM</span><span class="variable">.Write</span>(Data_out, i);   <span class="comment">// Data_out 为写数据. i 为写地址</span></span><br><span class="line">harness<span class="variable">.inst_BFM</span><span class="variable">.Read</span>(Data_in, i);     <span class="comment">// Data_in 为读数据. i 为读地址</span></span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>ModelSim 中调用多个顶层仿真的命令：
<code>vsim-L altera_mf testcase harness</code>。</p>
</blockquote>
<p>在多顶层的结构中，harness 代码是不变的，只有 testcase
需要做相应的修改。代码修改如下：</p>
<figure class="highlight verilog"><figcaption><span>testcase.v</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// testcase.v</span></span><br><span class="line"><span class="comment">// - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span></span><br><span class="line"><span class="comment">//            Verilog Design &amp; Verification</span></span><br><span class="line"><span class="comment">//            EDA Pioneer</span></span><br><span class="line"><span class="comment">// - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span></span><br><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/100ps</span></span><br><span class="line"><span class="keyword">module</span> testcase ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//harness inst_harness ();</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span>    [<span class="number">7</span>:<span class="number">0</span>] Data_out;</span><br><span class="line"><span class="keyword">reg</span>    [<span class="number">7</span>:<span class="number">0</span>] Data_in;</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span>    [<span class="number">7</span>:<span class="number">0</span>] DataSource [<span class="number">0</span>:<span class="number">47</span>];</span><br><span class="line"><span class="keyword">integer</span>      Write_Out_File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span></span><br><span class="line"><span class="keyword">begin</span>: MYCASE</span><br><span class="line">    <span class="keyword">integer</span> i;</span><br><span class="line">    # <span class="number">222</span> ;</span><br><span class="line">    <span class="comment">// testcase 1:</span></span><br><span class="line">    <span class="keyword">for</span> ( i=<span class="number">6'b101111</span>; i&gt;= <span class="number">0</span>; i=i-<span class="number">1</span> ) <span class="keyword">begin</span></span><br><span class="line">        Data_out = {<span class="built_in">$random</span>} % <span class="number">256</span>; <span class="comment">//data between 0~255</span></span><br><span class="line">        harness<span class="variable">.inst_BFM</span><span class="variable">.Write</span>(Data_out, i);</span><br><span class="line">        <span class="built_in">$display</span> (<span class="string">"case1, Addr: %h -&gt; DataWrite: %h"</span>, i, Data_out);</span><br><span class="line">        harness<span class="variable">.inst_BFM</span><span class="variable">.Read</span>(Data_in, i);</span><br><span class="line">        <span class="built_in">$display</span> (<span class="string">"case1, Addr: %h -&gt; DataRead: %h"</span>, i, Data_in);</span><br><span class="line">        <span class="built_in">$display</span> (<span class="string">"------------------------"</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">$readmemh</span> ( <span class="string">"Read_In_File.txt"</span>, DataSource );</span><br><span class="line">    Write_Out_File = <span class="built_in">$fopen</span>(<span class="string">"Write_Out_File.txt"</span>);</span><br><span class="line">    <span class="comment">// testcase 2</span></span><br><span class="line">    <span class="keyword">for</span> ( i=<span class="number">6'b101111</span>; i&gt;= <span class="number">0</span>; i=i-<span class="number">1</span> ) <span class="keyword">begin</span></span><br><span class="line">        Data_out = DataSource[i] ;</span><br><span class="line">        harness<span class="variable">.inst_BFM</span><span class="variable">.Write</span>(Data_out, i);</span><br><span class="line">        <span class="built_in">$display</span> (<span class="string">"case2, Addr: %h -&gt; DataWrite: %h"</span>, i, Data_out);</span><br><span class="line">        harness<span class="variable">.inst_BFM</span><span class="variable">.Read</span>(Data_in, i);</span><br><span class="line">        <span class="built_in">$display</span> (<span class="string">"case2, Addr: %h -&gt; DataRead: %h"</span>, i, Data_in);</span><br><span class="line">        <span class="built_in">$display</span> (<span class="string">"------------------------"</span>);</span><br><span class="line">        <span class="built_in">$fdisplay</span> (Write_Out_File, <span class="string">"@%h\n%h"</span>, i, Data_in);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">$fclose</span> ( Write_Out_File );</span><br><span class="line">    <span class="built_in">$display</span> (<span class="string">"Simulation Finished!"</span>);</span><br><span class="line">    <span class="built_in">$stop</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></tbody></table></figure>
<p>容易发现，在本例中，testcase 调用 harness 中的任务格式如下：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line">harness<span class="variable">.inst_BFM</span><span class="variable">.Write</span>(Data_out, i);    <span class="comment">// 直接引用 harness 模块名</span></span><br></pre></td></tr></tbody></table></figure>
<p>而在 <a href="#toc.5.1">5.1 小节</a>的单顶层 testbench
中格式如下：</p>
<figure class="highlight verilog"><table><tbody><tr><td class="code"><pre><span class="line">inst_harness<span class="variable">.inst_BFM</span><span class="variable">.Write</span>(Data_out, i);  <span class="comment">// 引用 harness 在 testcase 中的实例名: inst_harness</span></span><br></pre></td></tr></tbody></table></figure>
<p>具体的仿真步骤请参考 <a href="#toc.3.2">3.2
小节</a>中的操作步骤。工程文件在本文<a href="https://download.csdn.net/download/weixin_43870101/12451000">附带资源</a>中的
<code>Example-7-4</code> 目录中。</p>
<h1 id="扩展-verilog-的高层建模能力">6. 扩展 Verilog 的高层建模能力</h1>
<p>一些 Verilog 的高级用户在使用 Verilog 编写 testbench
时常常感到它的文件输入/输出操作，以及高级抽象的数学功能比 C
语言要弱，毕竟 Verilog 是硬件描述语言。</p>
<p>不过，Verilog 还是开放了一个接口叫
<strong>PLI</strong>（编程语言接口），专门用来和 C
语言的程序通信。这样，借助 PLI，Verilog
的高层次建模的不足就得到了弥补。</p>
<p>目前，业界绝大部分的仿真器都支持PLI。</p>
<p>这里简单说明一下PLI 如何工作。例如，在 PC 上运行了一个 Verilog
的仿真器，同时还运行了一个 C 语言编写的应用程序。该 C 应用程序可以通过
PC 的一个内存空间与 Verilog
仿真器交换数据。比如应用程序产生的激励可以放在内存中，等待仿真器取走数据后，将结果写回。应用程序再将写回的结果取走。这样完成了一个由
C 应用程序扩展Verilog 语言能力的过程。</p>
<p>关于PLI，这里不再详述，感兴趣可以参考其他文献。</p>
<h1 id="小结">7. 小结</h1>
<p>在本篇笔记中，介绍了验证和仿真的基本概念。重点叙述了如何建立
testbench 、如何搭建仿真环境以及如何确认仿真结果。</p>
<p>通过一个 CPU 接口的设计，介绍了 testbench 的设计方法、结构化的
testbench 。希望大家能通过实例熟练掌握 testbench 的设计方法。</p>
<p>另外补充一点，testbench
是<strong>可以继承的</strong>。虽然在本篇笔记中，重点放在 RTL
级的代码仿真上，但同样的 testbench
在门级仿真或者后仿真阶段，也可以使用。</p>
<h1 id="参考文献">参考文献</h1>
<p>EDA 先锋工作室. <em>轻松成为设计高手——Verilog HDL 实用精解.</em>
北京航空航天大学出版社, 2012.</p>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/css/markmap.css">

<script src="/js/markmap.js"></script>
]]></content>
      <categories>
        <category>Josh 的学习笔记</category>
        <category>Verilog</category>
      </categories>
      <tags>
        <tag>Verilog</tag>
        <tag>HDL</tag>
        <tag>Testbench</tag>
        <tag>系统函数</tag>
        <tag>仿真</tag>
        <tag>激励</tag>
        <tag>时钟</tag>
        <tag>复位</tag>
        <tag>系统任务</tag>
        <tag>函数</tag>
        <tag>任务</tag>
      </tags>
  </entry>
  <entry>
    <title>Josh&#39;s Note — 最优阵列处理&lt;br&gt;Part 1.3 均匀加权线阵</title>
    <url>/posts/aa32ec76.html</url>
    <content><![CDATA[<h1 id="均匀加权线阵的频率-波数响应函数">均匀加权线阵的频率-波数响应函数</h1>
<p>  现在把注意力集中到均匀加权线阵（Uniformly Weighted Linear
Array）的情况，即</p>
<p><span class="math display">\[\begin{equation}
  w_n = \frac{1}{N}, \, n = 0,1,\cdots,N-1
\end{equation}\]</span></p>
<p><span class="math display">\[\begin{equation}
  \boldsymbol{w} = \frac{1}{N} \boldsymbol{1}
\end{equation}\]</span></p>
<p>其中 <span class="math inline">\(\boldsymbol{1}\)</span> 是 <span class="math inline">\(N \times 1\)</span> 维的单位矢量，则在 <span class="math inline">\(\psi\)</span>
空间的频率-波数响应函数可以写成（利用等比级数的求和公式）</p>
<p><span class="math display">\[\begin{equation}
  \begin{aligned}
    \boldsymbol{\varUpsilon}_\psi(\psi) &amp;= \frac{1}{N}
\sum_{n=0}^{N-1}  e^{j \left(n - \frac{N-1}{2}\right)\psi} \\
    &amp;= \frac{1}{N} e^{-j \left(\frac{N-1}{2}\right)\psi}
\sum_{n=0}^{N-1} e^{j n \psi} \\
    &amp;= \frac{1}{N} e^{-j \left(\frac{N-1}{2}\right)\psi} \left[
\frac{1-e^{jN\psi}}{1-e^{j\psi}} \right]
  \end{aligned}
\end{equation}\]</span></p>
<p>或（利用欧拉公式）</p>
<p><span class="math display">\[\begin{equation}
  \boldsymbol{\varUpsilon}_\psi(\psi) = \frac{1}{N} \frac{\sin\left( N
\frac{\psi}{2} \right)}{\sin\frac{\psi}{2}}
\end{equation}\]</span></p>
<span id="more"></span>
<p>可以观察到：</p>
<ul>
<li>当 <span class="math inline">\(N\)</span> 是奇数时，<span class="math inline">\(\boldsymbol{\varUpsilon}_\psi(\psi)\)</span>
是周期函数，周期为 <span class="math inline">\(2\pi\)</span>；</li>
<li>当 <span class="math inline">\(N\)</span> 为偶数时，波瓣在 <span class="math inline">\(\pm 2 \pi\)</span>、<span class="math inline">\(\pm 6 \pi\)</span> 处的值为负值，周期为 <span class="math inline">\(4 \pi\)</span>；</li>
<li>对任意的 <span class="math inline">\(N\)</span>，<span class="math inline">\(\left|\boldsymbol{\varUpsilon}_\psi(\psi)\right|\)</span>
的周期为 <span class="math inline">\(2 \pi\)</span>。</li>
</ul>
<p>当 <span class="math inline">\(N = 11\)</span> 时， <span class="math inline">\(\boldsymbol{\varUpsilon}_\psi(\psi)\)</span> 和
<span class="math inline">\(\psi\)</span> 的关系在<a href="#fig.1-3-1">图 1-3-1</a> 中给出。<a href="#fig.1-3-2">图 1-3-2</a>
给出了 <span class="math inline">\(\left|\boldsymbol{\varUpsilon}_\psi(\psi)\right|\)</span>，单位为
dB，其中</p>
<p><span class="math display">\[\begin{equation}
  \boldsymbol{\varUpsilon}_\mathrm{dB}(\psi) = 10 \log_{10}
\left|\boldsymbol{\varUpsilon}(\psi)\right|^2
\end{equation}\]</span></p>
<p><a id="fig.1-3-1"></a></p>
<figure>
<img data-src="../images/post/2023-04-20-josh-oap-part-1-3/2023-04-20-josh-oap-part-1-3-010-FrequencyWavenumberResponseFunction.svg" width="1000" alt="图 1-3-1 \boldsymbol{\varUpsilon}(\psi): \psi = \frac{2\pi}{\lambda} d \cos\theta, N=11">
<figcaption aria-hidden="true">图 1-3-1 <span class="math inline">\(\boldsymbol{\varUpsilon}(\psi): \psi =
\frac{2\pi}{\lambda} d \cos\theta, N=11\)</span></figcaption>
</figure>
<p><a id="fig.1-3-2"></a></p>
<figure>
<img data-src="../images/post/2023-04-20-josh-oap-part-1-3/2023-04-20-josh-oap-part-1-3-020-FrequencyWavenumberResponseFunctionInDB.svg" width="1000" alt="图 1-3-2 用 dB 表示 \left|\boldsymbol{\varUpsilon}(\psi)\right|">
<figcaption aria-hidden="true">图 1-3-2 用 dB 表示 <span class="math inline">\(\left|\boldsymbol{\varUpsilon}(\psi)\right|\)</span></figcaption>
</figure>
<details class="note primary"><summary><p>MATLAB Code</p>
</summary>
<figure class="highlight matlab"><figcaption><span>fig2_1516.m</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% Figure 2.15 &amp; 2.16</span></span><br><span class="line"><span class="comment">% Beampattern of uniformly weighted linear array</span></span><br><span class="line"><span class="comment">% Xiaomin Lu</span></span><br><span class="line"><span class="comment">% Updated 1/5/99</span></span><br><span class="line"><span class="comment">% Last updated  by K. Bell 7/22/01, 10/4/01</span></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"></span><br><span class="line">clear all</span><br><span class="line">close all</span><br><span class="line"></span><br><span class="line">N = <span class="number">11</span>;        <span class="comment">% 11 elements</span></span><br><span class="line"><span class="comment">% Note, Eq. (2.92) is in fact the standard Dirichlet function</span></span><br><span class="line"><span class="comment">% beam = diric(psi, N);</span></span><br><span class="line"><span class="comment">% if you don't have the signal processing toolbox, this does the same thing</span></span><br><span class="line"><span class="built_in">psi</span> = (<span class="number">-5</span>:<span class="number">1</span>/<span class="number">400</span>:<span class="number">5</span>)*<span class="built_in">pi</span>;</span><br><span class="line">beam = <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="built_in">length</span>(<span class="built_in">psi</span>(:)));</span><br><span class="line">y=<span class="built_in">sin</span>(<span class="number">.5</span>*<span class="built_in">psi</span>);</span><br><span class="line"><span class="built_in">i</span>=<span class="built_in">find</span>(<span class="built_in">abs</span>(y)&gt;<span class="number">1e-12</span>);            <span class="comment">% set where x is not divisible by 2 pi</span></span><br><span class="line"><span class="built_in">j</span>=<span class="number">1</span>:<span class="built_in">length</span>(<span class="built_in">psi</span>(:));</span><br><span class="line"><span class="built_in">j</span>(<span class="built_in">i</span>)=[];                         <span class="comment">% complement set</span></span><br><span class="line">beam(<span class="built_in">i</span>)=<span class="built_in">sin</span>((N/<span class="number">2</span>)*<span class="built_in">psi</span>(<span class="built_in">i</span>))./(N*y(<span class="built_in">i</span>));</span><br><span class="line">beam(<span class="built_in">j</span>)=<span class="built_in">sign</span>(<span class="built_in">cos</span>(<span class="built_in">psi</span>(<span class="built_in">j</span>)*((N+<span class="number">1</span>)/<span class="number">2</span>)));</span><br><span class="line"></span><br><span class="line"><span class="built_in">plot</span>(<span class="built_in">psi</span>/<span class="built_in">pi</span>, beam)</span><br><span class="line">grid</span><br><span class="line">xlabel(<span class="string">'$\psi/\pi$'</span>,<span class="string">'Interpreter'</span>,<span class="string">'latex'</span>)</span><br><span class="line">ylabel(<span class="string">'Frequency wavenumber response function'</span>)</span><br><span class="line">axis([<span class="number">-5</span> <span class="number">5</span> <span class="number">-0.4</span> <span class="number">1</span>])</span><br><span class="line">set(gcf,<span class="string">'Position'</span>,[<span class="number">0</span> <span class="number">0</span> <span class="number">1000</span> <span class="number">600</span>])</span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line">beam = <span class="number">20</span>*<span class="built_in">log10</span>(<span class="built_in">abs</span>(beam));</span><br><span class="line"><span class="built_in">plot</span>(<span class="built_in">psi</span>/<span class="built_in">pi</span>,beam);</span><br><span class="line">xlabel(<span class="string">'$\psi/\pi$'</span>,<span class="string">'Interpreter'</span>,<span class="string">'latex'</span>)</span><br><span class="line">ylabel(<span class="string">'Frequency wavenumber response function (dB)'</span>)</span><br><span class="line">axis([<span class="number">-5</span> <span class="number">5</span> <span class="number">-25</span> <span class="number">0</span>])</span><br><span class="line">grid</span><br><span class="line">set(gcf,<span class="string">'Position'</span>,[<span class="number">0</span> <span class="number">0</span> <span class="number">1000</span> <span class="number">600</span>])</span><br></pre></td></tr></tbody></table></figure>

</details>
<p>若不指定 <span class="math inline">\(\boldsymbol{w}\)</span>
的类型，则 <span class="math inline">\(\boldsymbol{\varUpsilon}_\psi(\psi)\)</span>
是复数，所以相位也应该画出来。但是，均匀加权线阵具有对称性，因此得到的频率-波数响应是实函数。</p>
<p>  也可以用 <span class="math inline">\(k_z\)</span>
来表示频率-波数响应</p>
<p><span class="math display">\[\begin{equation}
  \boldsymbol{\varUpsilon}(\omega:k_z) = \frac{1}{N} \frac{\sin\left( N
k_z \frac{d}{2} \right)}{\sin \left(k_z\frac{d}{2}\right)}
\end{equation}\]</span></p>
<p>这里 <span class="math inline">\(\boldsymbol{\varUpsilon}(\omega:k_z)\)</span>
是周期函数，周期为 <span class="math inline">\(2\pi/d\)</span>。</p>
<div class="note warning"><p>注意，响应函数仅依赖于波数分量 <span class="math inline">\(k_z\)</span>，是 <span class="math inline">\(k_z\)</span> 的周期函数，间隔为 <span class="math inline">\(2\pi/d\)</span>，这是线性阵列的一维特性导致的，所以该阵列仅能分析在
<span class="math inline">\(k_z\)</span> 方向上投影的波数分量。</p>
</div>
<h1 id="均匀加权线阵的波束方向图">均匀加权线阵的波束方向图</h1>
<p>  均匀加权线阵的波束方向图为</p>
<p><span class="math display">\[\begin{equation}
  B_\theta(\theta) = \frac{1}{N} \frac{\sin\left(\frac{N}{2} \cdot
\frac{2\pi}{\lambda} \cos \theta \cdot d \right)}{\sin \left(
\frac{1}{2} \cdot \frac{2\pi}{\lambda} \cos\theta \cdot d\right)}, \quad
0 \leqslant \theta \leqslant \pi \\
\end{equation}\]</span></p>
<p><span class="math display">\[\begin{equation}
  B_u(u) = \frac{1}{N} \frac{\sin\left(\frac{ \pi Nd}{\lambda} u
\right)}{\sin \left( \frac{N d}{\lambda} u\right)}, \quad -1 \leqslant u
\leqslant 1 \label{BeamPatternOfUWLAInDirectionCosineDomain}
\end{equation}\]</span></p>
<p><span class="math display">\[\begin{equation}
  B_\psi(\psi) = \frac{1}{N}
\frac{\sin\left(N\frac{\psi}{2}\right)}{\sin \left( \frac{\psi}{2}
\right)}, \quad -\frac{2\pi d}{\lambda} \leqslant \psi \leqslant
\frac{2\pi d}{\lambda} \label{BeamPatternOfUWLAInWaveNumberDomain}
\end{equation}\]</span></p>
<p>其中定义域分别为 <span class="math inline">\(0 \leqslant \theta
\leqslant \pi\)</span>、<span class="math inline">\(-1 \leqslant u
\leqslant 1\)</span> 和 <span class="math inline">\(-\displaystyle\frac{2\pi d}{\lambda} \leqslant
\psi \leqslant \frac{2\pi
d}{\lambda}\)</span>，称为<strong><mark class="label primary">可视区域（visible region）</mark></strong>。</p>
<div class="note info"><p>函数 <span class="math inline">\(B_u(u)\)</span> 和 <span class="math inline">\(B_\psi(\psi)\)</span>
有时称为<strong><mark class="label primary">阵列因子（Array
Factor）</mark></strong>。这个量对非全向性阵元非常重要。</p>
</div>
<p>  <a href="#fig.1-3-3">图 1-3-3</a> 给出了 <span class="math inline">\(B_\theta(\theta)\)</span> 的极坐标形式，单位为
dB。如果在三维空间画出波束方向图，在<a href="#fig.1-3-3">图 1-3-3</a>
中的图将对应沿着任意方位角 <span class="math inline">\(\theta\)</span>
切割得到的方向图。<a href="#fig.1-3-4">图 1-3-4</a>
给出了波束方向图的幅度和不同变量之间的关系。</p>
<p><a id="fig.1-3-3"></a></p>
<figure>
<img data-src="../images/post/2023-04-20-josh-oap-part-1-3/2023-04-20-josh-oap-part-1-3-030-PloarPlotOfBeamPatternInAngleSpace.svg" width="800" alt="图 1-3-3 在极坐标系中画出 B_\theta(\theta)">
<figcaption aria-hidden="true">图 1-3-3 在极坐标系中画出 <span class="math inline">\(B_\theta(\theta)\)</span></figcaption>
</figure>
<details class="note primary"><summary><p>MATLAB Code</p>
</summary>
<figure class="highlight matlab"><figcaption><span>fig2_17.m</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% Figure 2.17</span></span><br><span class="line"><span class="comment">% Polar plot of B (Theta)</span></span><br><span class="line"><span class="comment">% Lillian Xu 1/5/99</span></span><br><span class="line"><span class="comment">% Updated by K. Bell 6/25/01</span></span><br><span class="line"><span class="comment">% Functions called: polardb</span></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">clear all</span><br><span class="line">close all</span><br><span class="line"></span><br><span class="line">N = <span class="number">11</span>;                                 <span class="comment">% Elements in array</span></span><br><span class="line">d = <span class="number">0.5</span>;                                <span class="comment">% spacing wrt wavelength</span></span><br><span class="line">beamwidth = <span class="number">2</span>/(N*d);                    <span class="comment">% null-to-null (LL BW is half this)</span></span><br><span class="line">D=d*(-(N<span class="number">-1</span>)/<span class="number">2</span>:<span class="number">1</span>:(N<span class="number">-1</span>)/<span class="number">2</span>);               <span class="comment">% element locations</span></span><br><span class="line">ang = <span class="built_in">pi</span>*(<span class="number">-1</span>:<span class="number">0.001</span>:<span class="number">1</span>);</span><br><span class="line">u   = <span class="built_in">cos</span>(ang);</span><br><span class="line">n2=<span class="built_in">size</span>(u,<span class="number">2</span>);</span><br><span class="line">AS  = <span class="built_in">exp</span>(<span class="number">-1</span><span class="built_in">i</span>*<span class="number">2</span>*<span class="built_in">pi</span>*<span class="built_in">cos</span>(<span class="number">90</span>/<span class="number">180</span>*<span class="built_in">pi</span>)*D');  <span class="comment">% BP points to 90 (broadside)</span></span><br><span class="line">Au  = <span class="built_in">exp</span>(<span class="number">-1</span><span class="built_in">i</span>*<span class="number">2</span>*<span class="built_in">pi</span>*D'*u);</span><br><span class="line">B   = <span class="built_in">real</span>(AS'*Au)/N;</span><br><span class="line">G   = <span class="number">20</span>*<span class="built_in">log10</span>((<span class="built_in">abs</span>(B)));</span><br><span class="line"></span><br><span class="line">h=polardb(ang,G,<span class="number">-40</span>);</span><br></pre></td></tr></tbody></table></figure>

</details>
<p><a id="fig.1-3-4"></a></p>
<figure>
<img data-src="../images/post/2023-04-20-josh-oap-part-1-3/2023-04-20-josh-oap-part-1-3-040-AbsOfFWRFForALinearArray.svg" width="1000" alt="图 1-3-4 d = \lambda/2, N=10，线阵的 \left|\boldsymbol{\varUpsilon}_\psi(\psi)\right|">
<figcaption aria-hidden="true">图 1-3-4 <span class="math inline">\(d =
\lambda/2, N=10\)</span>，线阵的 <span class="math inline">\(\left|\boldsymbol{\varUpsilon}_\psi(\psi)\right|\)</span></figcaption>
</figure>
<details class="note primary"><summary><p>MATLAB Code</p>
</summary>
<figure class="highlight matlab"><figcaption><span>fig2_18.m</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% Figure 2.18</span></span><br><span class="line"><span class="comment">% beam patterns in different spaces</span></span><br><span class="line"><span class="comment">% Lillian Xiaolan Xu</span></span><br><span class="line"><span class="comment">% Last updated 09/07/2000</span></span><br><span class="line"><span class="comment">% updated by K. Bell 7/22/01, 10/4/01</span></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"></span><br><span class="line">clear all</span><br><span class="line">close all</span><br><span class="line"></span><br><span class="line">N = <span class="number">10</span>;</span><br><span class="line">n = (-(N<span class="number">-1</span>)/<span class="number">2</span>:(N<span class="number">-1</span>)/<span class="number">2</span>).';</span><br><span class="line"><span class="built_in">psi</span> = <span class="built_in">pi</span>*(<span class="number">-3</span>:<span class="number">0.001</span>:<span class="number">3</span>);</span><br><span class="line">w = <span class="number">1</span>/N*[<span class="built_in">ones</span>(N,<span class="number">1</span>)];</span><br><span class="line">d = <span class="number">1</span>/<span class="number">2</span>;</span><br><span class="line">vv = <span class="built_in">exp</span>(<span class="number">1</span><span class="built_in">i</span>*<span class="number">2</span>*d*n*<span class="built_in">psi</span>);</span><br><span class="line">B = (<span class="built_in">abs</span>(w'*vv));</span><br><span class="line"></span><br><span class="line">u1=<span class="number">-1</span>;</span><br><span class="line">u2=<span class="number">3</span>;</span><br><span class="line">y1=<span class="number">0</span>;</span><br><span class="line">y2=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">4</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">plot</span>(-<span class="built_in">psi</span>/d,B);</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line">axis([u1*<span class="built_in">pi</span>/d u2*<span class="built_in">pi</span>/d y1 y2])</span><br><span class="line">set(gca,<span class="string">'XTick'</span>,[-<span class="built_in">pi</span>/d <span class="number">0</span> <span class="built_in">pi</span>/d <span class="number">2</span>*<span class="built_in">pi</span>/d <span class="number">3</span>*<span class="built_in">pi</span>/d])</span><br><span class="line">set(gca,<span class="string">'YTick'</span>,[<span class="number">0</span> <span class="number">0.5</span> <span class="number">1</span>])</span><br><span class="line">set(gca,<span class="string">'XTickLabel'</span>,{<span class="string">'$-\pi/d$'</span>;<span class="string">'$0$'</span>;<span class="string">'$\pi/d$'</span>;<span class="string">'$2\pi/d$'</span>;<span class="string">'$3\pi/d$'</span>}, ...</span><br><span class="line">  <span class="string">'TickLabelInterpreter'</span>,<span class="string">'latex'</span>)</span><br><span class="line"></span><br><span class="line">grid on</span><br><span class="line">point=<span class="number">0.8</span>;</span><br><span class="line">point_up=<span class="number">0.84</span>;</span><br><span class="line">point_down=<span class="number">0.76</span>;</span><br><span class="line"><span class="built_in">plot</span>([-<span class="built_in">pi</span>/d <span class="built_in">pi</span>/d],[point point],<span class="string">'--'</span>)</span><br><span class="line"><span class="built_in">plot</span>([<span class="number">-1</span>*<span class="built_in">pi</span>/d <span class="number">-0.9</span>*<span class="built_in">pi</span>/d],[point point_up])</span><br><span class="line"><span class="built_in">plot</span>([<span class="number">-1</span>*<span class="built_in">pi</span>/d <span class="number">-0.9</span>*<span class="built_in">pi</span>/d],[point point_down])</span><br><span class="line"><span class="built_in">plot</span>([<span class="number">0.9</span>*<span class="built_in">pi</span>/d <span class="built_in">pi</span>/d],[point_up point])</span><br><span class="line"><span class="built_in">plot</span>([<span class="number">0.9</span>*<span class="built_in">pi</span>/d <span class="built_in">pi</span>/d],[point_down point])</span><br><span class="line">text(<span class="number">-0.3</span>*<span class="built_in">pi</span>/d,<span class="number">1.2</span>,<span class="string">'Visible region'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">plot</span>([<span class="built_in">pi</span>/d <span class="number">3</span>*<span class="built_in">pi</span>/d],[point point],<span class="string">'--'</span>)</span><br><span class="line"><span class="built_in">plot</span>([<span class="built_in">pi</span>/d <span class="number">1.1</span>*<span class="built_in">pi</span>/d],[point point_up])</span><br><span class="line"><span class="built_in">plot</span>([<span class="built_in">pi</span>/d <span class="number">1.1</span>*<span class="built_in">pi</span>/d],[point point_down])</span><br><span class="line"><span class="built_in">plot</span>([<span class="number">2.9</span>*<span class="built_in">pi</span>/d <span class="number">3</span>*<span class="built_in">pi</span>/d],[point_up point])</span><br><span class="line"><span class="built_in">plot</span>([<span class="number">2.9</span>*<span class="built_in">pi</span>/d <span class="number">3</span>*<span class="built_in">pi</span>/d],[point_down point])</span><br><span class="line">text(<span class="number">1.7</span>*<span class="built_in">pi</span>/d,<span class="number">1.2</span>,<span class="string">'Virtual region'</span>)</span><br><span class="line"><span class="built_in">legend</span>({<span class="string">'$k_z$-space'</span>},<span class="string">'Interpreter'</span>,<span class="string">'latex'</span>)</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">plot</span>(<span class="built_in">psi</span>,B);</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line">axis([u1*<span class="built_in">pi</span> u2*<span class="built_in">pi</span> y1 y2])</span><br><span class="line">set(gca,<span class="string">'XTick'</span>,[-<span class="built_in">pi</span> <span class="number">0</span> <span class="built_in">pi</span> <span class="number">2</span>*<span class="built_in">pi</span> <span class="number">3</span>*<span class="built_in">pi</span>])</span><br><span class="line">set(gca,<span class="string">'YTick'</span>,[<span class="number">0</span> <span class="number">0.5</span> <span class="number">1</span>])</span><br><span class="line">set(gca,<span class="string">'XTickLabel'</span>,{<span class="string">'$-\pi$'</span>;<span class="string">'$0$'</span>;<span class="string">'$\pi$'</span>;<span class="string">'$2\pi$'</span>;<span class="string">'$3\pi$'</span>}, ...</span><br><span class="line">  <span class="string">'TickLabelInterpreter'</span>,<span class="string">'latex'</span>)</span><br><span class="line"></span><br><span class="line">grid on</span><br><span class="line"><span class="built_in">legend</span>({<span class="string">'$\psi$-space'</span>},<span class="string">'Interpreter'</span>,<span class="string">'latex'</span>)</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">4</span>,<span class="number">1</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">plot</span>(<span class="built_in">psi</span>/<span class="built_in">pi</span>,B);</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line">axis([u1 u2 y1 y2])</span><br><span class="line">set(gca,<span class="string">'XTick'</span>,[<span class="number">-1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>])</span><br><span class="line">set(gca,<span class="string">'YTick'</span>,[<span class="number">0</span> <span class="number">0.5</span> <span class="number">1</span>])</span><br><span class="line">grid on</span><br><span class="line"><span class="built_in">legend</span>({<span class="string">'$u$-space'</span>},<span class="string">'Interpreter'</span>,<span class="string">'latex'</span>)</span><br><span class="line"></span><br><span class="line">theta = <span class="number">-180</span>:<span class="number">0.1</span>:<span class="number">360</span>;</span><br><span class="line">vv = <span class="built_in">exp</span>(<span class="number">1</span><span class="built_in">i</span>*<span class="number">2</span>*d*n*<span class="built_in">pi</span>*<span class="built_in">cos</span>(theta/<span class="number">180</span>*<span class="built_in">pi</span>));</span><br><span class="line">B = (<span class="built_in">abs</span>(w'*vv));</span><br><span class="line">subplot(<span class="number">4</span>,<span class="number">1</span>,<span class="number">4</span>)</span><br><span class="line"><span class="built_in">plot</span>(theta,B);</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line">axis([<span class="number">-180</span> <span class="number">180</span> y1 y2])</span><br><span class="line">set(gca,<span class="string">'XTick'</span>,[<span class="number">-180</span> <span class="number">-90</span> <span class="number">0</span> <span class="number">90</span> <span class="number">180</span>])</span><br><span class="line">set(gca,<span class="string">'YTick'</span>,[<span class="number">0</span> <span class="number">0.5</span> <span class="number">1</span>])</span><br><span class="line">set(gca,<span class="string">'XTickLabel'</span>,{<span class="string">'$180^\circ$'</span>;<span class="string">'$90^\circ$'</span>;<span class="string">'$0^\circ$'</span>;<span class="string">'$-90^\circ$'</span>; ...</span><br><span class="line">  <span class="string">'$-180^\circ$'</span>},<span class="string">'TickLabelInterpreter'</span>,<span class="string">'latex'</span>)</span><br><span class="line"></span><br><span class="line">grid on</span><br><span class="line"><span class="built_in">legend</span>({<span class="string">'$\theta$-space'</span>},<span class="string">'Interpreter'</span>,<span class="string">'latex'</span>)</span><br><span class="line"></span><br><span class="line">set(gcf,<span class="string">'Position'</span>,[<span class="number">0</span> <span class="number">0</span> <span class="number">800</span> <span class="number">800</span>])</span><br></pre></td></tr></tbody></table></figure>

</details>
<div class="note info"><p>虽然以上例子比较简单，但是可以用来展示线性阵列的一些重要特征。</p>
</div>
<h1 id="波束方向图的参数">波束方向图的参数</h1>
<p>  波束方向图的重要特征可以使用波束方向图的参数来描述。</p>
<ol type="1">
<li>3dB 带宽（半功率波束宽度，half-power beamwidth，HPBW）</li>
<li>到第一零点的距离（这个距离的两倍称为 <span class="math inline">\(BW_{NN}\)</span>）</li>
<li>到第一旁瓣的距离</li>
<li>第一旁瓣的高度</li>
<li>其余零点的位置</li>
<li>旁瓣衰减的速率</li>
<li>栅瓣（Grating lobes）</li>
</ol>
<h2 id="半功率波束宽度">半功率波束宽度</h2>
<p>  为了说明前两个参数，考虑在<a href="#fig.1-3-5">图 1-3-5</a>
中给出的原点附近的波束方向图。</p>
<p><a id="fig.1-3-5"></a></p>
<figure>
<img data-src="../images/post/2023-04-20-josh-oap-part-1-3/2023-04-20-josh-oap-part-1-3-050-MainLobeOfBeamPattern.svg" width="700" alt="图 1-3-5 波束方向图的主波束">
<figcaption aria-hidden="true">图 1-3-5 波束方向图的主波束</figcaption>
</figure>
<details class="note primary"><summary><p>MATLAB Code</p>
</summary>
<figure class="highlight matlab"><figcaption><span>fig2_19.m</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% Figure 2.19</span></span><br><span class="line"><span class="comment">% Main lobe of beam pattern</span></span><br><span class="line"><span class="comment">% Kristine Bell</span></span><br><span class="line"><span class="comment">% Last updated 6/4/01, 10/4/01</span></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% bp_sect - plots conventional bp with sector</span></span><br><span class="line"></span><br><span class="line">clear all</span><br><span class="line"><span class="comment">% close all</span></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% Uniform Linear Array</span></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line">N = <span class="number">10</span>;                                 <span class="comment">% Elements in array</span></span><br><span class="line">d = <span class="number">0.5</span>;                                <span class="comment">% spacing wrt wavelength</span></span><br><span class="line">beamwidth = <span class="number">2</span>/(N*d);                    <span class="comment">% null-to-null (LL BW is half this)</span></span><br><span class="line">D=d*(-(N<span class="number">-1</span>)/<span class="number">2</span>:<span class="number">1</span>:(N<span class="number">-1</span>)/<span class="number">2</span>);               <span class="comment">% element locations</span></span><br><span class="line">u   = <span class="number">-0.45</span>:<span class="number">0.01</span>:<span class="number">0.45</span>;</span><br><span class="line">AS  = <span class="built_in">exp</span>(<span class="number">-1</span><span class="built_in">i</span>*<span class="number">2</span>*<span class="built_in">pi</span>*D'*<span class="number">0</span>);               <span class="comment">% BP points to 0</span></span><br><span class="line">Au  = <span class="built_in">exp</span>(<span class="number">-1</span><span class="built_in">i</span>*<span class="number">2</span>*<span class="built_in">pi</span>*D'*u);</span><br><span class="line">B   = <span class="built_in">real</span>(AS'*Au)/N;                   <span class="comment">% BP</span></span><br><span class="line"></span><br><span class="line">h=<span class="built_in">plot</span>(u,B,<span class="string">'-'</span>);</span><br><span class="line">set(h,<span class="string">'LineWidth'</span>,<span class="number">1.5</span>)</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="comment">% HPBW</span></span><br><span class="line">I=<span class="built_in">find</span>(B&gt;=<span class="number">0.707</span>);</span><br><span class="line"><span class="built_in">plot</span>([u(<span class="built_in">min</span>(I)<span class="number">-1</span>) u(<span class="built_in">max</span>(I)+<span class="number">1</span>)],[B(<span class="built_in">min</span>(I)<span class="number">-1</span>) B(<span class="built_in">max</span>(I)+<span class="number">1</span>)],<span class="string">'-'</span>)</span><br><span class="line"><span class="built_in">plot</span>(u(<span class="built_in">min</span>(I)<span class="number">-1</span>)*[<span class="number">1</span> <span class="number">1</span>],B(<span class="built_in">min</span>(I)<span class="number">-1</span>)*[<span class="number">1</span> <span class="number">1</span>]+<span class="number">0.03</span>*[<span class="number">-1</span> <span class="number">1</span>],<span class="string">'-'</span>)</span><br><span class="line"><span class="built_in">plot</span>(u(<span class="built_in">max</span>(I)+<span class="number">1</span>)*[<span class="number">1</span> <span class="number">1</span>],B(<span class="built_in">max</span>(I)+<span class="number">1</span>)*[<span class="number">1</span> <span class="number">1</span>]+<span class="number">0.03</span>*[<span class="number">-1</span> <span class="number">1</span>],<span class="string">'-'</span>)</span><br><span class="line"><span class="built_in">plot</span>([<span class="number">0.03</span> <span class="number">0.13</span>],[<span class="number">0.72</span> <span class="number">0.845</span>],<span class="string">'-'</span>)</span><br><span class="line">text(<span class="number">0.155</span>,<span class="number">0.84</span>,<span class="string">'$\Delta u_1 = $HPBW'</span>,<span class="string">'Interpreter'</span>,<span class="string">'latex'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% BW-NN</span></span><br><span class="line"><span class="built_in">plot</span>([<span class="number">-0.2</span> <span class="number">0.2</span>],[<span class="number">-0.3</span> <span class="number">-0.3</span>],<span class="string">'-'</span>)</span><br><span class="line"><span class="built_in">plot</span>(<span class="number">-0.2</span>*[<span class="number">1</span> <span class="number">1</span>],<span class="number">-0.3</span>*[<span class="number">1</span> <span class="number">1</span>]+<span class="number">0.03</span>*[<span class="number">-1</span> <span class="number">1</span>],<span class="string">'-'</span>)</span><br><span class="line"><span class="built_in">plot</span>(<span class="number">0.2</span>*[<span class="number">1</span> <span class="number">1</span>],<span class="number">-0.3</span>*[<span class="number">1</span> <span class="number">1</span>]+<span class="number">0.03</span>*[<span class="number">-1</span> <span class="number">1</span>],<span class="string">'-'</span>)</span><br><span class="line">text(<span class="number">-0.05</span>,<span class="number">-0.35</span>,<span class="string">'$\Delta u_2 = BW_{NN}$'</span>,<span class="string">'Interpreter'</span>,<span class="string">'latex'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% axes</span></span><br><span class="line"><span class="built_in">plot</span>([<span class="number">-1</span> <span class="number">1</span> ],[<span class="number">0</span> <span class="number">0</span>],<span class="string">'-'</span>)</span><br><span class="line"><span class="built_in">plot</span>([<span class="number">0</span> <span class="number">0</span>],[<span class="number">-0</span> <span class="number">1.1</span>],<span class="string">'-'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% tick marks</span></span><br><span class="line"><span class="built_in">plot</span>(<span class="number">-0.4</span>*[<span class="number">1</span> <span class="number">1</span>],<span class="number">0.03</span>*[<span class="number">-1</span> <span class="number">1</span>])</span><br><span class="line"><span class="built_in">plot</span>(<span class="number">-0.2</span>*[<span class="number">1</span> <span class="number">1</span>],<span class="number">0.03</span>*[<span class="number">-1</span> <span class="number">1</span>])</span><br><span class="line"><span class="built_in">plot</span>(<span class="number">0.2</span>*[<span class="number">1</span> <span class="number">1</span>],<span class="number">0.03</span>*[<span class="number">-1</span> <span class="number">1</span>])</span><br><span class="line"><span class="built_in">plot</span>(<span class="number">0.4</span>*[<span class="number">1</span> <span class="number">1</span>],<span class="number">0.03</span>*[<span class="number">-1</span> <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">yy = <span class="number">-0.1</span>;</span><br><span class="line"><span class="comment">%tick labels</span></span><br><span class="line">text(<span class="number">-0.45</span>,yy,<span class="string">'$-2\frac{\lambda}{ND}$'</span>,<span class="string">'Interpreter'</span>,<span class="string">'latex'</span>);</span><br><span class="line">text(<span class="number">-0.21</span>,yy,<span class="string">'$-\frac{\lambda}{ND}$'</span>,<span class="string">'Interpreter'</span>,<span class="string">'latex'</span>);</span><br><span class="line">text(<span class="number">-0.005</span>,yy,<span class="string">'0'</span>,<span class="string">'Interpreter'</span>,<span class="string">'latex'</span>);</span><br><span class="line">text(<span class="number">0.18</span>,yy,<span class="string">'$\frac{\lambda}{ND}$'</span>,<span class="string">'Interpreter'</span>,<span class="string">'latex'</span>);</span><br><span class="line">text(<span class="number">0.38</span>,yy,<span class="string">'$2\frac{\lambda}{ND}$'</span>,<span class="string">'Interpreter'</span>,<span class="string">'latex'</span>);</span><br><span class="line"></span><br><span class="line">text(<span class="number">0.01</span>,<span class="number">1.1</span>,<span class="string">'$B(u)$'</span>,<span class="string">'Interpreter'</span>,<span class="string">'latex'</span>)</span><br><span class="line"><span class="built_in">hold</span> off</span><br><span class="line">axis([<span class="number">-0.42</span> <span class="number">0.42</span> <span class="number">-0.4</span> <span class="number">1.2</span>])</span><br><span class="line"></span><br><span class="line">set(gca,<span class="string">'Visible'</span>,<span class="string">'off'</span>)</span><br></pre></td></tr></tbody></table></figure>

</details>
<p>  3dB 波束宽度是波束宽度的一个度量。定义为对应 <span class="math inline">\(\left| B_u(u) \right|^2 = 0.5\)</span> 或 <span class="math inline">\(\left| B_u(u) \right| = 1/\sqrt{2}\)</span>
的点。可以通过令波束方向图 <span class="math inline">\(B_u(u)\)</span>（式 <span class="math inline">\(\eqref{BeamPatternOfUWLAInDirectionCosineDomain}\)</span>）等于
<span class="math inline">\(1/\sqrt{2}\)</span>，来求出 <span class="math inline">\(u\)</span> 空间的半功率点。对于 <span class="math inline">\(N\geqslant
10\)</span>，通过解下面的方程可以得到一个很好的近似：</p>
<p><span class="math display">\[\begin{equation}
  \frac{\pi N d}{\lambda} u = 1.4
\end{equation}\]</span></p>
<p>即有</p>
<p><a id="ApproximationOfHPBW"></a></p>
<p><span class="math display">\[\begin{equation}
\label{ApproximationOfHPBW}
\Delta u_1 = 0.891 \frac{\lambda}{N d}
\end{equation}\]</span></p>
<p>我们把这个间隔称为<strong><mark class="label primary">半功率波束宽度（half-power beamwidth，HPBW）</mark></strong>。当 <span class="math inline">\(N\)</span> 增加时，式 <span class="math inline">\(\eqref{ApproximationOfHPBW}\)</span>
中的常系数会稍稍减小。对于 <span class="math inline">\(N &gt;
30\)</span>，<span class="math inline">\(0.886 \lambda/Nd\)</span>
是一个更好的近似表达式。</p>
<p>  <a href="#table.1-3-1">表 1-3-1</a> 中列出了不同空间内 HPBW
的表达式。</p>
<p><a id="table.1-3-1"></a></p>
<center>
<font color="#999">表 1-3-1 各个空间的半功率波束宽度</font>
</center>
<table>
<colgroup>
<col style="width: 20%">
<col style="width: 40%">
<col style="width: 40%">
</colgroup>
<thead>
<tr>
<th style="text-align: center;">空间</th>
<th style="text-align: center;">任意 <span class="math inline">\(d\)</span></th>
<th style="text-align: center;"><span class="math inline">\(d=\lambda/2\)</span></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><span class="math inline">\(u\)</span></td>
<td style="text-align: center;"><span class="math inline">\(0.891
\frac{\lambda}{Nd}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(1.782
\frac{1}{N}\)</span></td>
</tr>
<tr>
<td style="text-align: center;"><span class="math inline">\(\bar{\theta}\)</span> <a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></td>
<td style="text-align: center;"><span class="math inline">\(2\sin^{-1}
\left( 0.446 \frac{\lambda}{Nd} \right)\)</span></td>
<td style="text-align: center;"><span class="math inline">\(2\sin^{-1}
\left( 0.891 \frac{1}{N} \right)\)</span></td>
</tr>
<tr>
<td style="text-align: center;">较小的 <span class="math inline">\(\bar{\theta}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\simeq 0.891
\frac{\lambda}{Nd}\)</span> radians <br> <span class="math inline">\(\simeq 51.05 \frac{\lambda}{Nd}\)</span>
degrees</td>
<td style="text-align: center;"><span class="math inline">\(\simeq 1.782
\frac{1}{N}\)</span> radians <br> <span class="math inline">\(\simeq
102.1 \frac{1}{N}\)</span> degrees</td>
</tr>
<tr>
<td style="text-align: center;"><span class="math inline">\(\psi\)</span></td>
<td style="text-align: center;"><span class="math inline">\(0.891
\frac{2\pi}{N}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(0.891
\frac{2\pi}{N}\)</span></td>
</tr>
<tr>
<td style="text-align: center;"><span class="math inline">\(k_z\)</span></td>
<td style="text-align: center;"><span class="math inline">\(0.891
\frac{2\pi}{dN}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(1.782
\frac{2\pi}{\lambda N}\)</span></td>
</tr>
</tbody>
</table>
<h2 id="第一零点波束宽度">第一零点波束宽度</h2>
<p>  方向图的零点出现在当波束方向图 <span class="math inline">\(B_u(u)\)</span>（式 <span class="math inline">\(\eqref{BeamPatternOfUWLAInDirectionCosineDomain}\)</span>）的分子为零而分母不为零时，即</p>
<p><span class="math display">\[\begin{equation}
  \sin \left( \frac{\pi N d}{\lambda} u \right) = 0
\end{equation}\]</span></p>
<p>成立的条件为</p>
<p><span class="math display">\[\begin{equation}
  \frac{\pi N d}{\lambda} u = m\pi, \quad m = 1,2,\cdots
\end{equation}\]</span></p>
<p>则出现零点需要满足下面的两个条件：</p>
<p><span class="math display">\[\begin{equation}
  u = m \frac{\lambda}{Nd}, \quad m = 1,2,\cdots
\end{equation}\]</span></p>
<p>且</p>
<p><span class="math display">\[\begin{equation}
  u \ne m \frac{\lambda}{d}, \quad m = 1,2,\cdots
\end{equation}\]</span></p>
<p>则第一个零点的位置为 <span class="math inline">\(\lambda/Nd\)</span>，即有</p>
<p><span class="math display">\[\begin{equation}
  \Delta u_2 = 2 \frac{\lambda}{Nd}
\end{equation}\]</span></p>
<p>我们把 <span class="math inline">\(\Delta u_2\)</span>
称为零点-零点波束宽度（null-to-null beamwidth），用 <span class="math inline">\(BW_{NN}\)</span> 表示。 <span class="math inline">\(BW_{NN}\)</span> 的一半是到第一零点的距离 (<span class="math inline">\(0.5 BW_{NN}\)</span>)
。这个量能够衡量阵列分辨两个不同平面波的能力，也称为<mark class="label primary">瑞利限（Rayleigh resolution limit）</mark>。如果第二个波束方向图的峰值在第一个波束方向图的第一零点之外（间隔
<span class="math inline">\(\geqslant \Delta u_2 /
2\)</span>），则认为这两个平面波是可以分辨的。在后面，我们将研究一个阵列的分辨能力的统计性度量。</p>
<div class="note warning"><p>注意到线阵在方位角方向（<span class="math inline">\(\varphi\)</span>）没有分辨能力，因为该阵列在 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span>
方向上没有扩展。我们将在后面详细讨论分辨率的问题。</p>
</div>
<p>  <a href="#table.1-3-2">表 1-3-2</a>中列出了在各个不同空间表示出的
<span class="math inline">\(BW_{NN}\)</span>。</p>
<p><a id="table.1-3-2"></a></p>
<center>
<font color="#999">表 1-3-2 各个空间的第一零点波束宽度</font>
</center>
<table>
<colgroup>
<col style="width: 20%">
<col style="width: 40%">
<col style="width: 40%">
</colgroup>
<thead>
<tr>
<th style="text-align: center;">空间</th>
<th style="text-align: center;">任意 <span class="math inline">\(d\)</span></th>
<th style="text-align: center;"><span class="math inline">\(d=\lambda/2\)</span></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><span class="math inline">\(u\)</span></td>
<td style="text-align: center;"><span class="math inline">\(2
\frac{\lambda}{Nd}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\frac{4}{N}\)</span></td>
</tr>
<tr>
<td style="text-align: center;"><span class="math inline">\(\bar{\theta}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(2\sin^{-1}
\left( \frac{\lambda}{Nd} \right)\)</span></td>
<td style="text-align: center;"><span class="math inline">\(2\sin^{-1}
\left( \frac{2}{N} \right)\)</span></td>
</tr>
<tr>
<td style="text-align: center;">较小的 <span class="math inline">\(\bar{\theta}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\simeq 2
\frac{\lambda}{Nd}\)</span> radians</td>
<td style="text-align: center;"><span class="math inline">\(\simeq
\frac{4}{N}\)</span> radians</td>
</tr>
<tr>
<td style="text-align: center;"><span class="math inline">\(\psi\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\frac{4\pi}{N}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\frac{4\pi}{N}\)</span></td>
</tr>
<tr>
<td style="text-align: center;"><span class="math inline">\(k_z\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\frac{4\pi}{dN}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\frac{8\pi}{\lambda N}\)</span></td>
</tr>
</tbody>
</table>
<h2 id="旁瓣的位置及其衰减速率">旁瓣的位置及其衰减速率</h2>
<p>  旁瓣极大值的位置出现在当波束方向图 <span class="math inline">\(B_\psi(\psi)\)</span>（式 <span class="math inline">\(\eqref{BeamPatternOfUWLAInWaveNumberDomain}\)</span>）中的分子逼近极大值的时候：</p>
<p><span class="math display">\[\begin{equation}
  \sin \left( \frac{N \psi}{2} \right) = 1
\end{equation}\]</span></p>
<p>则此时有</p>
<p><span class="math display">\[\begin{equation}
  \frac{N \psi}{2} = \pm \left( 2m+1 \right)\frac{\pi}{2}, \quad m =
1,2,\cdots
\end{equation}\]</span></p>
<p>也即在 <span class="math inline">\(\psi\)</span> 空间有</p>
<p><span class="math display">\[\begin{equation}
  \psi = \pm \frac{2m+1}{N}\pi
\end{equation}\]</span></p>
<p>也即在 <span class="math inline">\(u\)</span> 空间有</p>
<p><span class="math display">\[\begin{equation}
  u = \pm \frac{2m+1}{N}\frac{\lambda}{2d}
\end{equation}\]</span></p>
<p>则第一旁瓣的峰值出现在</p>
<p><span class="math display">\[\begin{equation}
  \psi = \pm \frac{2\pi}{N}
\end{equation}\]</span></p>
<p>由于在极大值时，波束方向图 <span class="math inline">\(B_\psi(\psi)\)</span>（式 <span class="math inline">\(\eqref{BeamPatternOfUWLAInWaveNumberDomain}\)</span>）中的分子趋近为
1，因此极大值为</p>
<p><span class="math display">\[\begin{equation}
  B_\psi \left( \pm \frac{3\pi}{N} \right) \approx \frac{1}{N \sin
\left( \frac{3\pi}{2N} \right)}
\end{equation}\]</span></p>
<p>对于较大的 <span class="math inline">\(N\)</span>，这个表达式可以进一步近似为</p>
<p><span class="math display">\[\begin{equation}
  B_\psi \left( \pm \frac{3\pi}{N} \right) \approx \frac{3}{2\pi}
\end{equation}\]</span></p>
<p>计算得 -13.5dB。</p>
<div class="note warning"><p>这意味着一个信号如果在这个旁瓣的位置入射，且比位置在 <span class="math inline">\(k_z = 0\)</span> 的信号大
13.5dB，则这两个信号将产生相同的响应。主要的旁瓣出现在 <span class="math inline">\(k_z = \pm(2m + 1)
\pi/Nd\)</span>，旁瓣的水平衰减速率为 <span class="math inline">\(1/(2m
+ 1)\)</span>。例如，第二旁瓣的高度为
-17.9dB。在实际中，这种旁瓣水平的分辨能力是不能被接受的，所以很少使用均匀加权。旁瓣控制在确定性阵列和自适应阵列设计中都是特别重要的问题。</p>
</div>
<h2 id="栅瓣grating-lobes">栅瓣（Grating lobes）</h2>
<p><a id="fig.1-3-6"></a></p>
<figure>
<img data-src="../images/post/2023-04-20-josh-oap-part-1-3/2023-04-20-josh-oap-part-1-3-060-%20EffectOfElementSpacingOnBeamPattern.svg" width="1000" alt="图 1-3-6 阵元间距对波束方向图的影响：(a) d=\lambda/4；(b) d=\lambda/2；(c) d=\lambda">
<figcaption aria-hidden="true">图 1-3-6 阵元间距对波束方向图的影响：(a)
<span class="math inline">\(d=\lambda/4\)</span>；(b) <span class="math inline">\(d=\lambda/2\)</span>；(c) <span class="math inline">\(d=\lambda\)</span></figcaption>
</figure>
<details class="note primary"><summary><p>MATLAB Code</p>
</summary>
<figure class="highlight matlab"><figcaption><span>fig2_20.m</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% Figure 2.20</span></span><br><span class="line"><span class="comment">% Effect of element spacing on beam pattern</span></span><br><span class="line"><span class="comment">% Xin Zhang</span></span><br><span class="line"><span class="comment">% Lillian Xu updated 09/2000</span></span><br><span class="line"><span class="comment">% updated by K. Bell 7/22/2001, 10/4/01</span></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"></span><br><span class="line">clear all</span><br><span class="line">close all</span><br><span class="line"></span><br><span class="line">N = <span class="number">10</span>;</span><br><span class="line">n = (-(N<span class="number">-1</span>)/<span class="number">2</span>:(N<span class="number">-1</span>)/<span class="number">2</span>).';</span><br><span class="line"><span class="built_in">psi</span> = <span class="built_in">pi</span>*(<span class="number">-3</span>:<span class="number">0.001</span>:<span class="number">3</span>);</span><br><span class="line">w = <span class="number">1</span>/N*[<span class="built_in">ones</span>(N,<span class="number">1</span>)];</span><br><span class="line">d = [<span class="number">1</span>/<span class="number">4</span> <span class="number">1</span>/<span class="number">2</span> <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line"><span class="keyword">for</span> k =<span class="number">1</span>:<span class="built_in">length</span>(d)</span><br><span class="line">  vv = <span class="built_in">exp</span>(<span class="number">1</span><span class="built_in">i</span>*<span class="number">2</span>*d(k)*n*<span class="built_in">psi</span>);</span><br><span class="line">  B(k,:) = <span class="number">20</span>*<span class="built_in">log10</span>(<span class="built_in">abs</span>(w'*vv));</span><br><span class="line">  subplot(<span class="number">3</span>,<span class="number">1</span>,k)</span><br><span class="line">  <span class="built_in">plot</span>(<span class="built_in">psi</span>/<span class="built_in">pi</span>,B(k,:));</span><br><span class="line">  <span class="built_in">hold</span> on</span><br><span class="line">  <span class="built_in">plot</span>([<span class="number">-1</span> <span class="number">-1</span>],[<span class="number">-25</span> <span class="number">0</span>],<span class="string">'--'</span>);</span><br><span class="line">  <span class="built_in">plot</span>([<span class="number">1</span> <span class="number">1</span>],[<span class="number">-25</span> <span class="number">0</span>],<span class="string">'--'</span>);</span><br><span class="line">  axis([<span class="number">-3</span> <span class="number">3</span> <span class="number">-25</span> <span class="number">5</span>])</span><br><span class="line">  set(gca,<span class="string">'YTick'</span>,[<span class="number">-25</span> <span class="number">-20</span> <span class="number">-15</span> <span class="number">-10</span> <span class="number">-5</span> <span class="number">0</span>])</span><br><span class="line">  grid on</span><br><span class="line">  xlabel(<span class="string">'$u$'</span>,<span class="string">'Interpreter'</span>,<span class="string">'latex'</span>)</span><br><span class="line">  <span class="keyword">if</span> k == <span class="number">1</span></span><br><span class="line">    <span class="built_in">plot</span>([<span class="number">-1</span> <span class="number">1</span>],[<span class="number">2.5</span> <span class="number">2.5</span>])</span><br><span class="line">    <span class="built_in">plot</span>([<span class="number">-1</span> <span class="number">-0.9</span>],[<span class="number">2.5</span> <span class="number">0.5</span>])</span><br><span class="line">    <span class="built_in">plot</span>([<span class="number">-1</span> <span class="number">-0.9</span>],[<span class="number">2.5</span> <span class="number">4.5</span>])</span><br><span class="line">    <span class="built_in">plot</span>([<span class="number">0.9</span> <span class="number">1</span>],[<span class="number">0.5</span> <span class="number">2.5</span>])</span><br><span class="line">    <span class="built_in">plot</span>([<span class="number">0.9</span> <span class="number">1</span>],[<span class="number">4.5</span> <span class="number">2.5</span>])</span><br><span class="line">    text(<span class="number">-0.4</span>,<span class="number">7</span>,<span class="string">'Visible region'</span>)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="built_in">hold</span> off</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">set(gcf,<span class="string">'Position'</span>,[<span class="number">0</span> <span class="number">0</span> <span class="number">800</span> <span class="number">600</span>])</span><br></pre></td></tr></tbody></table></figure>

</details>
<p>  在<a href="#fig.1-3-6">图 1-3-6</a> 中，针对多种 <span class="math inline">\(d/\lambda\)</span> 的值，画出了 <span class="math inline">\(\left| \boldsymbol{\varUpsilon}_u(u)
\right|\)</span>。图中说明了“栅瓣”这个重要的概念，即和主波束一样高的波瓣。栅瓣发生在当波束方向图
<span class="math inline">\(B_\psi(\psi)\)</span>（式 <span class="math inline">\(\eqref{BeamPatternOfUWLAInWaveNumberDomain}\)</span>）中的分子和分母均为零的时候。栅瓣出现的间隔为</p>
<p><span class="math display">\[\begin{equation}
  \frac{\psi}{2} = m \cdot \pi
\end{equation}\]</span></p>
<p>也即</p>
<p><span class="math display">\[\begin{equation}
  \psi = m \cdot 2 \pi
\end{equation}\]</span></p>
<p>也即</p>
<p><span class="math display">\[\begin{equation}
  u = m \cdot \frac{\lambda}{d}
\end{equation}\]</span></p>
<p>  如果阵列的间距大于 <span class="math inline">\(\lambda\)</span>，则栅瓣的峰值出现在信号传播区域以内，即在
<span class="math inline">\(\left| u \right| \leqslant 1\)</span>
的区域以内。这里就会出现峰值响应模糊的问题，只有当我们对信号的入射方向有先验信息的时候，才可能解决这个问题。</p>
<p>  下一节将讨论阵列调向的问题，阵列调向使得在 <span class="math inline">\(u\)</span> 空间的频率-波数响应函数 <span class="math inline">\(\left| \boldsymbol{\varUpsilon}_u(u)
\right|\)</span>
发生平移，这种平移导致栅瓣进入了可视区域以内。我们发现，如果阵列需要的调向范围为
<span class="math inline">\(0^\circ \leqslant \theta \leqslant
180^\circ\)</span> 则需要</p>
<p><span class="math display">\[\begin{equation}
  \frac{d}{\lambda} \leqslant \frac{1}{2}
\end{equation}\]</span></p>
<p>也即</p>
<p><span class="math display">\[\begin{equation}
  \lambda \leqslant \frac{\lambda}{2}
\end{equation}\]</span></p>
<p>  通常，我们考虑满足 <span class="math inline">\(d \leqslant
\lambda/2\)</span> 的阵列，并假设需要在整个球内进行调向。我们把满足
<span class="math inline">\(d = \lambda/2\)</span>
的均匀线阵称为<strong><mark class="label primary">标准线阵（standard linear array）</mark></strong>。</p>
<div class="note info"><p>在时间序列分析中，当对时域波形欠采样时，会出现混迭问题。栅瓣的问题和时域混迭问题是等同的。</p>
</div>
<h1 id="参考文献">参考文献</h1>
<ol type="1">
<li>Harry L. Van Trees. <em>Optimum array processing: Part IV of
detection, estimation, and modulation theory.</em> New York, NY, USA:
John Wiley &amp; Sons, 2002.</li>
<li>Harry L. Van Trees, 汤俊. <em>最优阵列处理技术.</em>
北京：清华大学出版社. 2008.</li>
</ol>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr>
<ol>
<li id="fn1"><p>侧射角（broadside angle）的定义为 <span class="math inline">\(\bar{\theta} = \pi/2 - \theta\)</span><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/css/markmap.css">

<script src="/js/markmap.js"></script>
]]></content>
      <categories>
        <category>Josh 的学习笔记</category>
        <category>最优阵列处理</category>
        <category>阵列和空域滤波器</category>
      </categories>
      <tags>
        <tag>阵列信号处理</tag>
        <tag>均匀加权线阵</tag>
        <tag>3dB 带宽</tag>
        <tag>第一零点波束宽度</tag>
        <tag>旁瓣</tag>
        <tag>栅瓣</tag>
        <tag>瑞利限</tag>
      </tags>
  </entry>
  <entry>
    <title>Josh&#39;s Note — 最优阵列处理&lt;br&gt;Part 1.2 均匀线阵模型</title>
    <url>/posts/de20fd09.html</url>
    <content><![CDATA[<h1 id="均匀线阵的基本模型">均匀线阵的基本模型</h1>
<p>  <strong><mark class="label primary">均匀线性阵列（uniform linear array, ULA）</mark></strong>如<a href="#fig.1-2-1">图 1-2-1</a>
所示，其中有 <span class="math inline">\(N\)</span> 个位于 <span class="math inline">\(z\)</span> 轴上的阵元，阵元间距均匀，记为 <span class="math inline">\(d\)</span>；这里将阵列的中心放在了坐标系的原点上，这种放置方法可以简化计算量。</p>
<p><a id="fig.1-2-1"></a></p>
<figure>
<img data-src="../images/post/2023-04-20-josh-oap-part-1-2/2023-04-20-josh-oap-part-1-2-010-LinearArrayAlongZAaxis.png" width="600" alt="图 1-2-1 放置在 z 轴上的线阵">
<figcaption aria-hidden="true">图 1-2-1 放置在 <span class="math inline">\(z\)</span> 轴上的线阵</figcaption>
</figure>
<span id="more"></span>
<p>  如<a href="#fig.1-2-1">图 1-2-1</a>，阵元的位置为</p>
<p><span class="math display">\[\begin{equation} \label{ElementLocation}
\begin{cases}
  p_{x_n} = 0 \\
  p_{y_n} = 0 \\
  p_{z_n} = \left( n - \frac{N-1}{2} \right) d
\end{cases}
  , \, n = 0,1,\cdots,N-1
\end{equation}\]</span></p>
<p>为了确定阵列流形矢量 <span class="math inline">\(\boldsymbol{v}_{\boldsymbol{k}}\left(\boldsymbol{k}\right)\)</span>，把式
<span class="math inline">\(\eqref{ElementLocation}\)</span> 代入到<a href="https://josh-gao.top/posts/8b61f5a7.html#DefinitionOfArrayManifoldVector">阵列流形矢量的定义</a>中，得到</p>
<p><span class="math display">\[\begin{equation}
\label{ManifoldVectorOfULA}
  \boldsymbol{v}_{\boldsymbol{k}}\left(k_z\right) =
\left[\begin{array}{c}
    e^{j \left( \frac{N-1}{2} \right) k_z d} \\
    e^{j \left( \frac{N-1}{2} - 1\right) k_z d} \\
    \vdots \\
    e^{-j \left( \frac{N-1}{2} \right) k_z d} \\
  \end{array}\right]
\end{equation}\]</span></p>
<p>这里</p>
<p><span class="math display">\[\begin{equation}
  k_z = -\frac{2\pi}{\lambda}\cos\theta = -k_0 \cos\theta
\end{equation}\]</span></p>
<p>其中波数的幅度</p>
<p><span class="math display">\[\begin{equation}
  k_0 \triangleq \left| \boldsymbol{k} \right| = \frac{2\pi}{\lambda}
\end{equation}\]</span></p>
<p>注意，线阵在 <span class="math inline">\(\varphi\)</span>
方向是没有分辨能力的。将<a href="https://josh-gao.top/posts/8b61f5a7.html#ComplexWeightVector">复权矢量</a>和式
<span class="math inline">\(\eqref{ManifoldVectorOfULA}\)</span> 代入<a href="https://josh-gao.top/posts/8b61f5a7.html#FrequencyWavenumberResponseWithComplexWeigh">用复权矢量表示的波数-频率响应函数</a>，得到
ULA 在角度域的频率-波数响应函数</p>
<p><span class="math display">\[\begin{equation}
\label{FWRFOfULAInAngleDomain}
  \begin{aligned}
    \boldsymbol{\varUpsilon}(\omega,k_z) &amp;=
\boldsymbol{w}^\mathrm{H}\boldsymbol{v}_{\boldsymbol{k}}\left(k_z\right)
\\
    &amp;= \sum_{n=0}^{N-1} w_n^\ast e^{-j\left( n - \frac{N-1}{2}
\right) k_z d}
  \end{aligned}
\end{equation}\]</span></p>
<p>定义下面的变量也是很有用的（波数在 <span class="math inline">\(z\)</span>
轴上的投影，乘以阵元间距，也即扫过一个阵元间距时，波数的变化量在 <span class="math inline">\(z\)</span> 轴上的体现）：</p>
<p><span class="math display">\[\begin{equation}
\label{DefinitionOfWavenumberDiffOfTwoElements}
  \psi = -k_z d = \frac{2\pi}{\lambda}\cos\theta\cdot d =
\frac{2\pi}{\lambda}u_z d
\end{equation}\]</span></p>
<p>其中 <span class="math inline">\(u_z\)</span> 是方向余弦的 <span class="math inline">\(z\)</span> 方向分量，</p>
<p><span class="math display">\[\begin{equation}
  u_z = \cos\theta
\end{equation}\]</span></p>
<p>将式 <span class="math inline">\(\eqref{DefinitionOfWavenumberDiffOfTwoElements}\)</span>
代入式 <span class="math inline">\(\eqref{FWRFOfULAInAngleDomain}\)</span>，得到<strong>在
<span class="math inline">\(\psi\)</span>
空间的频率-波数函数（frequency-wavenumber function in <span class="math inline">\(\psi\)</span>-space）</strong></p>
<p><span class="math display">\[\begin{equation}  \label{FWRFOfULAInWavenumberDomain}
  \boldsymbol{\varUpsilon}_\psi(\psi) = e^{-j \frac{N-1}{2} \psi }
\sum_{n=0}^{N-1} w_n^\ast e^{j n\psi}
\end{equation}\]</span></p>
<p><span class="math inline">\(\boldsymbol{\varUpsilon}(\omega,k_z)\)</span> 和
<span class="math inline">\(\boldsymbol{\varUpsilon}_\psi(\psi)\)</span>
的定义域均为 <span class="math inline">\(-\infty\)</span> 到 <span class="math inline">\(\infty\)</span>，但仅在区域 <span class="math inline">\(0 \leqslant \theta \leqslant \pi\)</span>（或
<span class="math inline">\(-1 \leqslant u_z \leqslant 1\)</span> ）
内代表传播的信号，即有 <span class="math inline">\(-\displaystyle\frac{2\pi d}{\lambda} \leqslant
\psi \leqslant \frac{2\pi
d}{\lambda}\)</span>，这个区域称为<strong><mark class="label primary">可视区域（visible region）</mark></strong>。</p>
<p>  可以观察到，若定义</p>
<p><span class="math display">\[\begin{equation}
  z = e^{j \psi}
\end{equation}\]</span></p>
<p><span class="math display">\[\begin{equation}
\label{FWRFOfULAInZDomain}
  \boldsymbol{\varUpsilon}_z(z) = z^{- \frac{N-1}{2}} \sum_{n=0}^{N-1}
w_n^\ast z^{n}
\end{equation}\]</span></p>
<p>则式 <span class="math inline">\(\eqref{FWRFOfULAInZDomain}\)</span>
可以写成</p>
<p><span class="math display">\[\begin{equation}
  \boldsymbol{\varUpsilon}_z(z) = z^{- \frac{N-1}{2}}
\left(\sum_{n=0}^{N-1} w_n z^{-n}\right)^\ast
\end{equation}\]</span></p>
<p>其中</p>
<p><span class="math display">\[\begin{equation}
  W(z) = \sum_{n=0}^{N-1} w_n z^{-n}
\end{equation}\]</span></p>
<p>和 <span class="math inline">\(z\)</span> 变换的形式相似，且</p>
<p><span class="math display">\[\begin{equation}
\label{FWRFOfULAInZDomainToWavenumberDomain}
  \boldsymbol{\varUpsilon}_\psi(\psi) = \left.
\boldsymbol{\varUpsilon}_z(z) \right|_{z=e^{j\psi}} = \left.\left(z^{-
\frac{N-1}{2}} W^\ast(z)\right)\right|_{z=e^{j\psi}}
\end{equation}\]</span></p>
<p>是在 <span class="math inline">\(\psi\)</span>
空间的频率-波数响应。我们在后面将利用这个关系。</p>
<p>  在式 <span class="math inline">\(\eqref{FWRFOfULAInAngleDomain}\)</span> 、式 <span class="math inline">\(\eqref{FWRFOfULAInWavenumberDomain}\)</span> 和式
<span class="math inline">\(\eqref{FWRFOfULAInZDomainToWavenumberDomain}\)</span>
中用三种不同的方式写出了频率-波数函数，尽管这可能显得引入了过多的符号，但我们将发现在不同的情况下，这些不同的形式都是有用的。</p>
<p>  在 <span class="math inline">\(\theta\)</span> 和 <span class="math inline">\(u\)</span> 空间定义出阵列流形也是有用的</p>
<p><span class="math display">\[\begin{equation}
  \left[ \boldsymbol{v}_\theta(\theta) \right] = e^{j\left( n -
\frac{N-1}{2} \right) \frac{2\pi d}{\lambda} \cos \theta}, \, n =
0,\cdots, N-1
\end{equation}\]</span></p>
<p><span class="math display">\[\begin{equation}
  \left[ \boldsymbol{v}_u(u) \right] = e^{j\left( n - \frac{N-1}{2}
\right) \frac{2\pi d}{\lambda} u}, \, n = 0,\cdots, N-1
\end{equation}\]</span></p>
<p>也可以用三种形式写出波束方向图。频率-波数函数和波束方向图的关键区别是波束方向图的参量受限于实际的物理角度
<span class="math inline">\(\theta\)</span>，所以，</p>
<p><span class="math display">\[\begin{equation}
  B_\theta(\theta) = \boldsymbol{w}^\mathrm{H}
\boldsymbol{v}_\theta(\theta) = e^{-j\left(\frac{N-1}{2} \right)
\frac{2\pi d}{\lambda} \cos \theta} \sum_{n=0}^{N-1} w_n^\ast e^{j n
\frac{2\pi d}{\lambda} \cos \theta}, \, 0 \leqslant \theta \leqslant \pi
\end{equation}\]</span></p>
<p><a id="BeamPatternInDirectionCosineDomain"></a></p>
<p><span class="math display">\[\begin{equation}
  B_u(u) = \boldsymbol{w}^\mathrm{H} \boldsymbol{v}_u(u) =
e^{-j\left(\frac{N-1}{2} \right) \frac{2\pi d}{\lambda} u}
\sum_{n=0}^{N-1} w_n^\ast e^{j n \frac{2\pi d}{\lambda} u}, \, -1
\leqslant u \leqslant 1
\end{equation}\]</span></p>
<p><span class="math display">\[\begin{equation}
\label{BeamPatternInWavenumberDomain}
  B_\psi(\psi) = \boldsymbol{w}^\mathrm{H} \boldsymbol{v}_\psi(\psi) =
e^{-j\left(\frac{N-1}{2} \right) \psi} \sum_{n=0}^{N-1} w_n^\ast e^{j n
\psi}, \, -\frac{2\pi d}{\lambda} \leqslant \psi \leqslant \frac{2\pi
d}{\lambda}
\end{equation}\]</span></p>
<p>当函数的变量很清楚时，我们将省略掉 <span class="math inline">\(B(\,\cdot\,)\)</span> 中的下标。</p>
<h1 id="均匀线阵的阵列流形">均匀线阵的阵列流形</h1>
<p>  对于均匀线阵，通常用 <span class="math inline">\(\psi\)</span>
表示阵列流形</p>
<p><span class="math display">\[\begin{equation}
  \left[ \boldsymbol{v}_\psi(\psi) \right]_n = e^{j\left( n -
\frac{N-1}{2} \right)\psi}, \, n = 0, 1, \cdots, N-1
\end{equation}\]</span></p>
<p><span class="math display">\[\begin{equation}
\label{ManifoldVecOfULAWithConjugateSymmetry}
  \boxed{\boldsymbol{v}_\psi(\psi) = \left[ \begin{array}{c}
    e^{-j\left(\frac{N-1}{2} \right)\psi} &amp;
    e^{-j\left(\frac{N-3}{2} \right)\psi} &amp;
    \cdots &amp;
    e^{j\left(\frac{N-3}{2} \right)\psi} &amp;
    e^{j\left(\frac{N-1}{2} \right)\psi} &amp;
  \end{array} \right]^\mathrm{T}}
\end{equation}\]</span></p>
<p>可以看到 ULA 的阵列流形矢量具有<strong><mark class="label primary">共扼对称性（conjugate symmetry）</mark></strong>。</p>
<div class="tabs" id="阵列流形矢量具有共扼对称性"><ul class="nav-tabs"><li class="tab active"><a href="#阵列流形矢量具有共扼对称性-1">$N$ 为偶数</a></li><li class="tab"><a href="#阵列流形矢量具有共扼对称性-2">$N$ 为奇数</a></li></ul><div class="tab-content"><div class="tab-pane active" id="阵列流形矢量具有共扼对称性-1"><p>当 <span class="math inline">\(N\)</span> 为偶数时，如果定义一个
<span class="math inline">\(N/2\)</span> 维的矢量 <span class="math inline">\(\boldsymbol{v}_{\psi_1}(\psi)\)</span>，对应 <span class="math inline">\(\boldsymbol{v}_\psi(\psi)\)</span> 的前 <span class="math inline">\(N/2\)</span> 个元素，则有</p>
<p><span class="math display">\[\begin{equation}
  \boldsymbol{v}_\psi(\psi) = \left[ \begin{array}{c}
    \boldsymbol{v}_{\psi_1}(\psi) \\
    \boldsymbol{J}\boldsymbol{v}_{\psi_1}^\ast(\psi)
  \end{array} \right]
\end{equation}\]</span></p></div><div class="tab-pane" id="阵列流形矢量具有共扼对称性-2"><p>当 <span class="math inline">\(N\)</span> 为奇数时，如果定义一个
<span class="math inline">\((N-1)/2\)</span> 维的矢量 <span class="math inline">\(\boldsymbol{v}_{\psi_1}(\psi)\)</span>，对应 <span class="math inline">\(\boldsymbol{v}_\psi(\psi)\)</span> 的前 <span class="math inline">\((N-1)/2\)</span> 个元素，则有</p>
<p><span class="math display">\[\begin{equation}
  \boldsymbol{v}_\psi(\psi) = \left[ \begin{array}{c}
    \boldsymbol{v}_{\psi_1}(\psi) \\
    1 \\
    \boldsymbol{J}\boldsymbol{v}_{\psi_1}^\ast(\psi)
  \end{array} \right]
\end{equation}\]</span></p></div></div></div>
<p>其中交换矩阵（exchange matrix） <span class="math inline">\(\boldsymbol{J}\)</span></p>
<p><span class="math display">\[\begin{equation}
  \boldsymbol{J} = \left[ \begin{array}{c}
    0 &amp; 0 &amp; \cdots &amp; 1 \\
    \vdots &amp; \vdots &amp; &amp; \vdots \\
    0 &amp; 1 &amp; \cdots &amp; 0 \\
    1 &amp; 0 &amp; \cdots &amp; 0 \\
  \end{array} \right]
\end{equation}\]</span></p>
<p>在很多应用中，这种共轭对称性可以用于节省运算量和改进性能。例如，如果
<span class="math inline">\(\boldsymbol{w}\)</span> 也是共枙对称的，则当
<span class="math inline">\(N\)</span> 为偶数时，可以写成</p>
<p><span class="math display">\[\begin{equation}
\label{ConjugateSymmetry}
  \boldsymbol{w} = \left[ \begin{array}{c}
    \boldsymbol{w}_1 \\
    \boldsymbol{J}\boldsymbol{w}_1
  \end{array} \right]
\end{equation}\]</span></p>
<p>在 <span class="math inline">\(\psi\)</span> 空间的波束方向图为</p>
<p><span class="math display">\[\begin{equation}
  \begin{aligned}
    B_\psi(\psi) &amp;=
\boldsymbol{w}^\mathrm{H}\boldsymbol{v}_\psi(\psi) \\
    &amp;= \left[\begin{array}{c}\boldsymbol{w_1}^\mathrm{H} &amp;
\boldsymbol{w_1}^\mathrm{T}\boldsymbol{J}\end{array}\right]
\left[\begin{array}{c}\boldsymbol{v}_{\psi_1}(\psi) \\
\boldsymbol{J}\boldsymbol{v}_{\psi_1}^\ast(\psi)\end{array}\right] \\
    &amp;= \boldsymbol{w}_1^\mathrm{H} \boldsymbol{v}_{\psi_1}(\psi) +
\boldsymbol{w_1}^\mathrm{T}\boldsymbol{v}_{\psi_1}^\ast(\psi) \\
    &amp;= 2 \Re\left[ \boldsymbol{w}_1^\mathrm{H}
\boldsymbol{v}_{\psi_1}(\psi) \right]
  \end{aligned}
\end{equation}\]</span></p>
<p>所以波束方向图是一个实函数。注意到，实对称的权矢量同样能够满足式
<span class="math inline">\(\eqref{ConjugateSymmetry}\)</span>；当 <span class="math inline">\(N\)</span>
为奇数时，也有类似的结果。我们将发现很多其他的阵列结构也具有共枙对称性质。</p>
<p>  式 <span class="math inline">\(\eqref{ManifoldVecOfULAWithConjugateSymmetry}\)</span>
强调了 <span class="math inline">\(\boldsymbol{v}_\psi(\psi)\)</span>
的共枙对称性质。也可以把 <span class="math inline">\(\boldsymbol{v}_\psi(\psi)\)</span> 写成</p>
<p><span class="math display">\[\begin{equation}
  \boldsymbol{v}_\psi(\psi) = e^{-j\left(\frac{N-1}{2} \right)\psi}
\left[ \begin{array}{c}
    1 &amp;
    e^{j\psi} &amp;
    \cdots &amp;
    e^{j(N-1)\psi} &amp;
  \end{array} \right]^\mathrm{T}
\end{equation}\]</span></p>
<p>这个形式强调了 <span class="math inline">\(\boldsymbol{v}_\psi(\psi)\)</span> 的 Vandermonde
结构。</p>
<h1 id="从波束方向图获得权矢量">从波束方向图获得权矢量</h1>
<p>  下面讨论如何从特定的方向图 <span class="math inline">\(B_\psi(\psi)\)</span> 中获得权矢量 <span class="math inline">\(\boldsymbol{w}\)</span>，我们从式 <span class="math inline">\(\eqref{BeamPatternInWavenumberDomain}\)</span>
中的关系开始</p>
<p><span class="math display">\[\begin{equation}
\label{ShortBeamPatternInWavenumberDomain}
  B_\psi(\psi) = \boldsymbol{w}^\mathrm{H} \boldsymbol{v}_\psi(\psi)
\end{equation}\]</span></p>
<p>假设 <span class="math inline">\(B_\psi(\psi)\)</span>
是已知的，我们想确定产生这个 <span class="math inline">\(B_\psi(\psi)\)</span> 的 <span class="math inline">\(\boldsymbol{w}\)</span>。由于 <span class="math inline">\(\boldsymbol{w}^\mathrm{H}\)</span> 是一个 <span class="math inline">\(1 \times N\)</span> 维的矢量，因此如果知道 <span class="math inline">\(B_\psi(\psi)\)</span> 在 <span class="math inline">\(N\)</span> 个 <span class="math inline">\(\psi\)</span> 值上的值，就可以确定 <span class="math inline">\(\boldsymbol{w}\)</span>。</p>
<p>  对波束方向图在 <span class="math inline">\(N\)</span> 个 <span class="math inline">\(\psi_i\)</span> 上进行采样，这里要求 <span class="math inline">\(\psi_i\)</span>
必须是不同的，但不一定是等距的，记采样点处的波束方向图的值为 <span class="math inline">\(B(\psi_i)\)</span>。根据式 <span class="math inline">\(\eqref{ShortBeamPatternInWavenumberDomain}\)</span>，有</p>
<p><span class="math display">\[\begin{equation}
\label{ElementOfShortBeamPatternInWavenumberDomain}
  \boldsymbol{w}^\mathrm{H} \boldsymbol{v}(\psi_i) = B(\psi_i), \, i =
1, \cdots, N
\end{equation}\]</span></p>
<p>定义一个 <span class="math inline">\(N \times N\)</span>
维的阵列流形矩阵</p>
<p><span class="math display">\[\begin{equation}
  \boldsymbol{V}(\psi) \triangleq \left[
\begin{array}{c}\boldsymbol{v}(\psi_1) &amp; \cdots &amp;
\boldsymbol{v}(\psi_N)\end{array}\right]
\end{equation}\]</span></p>
<p>和一个 <span class="math inline">\(1 \times N\)</span>
维的波束方向图矩阵</p>
<p><span class="math display">\[\begin{equation}
  \boldsymbol{B} \triangleq \left[ \begin{array}{c}B(\psi_1) &amp;
\cdots &amp; B(\psi_N)\end{array}\right]
\end{equation}\]</span></p>
<p>则式 <span class="math inline">\(\eqref{ElementOfShortBeamPatternInWavenumberDomain}\)</span>
可以写成</p>
<p><span class="math display">\[\begin{matrix}
  \boldsymbol{w}^\mathrm{H} \boldsymbol{V}(\psi) = \boldsymbol{B}
\end{matrix}\]</span></p>
<p>或</p>
<p><span class="math display">\[\begin{matrix}
  \boldsymbol{V}^\mathrm{H}(\psi) \boldsymbol{w} =
\boldsymbol{B}^\mathrm{H}
\end{matrix}\]</span></p>
<p>由于 <span class="math inline">\(\boldsymbol{V}^\mathrm{H}(\psi)\)</span>
是满秩的，所以</p>
<p><span class="math display">\[\begin{equation}
\label{WeightVecCalculation}
  \boxed{\boldsymbol{w} = \left[ \boldsymbol{V}^\mathrm{H}(\psi)
\right]^{-1}\boldsymbol{B}^\mathrm{H}}
\end{equation}\]</span></p>
<p>尽管 <span class="math inline">\(\psi_i\)</span>
可以任意选择，但如果它们相距太近，那么阵列流形矢量将接近于线性相关，在式
<span class="math inline">\(\eqref{WeightVecCalculation}\)</span>
中的求逆可能会有数值计算的问题。如果采用均匀间距 <span class="math inline">\(2\pi/N\)</span>，那么后续将会推导一个高效的权值计算算法。</p>
<p>  我们特别感兴趣的一种情况是已经定义了波束方向图的 <span class="math inline">\(N — 1\)</span>
个零点。如果假设阵列的指向为正侧向（broadside，即阵列排布方向和信号来向垂直），令</p>
<p><span class="math display">\[\begin{equation}
  \psi_1 = 0
\end{equation}\]</span></p>
<p>且 <span class="math inline">\(\psi_2, \psi_3, \cdots,
\psi_N\)</span>
对应于零点的位置。假设期望方向的信号无失真通过，其他方向的信号全部抑制，则预期的归一化波束方向图为：</p>
<p><span class="math display">\[\begin{matrix}
  \boldsymbol{B} = \left[ \begin{array}{c} 1 &amp; 0 &amp; \cdots &amp;
0 \end{array} \right] = \boldsymbol{e}_1^\mathrm{T}
\end{matrix}\]</span></p>
<p>则式 <span class="math inline">\(\eqref{WeightVecCalculation}\)</span> 简化为</p>
<p><span class="math display">\[\begin{equation}
\label{WeightVecCalculationWithAllZeroExceptMainAxis}
  \boxed{\boldsymbol{w} = \left[ \boldsymbol{V}^\mathrm{H}(\psi)
\right]^{-1}\boldsymbol{e}_1}
\end{equation}\]</span></p>
<p>后续将发现这些算法是非常有用的。</p>
<p>在式 <span class="math inline">\(\eqref{WeightVecCalculation}\)</span> 和式 <span class="math inline">\(\eqref{WeightVecCalculationWithAllZeroExceptMainAxis}\)</span>
中有两点需要强调：</p>
<ol type="1">
<li><p>上述讨论已经假设 <span class="math inline">\(B_\psi(\psi)\)</span> 在式 <span class="math inline">\(\eqref{ShortBeamPatternInWavenumberDomain}\)</span>
中进行了定义，是由一个 <span class="math inline">\(N \times 1\)</span>
维复矢量 <span class="math inline">\(\boldsymbol{w}\)</span>
产生的。如果 <span class="math inline">\(B_\psi(\psi)\)</span>
是任意函数，且使用式 <span class="math inline">\(\eqref{WeightVecCalculation}\)</span>，那么将产生一个方向图，和
<span class="math inline">\(B(\psi_i), i = 1,\cdots,N\)</span>
相匹配，但不一定和函数 <span class="math inline">\(B_\psi(\psi)\)</span>
相匹配。</p></li>
<li><p>我们是在一个均匀线阵的背景下介绍这个结果的。但是，这个推导过程适用于任意结构的
<span class="math inline">\(N\)</span> 阵元阵列。</p></li>
</ol>
<p>我们已经推导了阵列流形矢量、权值矢量和波束方向图之间的基本关系。下一节将考虑均匀加权的特殊情况。</p>
<h1 id="参考文献">参考文献</h1>
<ol type="1">
<li>Harry L. Van Trees. <em>Optimum array processing: Part IV of
detection, estimation, and modulation theory.</em> New York, NY, USA:
John Wiley &amp; Sons, 2002.</li>
<li>Harry L. Van Trees, 汤俊. <em>最优阵列处理技术.</em>
北京：清华大学出版社. 2008.</li>
</ol>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/css/markmap.css">

<script src="/js/markmap.js"></script>
]]></content>
      <categories>
        <category>Josh 的学习笔记</category>
        <category>最优阵列处理</category>
        <category>阵列和空域滤波器</category>
      </categories>
      <tags>
        <tag>阵列信号处理</tag>
        <tag>均匀线阵</tag>
        <tag>ULA</tag>
        <tag>可视区域</tag>
      </tags>
  </entry>
  <entry>
    <title>Josh&#39;s Note — 最优阵列处理&lt;br&gt;Part 1.4 阵列调向</title>
    <url>/posts/c2604c43.html</url>
    <content><![CDATA[<p>  <a href="https://josh-gao.top/posts/8b61f5a7.html">1.1 节</a>、<a href="https://josh-gao.top/posts/de20fd09.html">1.2 节</a>和 <a href="https://josh-gao.top/posts/aa32ec76.html">1.3
节</a>已经考虑了最大响应在正侧向（broadside），即 <span class="math inline">\(k_z=0\)</span>
的阵列。在大多数应用中，我们希望能够把最大响应放置到，或者说调向（steer）到任意一个波数位置或方向上。有两种方法可以实现这个目标。直接的方法是改变传感器的位置，使得阵列的轴线和目标方向之间是垂直的，称为机械调向（mechanical
steering）。当一个天线在物理上是可旋转的时候，我们可以采取这种方法，如雷达系统中抛物面孔径。通常机械调向的实现有很大的困难，原因可能是当处理长波长信号时所需阵列的物理维度较大，也可能是当传感器被移动时需要进行重新校准。</p>
<p>  另外一个方法是引入时间延时（或在窄带的情况下，引入相移）来实现对一个阵列的<strong><mark class="label primary">主响应轴 (main response axis，MRA)</mark></strong>进行调向。随着高速信号处理器的发展，电子调向（electronic
steering）技术正在被更广泛地应用在阵列处理中，其不仅仅突破了机械调向的限制，还具有迅速改变响应函数的灵活能力。此外，在有些阵列中，在一个方向上采用机械调向，在其他的方向上采用电子调向。</p>
<p>  本文首先考虑任意结构阵列，然后讨论均匀加权阵列的结果。</p>
<span id="more"></span>
<h1 id="任意结构阵列的调向">任意结构阵列的调向</h1>
<p><a id="fig.1-4-1"></a></p>
<figure>
<img data-src="../images/post/2023-04-22-josh-oap-part-1-4/2023-04-22-josh-oap-part-1-4-010-ArraySteeringWithDelays.png" width="700" alt="图 1-4-1 利用延时实现阵列调向">
<figcaption aria-hidden="true">图 1-4-1
利用延时实现阵列调向</figcaption>
</figure>
<p>  <a href="https://josh-gao.top/posts/de20fd09.html">1.2
节</a>开头的简单例子说明了把阵列调向某个特定方向的主要思想，调向在波数空间的影响是很直接的。考虑<a href="#fig.1-4-1">图 1-4-1</a> 中的处理器，输入到调向环节的基函数为</p>
<p><span class="math display">\[\begin{equation}
  f\left( t, \boldsymbol{p}\right) = e^{j\omega t}
\boldsymbol{v}_{\boldsymbol{k}}\left(\boldsymbol{k}\right)
\end{equation}\]</span></p>
<p>我们希望当波数等于“目标”的波数时，即</p>
<p><span class="math display">\[\begin{equation}
  \boldsymbol{k} = \boldsymbol{k}_\mathrm{T}
\end{equation}\]</span></p>
<p>输出是对齐的。我们把 <span class="math inline">\(\boldsymbol{k}_\mathrm{T}\)</span>
称为<strong><mark class="label primary">所调方向（steering direction）</mark></strong>或在 <span class="math inline">\(k\)</span>
空间的<strong><mark class="label primary">主响应轴（main response axis）</mark></strong>。可以使用一个 <span class="math inline">\(N \times N\)</span> 的对角调向矩阵（diagonal
steering matrix）来完成这个操作</p>
<p><a id="DiagonalSteeringMatrix"></a></p>
<p><span class="math display">\[\begin{equation}
  \boldsymbol{I}_\mathrm{s}\left(\boldsymbol{k}_\mathrm{T}\right) =
\left[ \begin{matrix}
    e^{j \boldsymbol{k}^\mathrm{T}_\mathrm{T}\boldsymbol{p}_1} &amp; 0
&amp; \cdots &amp; 0 \\
    0 &amp; e^{j \boldsymbol{k}^\mathrm{T}_\mathrm{T}\boldsymbol{p}_2}
&amp; \cdots &amp; 0 \\
    \vdots &amp; \vdots &amp;  &amp; \vdots \\
    0 &amp; 0 &amp; \cdots &amp; e^{j
\boldsymbol{k}^\mathrm{T}_\mathrm{T}\boldsymbol{p}_N}
  \end{matrix} \right]
\end{equation}\]</span></p>
<p>得到的输出为</p>
<p><span class="math display">\[\begin{equation}
  f_\mathrm{s}\left( t, \boldsymbol{p}\right) = e^{j\omega t}
\boldsymbol{v}_{\boldsymbol{k}}\left(\boldsymbol{k} -
\boldsymbol{k}_\mathrm{T}\right)
\end{equation}\]</span></p>
<p>总的频率-波数响应为</p>
<p><span class="math display">\[\begin{equation}
  \boldsymbol{\varUpsilon} \left(\left. \omega, \boldsymbol{k} \right|
\boldsymbol{k}_\mathrm{T} \right) = \boldsymbol{\varUpsilon} \left(
\omega, \boldsymbol{k} - \boldsymbol{k}_\mathrm{T} \right)
\end{equation}\]</span></p>
<div class="note info"><p>阵列的响应函数仅是简单地平移到 <span class="math inline">\(\boldsymbol{k}_\mathrm{T}\)</span>
的位置，这是利用波数空间来解释阵列响应函数的好处之一。如果在波数空间考虑波束方向图，也会得到一个简单的平移关系。</p>
</div>
<h1 id="均匀幅度加权的情况">均匀幅度加权的情况</h1>
<p>  当采用均匀幅度加权时，在<a href="#fig.1-4-1">图 1-4-1</a>
中的两步的过程是不必要的。令</p>
<p><span class="math display">\[\begin{equation}
  \boldsymbol{w} = \frac{1}{N}
\boldsymbol{v}_{\boldsymbol{k}}\left(\boldsymbol{k}_\mathrm{T}\right)
\end{equation}\]</span></p>
<p>则有</p>
<p><span class="math display">\[\begin{equation}
  B_\mathrm{c} \left( \boldsymbol{k}, \boldsymbol{k}_\mathrm{T} \right)
= \frac{1}{N}
\boldsymbol{v}_{\boldsymbol{k}}^\mathrm{H}  \left(\boldsymbol{k}_\mathrm{T}\right)
\boldsymbol{v}_{\boldsymbol{k}}\left(\boldsymbol{k}\right)
\end{equation}\]</span></p>
<p>称 <span class="math inline">\(B_c \left( \boldsymbol{k},
\boldsymbol{k}_\mathrm{T} \right)\)</span>
为<strong><mark class="label primary">常规波束方向图（conventional beam pattern）</mark></strong>。我们将发现常规波束方向图是后面要讨论的很多最优处理内容的基础。</p>
<h1 id="均匀线性阵列的调向">均匀线性阵列的调向</h1>
<p>  线性阵列的常规波束方向图为</p>
<p><span class="math display">\[\begin{equation}
  B_{\psi\mathrm{c}}\left( \psi : \psi_\mathrm{T} \right) = \frac{1}{N}
\boldsymbol{v}_\psi^\mathrm{H}  \left(\psi_\mathrm{T}\right)
\boldsymbol{v}_\psi\left(\psi\right)
\end{equation}\]</span></p>
<p><span class="math display">\[\begin{equation}
  B_{u\mathrm{c}}\left( u : u_\mathrm{T} \right) = \frac{1}{N}
\boldsymbol{v}_u^\mathrm{H}  \left(u_\mathrm{T}\right)
\boldsymbol{v}_u\left(u\right)
\end{equation}\]</span></p>
<p>对于均匀线性阵列（阵元间距相同），有</p>
<p><span class="math display">\[\begin{equation}
  B_{\psi\mathrm{c}}\left( \psi : \psi_\mathrm{T} \right) = \frac{1}{N}
\frac{\sin\left( N \frac{\psi-\psi_\mathrm{T}}{2}
\right)}{\sin\left(\frac{\psi-\psi_\mathrm{T}}{2} \right)}
\label{SteeredBeamPatternInWavenumberDomain}
\end{equation}\]</span></p>
<p><span class="math display">\[\begin{equation}
  B_{u\mathrm{c}}\left( u : u_\mathrm{T} \right) = \frac{1}{N}
\frac{\sin\left[ \frac{\pi Nd}{\lambda} (u - u_\mathrm{T})
\right]}{\sin\left[ \frac{\pi d}{\lambda} (u - u_\mathrm{T}) \right]}
\label{SteeredBeamPatternInDirectionCosineDomain}
\end{equation}\]</span></p>
<p>式 <span class="math inline">\(\eqref{SteeredBeamPatternInWavenumberDomain}\)</span>
或式 <span class="math inline">\(\eqref{SteeredBeamPatternInDirectionCosineDomain}\)</span>
均对应方向图的平移，其形状并没有改变。这种没有畸变的平移性质是在 <span class="math inline">\(\psi\)</span> 空间或 <span class="math inline">\(u\)</span> 空间处理的众多优点之一。</p>
<p>  当我们对阵列调向，并使得主响应轴对准 <span class="math inline">\(\bar{\theta}_0\)</span> 时（其中 <span class="math inline">\(\bar{\theta}_0\)</span>
是从正侧向（broadside）测得的角度），波束方向图将发生平移，使得中心峰值位于
<span class="math inline">\(u_0 =
\sin\bar{\theta}_0\)</span>。同时，这个平移也<strong>使栅瓣发生移动</strong>。</p>
<p>  <a href="#fig.1-4-2">图 1-4-2</a> 说明了调向对波束方向图的影响。<a href="#fig.1-4-2">图 1-4-2(a)</a> 给出了 <span class="math inline">\(d=2\lambda/3\)</span> 和 <span class="math inline">\(\bar\theta = 30^\circ\)</span>
时的波束方向图。我们看到，在这种调向的情况下，栅瓣位于可视区域的边缘。<a href="#fig.1-4-2">图 1-4-2(b)</a> 给出了 <span class="math inline">\(d=\lambda/2\)</span> 和 <span class="math inline">\(\bar\theta = 90^\circ\)</span>
时的波束方向图，栅瓣同样位于可视区域的边缘。</p>
<p><a id="fig.1-4-2"></a></p>
<figure>
<img data-src="../images/post/2023-04-22-josh-oap-part-1-4/2023-04-22-josh-oap-part-1-4-020-%20EffectOfSteeringOnTheGratingLobes.svg" width="1000" alt="图 1-4-2 阵列调向对栅瓣的影响：N=10，(a) d=2\lambda/3, \bar\theta = 30^\circ；(b) d=\lambda/2, \bar\theta = 90^\circ">
<figcaption aria-hidden="true">图 1-4-2 阵列调向对栅瓣的影响：<span class="math inline">\(N=10\)</span>，(a) <span class="math inline">\(d=2\lambda/3, \bar\theta = 30^\circ\)</span>；(b)
<span class="math inline">\(d=\lambda/2, \bar\theta =
90^\circ\)</span></figcaption>
</figure>
<details class="note primary"><summary><p>MATLAB Code</p>
</summary>
<figure class="highlight matlab"><figcaption><span>fig2_22.m</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% Figure 2.22</span></span><br><span class="line"><span class="comment">% Effect of element spacing on beam pattern</span></span><br><span class="line"><span class="comment">% Lillian Xu</span></span><br><span class="line"><span class="comment">% Last updated by K. Bell 7/22/01, 10/4/01</span></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"></span><br><span class="line">clear all</span><br><span class="line">close all</span><br><span class="line"></span><br><span class="line">N=<span class="number">10</span>;</span><br><span class="line">n=(-(N<span class="number">-1</span>)/<span class="number">2</span>:(N<span class="number">-1</span>)/<span class="number">2</span>)';</span><br><span class="line">w=<span class="built_in">ones</span>(N,<span class="number">1</span>)/N;</span><br><span class="line">u=<span class="number">-3</span>:<span class="number">0.01</span>:<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">d=[<span class="number">2</span>/<span class="number">3</span> <span class="number">1</span>/<span class="number">2</span>];</span><br><span class="line">theta=[<span class="number">30</span> <span class="number">90</span>];</span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line">s = [<span class="string">'(a)'</span>;<span class="string">'(b)'</span>];</span><br><span class="line"><span class="keyword">for</span> m=<span class="number">1</span>:<span class="number">2</span></span><br><span class="line">  beam=(w.*<span class="built_in">exp</span>(<span class="number">1</span><span class="built_in">i</span>*<span class="number">2</span>*<span class="built_in">pi</span>*n*d(m)*<span class="built_in">sin</span>(theta(m)/<span class="number">180</span>*<span class="built_in">pi</span>)))' ...</span><br><span class="line">    *<span class="built_in">exp</span>(<span class="number">1</span><span class="built_in">i</span>*<span class="number">2</span>*<span class="built_in">pi</span>*n*d(m)*u);</span><br><span class="line">  subplot(<span class="number">2</span>,<span class="number">1</span>,m);</span><br><span class="line">  <span class="built_in">plot</span>(u,<span class="number">20</span>*<span class="built_in">log10</span>(<span class="built_in">abs</span>(beam)));</span><br><span class="line">  <span class="built_in">hold</span> on</span><br><span class="line">  axis([<span class="number">-3</span> <span class="number">3</span> <span class="number">-25</span> <span class="number">5</span>])</span><br><span class="line">  ylabel(<span class="string">'Beam pattern (dB)'</span>)</span><br><span class="line">  xlabel(<span class="string">'$u$'</span>,<span class="string">'Interpreter'</span>,<span class="string">'latex'</span>)</span><br><span class="line">  text(<span class="number">0</span>,<span class="number">-32</span>,s(m,:),<span class="string">'HorizontalAlignment'</span>,<span class="string">'center'</span>)</span><br><span class="line">  <span class="comment">% title(['N=',num2str(N),', d=',num2str(d(m),2),' lambda, theta-Bar=', ...</span></span><br><span class="line">  <span class="comment">%   num2str(theta(m)),' degrees'])</span></span><br><span class="line">  grid on</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">set(gcf,<span class="string">'Position'</span>,[<span class="number">0</span> <span class="number">0</span> <span class="number">800</span> <span class="number">600</span>])</span><br></pre></td></tr></tbody></table></figure>

</details>
<p>  通常，为了避免栅瓣进入可视区域，需要有</p>
<p><span class="math display">\[\begin{equation}
  \frac{d}{\lambda} \leqslant \frac{1}{1 + \left| \sin\bar\theta_{\max}
\right|}
\end{equation}\]</span></p>
<p>其中， <span class="math inline">\(\bar\theta_{\max}\)</span>
是阵列将要调向的最大角度。这个结果可以令 <span class="math inline">\(\bar\theta_\mathrm{T} =
\bar\theta_{\max}\)</span>，计算第一个栅瓣的位置和 <span class="math inline">\(\frac{d}{\lambda}\)</span>
的关系而得到。所以，如果阵列需要的所调方向为 <span class="math inline">\(-90^\circ \leqslant \bar\theta \leqslant
90^\circ\)</span>，则有</p>
<p><span class="math display">\[\begin{equation}
  d \leqslant \frac{\lambda}{2}
\end{equation}\]</span></p>
<div class="note warning"><p>虽然研究在 <span class="math inline">\(\psi\)</span> 空间或 <span class="math inline">\(u\)</span>
空间的特性是很有用的，但必须要注意信号实际是从 <span class="math inline">\((\theta, \varphi)\)</span>
空间产生的，我们需要理解在这个空间的特性，这一点很重要。</p>
</div>
<p>  在 <span class="math inline">\(\theta\)</span>
空间（即角度空间），有</p>
<p><span class="math display">\[\begin{equation}
  B_{\theta\mathrm{c}}\left( \theta : \theta_\mathrm{T} \right) =
\frac{1}{N} \frac{\sin\left[ \frac{\pi Nd}{\lambda} (\cos\theta -
\cos\theta_\mathrm{T}) \right]}{\sin\left[ \frac{\pi d}{\lambda}
(\cos\theta - \cos\theta_\mathrm{T}) \right]}
\label{SteeredBeamPatternInAngleDomain}
\end{equation}\]</span></p>
<p>我们在 <span class="math inline">\(\theta\)</span> 空间画出 <span class="math inline">\(B_{\theta\mathrm{c}}\)</span>，由于和 <span class="math inline">\(\theta\)</span>
的关系，方向图的形状将随之发生改变。<a href="#fig.1-4-3">图 1-4-3</a>
给出了 <span class="math inline">\(\theta_\mathrm{T} = 30^\circ\)</span>
和 <span class="math inline">\(d=\lambda/2\)</span>
的波束方向图。把这个方向图和<a href="https://josh-gao.top/posts/aa32ec76.html#fig.1-3-3">图 1-3-3</a>
中的方向图进行比较， 可以看到主波束的波束宽度有所增加。</p>
<p><a id="fig.1-4-3"></a></p>
<figure>
<img data-src="../images/post/2023-04-22-josh-oap-part-1-4/2023-04-22-josh-oap-part-1-4-030-BeamPatternFor10ElementUniformArrayScannedTo30Degree.svg" width="800" alt="图 1-4-3 10 阵元均匀阵列（d = \lambda/2）扫描到 30°（和正侧向夹角为 60°）时的波束方向图">
<figcaption aria-hidden="true">图 1-4-3 10 阵元均匀阵列（<span class="math inline">\(d = \lambda/2\)</span>）扫描到 30°（和正侧向夹角为
60°）时的波束方向图</figcaption>
</figure>
<details class="note primary"><summary><p>MATLAB Code</p>
</summary>
<figure class="highlight matlab"><figcaption><span>fig2_23.m</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% Figure 2.23</span></span><br><span class="line"><span class="comment">% Beam pattern for 10-element uniform array (d=lambda/2)</span></span><br><span class="line"><span class="comment">% scanned to 30 degrees (60 degrees from broadside)</span></span><br><span class="line"><span class="comment">% Xin Zhang 1/20/99</span></span><br><span class="line"><span class="comment">% Last updated by K. Bell 6/25/01</span></span><br><span class="line"><span class="comment">% Functions called: polardb</span></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"></span><br><span class="line">clear all</span><br><span class="line">close all</span><br><span class="line"></span><br><span class="line">N = <span class="number">10</span>;</span><br><span class="line">n = (-(N<span class="number">-1</span>)/<span class="number">2</span>:(N<span class="number">-1</span>)/<span class="number">2</span>).';</span><br><span class="line">theta = <span class="built_in">pi</span>*(<span class="number">-1</span>:<span class="number">0.001</span>:<span class="number">1</span>);</span><br><span class="line">u = <span class="built_in">cos</span>(theta);</span><br><span class="line">d = <span class="number">1</span>/<span class="number">2</span>;</span><br><span class="line">vv = <span class="built_in">exp</span>(<span class="number">1</span><span class="built_in">i</span>*<span class="number">2</span>*<span class="built_in">pi</span>*d*n*u);</span><br><span class="line">theta_T = <span class="number">30</span>/<span class="number">180</span>*<span class="built_in">pi</span>;</span><br><span class="line">w = <span class="number">1</span>/N*<span class="built_in">ones</span>(N,<span class="number">1</span>).*<span class="built_in">exp</span>(<span class="number">1</span><span class="built_in">i</span>*n*<span class="built_in">pi</span>*<span class="built_in">cos</span>(theta_T));</span><br><span class="line">B = w'*vv;</span><br><span class="line">B = <span class="number">10</span>*<span class="built_in">log10</span>(<span class="built_in">abs</span>(B).^<span class="number">2</span>);</span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line">h=polardb(theta,B,<span class="number">-40</span>);</span><br><span class="line"><span class="built_in">hold</span> off</span><br></pre></td></tr></tbody></table></figure>

</details>
<p>  为了研究在 <span class="math inline">\(\theta\)</span>
空间的半功率带宽情况，我们利用式 <span class="math inline">\(\eqref{SteeredBeamPatternInAngleDomain}\)</span>
和 <a href="https://josh-gao.top/posts/aa32ec76.html#ApproximationOfHPBW"><span class="math inline">\(N \geqslant 10\)</span>
时半功率带宽的估算式</a>，可以得到在 <span class="math inline">\(u\)</span> 空间的左右半功率点分别为</p>
<p><span class="math display">\[\begin{equation}
  u_\mathrm{L} = u_\mathrm{T} - 0.450 \frac{\lambda}{Nd}
\end{equation}\]</span></p>
<p><span class="math display">\[\begin{equation}
  u_\mathrm{R} = u_\mathrm{T} + 0.450 \frac{\lambda}{Nd}
\end{equation}\]</span></p>
<p>或在 <span class="math inline">\(\theta\)</span> 空间（<span class="math inline">\(\theta_\mathrm{L}\)</span> 对应 <span class="math inline">\(u_\mathrm{R}\)</span>，<span class="math inline">\(\theta_\mathrm{R}\)</span> 对应 <span class="math inline">\(u_\mathrm{L}\)</span>）有</p>
<p><span class="math display">\[\begin{equation}
  \cos\theta_\mathrm{R} = \cos\theta_\mathrm{T} - 0.450
\frac{\lambda}{Nd}
\end{equation}\]</span></p>
<p><span class="math display">\[\begin{equation}
\label{LeftHalfPowerPointInAngleDomain}
  \cos\theta_\mathrm{L} = \cos\theta_\mathrm{T} + 0.450
\frac{\lambda}{Nd}
\end{equation}\]</span></p>
<p>所以，对于 <span class="math inline">\(0 \leqslant \theta \leqslant
\pi\)</span>，<span class="math inline">\(\theta_\mathrm{L},
\theta_\mathrm{R} \geqslant 0\)</span>，在 <span class="math inline">\(\theta\)</span> 空间的半功率波束宽度为</p>
<p><span class="math display">\[\begin{equation} \label{HPBWOfUWLA}
  \theta_\mathrm{H} = \theta_\mathrm{R} - \theta_\mathrm{L} = \cos^{-1}
\left[ \cos\theta_\mathrm{T} - 0.450 \frac{\lambda}{Nd} \right] -
\cos^{-1} \left[ \cos\theta_\mathrm{T} + 0.450 \frac{\lambda}{Nd}
\right]
\end{equation}\]</span></p>
<p>  除了当 <span class="math inline">\(\theta_\mathrm{T} = 0\)</span>
或 <span class="math inline">\(\pi\)</span>（端射，endfire，信号入射方向与阵元排布方向平行）的情况，定义
<span class="math inline">\(\theta_\mathrm{L}\)</span> 为最接近 <span class="math inline">\(\theta = 0\)</span>
的半功率点。当波束从正侧向（<span class="math inline">\(\theta_\mathrm{T} = \pi/2\)</span>）调向 <span class="math inline">\(z\)</span> 轴的正半轴（端射，<span class="math inline">\(\theta_\mathrm{T} =
0\)</span>）时，波束变宽。在某点上，如式 <span class="math inline">\(\eqref{LeftHalfPowerPointInAngleDomain}\)</span>
中所示，<span class="math inline">\(\theta_\mathrm{L}\)</span> 等于
0。在该点以外，在波束的那一边再也没有半功率点。 Elliott<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>
把这个点称为扫描极限（scan limit）。</p>
<p>  Elliot <a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> 画出了式 <span class="math inline">\(\eqref{HPBWOfUWLA}\)</span> 和式 <span class="math inline">\(\eqref{HPBWOfEndfireUWLA}\)</span>
中给出的波束宽度，并在<a href="#fig.1-4-4">图 1-4-4</a> 中给出。</p>
<p><a id="fig.1-4-4"></a></p>
<figure>
<img data-src="../images/post/2023-04-22-josh-oap-part-1-4/2023-04-22-josh-oap-part-1-4-040-HPBWVersusSteeringAngleStandardUWLA.svg" width="1000" alt="图 1-4-4 HPBW 和阵列调向角的关系：标准线阵，采用均匀加权">
<figcaption aria-hidden="true">图 1-4-4 HPBW
和阵列调向角的关系：标准线阵，采用均匀加权</figcaption>
</figure>
<details class="note primary"><summary><p>MATLAB Code</p>
</summary>
<figure class="highlight matlab"><figcaption><span>fig2_24.m</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% Figure 2.24</span></span><br><span class="line"><span class="comment">% HPBW versus steering angle</span></span><br><span class="line"><span class="comment">% Lillian Xu</span></span><br><span class="line"><span class="comment">% Modified by Xin Zhang</span></span><br><span class="line"><span class="comment">% Last updated by L. Xu 11/30/00, K. Bell 7/22/01, 10/4/01, 10/17/01</span></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"></span><br><span class="line">clear all;</span><br><span class="line">close all;</span><br><span class="line"></span><br><span class="line">Nd_set=[<span class="number">1000</span>:<span class="number">-5</span>:<span class="number">700</span> <span class="number">700</span>:<span class="number">-0.5</span>:<span class="number">200</span> <span class="number">200</span>:<span class="number">-0.05</span>:<span class="number">20</span> <span class="number">15</span>:<span class="number">-0.005</span>:<span class="number">1</span>];</span><br><span class="line">theta_deg=[<span class="number">2.5</span> <span class="number">5</span> <span class="number">10</span> <span class="number">20</span> <span class="number">30</span> <span class="number">45</span> <span class="number">90</span>];</span><br><span class="line"><span class="comment">%theta_deg=[2.5 5 10 20 30 45 60 90];</span></span><br><span class="line">theta_set=theta_deg*<span class="built_in">pi</span>/<span class="number">180</span>;</span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line"><span class="keyword">for</span> num=<span class="number">1</span>:<span class="built_in">size</span>(theta_set,<span class="number">2</span>)</span><br><span class="line">  theta=theta_set(num);</span><br><span class="line">  bw=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> num1=<span class="number">1</span>:<span class="built_in">size</span>(Nd_set,<span class="number">2</span>)</span><br><span class="line">    Nd=Nd_set(num1);</span><br><span class="line">    r=<span class="built_in">cos</span>(theta)+<span class="number">0.443</span>/Nd;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">abs</span>(r)&lt;=<span class="number">1</span></span><br><span class="line">        bw(num1)=<span class="built_in">acos</span>(r)-<span class="built_in">acos</span>(<span class="built_in">cos</span>(theta)<span class="number">-0.443</span>/Nd);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  loglog(Nd_set(<span class="number">1</span>:<span class="built_in">size</span>(bw,<span class="number">2</span>)),<span class="built_in">abs</span>(bw*<span class="number">180</span>/<span class="built_in">pi</span>));</span><br><span class="line">  <span class="built_in">hold</span> on</span><br><span class="line">  rightpoint=<span class="built_in">abs</span>(bw(<span class="number">1</span>)*<span class="number">180</span>/<span class="built_in">pi</span>);</span><br><span class="line">  text(<span class="number">1040</span>,rightpoint,[num2str(theta_deg(num)),<span class="string">'$^\circ$'</span>],Interpreter=<span class="string">'latex'</span>); <span class="comment">% used to be 7</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">axis([<span class="number">1</span> <span class="number">1000</span> <span class="number">0.04</span> <span class="number">100</span>])</span><br><span class="line">xlabel(<span class="string">'$Nd/\lambda$'</span>,<span class="string">'Interpreter'</span>,<span class="string">'latex'</span>)</span><br><span class="line">ylabel(<span class="string">'3-dB beamwidth in degrees'</span>)</span><br><span class="line"></span><br><span class="line">scanlimit=-<span class="built_in">acos</span>(<span class="number">1</span><span class="number">-2</span>*<span class="number">0.443</span>./Nd_set);</span><br><span class="line">loglog(Nd_set,<span class="built_in">abs</span>(scanlimit*<span class="number">180</span>/<span class="built_in">pi</span>),<span class="string">'--'</span>)</span><br><span class="line"></span><br><span class="line">Endfire = <span class="number">2</span>*<span class="built_in">acos</span>(<span class="number">1</span><span class="number">-0.433</span>./Nd_set);</span><br><span class="line">loglog(Nd_set,<span class="built_in">abs</span>(Endfire*<span class="number">180</span>/<span class="built_in">pi</span>))</span><br><span class="line">rightpoint=<span class="built_in">abs</span>(Endfire(<span class="number">1</span>)*<span class="number">180</span>/<span class="built_in">pi</span>);</span><br><span class="line">text(<span class="number">1040</span>,rightpoint,<span class="string">'$\theta=0^\circ$'</span>,Interpreter=<span class="string">'latex'</span>); <span class="comment">% used to be 7</span></span><br><span class="line"><span class="comment">%title('HPBW versus steering angle: standard linear array with uniform weighting')</span></span><br><span class="line">text(<span class="number">12</span>,<span class="number">35</span>,<span class="string">'Endfire'</span>)</span><br><span class="line">text(<span class="number">12</span>,<span class="number">14.4</span>,<span class="string">'Scan limit'</span>)</span><br><span class="line">text(<span class="number">12</span>,<span class="number">1.8</span>,<span class="string">'Broadside'</span>)</span><br><span class="line">grid on;</span><br><span class="line">set(gcf,<span class="string">'Position'</span>,[<span class="number">0</span> <span class="number">0</span> <span class="number">800</span> <span class="number">500</span>])</span><br></pre></td></tr></tbody></table></figure>

</details>
<p>  当波束调向到正侧向的附近（<span class="math inline">\(\bar{\theta}_\mathrm{T}\)</span> 的值很小）且
<span class="math inline">\(Nd \gg \lambda\)</span> 时，<span class="math inline">\(\theta_\mathrm{H}\)</span>
很小，利用小角度展开形式得到</p>
<p><span class="math display">\[\begin{equation}
\label{HPBWWithSmallAngle}
  \theta_\mathrm{H} \approx 0.891 \frac{\lambda}{Nd} \sec
\bar\theta_\mathrm{T}
\end{equation}\]</span></p>
<p>式 <span class="math inline">\(\eqref{HPBWWithSmallAngle}\)</span>
的意义在<a href="#fig.1-4-5">图 1-4-5</a>
中比较明显。有效的阵列长度缩减了 <span class="math inline">\(\cos\bar\theta_\mathrm{T}\)</span> 倍。</p>
<p><a id="fig.1-4-5"></a></p>
<figure>
<img data-src="../images/post/2023-04-22-josh-oap-part-1-4/2023-04-22-josh-oap-part-1-4-050-EffectiveArrayLength.png" width="600" alt="图 1-4-5 长度降低了 \cos\bar\theta_\mathrm{T} 倍的等效阵列">
<figcaption aria-hidden="true">图 1-4-5 长度降低了 <span class="math inline">\(\cos\bar\theta_\mathrm{T}\)</span>
倍的等效阵列</figcaption>
</figure>
<p>  对于 <span class="math inline">\(Nd \geqslant
5\lambda\)</span>，在正侧向附近，式 <span class="math inline">\(\eqref{HPBWWithSmallAngle}\)</span> 的误差在 0.2%
以内，在扫描极限附近，误差在 4% 以内。</p>
<p>  当 <span class="math inline">\(\theta_\mathrm{T} = 0\)</span> 或
<span class="math inline">\(\pi\)</span>
时，最大响应轴的指向沿着阵列的轴线，此时称为一个端射阵列（endfire
array）。一个标准 10 阵元端射阵列的波束方向图在<a href="#fig.1-4-6">图
1-4-6</a> 中给出。在这种情况下，有</p>
<p><span class="math display">\[\begin{equation}
\label{HPBWOfEndfireUWLA}
  \theta_\mathrm{H} = 2 \cos^{-1} \left[ 1 - 0.450 \frac{\lambda}{Nd}
\right], \quad \theta_\mathrm{T} = 0 \text{或} \pi
\end{equation}\]</span></p>
<p><a id="fig.1-4-6"></a></p>
<figure>
<img data-src="../images/post/2023-04-22-josh-oap-part-1-4/2023-04-22-josh-oap-part-1-4-060-BeamPatternOfStandard10ElementUWLAAtEndfire.svg" width="800" alt="图 1-4-6 一个标准 10 阵元线阵。采用均匀幅度加权时在端射时的波束方向图">
<figcaption aria-hidden="true">图 1-4-6 一个标准 10
阵元线阵。采用均匀幅度加权时在端射时的波束方向图</figcaption>
</figure>
<details class="note primary"><summary><p>MATLAB Code</p>
</summary>
<figure class="highlight matlab"><figcaption><span>fig2_26.m</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% Figure 2.26</span></span><br><span class="line"><span class="comment">% Beam pattern of a standard 10-element linear array</span></span><br><span class="line"><span class="comment">% with uniform amplitude weighting at end-fire</span></span><br><span class="line"><span class="comment">% Xin Zhang 1/20/99</span></span><br><span class="line"><span class="comment">% Last updated by K. Bell 6/25/01</span></span><br><span class="line"><span class="comment">% Functions called: polardb</span></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"></span><br><span class="line">clear all</span><br><span class="line">close all</span><br><span class="line"></span><br><span class="line">N = <span class="number">10</span>;</span><br><span class="line">n = (-(N<span class="number">-1</span>)/<span class="number">2</span>:(N<span class="number">-1</span>)/<span class="number">2</span>).';</span><br><span class="line">theta = <span class="built_in">pi</span>*(<span class="number">-1</span>:<span class="number">0.001</span>:<span class="number">1</span>);</span><br><span class="line">u = <span class="built_in">cos</span>(theta);</span><br><span class="line">d = <span class="number">1</span>/<span class="number">2</span>;</span><br><span class="line">vv = <span class="built_in">exp</span>(<span class="number">1</span><span class="built_in">i</span>*<span class="number">2</span>*<span class="built_in">pi</span>*d*n*u);</span><br><span class="line">theta_T = <span class="number">0</span>/<span class="number">180</span>*<span class="built_in">pi</span>;</span><br><span class="line">w = <span class="number">1</span>/N*<span class="built_in">ones</span>(N,<span class="number">1</span>).*<span class="built_in">exp</span>(<span class="number">1</span><span class="built_in">i</span>*n*<span class="built_in">pi</span>*<span class="built_in">cos</span>(theta_T));</span><br><span class="line">B = w'*vv;</span><br><span class="line">B = <span class="number">10</span>*<span class="built_in">log10</span>(<span class="built_in">abs</span>(B).^<span class="number">2</span>);</span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line">h=polardb(theta,B,<span class="number">-40</span>);</span><br><span class="line"><span class="built_in">hold</span> off</span><br></pre></td></tr></tbody></table></figure>

</details>
<p>可以把式 <span class="math inline">\(\eqref{HPBWOfEndfireUWLA}\)</span> 写成</p>
<p><span class="math display">\[\begin{equation}
  1 - \cos \left( \frac{\theta_\mathrm{H}}{2} \right) = 0.450
\frac{\lambda}{Nd}
\end{equation}\]</span></p>
<p>或</p>
<p><span class="math display">\[\begin{equation}
\label{SineOfHPBWOfEndfireUWLA}
  \sin \left( \frac{\theta_\mathrm{H}}{4} \right) =
\sqrt{\frac{0.450}{2}\cdot \frac{\lambda}{Nd}}
\end{equation}\]</span></p>
<p>对于 <span class="math inline">\(Nd \gg \lambda\)</span>，<span class="math inline">\(\theta_\mathrm{H}\)</span> 很小，则式 <span class="math inline">\(\eqref{SineOfHPBWOfEndfireUWLA}\)</span> 成为</p>
<p><span class="math display">\[\begin{equation}
\label{ApproximationOfHPBWOfEndfireUWLA}
  \theta_\mathrm{H} = 2 \sqrt{0.890 \frac{\lambda}{Nd}}
\end{equation}\]</span></p>
<p>对于 <span class="math inline">\(Nd \gg 5\lambda\)</span>，式 <span class="math inline">\(\eqref{ApproximationOfHPBWOfEndfireUWLA}\)</span>
的误差小于 1%。</p>
<p>  类似的，方向图的第一零点的位置为</p>
<p><span class="math display">\[\begin{equation}
  \theta_\mathrm{null} = \sqrt{2 \frac{\lambda}{Nd}}
\end{equation}\]</span></p>
<p>  所以，一个线阵在端射位置的分辨率随 <span class="math inline">\(Nd/\lambda\)</span>
的平方根的倒数变化，而在正侧向的时候是线性的关系。</p>
<h1 id="参考文献">参考文献</h1>
<ol type="1">
<li>Harry L. Van Trees. <em>Optimum array processing: Part IV of
detection, estimation, and modulation theory.</em> New York, NY, USA:
John Wiley &amp; Sons, 2002.</li>
<li>Harry L. Van Trees, 汤俊. <em>最优阵列处理技术.</em>
北京：清华大学出版社. 2008.</li>
</ol>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr>
<ol>
<li id="fn1"><p>R. S. Elliott. <em>Antenna Theory and Design.</em>
Prentice-Hall, Englewood Cliffs, New Jersey, 1981.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>R. S. Elliott. <em>Antenna Theory and Design.</em>
Prentice-Hall, Englewood Cliffs, New Jersey, 1981.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/css/markmap.css">

<script src="/js/markmap.js"></script>
]]></content>
      <categories>
        <category>Josh 的学习笔记</category>
        <category>最优阵列处理</category>
        <category>阵列和空域滤波器</category>
      </categories>
      <tags>
        <tag>阵列信号处理</tag>
        <tag>可视区域</tag>
        <tag>阵列调向</tag>
        <tag>主响应轴</tag>
        <tag>端射</tag>
        <tag>侧射</tag>
        <tag>扫描极限</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 删除已提交的大文件</title>
    <url>/posts/a587d6e6.html</url>
    <content><![CDATA[<p>在使用 git
管理代码仓库的时候，有可能不小心提交了一些大文件，虽然后来从工作区删除了，但是已经于事无补，大文件的历史记录仍然保存在
git 仓库里。以下提供了基于文件大小排序的 Git
仓库文件搜索和删除方法。</p>
<h1 id="查找大文件">查找大文件</h1>
<p>在 Git 仓库目录下执行命令对归档的文件进行排序，并给出文件大小前 5
的文件 ID 等信息：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">git verify-pack -v .git/objects/pack/pack-*.idx | <span class="built_in">sort</span> -k 3 -g | <span class="built_in">tail</span> -5</span><br></pre></td></tr></tbody></table></figure>
<p>输出结果如下，依次是文件
ID、文件类型、文件字节数、<code>size-in-packfil</code> 和
<code>offset-in-packfile</code>：</p>
<figure class="highlight plaintext"><figcaption><span>Example Output</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">10eaa37e6e1999cf5652e9b4c6b3ca5fa43a90b1 blob   14873202 11312961 77109113</span><br><span class="line">c8aeb64369be1be657633e92d07dc49ed91fbdc1 blob   14873202 11313163 23914709</span><br><span class="line">1ed41690c8dced0c2ac10b41fafbf23b72a081fd blob   17416456 749732 16400558</span><br><span class="line">b7cb7ef09404b7514d04a5d0f56a7a99e96c072d blob   26776467 1877027 96312339</span><br><span class="line">66e27e2c0159a8439a744d57f058d63dbe192e95 blob   552933714 543247488 117101156</span><br></pre></td></tr></tbody></table></figure>
<span id="more"></span>
<p>根据文件的 ID（SHA1），查找文件路径：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">git rev-list --objects --all | grep &lt;targrt_file_ID&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>示例输入如下：</p>
<figure class="highlight bash"><figcaption><span>Example Input</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">git rev-list --objects --all | grep 66e27e2c0159a8439a744d57f058d63dbe192e95</span><br></pre></td></tr></tbody></table></figure>
<p>输出结果如下，以此是文件 ID 和文件路径：</p>
<figure class="highlight plaintext"><figcaption><span>Example Output</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">66e27e2c0159a8439a744d57f058d63dbe192e95 projects/duifei/duifei_online_acq_par/duifei_online_acq_par_20230511.xpr.zip</span><br></pre></td></tr></tbody></table></figure>
<h1 id="将要删除的大文件从各个分支中移除">将要删除的大文件从各个分支中移除</h1>
<p>执行下面命令，将文件从分支的提交中移除</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">git filter-branch --force --index-filter <span class="string">'git rm --cached --ignore-unmatch &lt;target_file_path&gt;'</span> --prune-empty --tag-name-filter <span class="built_in">cat</span> -- --all</span><br></pre></td></tr></tbody></table></figure>
<p>示例输入如下：</p>
<figure class="highlight bash"><figcaption><span>Example Input</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">git filter-branch --force --index-filter <span class="string">'git rm --cached --ignore-unmatch projects/duifei/duifei_online_acq_par/duifei_online_acq_par_20230511.xpr.zip'</span> --prune-empty --tag-name-filter <span class="built_in">cat</span> -- --all</span><br></pre></td></tr></tbody></table></figure>
<p>示例输出如下：</p>
<figure class="highlight plaintext"><figcaption><span>Example Output</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">WARNING: git-filter-branch has a glut of gotchas generating mangled history</span><br><span class="line">         rewrites.  Hit Ctrl-C before proceeding to abort, then use an</span><br><span class="line">         alternative filtering tool such as 'git filter-repo'</span><br><span class="line">         (https://github.com/newren/git-filter-repo/) instead.  See the</span><br><span class="line">         filter-branch manual page for more details; to squelch this warning,</span><br><span class="line">         set FILTER_BRANCH_SQUELCH_WARNING=1.</span><br><span class="line">Proceeding with filter-branch...</span><br><span class="line"></span><br><span class="line">Rewrite 28271ddd7ce45bc13561bc7343664d937c267a2f (4/10) (1 seconds passed, remaining 1 predicted)    rm 'projects/duifei/duifei_online_acq_par/duifei_online_acq_par_20230511.xpr.zip'</span><br><span class="line">Rewrite e6b6be1ada32ad2eff5f52b45372ed9274a04f30 (9/10) (1 seconds passed, remaining 0 predicted)</span><br><span class="line">Ref 'refs/heads/master' was rewritten</span><br><span class="line">WARNING: Ref 'refs/remotes/github/master' is unchanged</span><br><span class="line">Ref 'refs/remotes/jgnas/master' was rewritten</span><br><span class="line">Ref 'refs/remotes/localhost/master' was rewritten</span><br><span class="line">Ref 'refs/remotes/origin/master' was rewritten</span><br></pre></td></tr></tbody></table></figure>
<h1 id="删除缓存下来的-ref-和-git-操作记录">删除缓存下来的 ref 和 git
操作记录</h1>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">git for-each-ref --format=<span class="string">'delete %(refname)'</span> refs/original | git update-ref --stdin</span><br><span class="line">git reflog expire --expire=now --all</span><br></pre></td></tr></tbody></table></figure>
<h1 id="垃圾回收">垃圾回收</h1>
<p>上面 2
步把大文件的索引都切断了，这个时候进行垃圾回收，就可以很明显看到效果。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">git gc --prune=now</span><br></pre></td></tr></tbody></table></figure>
<p>这时候的仓库中的大文件就已经被删除了，把仓库<strong>推送到新的远程仓库</strong>或者<strong>强制推送到现在的远程仓库</strong>都是可以的。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">git push --force</span><br></pre></td></tr></tbody></table></figure>
<h1 id="参考">参考</h1>
<p><a href="https://www.cnblogs.com/oloroso/p/13367120.html">删除 git
仓库中无用大文件</a></p>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/css/markmap.css">

<script src="/js/markmap.js"></script>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Josh&#39;s Note — 最优阵列处理&lt;br&gt;Part 1.5 阵列性能度量指标</title>
    <url>/posts/6a7100b0.html</url>
    <content><![CDATA[<p> 评估阵列性能的方法有很多，不同方法会量化阵列的不同重要特性，比如阵列对信号的响应，或是阵列的敏感度。在之前的讨论中，第一零点间距是波束宽度，也即频率-波数响应分辨率的度量指标；主旁瓣高度是均匀加权线阵的一种度量指标。本文讨论三个常用的阵列性能度量指标：</p>
<ol type="1">
<li>方向性（Directivity）</li>
<li>对空域自噪声的阵列增益 (Array gain versus spatially white
noise，<span class="math inline">\(A_w\)</span>)</li>
<li>敏感度（Sensitivity）和容错因子（Tolerance Factor）</li>
</ol>
<span id="more"></span>
<h1 id="方向性">方向性</h1>
<p>  方向性是阵列和孔径常用性能度量指标。下面首先在给出一般情况下的定义，然后讨论线性阵列的特殊情况。</p>
<h2 id="方向性的定义">方向性的定义</h2>
<p>  定义<strong><mark class="label primary">功率方向图（power pattern）</mark></strong> <span class="math inline">\(P(\theta,\varphi)\)</span> 为波束方向图 <span class="math inline">\(B(\omega : \theta, \varphi)\)</span>
幅度的平方，即</p>
<p><span class="math display">\[\begin{equation}
  P(\theta,\varphi) = \left| B(\omega : \theta, \varphi) \right|^2
\end{equation}\]</span></p>
<p>其中省略了 <span class="math inline">\(P(\theta,\varphi)\)</span>
和频率的关系，则方向性 <span class="math inline">\(D\)</span> 定义为</p>
<p><span class="math display">\[\begin{equation}
  D = \frac{P(\theta_\mathrm{T},\varphi_\mathrm{T})}{
\displaystyle\frac{1}{4\pi} \int_0^\pi \int_0^{2\pi} \sin \theta \cdot
P(\theta,\varphi) \,\mathrm{d} \varphi \,\mathrm{d} \theta}
\end{equation}\]</span></p>
<p>其中 <span class="math inline">\((\theta_\mathrm{T},\varphi_\mathrm{T})\)</span>
是主响应轴（main response axis，MRA）的指向。</p>
<ul>
<li><p>对于发射天线，<span class="math inline">\(D\)</span>
代表最大发射密度（单位立体角发射功率）和平均发射密度（球面平均发射功率）的比值。</p></li>
<li><p>对于接收天线，分母代表阵列/孔径对全向噪声（在球内均匀分布的噪声）的输出噪声功率，分子代表从
<span class="math inline">\((\theta_\mathrm{T},\varphi_\mathrm{T})\)</span>
方向入射的信号的功率，所以 <span class="math inline">\(D\)</span>
可以理解为对全向噪声的阵列增益。</p></li>
</ul>
<p>  假设权值做了归一化，使得 <span class="math inline">\(P_n(\theta_\mathrm{T},\varphi_\mathrm{T}) =
1\)</span>，则方向性可以进一步写成</p>
<p><span class="math display">\[\begin{equation}
  D = \left\{ \frac{1}{4\pi} \int_0^\pi \int_0^{2\pi} \sin \theta \cdot
P(\theta,\varphi) \,\mathrm{d} \varphi \,\mathrm{d}
\theta  \right\}^{-1}
\end{equation}\]</span></p>
<h2 id="线阵的情况">线阵的情况</h2>
<p>  对于线性阵列，有</p>
<p><span class="math display">\[
B(\theta,\varphi) = B(\theta)
\]</span></p>
<p>则线阵的方向性</p>
<p><span class="math display">\[\begin{align}
  D &amp;= \left\{ \frac{1}{2} \int_0^\pi \left| B(\theta) \right|^2
\sin \theta \,\mathrm{d} \theta  \right\}^{-1} \\
  &amp;= \left\{ \frac{1}{2} \int_{-1}^1 \left| B(u) \right|^2
\,\mathrm{d} u  \right\}^{-1}
\end{align}\]</span></p>
<p>  利用 <a href="https://josh-gao.top/posts/de20fd09.html#BeamPatternInDirectionCosineDomain"><span class="math inline">\(u\)</span> 空间的波束方向图的表达式</a>，<span class="math inline">\(u\)</span>
空间线阵的方向性可以用阵列权值表示为</p>
<p><span class="math display">\[
D = \left\{ \frac{1}{2} \int_{-1}^1 \sum_{n=0}^{N-1}w_n^\ast e^{jn\left(
\frac{2\pi d}{\lambda} \right) \left( u - u_\mathrm{T} \right)}
\sum_{m=0}^{N-1} w_m e^{-jm\left( \frac{2\pi d}{\lambda} \right) \left(
u - u_\mathrm{T} \right)} \,\mathrm{d} u  \right\}^{-1}
\]</span></p>
<p>其中 <span class="math inline">\(u_\mathrm{T}\)</span> 是 <span class="math inline">\(u\)</span>
空间内的阵列的所调方向。交换积分和求和的顺序，积分得到</p>
<p><span class="math display">\[\begin{equation} \label{DirectivityOfLA}
  D = \left\{ \sum_{n=0}^{N-1} \sum_{m=0}^{N-1} w_m w_n^\ast e^{j \left(
\frac{2\pi d}{\lambda} \right) (m-n) u_\mathrm{T} } \mathrm{sinc} \left(
\frac{2\pi d}{\lambda} (n-m)\right)  \right\}^{-1}
\end{equation}\]</span></p>
<p>  为了使表达式更加简洁，定义几个矩阵。定义 <span class="math inline">\(\mathbf{sinc}\)</span> 矩阵的第 <span class="math inline">\(n,m\)</span> 个元素为</p>
<p><span class="math display">\[
\left[ \mathbf{sinc} \right]_{nm} \triangleq \mathrm{sinc} \left(
\frac{2\pi d}{\lambda} (n-m)\right)
\]</span></p>
<p><a href="https://josh-gao.top/posts/c2604c43.html#DiagonalSteeringMatrix">对角调向矩阵</a>
在 <span class="math inline">\(u\)</span> 空间的表示形式为</p>
<p><span class="math display">\[
\boldsymbol{I}_{\mathrm{s}u} = \mathrm{diag}\left( 1, e^{j \frac{2\pi
d}{\lambda}u_\mathrm{T}} , e^{j \frac{2\pi d}{\lambda} 2u_\mathrm{T}},
\cdots, , e^{j \frac{2\pi d}{\lambda}(N-1)u_\mathrm{T}} \right)
\]</span></p>
<p>则</p>
<p><span class="math display">\[\begin{equation}
  D = \boldsymbol{I}_{\mathrm{s}u} \boldsymbol{w}^\mathrm{H} \left[
\mathbf{sinc} \right] \boldsymbol{w}
\boldsymbol{I}_{\mathrm{s}u}^\mathrm{H}
\end{equation}\]</span></p>
<p>由于调向运算通常在权值矢量中包含<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
<p><span class="math display">\[\begin{equation}
  \boldsymbol{w}_\mathrm{s} =
\boldsymbol{w}\boldsymbol{I}_{\mathrm{s}u}^\mathrm{H}
\end{equation}\]</span></p>
<p>则</p>
<p><span class="math display">\[\begin{equation}
  D = \boldsymbol{w}_\mathrm{s}^\mathrm{H} \left[ \mathbf{sinc} \right]
\boldsymbol{w}_\mathrm{s}
\end{equation}\]</span></p>
<h2 id="标准线阵的情况">标准线阵的情况</h2>
<p>  标准线阵（standard linear array）是我们所感兴趣的一个特殊情况。如果
<span class="math inline">\(d = \lambda/2\)</span>，则方向性</p>
<p><span class="math display">\[
  D = \left\{ \sum_{n=0}^{N-1} \sum_{m=0}^{N-1} w_m w_n^\ast e^{j \pi
(m-n) u_\mathrm{T} } \mathrm{sinc} \left( \pi
(n-m)\right)  \right\}^{-1}
\]</span></p>
<p>当 <span class="math inline">\(m = n\)</span> 时，<span class="math inline">\(\mathrm{sinc}\)</span> 函数等于 1，当 <span class="math inline">\(m \ne n\)</span> 时，<span class="math inline">\(\mathrm{sinc}\)</span> 函数等于
0，所以方向性可以进一步简化为</p>
<p><span class="math display">\[\begin{equation}
  D = \left\{ \sum_{n=0}^{N-1} \left| w_n \right|^2 \right\} = \left(
\boldsymbol{w}^\mathrm{H}\boldsymbol{w} \right)^{-2} = \left\{ \left\|
\boldsymbol{w} \right \|^2 \right\}^{-1}
\end{equation}\]</span></p>
<p>其中</p>
<p><span class="math display">\[\begin{equation}
  \left\| \boldsymbol{w} \right \| = \left(
\boldsymbol{w}^\mathrm{H}\boldsymbol{w} \right)^{\frac{1}{2}}
\end{equation}\]</span></p>
<p>是矢量 <span class="math inline">\(\boldsymbol{w}\)</span> 的
2-模。因此<strong>标准线阵的方向性是权值矢量幅度平方的倒数</strong>。且<strong>标准线的方向性不依赖于阵列的指向</strong>，当阵列指向从阵列的正侧向（broadside）移开时。波束变宽，但是
<span class="math inline">\(\varphi\)</span> 的积分范围减小。</p>
<p>  对于 <span class="math inline">\(d \ne \lambda/2\)</span>，利用式
<span class="math inline">\(\eqref{DirectivityOfLA}\)</span>
给出的线阵方向性的定义，方向性将和阵列的指向有关。</p>
<p>  对于均匀加权的标准线阵（UWLA），<span class="math inline">\(w_n =
1/N\)</span>，所以</p>
<p><span class="math display">\[
\sum_{n=0}^{N-1} \left| w_n \right|^2 = \frac{1}{N}
\]</span></p>
<p>所以</p>
<p><span class="math display">\[\begin{equation}
  D = N
\end{equation}\]</span></p>
<p>  均匀加权使得标准线阵的方向性最大，下面给出简单证明。</p>
<blockquote>
<p>  采用 Lagrange 乘子法进行证明。待求解的问题可以表述为</p>
<p><span class="math display">\[
\min_{w_n} \sum_{n=0}^{N-1} \left| w_n \right|^2, \quad \mathrm{s.t.}
\sum_{n=0}^{N-1} w_n = 1
\]</span></p>
<p>约束条件保证了波束方向图在 <span class="math inline">\(u_\mathrm{T}\)</span> 方向的值为 1。令</p>
<p><span class="math display">\[
F = \sum_{n=0}^{N-1} \left| w_n \right|^2 + \lambda \left(
\sum_{n=0}^{N-1} w_m - 1 \right)
\]</span></p>
<p>其中 <span class="math inline">\(\lambda\)</span> 是 Lagrange
乘子。对 <span class="math inline">\(w_n\)</span>
求导，并令结果等于零，得到</p>
<p><span class="math display">\[
w_n^\ast = -\lambda
\]</span></p>
<p>也即</p>
<p><span class="math display">\[
w_n = -\lambda^\ast
\]</span></p>
<p>把所得结果代入约束条件，得到 <span class="math inline">\(\lambda =
-\displaystyle\frac{1}{N}\)</span>，则有</p>
<p><span class="math display">\[
w_n = \frac{1}{N}
\]</span></p>
<p>此即为我们想要得到的结果。</p>
</blockquote>
<div class="note info"><p>对于非均匀加权的情况，阵列的方向性总是减小的。它是以半波长度量的阵列长度的函数，加上一个由于非均匀加权而产生的部分。</p>
</div>
<p>  一个<strong>标准均匀加权线阵</strong>的方向性可以和半功率带宽
HPBW，或者第一零点波束宽度<span class="math inline">\(BW_{NN}\)</span>
相联系起来。根据<a href="https://josh-gao.top/posts/aa32ec76.html#table.1-3-2">各个空间的第一零点波束宽度表</a>,
有</p>
<p><span class="math display">\[\begin{equation}
  D = \frac{4}{BW_{NN}}
\end{equation}\]</span></p>
<p>其中，<span class="math inline">\(BW_{NN}\)</span> 是在 <span class="math inline">\(u\)</span> 空间的值。</p>
<p>  方向性经常用 dB
来表示，并称之为<strong><mark class="label primary">方向性指数（directivity index）</mark></strong>：</p>
<p><span class="math display">\[\begin{equation}
  DI = 10 \lg D
\end{equation}\]</span></p>
<p>可以把 <span class="math inline">\(DI\)</span> 写成</p>
<p><span class="math display">\[\begin{equation}
  DI = 10 \lg N + 10 \lg(g(\boldsymbol{w}))
\end{equation}\]</span></p>
<p>其中第二项是权值的函数。对于非均匀加权（<span class="math inline">\(w_n \ne N^{-1}\)</span>），<span class="math inline">\(DI\)</span> 将会减小。</p>
<h1 id="对空域白噪声的阵列增益a_w">对空域白噪声的阵列增益（<span class="math inline">\(A_w\)</span>）</h1>
<p>  阵列处理的一个目标是通过相干地累加信号和不相干地累加噪声来改善<strong><mark class="label primary">信噪比（signal-to-noise ratio，SNR）</mark></strong>，阵列增益可以度量信噪比的改善程度。这是阵列性能的一个重要度量指标，后面我们会深入地讨论这个问题。阵列增益的一般定义要到介绍了谱协方差矩阵（用于描述噪声过程的空域统计特性）后给出。这里仅给出阵列增益的一个应用范围受限的定义。</p>
<p>  假设每个阵元的输入由一个从主响应轴入射的平面波和一个噪声过程组成，各阵元的噪声过程是不相关的（空域白噪声），则各阵元的输入信号</p>
<p><span class="math display">\[\begin{equation}
  x_n (t) = f(t - \tau_n) + n_n(t), \quad n = 0,\cdots,N-1
\end{equation}\]</span></p>
<p>每个阵元上信号谱和噪声谱的比值，也即输入信噪比为</p>
<p><span class="math display">\[\begin{equation}
  \mathrm{SNR}_\mathrm{in} (\omega) = \frac{S_f(\omega)}{S_n (\omega)}
\end{equation}\]</span></p>
<p>其中下标 “<span class="math inline">\(\mathrm{in}\)</span>”
表示输入，假设每个阵元的噪声谱相同。</p>
<p>  下面推导使用权值和输入谱矩阵来描述输出谱的表达式。根据<a href="https://josh-gao.top/posts/8b61f5a7.html#VectorFormOfLinearArrayOutputInTimeDomain">阵列输出的向量形式</a>,
有</p>
<p><span class="math display">\[
y(t) = \int_{-\infty}^{\infty} \boldsymbol{h}^\mathrm{T} (\tau)
\boldsymbol{x}\left(t - \tau\right) \mathrm{d} \tau
\]</span></p>
<p>假设 <span class="math inline">\(x(t)\)</span> 是零均值宽平稳的，输出
<span class="math inline">\(y(t)\)</span> 的自相关函数</p>
<p><span class="math display">\[
R_{y}(\tau) = E[y(t)y^\ast(t-\tau)]
\]</span></p>
<p><span class="math inline">\(y(t)\)</span> 的谱为</p>
<p><span class="math display">\[\begin{aligned}
  S_y (\omega) &amp;= \int_{-\infty}^{\infty} e^{-j\omega \tau}
R_{y}(\tau) \, \mathrm{d} \tau  \\
  &amp;= \int_{-\infty}^{\infty} e^{-j\omega\tau} \, \mathrm{d} \tau
\int_{-\infty}^{\infty} \boldsymbol{h}^\mathrm{T} (\alpha) \, \mathrm{d}
\alpha \int_{-\infty}^{\infty} E \left[  \boldsymbol{x} (t-\alpha)
\boldsymbol{x}^\mathrm{H} (t-\tau-\beta)\right]
\boldsymbol{h}^\ast(\beta) \, \mathrm{d} \beta \\
  &amp;= \int_{-\infty}^{\infty} \boldsymbol{h}^\mathrm{T} (\alpha)
e^{-j\omega\alpha}  \, \mathrm{d} \alpha \int_{-\infty}^{\infty}
\boldsymbol{R}_x (z) e^{-j\omega z} \, \mathrm{d} z
\int_{-\infty}^{\infty} \boldsymbol{h}^\ast(\beta) e^{-j\omega \beta} \,
\mathrm{d} \beta
\end{aligned}\]</span></p>
<p>也即</p>
<p><span class="math display">\[\begin{equation}
  S_y (\omega) = \boldsymbol{H}^\mathrm{T} (\omega)
\boldsymbol{S}_x(\omega) \boldsymbol{H} ^\ast (\omega)
\end{equation}\]</span></p>
<p>对于窄带波束形成器，利用<a href="https://josh-gao.top/posts/8b61f5a7.html#NarrowBandComplexWeightVector">窄带假设下的复加权的表达式</a>，可得</p>
<p><span class="math display">\[\begin{equation}
  S_y (\omega) = \boldsymbol{w}^\mathrm{H} \boldsymbol{S}_x(\omega)
\boldsymbol{w}
\end{equation}\]</span></p>
<p>为了计算由于信号而产生的输出，对 <span class="math inline">\(\boldsymbol{w}\)</span>
施加<strong><mark class="label primary">无畸变/失真约束（distortionless constraint）</mark></strong></p>
<p><span class="math display">\[\begin{equation}
  \boldsymbol{w}^\mathrm{H} \boldsymbol{v}_{\boldsymbol{k}} \left(
\boldsymbol{k}_\mathrm{s} \right) = 1
\end{equation}\]</span></p>
<p>表示从 <span class="math inline">\(\boldsymbol{k}_\mathrm{s}\)</span>
方向入射的任意信号将无畸变地通过波束形成器。在后续的讨论中这个条件经常使用。</p>
<p>  输入信号谱</p>
<p><span class="math display">\[\begin{equation}
  \boldsymbol{S}_{\boldsymbol{f}}(\omega) =
\boldsymbol{v}_{\boldsymbol{k}} \left( \boldsymbol{k}_\mathrm{s} \right)
S_f(\omega) \boldsymbol{v}_{\boldsymbol{k}}^\mathrm{H} \left(
\boldsymbol{k}_\mathrm{s} \right)
\end{equation}\]</span></p>
<p>则输出信号谱为</p>
<p><span class="math display">\[\begin{equation}
\begin{aligned}
  S_{y_\mathrm{s}} &amp;= \boldsymbol{w}^\mathrm{H}
\boldsymbol{v}_{\boldsymbol{k}} \left( \boldsymbol{k}_\mathrm{s} \right)
S_f (\omega) \boldsymbol{v}_{\boldsymbol{k}}^\mathrm{H} \left(
\boldsymbol{k}_\mathrm{s} \right) \boldsymbol{w} \\
  &amp;= S_f(\omega)
\end{aligned}
\end{equation}\]</span></p>
<p>  输出噪声谱为</p>
<p><span class="math display">\[\begin{equation}
  S_{y_\mathrm{n}} = \boldsymbol{w}^\mathrm{H}
\boldsymbol{S_{\boldsymbol{n}}} (\omega) \boldsymbol{w}
\end{equation}\]</span></p>
<p>其中 <span class="math inline">\(\boldsymbol{S_{\boldsymbol{n}}}
(\omega)\)</span>
是输入噪声过程的谱矩阵。对于空域白噪声，若各阵元的噪声谱相同，有</p>
<p><span class="math display">\[\begin{equation}
  S_{\boldsymbol{n}} = S_n (\omega) \boldsymbol{I}
\end{equation}\]</span></p>
<p>则输出噪声谱</p>
<p><span class="math display">\[\begin{equation}
  S_{y_n} = \left\| \boldsymbol{w} \right\|^2 S_n(w) = \sum_{n=0}^{N-1}
\left| w_n \right|^2 S_n(\omega)
\end{equation}\]</span></p>
<p>所以</p>
<p><span class="math display">\[\begin{equation}
  \mathrm{SNR_o}(\omega) = \frac{1}{\displaystyle\sum_{n=0}^{N-1} \left|
w_n \right|^2} \frac{S_f(\omega)}{S_n(\omega)}
\end{equation}\]</span></p>
<p>其中，下标“<span class="math inline">\(\mathrm{o}\)</span>”代表输出。</p>
<p>  阵列增益 <span class="math inline">\(A_w\)</span> 反映了阵列带来的
SNR 改善程度，定义为阵列输出 SNR 和一个阵元上输入 SNR 的比值。</p>
<p><span class="math display">\[\begin{equation}
  A_w = \frac{\mathrm{SNR_o}(\omega)}{\mathrm{SNR_{in}}(\omega)} =
\frac{1}{\displaystyle \sum_{n=0}^{N-1} \left| w \right|^2} = \left(
\sum_{n=0}^{N-1} \frac{1}{\left| w_n \right|^2}  \right) ^{-1} = \left\|
\boldsymbol{w} \right\| ^{-2}
\end{equation}\]</span></p>
<p>下标“<span class="math inline">\(w\)</span>”表示空域不相关的噪声输入，<strong>噪声的时域频谱不一定是平坦的</strong>。</p>
<p>  观察阵列增益的定义式可以得到以下三个有用的结果：</p>
<ol type="1">
<li><p>只要满足</p>
<p><span class="math display">\[
\left| \boldsymbol{w}^\mathrm{H}\boldsymbol{v}_{\boldsymbol{k}} \left(
\boldsymbol{k}_\mathrm{s} \right) \right|^2 = 1
\]</span></p>
<p>这个结果就适用于任意的阵列结构。</p></li>
<li><p>对于标准线阵（阵元间距为 <span class="math inline">\(d=\lambda/2\)</span>），白噪声阵列增益 <span class="math inline">\(A_w\)</span> 等于阵列方向性 <span class="math inline">\(D\)</span>。</p></li>
<li><p>对于非均匀线阵 <span class="math inline">\(d \ne
\lambda/2\)</span>，<span class="math inline">\(D\)</span>
是对全向噪声的阵列增益 <span class="math inline">\(A_\mathrm{iso}\)</span>，而非白噪声增益 <span class="math inline">\(A_w\)</span>。</p></li>
</ol>
<p>  对于均匀加权阵列，有</p>
<p><span class="math display">\[
w_n = \frac{1}{N}, \quad n = 0,\cdots,N-1
\]</span></p>
<p>且 <span class="math inline">\(A_w = N\)</span>（或单位为 <span class="math inline">\(\mathrm{dB}\)</span> 时，为 <span class="math inline">\(10 \log N\)</span>）。直接利用 Schwarz
不等式，可以得到 <span class="math inline">\(A_w \leqslant
N\)</span>。所以，如果要在空域不相关噪声下使阵列增益最大，均匀加权阵列是最优的。</p>
<h1 id="敏感度和容错因子">敏感度和容错因子</h1>
<p><a id="fig.1-5-1"></a></p>
<figure>
<img data-src="../images/post/2023-04-24-josh-oap-part-1-5/2023-04-24-josh-oap-part-1-5-010-ArrayWithPositionErrors.png" width="700" alt="图 1-5-1 具有阵元位置误差的阵列">
<figcaption aria-hidden="true">图 1-5-1
具有阵元位置误差的阵列</figcaption>
</figure>
<p>  后面会分析最优处理器对于增益和相位误差、传感器定位不准确等因素的敏感度。这里总结一下<a href="#fig.1-5-1">图 1-5-1</a>
中阵列的典型结果，设计的目标是使得在没有阵列扰动的情况下，从正侧向入射到阵列的信号无畸变地通过，即有</p>
<p><span class="math display">\[
\boldsymbol{w}^\mathrm{H} \cdot \boldsymbol{1} F(\omega) = F(\omega)
\]</span></p>
<p>现在考虑滤波器扰动和阵列位置扰动的影响。</p>
<h2 id="滤波器扰动filter-perturbations">滤波器扰动（Filter
Perturbations）</h2>
<p>  假设理想的矩阵滤波器为 <span class="math inline">\(\boldsymbol{w}^n\)</span>，把 <span class="math inline">\(\boldsymbol{w}^n\)</span> 的第 <span class="math inline">\(i\)</span> 个元素表示为 <span class="math inline">\(w_i^n\)</span>，则理想的权值可表示为</p>
<p><span class="math display">\[\begin{equation}
  (w_i^n)^\ast = g_i^n e^{-j \varphi_i^n}
\end{equation}\]</span></p>
<p>实际的权值可表示为</p>
<p><span class="math display">\[\begin{align}
  w_i^\ast &amp;= g_i e^{-j \varphi_i} \notag \\
  &amp;= g_i^n (1 + \Delta g_i) e^{-j (\varphi_i^n + \Delta \varphi_i)}
\end{align}\]</span></p>
<p>其中 <span class="math inline">\(\Delta g_i\)</span> 和 <span class="math inline">\(\Delta \varphi_i\)</span> 是随机变量。</p>
<h2 id="阵列位置扰动array-location-perturbations">阵列位置扰动（Array
Location Perturbations）</h2>
<p>  假设理想的阵元位置为 <span class="math inline">\(\boldsymbol{p}_i^n\)</span>，实际阵元位置为</p>
<p><span class="math display">\[\begin{equation}
  \boldsymbol{p_i} = \boldsymbol{p}_i^n + \Delta \boldsymbol{p}_i
\end{equation}\]</span></p>
<p>所以理想的模型可能会产生三种变化</p>
<p><span class="math display">\[
  g_i = g_i^n (1 + \Delta g_i)
\]</span></p>
<p><span class="math display">\[
  \varphi_i = \varphi_i^n + \Delta \varphi_i
\]</span></p>
<p><span class="math display">\[
  \boldsymbol{p_i} = \boldsymbol{p}_i^n + \Delta \boldsymbol{p}_i
\]</span></p>
<p>前两种变化可能是由于阵元的增益和相位改变，或者是由于阵元增益和相位不准确造成的。最后一种变化是由于对阵元的位置缺乏精确了解造成的。假设
<span class="math inline">\(\{ \Delta g_i \}_{i=0}^{N-1}\)</span>、<span class="math inline">\(\{ \varphi_i \}_{i=0}^{N-1}\)</span> 和 <span class="math inline">\(\{ \boldsymbol{p_i} \}_{i=0}^{N-1}\)</span>
是统计独立、零均值的高斯随机变量，下面在阵列存在这些变化的情况下分析波束方向图的变化情况。</p>
<p>  理想波束方向图为</p>
<p><span class="math display">\[\begin{align}
  B^{(n)}(\boldsymbol{k}) &amp;=
(\boldsymbol{w}^n)^\mathrm{H}\boldsymbol{v}(\boldsymbol{k}) \notag \\
  &amp;= \sum_{i=0}^{N-1} g_i^n \exp (j\varphi_i^n - j
\boldsymbol{k}^\mathrm{T} \boldsymbol{p}_i^n)
\end{align}\]</span></p>
<p>实际波束方向图是一个随机函数，其幅度平方的期望值可以写成</p>
<p><span class="math display">\[\begin{aligned}
  \overline{\left| B (\boldsymbol{k}) \right| ^2} &amp; \triangleq
&amp;&amp; E \left\{ \left| B (\boldsymbol{k}) \right| ^2 \right\}
\notag \\
  &amp;=&amp;&amp; E \left\{ \sum_{i=0}^{N-1} \sum_{l=0}^{N-1} g_i
\exp(j\varphi_i^n - j \boldsymbol{k}^\mathrm{T} \boldsymbol{p}_i^n)
\cdot g_l (-j\varphi_l^n + j \boldsymbol{k}^\mathrm{T}
\boldsymbol{p}_l^n) \right\} \\
  &amp;=&amp;&amp; \sum_{i=0}^{N-1} \sum_{l=0}^{N-1} E \left\{ g_i^n (1
+ \Delta g_i) g_l^n (1 + \Delta g_l) \right. \notag \\
  &amp; &amp;&amp; \cdot \exp\left[ j (\varphi_i^n + \Delta \varphi_i -
\varphi_l^n - \Delta \varphi_l) \right]\left. \right. \notag \\
  &amp; &amp;&amp; \left. \cdot \exp \left[ -j \boldsymbol{k}^\mathrm{T}
\left( \boldsymbol{p}_i^n + \Delta \boldsymbol{p}_i - \boldsymbol{p}_l^n
- \Delta \boldsymbol{p}_l \right) \right] \right\}
\end{aligned}\]</span></p>
<p>  定义</p>
<p><span class="math display">\[\begin{cases}
  \alpha_{il} = E \left\{ (1 + \Delta g_i)(1 + \Delta g_l) \exp[j(\Delta
\varphi_i - \Delta \varphi_l)] \right\} \\
  \beta_{il}(\boldsymbol{k}) = E \left\{
\exp[-j\boldsymbol{k}^\mathrm{T}(\Delta \boldsymbol{p}_i - \Delta
\boldsymbol{p}_l)] \right\}
\end{cases}\]</span></p>
<p>利用独立高斯随机变栨的假设，有</p>
<p><span class="math display">\[
\alpha_{il} = \begin{cases}
  \exp (-\sigma_{\varphi}^2), &amp; i \ne l \\
  1 + \sigma_g^2, &amp; i = l
\end{cases}
\]</span></p>
<p><span class="math display">\[
\beta_{il}(\boldsymbol{k}) = \begin{cases}
  \exp (-\sigma_p^2 |\boldsymbol{k}|^2) = \exp \left( - \left[
\displaystyle\frac{2\pi\sigma_p}{\lambda}^2 \right] \right) \triangleq
\exp (-\sigma_\lambda^2), &amp; i \ne l \\
  1 , &amp; i = l
\end{cases}
\]</span></p>
<p>在 <span class="math inline">\(\beta_{il}(\boldsymbol{k})\)</span>
的表达式中，假设每个分量 <span class="math inline">\(\Delta
\boldsymbol{p}_i\)</span> 的方差等于 <span class="math inline">\(\sigma_p^2\)</span>，<span class="math inline">\(\sigma_\lambda^2\)</span>
是以波长进行归一化的方差。则</p>
<p><span class="math display">\[\begin{align}
  \overline{\left| B (\boldsymbol{k}) \right| ^2}
&amp;=&amp;&amp;  \sum_{i=0,i\ne l}^{N-1}\sum_{l=0}^{N-1} \left\{ g_i^n
g_l^n \exp (j\varphi_i^n- j\varphi_l^n) \exp \left[ -j
\boldsymbol{k}^\mathrm{T} \left( \boldsymbol{p}_i - \boldsymbol{p}_l
\right)\right] \right. \notag \\
  &amp; &amp;&amp; \cdot \left. \exp
[-(\sigma_\varphi^2+\sigma_\lambda^2)] \right\}+ \sum_{i=0}^{N-1}
(1+\sigma_g^2)(g_i^n)^2 \notag \\
  &amp;=&amp;&amp; \left| B^{(n)}(\boldsymbol{k}) \right| ^2 \exp
[-(\sigma_\varphi^2+\sigma_\lambda^2)] \notag \\
  &amp; &amp;&amp; + \sum_{i=0}^{N-1} (g_i^n)^2 \{(1+\sigma_g^2) - \exp
[-(\sigma_\varphi^2+\sigma_\lambda^2)] \}
\end{align}\]</span></p>
<p>其中 <span class="math inline">\(\sigma_\varphi^2\)</span>、<span class="math inline">\(\sigma_\lambda^2\)</span> 和 <span class="math inline">\(\sigma_g^2\)</span> 表示对应的随机变量的方差。</p>
<p>  从实际波束方向图的表达式可以看出，随机变化引入了两种影响。第一项使波束方向图在
<span class="math inline">\(\boldsymbol{k}\)</span>
空间均匀衰减，这种均匀性是随机变量独立于 <span class="math inline">\(\boldsymbol{k}\)</span>
的假设造成的，意味着波束方向图具有统计偏差，使得主响应轴方向的波束方向图的期望值小于
<span class="math inline">\(1\)</span>。第二项更为关键，定义<strong><mark class="label primary">敏感度函数</mark></strong>为</p>
<p><span class="math display">\[\begin{equation}
  T_\mathrm{se} = \sum_{i=0}^{N-1} \left| w_i^n \right| ^2 =
\sum_{i=0}^{N-1} (g_i^n)^2
\end{equation}\]</span></p>
<p>则第二项成为</p>
<p><span class="math display">\[
\overline{\left| B_2 (\boldsymbol{k}) \right| ^2} = T_\mathrm{se}
\{(1+\sigma_g^2) - \exp [-(\sigma_\varphi^2+\sigma_\lambda^2)] \}
\]</span></p>
<p>若方差较小，则</p>
<p><span class="math display">\[
\overline{\left| B_2 (\boldsymbol{k}) \right| ^2} = T_\mathrm{se}
\{\sigma_g^2 + \sigma_\varphi^2 + \sigma_\lambda^2 \}
\]</span></p>
<p>注意到 <span class="math inline">\(T_\mathrm{se}\)</span>
是白噪声增益的逆，也即</p>
<p><span class="math display">\[\begin{equation}
  T_\mathrm{se} = [A_w] ^{-1} = \left\| \boldsymbol{w} \right\|^2
\end{equation}\]</span></p>
<p>所以当白噪声增益增加时，敏感度减小。对于 <span class="math inline">\(N\)</span> 元阵列，白噪声增益最大为 <span class="math inline">\(N\)</span>,
对应均匀加权的情况。所以，任意一个具有非均匀加权的阵列对参数的变化将比均匀加权阵列更敏感。第二项均匀地提高了旁瓣区域的期望值，在整个
<span class="math inline">\(\boldsymbol{k}\)</span>
空间产生了主要的影响。在很多阵列设计的问题中，我们希望能在一个干扰信号的方向放置一个完全零点（perfect
null），使得 <span class="math inline">\(|B(\boldsymbol{k})|^2 =
0\)</span>，如果 <span class="math inline">\((\sigma_\varphi^2,
\sigma_\lambda^2, \sigma_g^2)\)</span>
中的任何一个变量不为零，则不可能得到一个完全零点。</p>
<p>  方向图期望值的下限依赖于敏感度函数 <span class="math inline">\(T_\mathrm{se}\)</span>
和扰动的方差，限制了方向图零点的深度<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>。</p>
<blockquote>
<p>  下面举例分析。假设</p>
<p><span class="math display">\[
\sigma_T^2 \triangleq \sigma_g^2 + \sigma_\varphi^2 + \sigma_\lambda^2 =
0.01
\]</span></p>
<p>则 <span class="math inline">\(A_w\)</span> 必须大于或等于 <span class="math inline">\(100\)</span>，才能在方向图上得到 <span class="math inline">\(-40\text{dB}\)</span>
的零陷。这需要均匀加权阵列至少具有 <span class="math inline">\(100\)</span>
个阵元，非均匀加权的阵列将需要更多阵元。</p>
</blockquote>
<p>  当设计最优阵列时，我们经常采用<strong><mark class="label primary">敏感度约束</mark></strong></p>
<p><span class="math display">\[\begin{equation}
  T_\mathrm{se} = \left\| \boldsymbol{w} \right\|^2 \leqslant
T_\mathrm{o}
\end{equation}\]</span></p>
<p>其中 <span class="math inline">\(T_\mathrm{o}\)</span>
是一个使得阵列的性能对扰动更加稳健的常数。上述约束也可以表述为<strong><mark class="label primary">白噪声增益约束</mark></strong></p>
<p><span class="math display">\[\begin{equation}
  A_w = (\left\| \boldsymbol{w} \right\|^2) ^{-1} \geqslant
T_\mathrm{o}^{-1}
\end{equation}\]</span></p>
<h1 id="总结">总结</h1>
<p>  本文给出了三个重要的阵列性能度量指标。我们看到权值矢量 <span class="math inline">\(\boldsymbol{w}\)</span>
的模在所有的三个度量指标中都出现了</p>
<ol type="1">
<li>对于标准线阵，方向性 <span class="math inline">\(D = \left\|
\boldsymbol{w} \right\|^{-2} \leqslant N\)</span>；</li>
<li>对于任意阵列结构，白噪声阵列增益 <span class="math inline">\(A_w =
\left\| \boldsymbol{w} \right\|^{-2}\)</span>；</li>
<li>对于任意阵列结构，敏感度函数 <span class="math inline">\(T_\mathrm{se} = A_w^{-1} = \left\| \boldsymbol{w}
\right\|^2\)</span>。</li>
</ol>
<p>可见 <span class="math inline">\(\left\| \boldsymbol{w}
\right\|^2\)</span> 在很多讨论中都起着非常核心的作用。</p>
<h1 id="参考文献">参考文献</h1>
<ol type="1">
<li>Van Trees, Harry L. <em>Optimum array processing: Part IV of
detection, estimation, and modulation theory.</em> John Wiley &amp;
Sons, 2002.</li>
<li>Van Trees, Harry L, 汤俊. <em>最优阵列处理技术.</em> 清华大学出版社.
2008.</li>
</ol>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr>
<ol>
<li id="fn1"><p>在大多数情况下，我们去掉下标 “<span class="math inline">\(s\)</span>”，因为假设 <span class="math inline">\(\boldsymbol{w}\)</span> 是包含调向的。<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>在数学上，零点意味 <span class="math inline">\(B(\boldsymbol{k}) =
0\)</span>，但是实际方向图具有非零的值，该值和 <span class="math inline">\(B(\boldsymbol{k}_\mathrm{T})\)</span>
的值的比值称为<strong><mark class="label primary">零点深度</mark></strong>。<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/css/markmap.css">

<script src="/js/markmap.js"></script>
]]></content>
      <categories>
        <category>Josh 的学习笔记</category>
        <category>最优阵列处理</category>
        <category>阵列和空域滤波器</category>
      </categories>
      <tags>
        <tag>阵列信号处理</tag>
        <tag>阵列性能</tag>
      </tags>
  </entry>
  <entry>
    <title>strike</title>
    <url>/posts/dc727c0.html</url>
    <content><![CDATA[<h1 id="verb">Verb</h1>
<h2 id="pronunciation">Pronunciation</h2>
<ul>
<li>BrE: /straɪk/</li>
<li>NAmE: /straɪk/</li>
</ul>
<h2 id="verb-forms">Verb Forms</h2>
<ul>
<li>present simple I / you / we / they <strong>strike</strong>
<ul>
<li>BrE: /straɪk/</li>
<li>NAmE: /straɪk/</li>
</ul></li>
<li>he / she / it <strong>strikes</strong>
<ul>
<li>BrE: /straɪks/</li>
<li>NAmE: /straɪks/</li>
</ul></li>
<li>past simple <strong>struck</strong>
<ul>
<li>BrE: /strʌk/</li>
<li>NAmE: /strʌk/</li>
</ul></li>
<li>past participle <strong>struck</strong>
<ul>
<li>BrE: /strʌk/</li>
<li>NAmE: /strʌk/</li>
</ul></li>
<li>-ing form <strong>striking</strong>
<ul>
<li>BrE: /ˈstraɪkɪŋ/</li>
<li>NAmE: /ˈstraɪkɪŋ/</li>
</ul></li>
</ul>
<h2 id="explanation">Explanation</h2>
<h3 id="section"><mark class="label primary">hit somebody/something 击打；碰撞</mark></h3>
<ol type="1">
<li><p><strong><mark class="label ">B2</mark></strong> [transitive, intransitive]
(<em>formal</em>) to hit somebody/something hard or with force
撞；碰；撞击；碰撞</p>
<span id="more"></span>
<ul>
<li><strong>strike somebody/something</strong> <em>The ship struck a
rock.</em> 船触礁了。</li>
<li><em>The child ran into the road and was <strong>struck by a
car</strong>.</em> 孩子跑到公路上给车撞了。</li>
<li><em>The tree was <strong>struck by lightning</strong>.</em>
树遭到雷击。</li>
<li><em>Warplanes struck several targets in the city.</em>
战机轰炸了城市里的几个目标。</li>
<li><strong>strike somebody/something + adv./prep.</strong> <em>He fell,
striking his head on the edge of the table.</em>
他摔倒了，头碰在桌子边上。</li>
<li><em>He was struck in the head by a bullet.</em>
他被子弹击中头部。</li>
<li><em>The stone struck her on the forehead.</em>
那块石头击中她的额头。</li>
<li><strong>strike against something</strong> <em>The oar struck against
something hard.</em> 桨重重地砸在了一件硬东西上。</li>
</ul>
<details class="note primary"><summary><p>Synonyms <strong>hit</strong></p>
</summary>
<p>knock | bang | strike | bump | bash</p>
<p>These words all mean to come against something with a lot of
force.</p>
<ul>
<li><strong>hit</strong> to come against somebody/​something with force,
especially causing damage or injury:
<ul>
<li><em>The boy was hit by a speeding car.</em>
男孩被超速行驶的汽车撞倒了。</li>
</ul></li>
<li><strong>knock</strong> to hit something so that it moves or breaks;
to put somebody/​something into a particular state or position by hitting
them/​it:
<ul>
<li><em>Someone had knocked a hole in the wall.</em>
有人在墙上打了个洞。</li>
</ul></li>
<li><strong>bang</strong> to hit something in a way that makes a loud
noise:
<ul>
<li><em>The baby was banging the table with his spoon.</em>
婴孩用调羹敲打着桌子。</li>
</ul></li>
<li><strong>fling</strong> to throw somebody/​something somewhere with a
lot of force, especially because you are angry or in a hurry:
<ul>
<li><em>She flung the letter down onto the table.</em>
她把信摔在桌子上。</li>
</ul></li>
<li><strong>strike</strong> (<em>formal</em>) to hit somebody/​something
hard: 指猛烈地撞、碰、撞击、碰撞：
<ul>
<li><em>The ship struck a rock.</em> 船触礁了。</li>
</ul></li>
<li><strong>bump</strong> to hit somebody/​something by accident:
<ul>
<li><em>In the darkness I bumped into a chair.</em>
我在黑暗中撞上了一把椅子。</li>
</ul></li>
<li><strong>bash</strong> (<em>informal</em>) to hit against something
very hard: 指猛击、猛撞：
<ul>
<li><em>I braked too late, bashing into the car in front.</em>
我刹车太晚，撞上了前面的车。</li>
</ul></li>
<li>Patterns
<ul>
<li>to hit/​knock/​bang/​bump/​bash <strong>against</strong>
somebody/​something</li>
<li>to knock/​bang/​bump/​bash <strong>into</strong>
somebody/​something</li>
<li>to hit/​strike the <strong>ground/​floor/​wall</strong></li>
</ul></li>
</ul>

</details>
<details class="note primary"><summary><p>Oxford Collocations Dictionary</p>
</summary>
<ul>
<li><strong>adverb</strong>
<ul>
<li>firmly</li>
<li>hard</li>
<li>deep</li>
<li>…</li>
</ul></li>
<li><strong>verb + strike</strong>
<ul>
<li>be about to</li>
<li>be going to</li>
<li>be ready to</li>
<li>…</li>
</ul></li>
<li><strong>preposition</strong>
<ul>
<li>against</li>
<li>at</li>
<li>on</li>
<li>…</li>
</ul></li>
<li><strong>phrases</strong>
<ul>
<li>be struck by lightning</li>
<li>get struck by lightning</li>
<li>be struck down by something</li>
<li>…</li>
</ul></li>
</ul>

</details></li>
<li><p><strong><mark class="label ">B2</mark></strong> [transitive] (<em>formal</em>) to
hit somebody/something with your hand or a weapon 打；击</p>
<ul>
<li><strong>strike somebody/something</strong> <em>She struck him in the
face.</em> 她掴了他一记耳光。</li>
<li><em>He struck the table with his fist.</em> 他用拳头打桌子。</li>
<li><em>Who struck the first blow</em> (= started the fight)?
是谁先动手的？</li>
<li><em>Did she ever strike you?</em> 她打过你吗？</li>
<li><strong>strike somebody/something sth</strong> He struck her two
blows on the leg. 他在她腿上打了两下。</li>
</ul>
<details class="note primary"><summary><p>Oxford Collocations Dictionary</p>
</summary>
<ul>
<li><strong>adverb</strong>
<ul>
<li>firmly</li>
<li>hard</li>
<li>deep</li>
<li>…</li>
</ul></li>
<li><strong>verb + strike</strong>
<ul>
<li>be about to</li>
<li>be going to</li>
<li>be ready to</li>
<li>…</li>
</ul></li>
<li><strong>preposition</strong>
<ul>
<li>against</li>
<li>at</li>
<li>on</li>
<li>…</li>
</ul></li>
<li><strong>phrases</strong>
<ul>
<li>be struck by lightning</li>
<li>get struck by lightning</li>
<li>be struck down by something</li>
<li>…</li>
</ul></li>
</ul>

</details></li>
</ol>
<h3 id="section-1"><mark class="label primary">kick/hit ball 踢球；击球</mark></h3>
<ol start="3" type="1">
<li><p>[transitive] <strong>strike something (+ adv./prep.)</strong>
(<em>formal</em>) to hit or kick a ball, etc. 击打，踢（球等）</p>
<ul>
<li><em>He walked up to the penalty spot and struck the ball firmly into
the back of the net.</em> 他走到罚球点，稳稳地把球踢入网内。</li>
</ul></li>
</ol>
<h3 id="section-2"><mark class="label primary">attack 攻击</mark></h3>
<ol start="4" type="1">
<li><p><strong><mark class="label ">B2</mark></strong> [intransitive] to attack
somebody/something, especially suddenly 突击；攻击</p>
<ul>
<li><em>The lion crouched ready to strike.</em> 狮子蹲身准备袭击。</li>
<li><em>Police fear that the killer may strike again.</em>
警方担心杀人犯可能再次下手。</li>
<li><em>The guerrillas struck with deadly force.</em>
游击队发起强势进攻。</li>
</ul>
<p><strong>Topics</strong> <a href="https://www.oxfordlearnersdictionaries.com/topic/war-and-conflict?level=b2">War
and conflict</a> <strong><mark class="label ">B2</mark></strong></p>
<details class="note primary"><summary><p>Oxford Collocations Dictionary</p>
</summary>
<ul>
<li><strong>adverb</strong>
<ul>
<li>firmly</li>
<li>hard</li>
<li>deep</li>
<li>…</li>
</ul></li>
<li><strong>verb + strike</strong>
<ul>
<li>be about to</li>
<li>be going to</li>
<li>be ready to</li>
<li>…</li>
</ul></li>
<li><strong>preposition</strong>
<ul>
<li>against</li>
<li>at</li>
<li>on</li>
<li>…</li>
</ul></li>
<li><strong>phrases</strong>
<ul>
<li>be struck by lightning</li>
<li>get struck by lightning</li>
<li>be struck down by something</li>
<li>…</li>
</ul></li>
</ul>

</details></li>
</ol>
<h3 id="section-3"><mark class="label primary">of disaster/disease 灾难；疾病</mark></h3>
<ol start="5" type="1">
<li><p><strong><mark class="label ">B2</mark></strong> [intransitive, transitive] to
happen suddenly and have a harmful or damaging effect on
somebody/something 侵袭；爆发</p>
<ul>
<li><em>Two days later <strong>tragedy struck</strong>.</em>
两天后悲剧发生了。</li>
<li><em><strong>Disaster struck</strong> again when their best player
was injured.</em> 灾难又一次发生了，他们最好的队员受伤了。</li>
<li><strong>strike somebody/something</strong> <em>The area was struck
by an outbreak of cholera.</em> 那一地区爆发了霍乱。</li>
</ul>
<details class="note primary"><summary><p>Extra Examples</p>
</summary>
<ul>
<li><em>A hurricane is about to strike Jamaica.</em>
飓风即将袭击牙买加。</li>
<li><em>Earthquakes can strike without warning.</em>
地震可能没有任何预兆就发生。</li>
<li><em>The disease first struck her 10 years ago.</em>
这种疾病第一次袭击她是在 10 年前。</li>
</ul>

</details></li>
</ol>
<h3 id="section-4"><mark class="label primary">thought/idea/impression 想法；念头；印象</mark></h3>
<ol start="6" type="1">
<li><p><strong><mark class="label ">B2</mark></strong> [transitive] (not used in the
progressive tenses 不用于进行时) (of a thought or an idea 想法或念头) to
come into somebody’s mind suddenly 突然想到；一下子想起；猛地意识到</p>
<ul>
<li><strong>strike somebody</strong> <em>An awful thought has just
struck me.</em> 刚才我脑子里突然闪过一个可怕的念头。</li>
<li><em>I was struck by her resemblance to my aunt.</em>
我猛然发现她长得跟我姑姑很像。</li>
<li><em>One thing that really struck me was how calm he appeared.</em>
他看起来如此平静，着实给我留下了深刻印象。</li>
<li><strong>it strikes somebody how, what, etc…</strong> <em>It suddenly
struck me how we could improve the situation.</em>
我一下子明白我们如何能改善局面了。</li>
</ul>
<details class="note primary"><summary><p>Oxford Collocations Dictionary</p>
</summary>
<ul>
<li><strong>adverb</strong>
<ul>
<li>immediately</li>
<li>suddenly</li>
<li>just</li>
<li>…</li>
</ul></li>
<li><strong>preposition</strong>
<ul>
<li>as</li>
</ul></li>
</ul>

</details></li>
<li><p><strong><mark class="label ">B2</mark></strong> [transitive] to give somebody a
particular impression 给（某人以…）印象；让（某人）觉得</p>
<ul>
<li><strong>strike somebody</strong> <em>Another part of his comment
struck me.</em> 他评论的另一部分打动了我。</li>
<li><strong>strike somebody as something</strong> <em>His reaction
struck me as odd.</em> 他的反应令我诧异。</li>
<li><em>She strikes me as a very efficient person.</em>
在我眼里，她是个很干练的人。</li>
<li><em>How does the idea strike you</em>? 你觉得这个主意怎么样？</li>
<li><strong>it strikes somebody that…</strong> <em>It strikes me that
nobody is really in favour of the changes.</em>
我觉得没人真正赞成这些变动。</li>
</ul>
<details class="note primary"><summary><p>Extra Examples</p>
</summary>
<ul>
<li><em>He always struck me as being rather stupid.</em>
他总是让我感觉傻乎乎的。</li>
<li><em>It struck me as strange that there was no one there.</em>
那里空无一人，我感到有些奇怪</li>
</ul>

</details>
<details class="note primary"><summary><p>Oxford Collocations Dictionary</p>
</summary>
<ul>
<li><strong>adverb</strong>
<ul>
<li>immediately</li>
<li>suddenly</li>
<li>just</li>
<li>…</li>
</ul></li>
<li><strong>preposition</strong>
<ul>
<li>as</li>
</ul></li>
</ul>

</details></li>
</ol>
<h3 id="section-5"><mark class="label primary">of workers 工人</mark></h3>
<ol start="8" type="1">
<li><p><strong><mark class="label ">B2</mark></strong> [intransitive] to refuse to work
because of an argument over pay or conditions 罢工</p>
<ul>
<li><em>Over 100,000 civil servants are set to strike on Tuesday.</em>
10 万多名公务员确定要在星期二举行罢工。</li>
<li><strong>strike over something</strong> <em>Drivers are threatening
to strike over pay.</em> 司机们威胁要就工资问题举行罢工。</li>
<li><strong>strike for something</strong> <em>The union has voted to
strike for a pay increase of 6%.</em> 工会投票决定罢工，要求加薪
6%。</li>
<li><em>Striking workers picketed the factory.</em>
罢工的工人在工厂附近设置了纠察队</li>
</ul>
<details class="note primary"><summary><p>Wordfinder</p>
</summary>
<p>ballot | closed shop | collective bargaining | industrial action |
labour | picket | protest | representative | strike | union</p>

</details>
<p><strong>Topics</strong> <a href="https://www.oxfordlearnersdictionaries.com/topic/social-issues?level=b2">Social
issues</a> <strong><mark class="label ">B2</mark></strong>, <a href="https://www.oxfordlearnersdictionaries.com/topic/working-life?level=b2">Working
life</a> <strong><mark class="label ">B2</mark></strong></p>
<details class="note primary"><summary><p>Oxford Collocations Dictionary</p>
</summary>
<ul>
<li><strong>verb + strike</strong>
<ul>
<li>threaten to</li>
<li>vote to</li>
<li>be set to</li>
<li>…</li>
</ul></li>
<li><strong>preposition</strong>
<ul>
<li>against</li>
<li>for</li>
<li>in protest at</li>
<li>…</li>
</ul></li>
<li><strong>phrases</strong>
<ul>
<li>the right to strike</li>
</ul></li>
</ul>

</details></li>
</ol>
<h3 id="section-6"><mark class="label primary">of light 光</mark></h3>
<ol start="9" type="1">
<li><p>[transitive] <strong>strike something</strong> to fall on a
surface 照在…上；照射</p>
<ul>
<li><em>The windows sparkled as the sun struck the glass.</em>
阳光照得玻璃窗熠熠闪光。</li>
</ul></li>
</ol>
<h3 id="section-7"><mark class="label primary">dumb/deaf/blind 哑；聋；瞎</mark></h3>
<ol start="10" type="1">
<li><p>[transitive] <strong>strike somebody + adj.</strong> [usually
passive] to put somebody suddenly into a particular state
顿时使处于某状态</p>
<ul>
<li><em>to be struck dumb/deaf/blind</em>
一时什么也说不出／听不见／看不见</li>
</ul></li>
</ol>
<h3 id="section-8"><mark class="label primary">match 火柴</mark></h3>
<ol start="11" type="1">
<li><p>[transitive, intransitive] <strong>strike (something)</strong> to
rub something such as a match against a surface so that it produces a
flame; to produce a flame when rubbed against a rough surface
擦，划（火柴）；击出（火星）</p>
<ul>
<li><em>to strike a match on a wall</em> 在墙上擦火柴</li>
<li><em>The sword struck sparks off the stone floor.</em>
剑砍在石头地板上，火星飞溅。</li>
<li><em>The matches were damp and he couldn’t make them strike.</em>
火柴受潮了，他划不着。</li>
</ul></li>
</ol>
<h3 id="section-9"><mark class="label primary">of clock 钟</mark></h3>
<ol start="12" type="1">
<li><p>[intransitive, transitive] to show the time by making a ringing
noise, etc. 敲；鸣；报时</p>
<details class="note primary"><summary><p><strong>synonym</strong> chime</p>
</summary>
<ul>
<li>BrE: /tʃaɪm/</li>
<li>NAmE: /tʃaɪm/</li>
</ul>
<p>[intransitive, transitive] (of a bell or a clock 铃或时钟) to ring;
to show the time by making a ringing sound 鸣响；敲响；报时</p>
<ul>
<li><em>I heard the clock chime.</em> 我听见钟响报时。</li>
<li><em>Eight o’clock had already chimed.</em> 已敲过八点钟了。</li>
<li><strong>chime something</strong> <em>The clock chimed midday.</em>
时钟响过正午十二点。</li>
</ul>

</details>
<ul>
<li><em>Did you hear the clock strike?</em> 你听见钟响了吗？</li>
<li><em>Four o’clock had just struck.</em> 那时候时钟刚刚敲过4点。</li>
<li><strong>strike something</strong> <em>The clock has just struck
three.</em> 时钟刚刚敲过三点。</li>
</ul></li>
</ol>
<h3 id="section-10"><mark class="label primary">make sound 发出声音</mark></h3>
<ol start="13" type="1">
<li><p>[transitive] <strong>strike something</strong> to produce a
musical note, sound, etc. by pressing a key or hitting something
弹奏；奏响；发出（声音）</p>
<ul>
<li><em>She struck a chord on the piano and the children began to
sing.</em> 她在钢琴上奏出和弦，孩子们开始唱歌。</li>
</ul>
<details class="note primary"><summary><p>Oxford Collocations Dictionary</p>
</summary>
<ul>
<li><strong>adverb</strong>
<ul>
<li>firmly</li>
<li>hard</li>
<li>deep</li>
<li>…</li>
</ul></li>
<li><strong>verb + strike</strong>
<ul>
<li>be about to</li>
<li>be going to</li>
<li>be ready to</li>
<li>…</li>
</ul></li>
<li><strong>preposition</strong>
<ul>
<li>against</li>
<li>at</li>
<li>on</li>
<li>…</li>
</ul></li>
<li><strong>phrases</strong>
<ul>
<li>be struck by lightning</li>
<li>get struck by lightning</li>
<li>be struck down by something</li>
<li>…</li>
</ul></li>
</ul>

</details></li>
</ol>
<h3 id="section-11"><mark class="label primary">gold/oil, etc. 金、石油等</mark></h3>
<ol start="14" type="1">
<li><p>[transitive] <strong>strike something</strong> to discover gold,
oil, etc. by digging or drilling 开采出；钻探到</p>
<ul>
<li><em>They had struck oil!</em> 他们开采出了石油！</li>
</ul></li>
</ol>
<h3 id="section-12"><mark class="label primary">go with purpose 有目的地走</mark></h3>
<ol start="15" type="1">
<li><p>[intransitive] <strong>strike + adv./prep.</strong> to go
somewhere with great energy or purpose 行进；加劲走</p>
<ul>
<li><em>We left the road and <strong>struck off</strong> across the
fields.</em> 我们下了公路，穿过旷野往前走。</li>
<li><em>He <strong>struck out</strong></em> (= started swimming)
<em>towards the shore.</em> 他朝岸边游去。</li>
<li><em>The German army struck deep into northern France.</em>
德国军队深入法国北方实施打击。</li>
</ul></li>
</ol>
<h2 id="word-origin">Word Origin</h2>
<p>Old English <em>strīcan</em> ‘go, flow’ and ‘rub lightly’, of West
Germanic origin; related to German <em>streichen</em> ‘to stroke’, also
to <strong>stroke</strong>. The sense ‘deliver a blow’ dates from Middle
English.</p>
<h2 id="idioms">Idioms</h2>
<ul>
<li><p><strong>be struck by/on/with somebody/something</strong></p>
<p>(<em>informal</em>) to be impressed or interested by
somebody/something; to like somebody/something very much
被某人（或某物）打动；迷恋某人（或某物）</p>
<ul>
<li><em>I was struck by her youth and enthusiasm.</em>
她年轻热情，把我迷住了。</li>
<li><em>We’re not very struck on that new restaurant.</em>
我们不大看得上那家新餐馆。.</li>
</ul>
<details class="note primary"><summary><p>Extra Examples</p>
</summary>
<ul>
<li><em>I was particularly struck by the sound of the birds.</em>
鸟的叫声尤其让我印象深刻。</li>
<li><em>Joan was struck quite forcibly by the silence.</em>
那种静默给琼留下了深刻的印象。</li>
</ul>

</details></li>
<li><p><strong>drive/strike a hard bargain</strong></p>
<p>to argue in an aggressive way and force somebody to agree on the best
possible price or arrangement 狠狠地杀价</p>
<p><strong>Topics</strong> <a href="https://www.oxfordlearnersdictionaries.com/topic/discussion-and-agreement?level=c2">Discussion
and agreement</a> <strong><mark class="label ">C2</mark></strong></p></li>
<li><p><strong>hit/strike home</strong></p>
<p>if a remark, etc. <strong>hits/strikes home</strong>, it has a strong
effect on somebody, in a way that makes them realize what the true facts
of a situation are （言语等）正中要害，说到点子上</p>
<ul>
<li><em>Her face went pale as his words hit home.</em>
他的话切中要害，她的脸变白了。</li>
</ul></li>
<li><p><strong>hit/strike pay dirt</strong></p>
<p>(<em>informal</em>) to suddenly be in a successful situation,
especially one that makes you rich 骤然成功；暴富</p>
<ul>
<li><em>The band really hit pay dirt with their last album.</em>
这个乐队的上一张专辑确实很畅销。</li>
</ul>
<p><strong>Topics</strong> <a href="https://www.oxfordlearnersdictionaries.com/topic/success?level=c2">Success</a>
<strong><mark class="label ">C2</mark></strong></p></li>
<li><p><strong>hit/strike the right/wrong note</strong></p>
<p>(<em>especially British English</em>) to do, say or write something
that is suitable/not suitable for a particular occasion
做（或说、写）得得体／不得体</p>
<ul>
<li><em>It is a bizarre tale and the author hits just the right note of
horror and disbelief.</em>
这是一个离奇的故事，作者恰到好处地表达了恐惧和怀疑。</li>
<li><em>Unfortunately, the president struck the wrong note in his
speech, ignoring the public mood.</em>
不幸的是，总统在他的演讲中打错了音，忽略了公众的情绪。</li>
</ul></li>
<li><p><strong>hit/strike the woodwork</strong></p>
<p>(<em>British English, informal</em>) to hit the wooden frame of the
goal in the game of football (soccer), instead of scoring a goal
交好运</p>
<ul>
<li><em>She hit the woodwork twice before scoring.</em>
得分前她击中了两次门框。</li>
</ul></li>
<li><p><strong>lightning never strikes (in the same place)
twice</strong></p>
<p>(<em>saying</em>) an unusual or unpleasant event is not likely to
happen in the same place or to the same people twice
倒霉的事不可能在同一场所（或同一人身上）重复发生；一事不过二</p></li>
<li><p><strong>sound/strike a note (of something)</strong></p>
<p>to express feelings or opinions of a particular kind
表达某种情感（或观点）</p>
<ul>
<li><em>She sounded a note of warning in her speech.</em>
她在讲话中透出了警告的意味。</li>
<li><em>The touch of cynicism struck a slightly sour note.</em>
冷嘲热讽的味道略带酸味。</li>
</ul>
<details class="note primary"><summary><p>Extra Examples</p>
</summary>
<ul>
<li><em>He sounded a cautionary note.</em>
他的声音带有一种提醒的意味。</li>
<li><em>His opening remarks struck the right note.</em>
他的开幕词讲得十分得体。</li>
</ul>

</details>
<p><strong>Topics</strong> <a href="https://www.oxfordlearnersdictionaries.com/topic/opinion-and-argument?level=c2">Opinion
and argument</a> <strong><mark class="label ">C2</mark></strong></p></li>
<li><p><strong>strike a balance (between A and B)</strong></p>
<p>to manage to find a way of being fair to two things that are opposed
to each other; to find an acceptable position that is between two things
（在对立二者之间）找到折中办法；平衡（对立的双方）</p>
<ul>
<li><em>We need to strike a balance between these conflicting
interests.</em> 我们需要在这些利益冲突中找到平衡。</li>
</ul></li>
<li><p><strong>strike a bargain/deal (with
somebody/something)</strong></p>
<p>to make an agreement with somebody in which both sides have an
advantage 达成（对双方都有利的）协议</p>
<ul>
<li><em>Perhaps we could strike a bargain.</em>
也许我们可以达成协议。</li>
<li><em>The United States has struck a historic deal with India.</em>
美国与印度达成了一项历史性协议。</li>
</ul>
<p><strong>Topics</strong> <a href="https://www.oxfordlearnersdictionaries.com/topic/discussion-and-agreement?level=c2">Discussion
and agreement</a> <strong><mark class="label ">C2</mark></strong></p></li>
<li><p><strong>strike a blow for/against/at something</strong></p>
<p>to do something in support of/against a belief, principle, etc.
维护（或损害）某种信念或原则等</p>
<ul>
<li><em>He felt that they had struck a blow for democracy.</em>
他感觉他们维护了民主制度。</li>
</ul></li>
<li><p><strong>strike/touch a chord (with somebody)</strong></p>
<p>to say or do something that makes people feel sympathy or enthusiasm
引起同情（或共鸣）</p>
<ul>
<li><em>The speaker had obviously struck a chord with his audience.</em>
讲演者显然已引起了听众的共鸣。</li>
</ul></li>
<li><p><strong>strike fear, etc. into somebody/sb’s heart</strong></p>
<p>(<em>formal</em>) to make somebody be afraid, etc.
使某人感到恐惧等</p>
<ul>
<li><em>The sound of gunfire struck fear into the hearts of the
villagers.</em> 炮声使村民心惊胆战。</li>
</ul></li>
<li><p><strong>strike gold</strong></p>
<p>to find or do something that brings you a lot of success or money
打开成功（或财富）之门；踏上通往成功（或财富）之路</p>
<ul>
<li><em>He has struck gold with his latest novel.</em>
他凭借最新的一部小说叩开了成功之门。</li>
</ul>
<p><strong>Topics</strong> <a href="https://www.oxfordlearnersdictionaries.com/topic/success?level=c2">Success</a>
<strong><mark class="label ">C2</mark></strong></p></li>
<li><p><strong>strike/hit home</strong></p>
<p>if a remark, etc. strikes/hits home, it has a strong effect on
somebody, in a way that makes them realize what the true facts of a
situation are （言语等）正中要害，说到点子上</p>
<ul>
<li><em>His face went pale as her words struck home.</em>
当她的话击中要害时，他的脸色变得苍白。</li>
</ul></li>
<li><p><strong>strike it rich</strong></p>
<p>(<em>informal</em>) to get a lot of money, especially suddenly or
unexpectedly 暴富；（意外）发大财</p></li>
<li><p><strong>strike (it) lucky</strong></p>
<p>(<em>informal</em>) to have good luck 交好运</p>
<ul>
<li><em>We certainly struck it lucky with the weather.</em>
我们真幸运，遇上了好天气。</li>
</ul></li>
<li><p><strong>strike a nerve (with somebody)</strong></p>
<p>to have a strong effect （言语等）正中要害，说到点子上</p>
<ul>
<li><em>His work strikes a nerve with people who are attracted to
nostalgia.</em> 他的作品触动了怀旧人群的神经。</li>
<li><em>It seems I struck a nerve with my last post about cell
phones.</em> 我上一篇关于手机的帖子似乎触动了我的神经。</li>
<li><em>Nissan may well strike a popular nerve here.</em>
日产汽车很可能会触动这里的一根大众神经。</li>
</ul></li>
<li><p><strong>strike/hit pay dirt</strong></p>
<p>(<em>informal</em>) to suddenly be in a successful situation,
especially one that makes you rich 骤然成功；暴富</p>
<ul>
<li><em>The band really struck pay dirt with their last album.</em>
这个乐队的上一张专辑确实赚了不少钱。</li>
</ul>
<p><strong>Topics</strong> <a href="https://www.oxfordlearnersdictionaries.com/topic/success?level=c2">Success</a>
<strong><mark class="label ">C2</mark></strong></p></li>
<li><p><strong>strike a pose/an attitude</strong></p>
<p>to hold your body in a particular way to create a particular
impression 摆出某种姿态</p>
<ul>
<li><em>to strike a dramatic pose</em> 摆出戏剧性的姿势</li>
<li><em>(figurative) He strikes an attitude of bravery and lonely
defiance.</em> 他表现出勇敢和孤独的反抗态度。</li>
</ul></li>
<li><p><strong>strike/hit the right/wrong note</strong></p>
<p>(<em>especially British English</em>) to do, say or write something
that is suitable/not suitable for a particular occasion
做（或说、写）得得体／不得体</p>
<ul>
<li><em>It is a bizarre tale and the author strikes just the right note
of horror and disbelief.</em>
这是一个离奇的故事，作者恰到好处地表达了恐惧和怀疑。</li>
</ul></li>
<li><p><strong>strike while the iron is hot</strong></p>
<p>(<em>saying</em>) to make use of an opportunity immediately
趁热打铁</p></li>
<li><p><strong>within striking distance (of something)</strong></p>
<p>near enough to be reached or attacked easily; near enough to reach or
attack something easily 近在咫尺；在攻击距离之内</p>
<ul>
<li><em>The beach is within striking distance.</em> 海滩近在咫尺。</li>
<li><em>The cat was now within striking distance of the duck.</em>
此时，猫就在可攻击鸭子的距离内。</li>
</ul></li>
</ul>
<h2 id="phrasal-verbs">Phrasal Verbs</h2>
<h3 id="strike-at">strike at</h3>
<ul>
<li><p><strong>strike at somebody/something</strong></p>
<ol type="1">
<li><p>to try to hit somebody/something, especially with a weapon
朝…打去</p>
<ul>
<li><em>He struck at me repeatedly with a stick.</em>
他拿着棍子一再朝我打过来。</li>
</ul></li>
<li><p>to cause damage or have a serious effect on somebody/something
损害；有损于；严重影响到</p>
<ul>
<li><em>to strike at the root of the problem</em>
从根源入手解决问题</li>
<li><em>criticisms that <strong>strike at the heart of</strong> the
party’s policies</em> 直指该党政策之要害的批评意见</li>
</ul></li>
</ol></li>
</ul>
<h3 id="strike-back">strike back</h3>
<ul>
<li><p><strong>strike back (at/against somebody)</strong></p>
<p>to try to harm somebody in return for an attack or injury you have
received 反击；回击</p></li>
</ul>
<h3 id="strike-down">strike down</h3>
<ul>
<li><p><strong>strike somebody down</strong> [usually passive]</p>
<ol type="1">
<li><p>(of a disease, etc.疾病等) to make somebody seriously ill; to
kill somebody 摧垮；使病倒；使丧命</p>
<ul>
<li><em>He was struck down by cancer at the age of thirty.</em>
他三十岁那年被癌症夺去了性命。</li>
<li><em>He was struck down with food poisoning.</em>
他因食物中毒卧床不起。</li>
</ul></li>
<li><p>to hit somebody very hard, so that they fall to the ground
击倒，撞倒（某人）</p></li>
</ol></li>
<li><p><strong>strike something ↔︎ down</strong></p>
<p>(<em>especially North American English</em>) to decide that a law is
illegal and should not apply 取消，撤销（法规）</p>
<ul>
<li><em>The Supreme Court struck down a Texas state law.</em>
最高法院撤销了得克萨斯州的一条法律。</li>
<li><em>The law was struck down as unconstitutional.</em>
这项法律因违宪而被否决。</li>
</ul></li>
</ul>
<h3 id="strike-off">strike off</h3>
<ul>
<li><p><strong>strike something ↔︎ off</strong></p>
<p>to remove something with a hard hit; to cut something off
打掉；砍掉；砍下</p>
<ul>
<li><em>He struck off the rotten branches with an axe.</em>
他用斧子把枯树枝砍掉。</li>
</ul></li>
<li><p><strong>strike somebody/something off (something)</strong></p>
<p>(also <strong>strike somebody/something from something</strong>)</p>
<p>to remove somebody/something’s name from something, such as the list
of members of a professional group把某人（或某事物）除名</p>
<ul>
<li><em>Strike her name off the list.</em> 把她的名字从名单上删掉。</li>
<li><em>The doctor was struck off</em> (= not allowed to continue to
work as a doctor) <em>for incompetence.</em>
那名医生因不称职而被取消了执业资格。</li>
</ul></li>
</ul>
<h3 id="strike-out">strike out</h3>
<ul>
<li><p><strong>strike out</strong></p>
<ol type="1">
<li><p>to start being independent 独立出去；自立谋生</p>
<ul>
<li>I knew it was time I struck out on my own.
我知道我该独立谋生了。</li>
</ul></li>
<li><p>(<em>North American English, informal</em>) to fail or be
unsuccessful 失败；砸锅</p>
<ul>
<li>The movie struck out and didn’t win a single Oscar.
那部影片砸锅了，奥斯卡奖一项都没得着。</li>
</ul>
<p><strong>Topics</strong> <a href="https://www.oxfordlearnersdictionaries.com/topic/difficulty-and-failure?level=c2">Difficulty
and failure</a> <strong><mark class="label ">C2</mark></strong></p></li>
</ol></li>
<li><p><strong>strike out (at somebody/something)</strong></p>
<ol type="1">
<li><p>to aim a sudden violent hit at somebody/something
（奋力朝某处）去；赶往（某处）</p>
<ul>
<li><em>He lost his temper and struck out wildly.</em>
他发了脾气，大打出手。</li>
</ul></li>
<li><p>to criticize somebody/something, especially in a public speech or
in a book or newspaper （尤指公开）抨击</p>
<ul>
<li><em>In a recent article she strikes out at her critics.</em>
她最近写了一篇文章，对批评她的人予以驳斥。</li>
</ul></li>
</ol></li>
<li><p><strong>strike out | strike somebody ↔︎ out</strong></p>
<p>(in baseball 棒球) to fail to hit the ball three times and therefore
not be allowed to continue hitting; to make somebody do this
（使）三击不中出局，三振出局</p>
<details class="note primary"><summary><p><strong>related noun</strong> strikeout</p>
</summary>
<ul>
<li>BrE: /ˈstraɪkaʊt/</li>
<li>NAmE: /ˈstraɪkaʊt/</li>
</ul>
<p>(in baseball 棒球) a situation in which the player who is supposed to
be hitting the ball has to stop because he or she has tried to hit the
ball three times and failed （三击不中） 出局；三振出局</p>

</details>
<p><strong>Topics</strong> <a href="https://www.oxfordlearnersdictionaries.com/topic/sports-ball-and-racket-sports?level=c2">Sports:
ball and racket sports</a> <strong><mark class="label ">C2</mark></strong></p></li>
<li><p><strong>strike something ↔︎ out/through</strong></p>
<p>to remove something by drawing a line through it 画掉；删去</p>
<details class="note primary"><summary><p><strong>synonym</strong> cross something ↔︎ out/through</p>
</summary>
<p>to draw a line through a word, usually because it is wrong
画掉，删掉（错字）</p>

</details>
<ul>
<li><em>The editor struck out the whole paragraph.</em>
编辑把整段全部删去了</li>
</ul></li>
</ul>
<h3 id="strike-through">strike through</h3>
<ul>
<li><p><strong>strike something ↔︎ out/through</strong></p>
<p>to remove something by drawing a line through it 画掉；删去</p>
<details class="note primary"><summary><p><strong>synonym</strong> cross something ↔︎ out/through</p>
</summary>
<p>to draw a line through a word, usually because it is wrong
画掉，删掉（错字）</p>

</details>
<ul>
<li><em>The editor struck out the whole paragraph.</em>
编辑把整段全部删去了</li>
</ul></li>
</ul>
<h3 id="strike-up">strike up</h3>
<ul>
<li><p><strong>strike up (with something) | strike up
something</strong></p>
<p>(of a band, an orchestra, etc.乐队等) to begin to play a piece of
music 开始演奏</p>
<ul>
<li><em>The orchestra struck up and the curtain rose.</em>
管弦乐队奏起音乐，幕启。</li>
<li><em>The band struck up a waltz.</em> 乐队奏起一支华尔兹舞曲。</li>
</ul></li>
<li><p><strong>strike up something (with somebody)</strong></p>
<p>to begin a friendship, a relationship, a conversation, etc.
（和某人）建立友谊，开始来往，交谈起来</p>
<ul>
<li><em>He would often strike up conversations with complete
strangers.</em> 他爱和完全不相识的人攀谈。</li>
</ul></li>
</ul>
<h1 id="noun">Noun</h1>
<h2 id="pronunciation-1">Pronunciation</h2>
<ul>
<li>BrE: /straɪk/</li>
<li>NAmE: /straɪk/</li>
</ul>
<h2 id="explanation-1">Explanation</h2>
<h3 id="section-13"><mark class="label primary">of workers 工人</mark></h3>
<ol type="1">
<li><p><strong><mark class="label ">B2</mark></strong> a period of time when an
organized group of employees of a company stops working because of an
argument over pay or conditions 罢工；罢课；罢市</p>
<ul>
<li><em>the miners’/firefighters’/teachers’ strike</em>
矿工/消防员/教师罢工</li>
<li><em>a strike by teachers</em> 教师举行的罢课</li>
<li><em>a <strong>one-day strike</strong></em> 罢工一天</li>
<li><em>an unofficial strike</em> 未经批准的罢工</li>
<li><em>Union leaders <strong>called a strike</strong>.</em>
工会领导人号召罢工。</li>
<li><em>Air traffic controllers are threatening to <strong>go on
strike</strong>.</em> 空中交通管制员威胁要罢工。</li>
<li><em>Half the workforce are now <strong>(out) on
strike</strong>.</em> 现在有半数职工罢工。</li>
<li><em>to come out on strike</em> 举行罢工</li>
<li><em>The train drivers have voted to <strong>take strike
action</strong>.</em> 火车司机投票表决采取罢工行动。</li>
<li><em>The student union has called for a <strong>rent
strike</strong></em> (= a refusal to pay rent as a protest).
学生会呼吁拒缴房租。</li>
</ul>
<details class="note primary"><summary><p><strong>see also</strong> climate strike, general strike, hunger
strike</p>
</summary>
<ul>
<li><p>climate strike</p>
<ul>
<li>BrE: /ˈklaɪmət straɪk/</li>
<li>NAmE: /ˈklaɪmət straɪk/</li>
</ul>
<p>the act of not going to school or work in order to join a public
protest to demand action against climate change
气候罢工：为了参加公众抗议而要求采取行动以应对气候变化的不上学或工作的行为</p>
<ul>
<li><em>Millions of people around the world joined the climate strike on
Friday.</em> 周五，全世界数百万人加入了气候罢工。</li>
</ul></li>
<li><p>general strike</p>
<ul>
<li>BrE: /ˌdʒenrəl ˈstraɪk/</li>
<li>NAmE: /ˌdʒenrəl ˈstraɪk/</li>
</ul>
<p>a period of time when most or all of the workers in a country go on
strike 总罢工</p></li>
<li><p>hunger strike</p>
<ul>
<li>BrE: /ˈhʌŋɡə straɪk/</li>
<li>NAmE: /ˈhʌŋɡər straɪk/</li>
</ul>
<p>[countable, uncountable] the act of refusing to eat for a long period
of time in order to protest about something 绝食（抗议）</p>
<ul>
<li><em>to <strong>be on/go on hunger strike</strong></em>
进行绝食抗议</li>
</ul></li>
</ul>

</details>
<details class="note primary"><summary><p>Extra Examples</p>
</summary>
<ul>
<li><em>More train strikes are threatened.</em>
铁路工人威胁要举行更多罢工。</li>
<li><em>The New York transit strike is in its second day.</em>
纽约公交工人的罢工进入了第二天。</li>
<li><em>The army was used to help break the strike.</em>
当局动用了军队来终止罢工。</li>
<li><em>The new government banned strikes.</em> 新政府禁止罢工。</li>
<li><em>The shipyard voted to launch a sympathy strike in support of the
machinists.</em> 造船厂投票决定举行罢工，以声援机械师。</li>
<li><em>The strike paralysed the port.</em> 罢工使港口陷于瘫痪。</li>
<li><em>The first wave of strikes began in January.</em> 第一波罢工始于
1 月份。</li>
<li><em>Miners staged a one-day strike in support of the steel
workers.</em> 矿工罢工一天以声援钢铁工人。</li>
<li><em>The union held a national strike ballot on the issue.</em>
工会就这个问题举行了全国罢工投票。</li>
</ul>

</details>
<p><strong>Topics</strong> <a href="https://www.oxfordlearnersdictionaries.com/topic/working-life?level=b2">Working
life</a> <strong><mark class="label ">B2</mark></strong>, <a href="https://www.oxfordlearnersdictionaries.com/topic/social-issues?level=b2">Social
issues</a> <strong><mark class="label ">B2</mark></strong></p>
<details class="note primary"><summary><p>Oxford Collocations Dictionary</p>
</summary>
<ul>
<li><strong>adjective</strong>
<ul>
<li>long</li>
<li>short</li>
<li>one-day</li>
<li>…</li>
</ul></li>
<li><strong>… of strikes</strong>
<ul>
<li>series</li>
<li>wave</li>
</ul></li>
<li><strong>verb + strike</strong>
<ul>
<li>be on</li>
<li>come out on</li>
<li>go on</li>
<li>…</li>
</ul></li>
<li><strong>strike + verb</strong>
<ul>
<li>occur</li>
<li>take place</li>
<li>start</li>
<li>…</li>
</ul></li>
<li><strong>strike + noun</strong>
<ul>
<li>action</li>
<li>threat</li>
<li>ballot</li>
<li>…</li>
</ul></li>
<li><strong>preposition</strong>
<ul>
<li>during a/​the strike</li>
<li>strike against</li>
<li>strike by</li>
<li>…</li>
</ul></li>
<li><strong>phrases</strong>
<ul>
<li>a ballot for a strike</li>
<li>a ballot for strike action</li>
<li>the threat of strikes</li>
<li>…</li>
</ul></li>
</ul>

</details></li>
</ol>
<h3 id="section-14"><mark class="label primary">attack 攻击</mark></h3>
<ol start="2" type="1">
<li><p><strong><mark class="label ">B2</mark></strong> a military attack, especially by
aircraft dropping bombs 军事进攻；袭击；（尤指）空袭</p>
<ul>
<li><em>They decided to launch a <strong>pre-emptive
strike</strong>.</em> 他们决定发动先发制人的攻击。</li>
<li><strong>strike against somebody/something</strong> <em>Diplomatic
efforts have averted a <strong>military strike</strong> against the
country.</em> 外交努力避免了对该国的军事打击。</li>
<li><em>The President ordered <strong>missile strikes</strong> against
them in retaliation for the earlier bombing.</em>
总统下令对他们进行导弹袭击，以报复早些时候的轰炸。</li>
</ul>
<details class="note primary"><summary><p><strong>see also</strong> air strike, first strike</p>
</summary>
<ul>
<li><p>air strike</p>
<ul>
<li>BrE: /ˈeə straɪk/</li>
<li>NAmE: /ˈer straɪk/</li>
</ul>
<p>an attack made by aircraft 空中打击；空袭</p></li>
<li><p>first strike</p>
<ul>
<li>BrE: /ˌfɜːst ˈstraɪk/</li>
<li>NAmE: /ˌfɜːrst ˈstraɪk/</li>
</ul>
<p>an attack on an enemy made before they attack you
先发制人；首先发起攻击</p>
<ul>
<li><em>the threat of a strategic first strike</em>
战略先发制人的威胁</li>
</ul></li>
</ul>

</details>
<p><strong>Topics</strong> <a href="https://www.oxfordlearnersdictionaries.com/topic/war-and-conflict?level=b2">War
and conflict</a> <strong><mark class="label ">B2</mark></strong></p>
<details class="note primary"><summary><p>Oxford Collocations Dictionary</p>
</summary>
<ul>
<li><strong>adjective</strong>
<ul>
<li>air</li>
<li>missile</li>
<li>nuclear</li>
<li>…</li>
</ul></li>
<li><strong>verb + strike</strong>
<ul>
<li>carry out</li>
<li>launch</li>
<li>make</li>
<li>…</li>
</ul></li>
<li><strong>strike + verb</strong>
<ul>
<li>force</li>
<li>aircraft</li>
</ul></li>
<li><strong>preposition</strong>
<ul>
<li>in a/​the strike</li>
<li>strike against</li>
<li>strike on</li>
<li>…</li>
</ul></li>
</ul>

</details></li>
</ol>
<h3 id="section-15"><mark class="label primary">hitting/kicking 击；踢</mark></h3>
<ol start="3" type="1">
<li><p>[usually singular] an act of hitting or kicking
something/somebody 击；打；踢</p>
<ul>
<li><em>His spectacular strike in the second half made the score
2–0.</em> 他在下半场令人叹为观止的一脚射门把比分改写为 2:0。</li>
</ul>
<details class="note primary"><summary><p><strong>see also</strong> bird strike, lightning</p>
</summary>
<ul>
<li><p>bird strike</p>
<ul>
<li>BrE: /ˈbɜːd straɪk/</li>
<li>NAmE: /ˈbɜːrd straɪk/</li>
</ul>
<p>an occasion when a bird hits an aircraft 鸟撞击飞机事故；鸟击</p>
<ul>
<li><em>The aircraft suffered multiple bird strikes immediately after
take-off.</em> 飞机起飞后立即遭到多次鸟撞。</li>
</ul></li>
<li><p>lightning</p>
<ul>
<li>BrE: /ˈlaɪtnɪŋ/</li>
<li>NAmE: /ˈlaɪtnɪŋ/</li>
</ul>
<p>[uncountable] a flash, or several flashes, of very bright light in
the sky caused by electricity闪电</p>
<ul>
<li><em>a <strong>flash of lightning</strong></em> 一道闪电</li>
<li><em>a violent storm with <strong>thunder and lightning</strong></em>
夹着雷鸣电闪的暴风雨</li>
<li><em>He was <strong>struck by lightning</strong> and killed</em>.
他被闪电击中而死。</li>
<li><em><strong>Lightning strikes</strong> caused scores of fires across
the state.</em> 雷击给整个州造成了多起火灾。</li>
</ul></li>
</ul>

</details></li>
</ol>
<h3 id="section-16"><mark class="label primary">in baseball 棒球</mark></h3>
<ol start="4" type="1">
<li><p>an unsuccessful attempt to hit the ball 击球未中</p>
<p><strong>Topics</strong> <a href="https://www.oxfordlearnersdictionaries.com/topic/sports-ball-and-racket-sports?level=c2">Sports:
ball and racket sports</a> <strong><mark class="label ">C2</mark></strong></p></li>
</ol>
<h3 id="section-17"><mark class="label primary">in bowling 保龄球</mark></h3>
<ol start="5" type="1">
<li>a situation in tenpin bowling when a player knocks down all the pins
with the first ball 全中（第一球撞倒全部十柱球）</li>
</ol>
<h3 id="section-18"><mark class="label primary">discovery of oil 石油的发现</mark></h3>
<ol start="6" type="1">
<li><p>[usually singular] a sudden discovery of something valuable,
especially oil （珍贵东西的）意外发现；（尤指石油的）发现</p>
<details class="note primary"><summary><p>Oxford Collocations Dictionary</p>
</summary>
<ul>
<li><strong>adjective</strong>
<ul>
<li>air</li>
<li>missile</li>
<li>nuclear</li>
<li>…</li>
</ul></li>
<li><strong>verb + strike</strong>
<ul>
<li>carry out</li>
<li>launch</li>
<li>make</li>
<li>…</li>
</ul></li>
<li><strong>strike + verb</strong>
<ul>
<li>force</li>
<li>aircraft</li>
</ul></li>
<li><strong>preposition</strong>
<ul>
<li>in a/​the strike</li>
<li>strike against</li>
<li>strike on</li>
<li>…</li>
</ul></li>
</ul>

</details></li>
</ol>
<h3 id="section-19"><mark class="label primary">bad thing/action 坏事；不利的行动</mark></h3>
<ol start="7" type="1">
<li><p><strong>strike (against somebody/something)</strong> (<em>North
American English</em>) a bad thing or action that damages
somebody/something’s reputation （有损声誉的）不利因素，打击</p>
<ul>
<li><em>The amount of fuel that this car uses is a big strike against
it.</em> 耗油量大是这辆车的一大缺点。</li>
</ul></li>
</ol>
<h2 id="word-origin-1">Word Origin</h2>
<p>Old English <em>strīcan</em> ‘go, flow’ and ‘rub lightly’, of West
Germanic origin; related to German <em>streichen</em> ‘to stroke’, also
to <strong>stroke</strong>. The sense ‘deliver a blow’ dates from Middle
English.</p>
<h2 id="idioms-1">Idioms</h2>
<ul>
<li><p><strong>three strikes and you’re out | the three strikes
rule</strong></p>
<p>used to describe a law that says that people who commit three crimes
will go straight to prison 三振出局法（三次犯罪即入狱的法律）</p></li>
</ul>
<h1 id="惯用法">惯用法</h1>
<ol type="1">
<li><p>A struck B 是“A 打 B 一下”。A struck <em>at</em> B 是“A 做出打 B
的动作（未必打着 B）”。</p></li>
<li><p>The idea strikes me as (<em>being</em>) original 里的 being
可有可无。</p></li>
<li><p>on strike（罢工）是英美通用的，但在美国往往说 on <em>a</em>
strike。</p></li>
</ol>
<h1 id="reference">Reference</h1>
<ol type="1">
<li><p>Diana Lea, Jennifer Bradbery. <em>Oxford Advanced Learner’s
Dictionary, 10th edition.</em> Oxford University Press, 2020.</p></li>
<li><p>Margaret Deuter, Jennifer Bradbery, Joanna Turnbull.
<em>牛津高阶英汉双解词典，第 9 版.</em> 商务印书馆, 2018.</p></li>
<li><p>葛传槼. <em>葛传槼英语惯用法词典.</em> 上海译文出版社,
2012.</p></li>
</ol>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/css/markmap.css">

<script src="/js/markmap.js"></script>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>牛津5000</tag>
        <tag>英语词汇</tag>
      </tags>
  </entry>
  <entry>
    <title>resort</title>
    <url>/posts/d69ad86a.html</url>
    <content><![CDATA[<h1 id="noun">Noun</h1>
<h2 id="pronunciation">Pronunciation</h2>
<ul>
<li>BrE: /rɪˈzɔːt/</li>
<li>NAmE: /rɪˈzɔːrt/</li>
</ul>
<h2 id="explanation">Explanation</h2>
<ol type="1">
<li><p><strong><mark class="label ">B2</mark></strong> [countable] a place where a lot of
people go on holiday 旅游胜地；度假胜地</p>
<ul>
<li><strong><em>seaside/mountain resorts</em></strong>
海滨/山区度假胜地</li>
<li><em>They spent a month at a fashionable <strong>ski resort</strong>
in Switzerland.</em> 他们在瑞士一个时尚的滑雪胜地呆了一个月。</li>
<li><em>a popular <strong>tourist resort</strong></em>
受欢迎的旅游胜地</li>
<li><em>(British English also)</em> <em>a popular <strong>holiday
resort</strong></em> 受欢迎的旅游胜地</li>
<li><em>the <strong>resort town</strong> of Byron Bay</em>
度假小镇拜伦贝城</li>
<li><em>destination resorts such as Atlantis in the Bahamas</em>
巴哈马亚特兰蒂斯之类的度假胜地</li>
</ul>
<span id="more"></span>
<details class="note primary"><summary><p>Wordfinder</p>
</summary>
<p>abroad | backpack | border | guide | passport | resort | sightseeing
| tourist | travel | visa</p>

</details>
<details class="note primary"><summary><p>Collocations <strong>Travel and tourism 旅游和旅游业</strong></p>
</summary>
<ul>
<li><strong>Holidays/​vacations 假期</strong>
<ul>
<li><strong>have/​take</strong> <em>(British English)</em> a
holiday/<em>(North American English)</em> a vacation/​a break/​a day
off/<em>(British English)</em> a gap year
休假；短期休假；休一天假；休空缺年假</li>
<li><strong>go on/​be on</strong>
holiday/​vacation/​leave/​honeymoon/​safari/​a trip/​a tour/​a cruise/​a
pilgrimage 去/在度假/休假/度蜜月/游猎/旅游/观光/乘船游览/朝圣</li>
<li><strong>go</strong> backpacking/​camping/​hitchhiking/​sightseeing
去背包旅行/露营/搭顺风车旅行/观光游览</li>
<li><strong>plan</strong> a trip/​a holiday/​a vacation/​your itinerary
计划旅行/假期/行程</li>
<li><strong>book</strong> accommodation/​a hotel room/​a flight/​tickets
预订住宿/酒店房间/航班/票</li>
<li><strong>have/​make/​cancel</strong> a reservation/(<em>especially
British English)</em> booking 预订；取消预订</li>
<li><strong>rent</strong> a villa/<em>(both British English)</em> a
holiday home/​a holiday cottage
租一座度假别墅/一个度假住所/一座度假小别墅</li>
<li><em>(especially British English)</em> <strong>hire/</strong>
<em>(especially North American English)</em> <strong>rent</strong> a
car/​bicycle/​moped 租借一辆汽车/自行车/摩托自行车</li>
<li><strong>stay in</strong> a hotel/​a bed and breakfast/​a youth
hostel/​a villa/<em>(both British English)</em> a holiday home/​a caravan
住在酒店/提供住宿和早餐的旅馆/青年旅舍/度假别墅/度假住所/旅行拖车里</li>
<li><strong>cost/​charge $100 a/​per night for</strong> a
single/​double/​twin/​standard/<em>(British English)</em> en suite room
单人房/双人房/标间/套房一晚花费/要价 100 美元</li>
<li><strong>check into/​out of</strong> a hotel/​a motel/​your room
入住/结账离开酒店/汽车旅馆/房间</li>
<li><strong>pack/​unpack</strong> your suitcase/​bags
把东西装进手提箱/旅行包；取出手提箱/旅行包里的东西</li>
<li><strong>call/​order</strong> room service 打电话叫/叫客房服务</li>
<li><strong>cancel/​cut short</strong> a trip/​holiday/​vacation
取消/缩短旅程/假期</li>
</ul></li>
<li><strong>Foreign travel 出国旅行</strong>
<ul>
<li><strong>apply for/​get/​renew</strong> a/​your passport
申请/拿到/续签护照</li>
<li><strong>take out/​buy/​get</strong> travel insurance
获得/购买/取得旅游保险</li>
<li><strong>catch/​miss</strong> your plane/​train/​ferry/​connecting flight
赶上/错过飞机/火车/渡船/转乘航班</li>
<li><strong>fly (in)/travel in</strong> business/​economy class
乘坐商务/经济舱飞行/旅行</li>
<li><strong>make/​have</strong> a brief/​two-day/​twelve-hour
stopover/<em>(North American English also)</em> layover in Hong Kong
在香港作短暂的/两天的/十二小时的中途停留</li>
<li><strong>experience/​cause/​lead</strong> to delays
遇上/引起/导致延误</li>
<li><strong>check (in)/collect/​get/​lose</strong> (your) <em>(especially
British English)</em> luggage/<em>(especially North American
English)</em> baggage 托运/取/弄丢行李</li>
<li><strong>be charged for/​pay</strong> excess baggage
被收取/支付超重行李费</li>
<li><strong>board/​get on/​leave/​get off</strong> the
aircraft/​plane/​ship/​ferry 上/下飞机/船/渡船</li>
<li><strong>taxi down/​leave/​approach/​hit/​overshoot</strong> the runway
在跑道上滑行；离开/接近/降落在/冲出跑道</li>
<li><strong>experience/​hit/​encounter</strong> severe turbulence
遇到强烈的气流</li>
<li><strong>suffer from/​recover from/​get over</strong> your jet
lag/​travel sickness
遭受时差反应/晕车；从时差反应/晕车恢复过来；克服时差反应/晕车</li>
</ul></li>
<li><strong>The tourist industry 旅游业</strong>
<ul>
<li><strong>attract/​draw/​bring</strong> tourists/​visitors 吸引游客</li>
<li><strong>encourage/​promote/​hurt</strong> tourism
鼓励/促进/损害旅游业</li>
<li><strong>promote/​develop</strong> ecotourism 促进/发展生态旅游</li>
<li><strong>build/​develop/​visit</strong> a
tourist/​holiday/<em>(especially British English)</em> seaside/​beach/​ski
resort 建立/开发/参观旅游/假日/海滨/海滩/滑雪胜地</li>
<li><strong>work for/​be operated by</strong> a major hotel chain
就职于一家大型连锁酒店；由一家大型连锁酒店经营</li>
<li><strong>be served by/​compete with</strong> low-cost/<em>(especially
North American English)</em> low-fare/​budget airlines
由廉价航空公司提供服务；与廉价航空公司竞争</li>
<li><strong>book something through/​make a booking through/​use</strong> a
travel agent 通过旅行社预订；经旅行社代办</li>
<li><strong>contact/​check with</strong> your travel agent/​tour operator
联系旅行社；向旅行社咨询</li>
<li><strong>book/​be on/​go on</strong> a package deal/​holiday/​tour
预订/进行/去包价旅游</li>
<li><strong>buy/​bring back</strong> (tacky/​overpriced) souvenirs
购买/带回（低劣的/定价过高的）纪念品</li>
</ul></li>
</ul>

</details>
<p><strong>Topics</strong> <a href="https://www.oxfordlearnersdictionaries.com/topic/holidays?level=b2">Holidays</a>
<strong><mark class="label ">B2</mark></strong></p></li>
<li><p>[uncountable] resort to something the act of using something,
especially something bad or unpleasant, because nothing else is possible
诉诸；求助；采取</p>
<details class="note primary"><summary><p><strong>synonym</strong> recourse</p>
</summary>
<ul>
<li>BrE: /rɪˈkɔːs/</li>
<li>NAmE: /ˈriːkɔːrs/</li>
</ul>
<p>[uncountable] <em>(formal)</em> the fact of having to, or being able
to, use something that can provide help in a difficult
situation依靠；依赖；求助</p>
<ul>
<li><em>Your only recourse is legal action.</em>
你的唯一依靠就是诉诸法律。</li>
<li><strong>recourse to something</strong> <em>The government, when
necessary, has recourse to the armed forces.</em>
政府在必要时可以动用军队。</li>
<li><strong>without recourse to something</strong> <em>She made a
complete recovery without recourse to surgery.</em>
她未做手术就完全恢复了健康。</li>
</ul>

</details>
<ul>
<li><em>There are hopes that the conflict can be resolved without resort
to violence.</em> 冲突有望不需要诉诸武力而得到解决。</li>
</ul></li>
<li><p><strong>the first/last/final resort</strong> the first or last
course of action that you should or can take in a particular situation
应急措施；可首先（或最后）采取的手段</p>
<ul>
<li><em>Strike action should be regarded as a last resort, when all
attempts to negotiate have failed.</em>
罢工应该是最后一着，在所有的谈判努力都告失败时才使用。</li>
<li><em>In the last resort (= in the end) everyone must decide for
themselves.</em> 最后人人都得自己作决定。</li>
</ul></li>
</ol>
<h2 id="word-origin">Word Origin</h2>
<p>late Middle English (denoting something one can turn to for
assistance): from Old French <em>resortir</em>, from <em>re-</em>
‘again’ + <em>sortir</em> ‘come or go out’. The sense ‘place frequently
visited’ dates from the mid 18th cent.</p>
<h1 id="verb">Verb</h1>
<h2 id="pronunciation-1">Pronunciation</h2>
<ul>
<li>BrE: /rɪˈzɔːt/</li>
<li>NAmE: /rɪˈzɔːrt/</li>
</ul>
<h2 id="verb-forms">Verb Forms</h2>
<ul>
<li>present simple I / you / we / they <strong>resort</strong>
<ul>
<li>/rɪˈzɔːt/</li>
<li>/rɪˈzɔːrt/</li>
</ul></li>
<li>he / she / it <strong>resorts</strong>
<ul>
<li>/rɪˈzɔːts/</li>
<li>/rɪˈzɔːrts/</li>
</ul></li>
<li>past simple <strong>resorted</strong>
<ul>
<li>/rɪˈzɔːtɪd/</li>
<li>/rɪˈzɔːrtɪd/</li>
</ul></li>
<li>past participle <strong>resorted</strong>
<ul>
<li>/rɪˈzɔːtɪd/</li>
<li>/rɪˈzɔːrtɪd/</li>
</ul></li>
<li>-ing form <strong>resorting</strong>
<ul>
<li>/rɪˈzɔːtɪŋ/</li>
<li>/rɪˈzɔːrtɪŋ/</li>
</ul></li>
</ul>
<h2 id="phrasal-verbs">Phrasal Verbs</h2>
<h3 id="resort-to">resort to</h3>
<ul>
<li><p><strong>resort to something</strong></p>
<p>to make use of something, especially something bad, as a means of
achieving something, often because there is no other possible
solution诉诸；求助于；依靠</p>
<details class="note primary"><summary><p><strong>synonym</strong> recourse</p>
</summary>
<ul>
<li>BrE: /rɪˈkɔːs/</li>
<li>NAmE: /ˈriːkɔːrs/</li>
</ul>
<p>[uncountable] <em>(formal)</em> the fact of having to, or being able
to, use something that can provide help in a difficult
situation依靠；依赖；求助</p>
<ul>
<li><em>Your only recourse is legal action.</em>
你的唯一依靠就是诉诸法律。</li>
<li><strong>recourse to something</strong> <em>The government, when
necessary, has recourse to the armed forces.</em>
政府在必要时可以动用军队。</li>
<li><strong>without recourse to something</strong> <em>She made a
complete recovery without recourse to surgery.</em>
她未做手术就完全恢复了健康。</li>
</ul>

</details>
<ul>
<li><em>They felt obliged to resort to violence.</em>
他们觉得有必要诉诸暴力。</li>
<li><em>They achieved their demands without having to resort to
force.</em> 他们没有诉诸武力就实现了他们的要求。</li>
<li><em>We had to resort to another loan from the bank.</em>
我们不得不求助于银行的另一笔贷款。</li>
<li><strong>resort to doing something</strong> <em>We may have to resort
to using untrained staff.</em> 我们也许只能使用未受过训练的员工了。</li>
</ul></li>
</ul>
<h1 id="reference">Reference</h1>
<ol type="1">
<li><p>Diana Lea, Jennifer Bradbery. <em>Oxford Advanced Learner’s
Dictionary, 10th edition.</em> Oxford University Press, 2020.</p></li>
<li><p>Margaret Deuter, Jennifer Bradbery, Joanna Turnbull.
<em>牛津高阶英汉双解词典，第 9 版.</em> 商务印书馆, 2018.</p></li>
</ol>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/css/markmap.css">

<script src="/js/markmap.js"></script>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>牛津5000</tag>
        <tag>英语词汇</tag>
      </tags>
  </entry>
  <entry>
    <title>bound</title>
    <url>/posts/a50e7db6.html</url>
    <content><![CDATA[<h1 id="adjective">Adjective</h1>
<p><strong>see also <a href="https://www.oxfordlearnersdictionaries.com/definition/english/bind_1">bind</a></strong></p>
<h2 id="pronunciation">Pronunciation</h2>
<ul>
<li>BrE: /baʊnd/</li>
<li>NAmE: /baʊnd/</li>
</ul>
<h2 id="explanation">Explanation</h2>
<p>[not before noun]</p>
<ol type="1">
<li><p><strong><mark class="label ">B2</mark></strong> <strong>bound to do/be
something</strong> certain or likely to happen, or to do or be
something一定会；很可能会</p>
<ul>
<li><em>There are bound to be changes when the new system is
introduced.</em> 引进新系统后一定会发生变化。</li>
<li><em>It’s bound to be sunny again tomorrow.</em>
明天肯定又是阳光灿烂。</li>
<li><em>You’ve done so much work—you’re bound to pass the exam.</em>
你下了这么大功夫，考试准能及格。</li>
<li><em>It was bound to happen sooner or later</em> (= we should have
expected it). 这事迟早都是要发生的。</li>
<li><em>These problems were almost bound to arise.</em>
这些问题几乎注定了会出现。</li>
<li><em>You’re bound to be nervous the first time</em> (= it’s easy to
understand). 第一次总是会紧张的。</li>
</ul>
<span id="more"></span>
<details class="note primary"><summary><p>Synonyms <strong>certain</strong></p>
</summary>
<p>bound | sure | definite | guaranteed</p>
<p>These are all words describing something that will definitely happen
or is definitely true.</p>
<ul>
<li><p><strong>certain</strong> that you can rely on to happen or be
true:</p>
<ul>
<li><em>It’s certain that they will agree.</em> 他们肯定会同意。</li>
<li><em>They are certain to agree.</em> 他们肯定会同意。</li>
</ul></li>
<li><p><strong>bound</strong> [not before noun] certain to happen, or to
do or be something. 指肯定会、一定会 &gt; Bound is <strong>only used in
the phrase</strong> <em>bound to do/​be, etc.</em>: &gt; &gt; -
<em>You’ve done so much work—you’re bound to pass the exam.</em> &gt; -
<em>There are bound to be changes when the new system is
introduced.</em></p></li>
<li><p><strong>sure</strong> certain to happen or be true; that can be
trusted or relied on:</p>
<ul>
<li><em>She’s sure to be picked for the team.</em>
她肯定会入选该队。</li>
<li><em>It’s sure to rain.</em> 必定会下雨。</li>
</ul></li>
<li><p><strong>definite</strong> (<em>rather informal</em>) certain to
happen; that is not going to change:指必将发生、不会改变：</p>
<ul>
<li><em>Is it definite that he’s leaving?</em> 他肯定要离开吗？</li>
</ul></li>
<li><p><strong>strike</strong> (<em>formal</em>) to hit
somebody/​something hard: 指猛烈地撞、碰、撞击、碰撞：</p>
<ul>
<li><em>The ship struck a rock.</em> 船触礁了。</li>
</ul></li>
<li><p><strong>guaranteed</strong> certain to have a particular
result:</p>
<ul>
<li><em>That kind of behaviour is guaranteed to make him angry.</em>
那样的行为肯定会让他生气。</li>
</ul></li>
<li><p>Patterns</p>
<ul>
<li>certain/​sure <strong>of</strong> something</li>
<li>certain/​bound/​sure/​guaranteed <strong>to do something</strong></li>
<li>certain/​definite <strong>that…</strong></li>
<li>I <strong>couldn’t say for</strong> certain/​sure/​definite.</li>
</ul></li>
</ul>

</details>
<p><strong>Topics</strong> <a href="https://www.oxfordlearnersdictionaries.com/topic/doubt-guessing-and-certainty?level=b2">Doubt,
guessing and certainty B2</a> <strong><mark class="label ">B2</mark></strong></p>
<details class="note primary"><summary><p>Oxford Collocations Dictionary</p>
</summary>
<ul>
<li><strong>verbs</strong>
<ul>
<li>be</li>
<li>seem</li>
</ul></li>
<li><strong>adverb</strong>
<ul>
<li>almost</li>
</ul></li>
</ul>

</details></li>
<li><p><strong><mark class="label ">C1</mark></strong> forced to do something by law,
duty or a particular situation
受（法律、义务或情况）约束（必须做某事）；有义务（做某事）</p>
<ul>
<li><strong>bound by something</strong> <em>We are not bound by the
decision.</em> 我们不受该决定的约束。</li>
<li><em>You are bound by the contract to pay before the end of the
month.</em> 按照合同规定，你必须在月底前付款。</li>
<li><strong>bound (by something) to do something</strong>
(<em>formal</em>) <em>I am <strong>bound to say</strong> I disagree with
you on this point.</em>
我觉得有必要指出，在这一点上我不同意你的观点。</li>
<li><em>They are legally bound to appear in court.</em>
他们依法必须出庭。</li>
</ul>
<details class="note primary"><summary><p>Extra Examples</p>
</summary>
<ul>
<li><em>He was legally bound to report them to the authorities.</em>
他有法律义务将这些报告给当局。</li>
<li><em>Officials are bound by law to investigate any possible
fraud.</em> 法律规定官员有义务调查任何可能的欺诈行为。</li>
<li><em>The country will not <strong>be held bound</strong> by a treaty
signed by the previous regime.</em>
国家不会为前政权签署的条约所束缚。</li>
<li><em>The president said the country could not be held bound by a
treaty signed by the previous regime.</em>
总统说，国家不应为前政权签署的条约所束缚。</li>
<li><em>We are legally bound by this decision.</em>
我们在法律上受这一决定的束缚。</li>
</ul>

</details>
<details class="note primary"><summary><p>Oxford Collocations Dictionary</p>
</summary>
<ul>
<li><strong>verbs</strong>
<ul>
<li>be</li>
<li>feel</li>
<li>become</li>
<li>…</li>
</ul></li>
<li><strong>adverb</strong>
<ul>
<li>absolutely</li>
<li>irrevocably</li>
<li>by law</li>
<li>…</li>
</ul></li>
<li><strong>preposition</strong>
<ul>
<li>by</li>
</ul></li>
</ul>

</details></li>
<li><p>(in compounds) prevented from going somewhere or from working
normally by the conditions mentioned 因…受阻（或不能正常工作）</p>
<ul>
<li><em>Strike-bound travellers face long delays.</em>
因罢工滞留的旅客要耽搁很长时间。</li>
<li><em>fogbound airports</em> 因雾不能正常作业的机场</li>
</ul>
<details class="note primary"><summary><p>Oxford Collocations Dictionary</p>
</summary>
<ul>
<li><strong>verbs</strong>
<ul>
<li>be</li>
</ul></li>
<li><strong>adverb</strong>
<ul>
<li>homeward</li>
<li>outward</li>
</ul></li>
<li><strong>preposition</strong>
<ul>
<li>for</li>
</ul></li>
</ul>

</details></li>
<li><p>(also in compounds) travelling, or ready to travel, in a
particular direction or to a particular place
正旅行去（某地）；准备前往（某地）</p>
<ul>
<li><em>homeward bound</em> (= going home) 在回家途中</li>
<li><em>Paris-bound</em> 前往巴黎的</li>
<li><strong><em>northbound/southbound/eastbound/westbound</em></strong>
向北／向南／向东／向西行进的</li>
<li><strong>bound for…</strong> <em>a plane bound for Dublin</em>
开往都柏林的飞机</li>
<li><em>tourists who are bound for Europe</em> 前往欧洲的游客</li>
<li><em>college-bound high school students</em> 上大学的高中生</li>
</ul>
<details class="note primary"><summary><p>Oxford Collocations Dictionary</p>
</summary>
<ul>
<li><strong>verbs</strong>
<ul>
<li>be</li>
</ul></li>
<li><strong>adverb</strong>
<ul>
<li>homeward</li>
<li>outward</li>
</ul></li>
<li><strong>preposition</strong>
<ul>
<li>for</li>
</ul></li>
</ul>

</details></li>
</ol>
<h2 id="word-origin">Word Origin</h2>
<p><em>adjective</em> sense 4 Middle English <em>boun</em> (in the sense
‘ready, dressed’), from Old Norse <em>búinn</em>, past participle of
<em>búa</em> ‘get ready’; the final <em>-d</em> is euphonic, or
influenced by other adjective senses of <strong>bound</strong>.</p>
<h2 id="idioms">Idioms</h2>
<ol type="1">
<li><p><strong>be bound together by/in something</strong></p>
<p>to be closely connected 因…（或在…方面）密切联系</p>
<ul>
<li><em>communities bound together by customs and traditions</em>
因习俗和传统而结合在一起的社区</li>
</ul></li>
<li><p><strong>be bound up in something</strong></p>
<p>very busy with something; very interested or involved in something
忙于某事；热衷于某事</p>
<ul>
<li><em>He’s too bound up in his work to have much time for his
children.</em> 他工作太忙，没有很多时间陪孩子们。</li>
</ul></li>
<li><p><strong>bound and determined</strong></p>
<p>(<em>North American English</em>) very determined to do
something矢志不渝；下定决心</p>
<ul>
<li><em>I came here bound and determined to put the last 12 months
behind me.</em> 我来到这里，下定决心把过去的12个月抛在脑后。</li>
</ul></li>
<li><p><strong>bound up with something</strong></p>
<p>closely connected with something 和某事密切相关</p>
<ul>
<li><em>From that moment my life became inextricably bound up with
hers.</em> 从那一刻起，我的一生就和她结下不解之缘。</li>
</ul></li>
<li><p><strong>(feel) honour-bound to do something</strong></p>
<p>(<em>formal</em>) to feel that you must do something because of your
sense of moral duty （感到）道义上应做某事</p>
<ul>
<li><em>She felt honour-bound to attend as she had promised to.</em>
她觉得既然答应了就应该出席。</li>
<li><em>He felt honour bound to help her.</em>
他觉得在道义上应该帮助她。</li>
</ul>
<details class="note primary"><summary><p><strong>compare</strong> duty-bound</p>
</summary>
<p>[not before noun] (<em>formal</em>) having to do something because it
is your duty 责无旁贷；义不容辞</p>

</details>
<p><strong>Topics</strong> <a href="https://www.oxfordlearnersdictionaries.com/topic/permission-and-obligation?level=c2">Permission
and obligation</a> <strong><mark class="label ">C2</mark></strong></p></li>
<li><p><strong>I’ll be bound</strong></p>
<p>(<em>old-fashioned, British English, informal</em>) I feel
sure我敢肯定</p>
<ul>
<li>They’re up to some mischief, I’ll be
bound!我敢肯定，他们在搞恶作剧！</li>
</ul>
<p><strong>Topics</strong> <a href="https://www.oxfordlearnersdictionaries.com/topic/doubt-guessing-and-certainty?level=c2">Doubt,
guessing and certainty C2</a> <strong><mark class="label ">C2</mark></strong></p></li>
</ol>
<h1 id="verb">Verb</h1>
<p><strong>see also <a href="https://www.oxfordlearnersdictionaries.com/definition/english/bind_1">bind</a></strong></p>
<h2 id="pronunciation-1">Pronunciation</h2>
<ul>
<li>BrE: /baʊnd/</li>
<li>NAmE: /baʊnd/</li>
</ul>
<h2 id="verb-forms">Verb Forms</h2>
<ul>
<li>present simple I / you / we / they bound
<ul>
<li>BrE: /baʊnd/</li>
<li>NAmE: /baʊnd/</li>
</ul></li>
<li>he / she / it bounds
<ul>
<li>BrE: /baʊndz/</li>
<li>NAmE: /baʊndz/</li>
</ul></li>
<li>past simple bounded
<ul>
<li>BrE: /ˈbaʊndɪd/</li>
<li>NAmE: /ˈbaʊndɪd/</li>
</ul></li>
<li>past participle bounded
<ul>
<li>BrE: /ˈbaʊndɪd/</li>
<li>NAmE: /ˈbaʊndɪd/</li>
</ul></li>
<li>-ing form bounding
<ul>
<li>BrE: /ˈbaʊndɪŋ/</li>
<li>NAmE: /ˈbaʊndɪŋ/</li>
</ul></li>
</ul>
<h2 id="explanation-1">Explanation</h2>
<ol type="1">
<li><p>[transitive] <strong>+ adv./prep.</strong> to run with long
steps, especially in an enthusiastic way 跳跃着跑</p>
<ul>
<li><em>The dogs bounded ahead.</em> 那些狗在前面蹦蹦跳跳地跑。</li>
</ul>
<details class="note primary"><summary><p>Extra Examples</p>
</summary>
<ul>
<li><em>He bounded back to meet us.</em> 他跳回来迎接我们。</li>
<li><em>Louis came bounding down the stairs.</em>
路易斯蹦蹦跳跳地下了楼</li>
<li><em>The dog bounded up to him.</em> 那只狗向他扑来。</li>
<li><em>A man bounded up to her and shook her hand.</em>
一个男人跳到她面前和她握手。</li>
<li><em>He braked sharply as a deer bounded across the road.</em>
当一只鹿飞奔过马路时，他猛地刹车。</li>
</ul>

</details></li>
<li><p>[transitive, usually passive] (<em>formal</em>) to form the edge
or limit of an area 形成…的边界（或界限）</p>
<ul>
<li><strong>be bounded by something</strong> <em>The field was bounded
on the left by a wood.</em> 那片地左边依傍着一片树林。</li>
</ul></li>
</ol>
<h2 id="word-origin-1">Word Origin</h2>
<p><em>verb</em> sense 1 early 16th cent. (as a noun): from French
<em>bond</em> (noun), <em>bondir</em> (verb) ‘resound’, later ‘rebound’,
from late Latin <em>bombitare</em>, from Latin <em>bombus</em>
‘humming’. <em>verb</em> sense 2 Middle English (in the senses
‘landmark’ and ‘borderland’): from Old French <em>bodne</em>, from
medieval Latin <em>bodina</em>, earlier <em>butina</em>, of unknown
ultimate origin.</p>
<h1 id="noun">Noun</h1>
<p><strong>see also <a href="https://www.oxfordlearnersdictionaries.com/definition/english/bind_1">bind</a></strong></p>
<h2 id="pronunciation-2">Pronunciation</h2>
<ul>
<li>BrE: /baʊnd/</li>
<li>NAmE: /baʊnd/</li>
</ul>
<h2 id="explanation-2">Explanation</h2>
<ol type="1">
<li><p>a high or long jump 蹦跳；跳跃</p>
<ul>
<li><em>The dog cleared the gate in one bound.</em>
那狗一跳就越过了栅门。</li>
</ul>
<details class="note primary"><summary><p><strong>see also</strong> bounds</p>
</summary>
<ul>
<li>BrE: /baʊndz/</li>
<li>NAmE: /baʊndz/</li>
</ul>
<p>[plural]</p>
<p>the accepted or furthest limits of something 限制范围；极限</p>
<ul>
<li><em><strong>beyond/outside/within the bounds of</strong>
decency</em> 没体统；有体统</li>
<li><em>I am afraid your behaviour was beyond the bounds of
decency.</em> 恐怕你的行为超出了体面的范围。</li>
<li><em>Public spending must be kept within reasonable bounds.</em>
公共开支必须控制在合理的范围内。</li>
<li><em>It was not <strong>beyond the bounds of possibility</strong>
that they would meet again one day.</em>
他们有一天会再度相遇，这不是没有可能。</li>
<li><em>His enthusiasm <strong>knew no bounds</strong></em> (= was very
great). 他有无限热情。</li>
</ul>

</details></li>
</ol>
<h2 id="word-origin-2">Word Origin</h2>
<p>noun early 16th cent. (as a noun): from French <em>bond</em> (noun),
<em>bondir</em> (verb) ‘resound’, later ‘rebound’, from late Latin
<em>bombitare</em>, from Latin <em>bombus</em> ‘humming’.</p>
<h2 id="idioms-1">Idioms</h2>
<ol type="1">
<li><p><strong>by/in leaps and bounds</strong></p>
<p>very quickly; in large amounts 非常迅速；飞跃地；突飞猛进；大量地</p>
<ul>
<li><em>Her health has improved in leaps and bounds.</em>
她的健康已迅速好转。</li>
<li><em>His technique has come on in leaps and bounds this season.</em>
这个赛季他的技术突飞猛进。</li>
</ul></li>
</ol>
<h1 id="惯用法">惯用法</h1>
<p>bound 后面接不定式从前在英国作“将不得不……”解，在美国作“决意……”解，如
He is bound to come
在英国是“他将不得不来”，在美国是“他决意来”。但现在似乎在英美通常都作“一定将……”解，如
It is bound to rain 是“肯定会下雨”。</p>
<h1 id="reference">Reference</h1>
<ol type="1">
<li><p>Diana Lea, Jennifer Bradbery. <em>Oxford Advanced Learner’s
Dictionary, 10th edition.</em> Oxford University Press, 2020.</p></li>
<li><p>Margaret Deuter, Jennifer Bradbery, Joanna Turnbull.
<em>牛津高阶英汉双解词典，第 9 版.</em> 商务印书馆, 2018.</p></li>
<li><p>葛传槼. <em>葛传槼英语惯用法词典.</em> 上海译文出版社,
2012.</p></li>
</ol>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/css/markmap.css">

<script src="/js/markmap.js"></script>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>牛津5000</tag>
        <tag>英语词汇</tag>
      </tags>
  </entry>
  <entry>
    <title>Josh&#39;s Note — 最优阵列处理&lt;br&gt;Part 2.1 谱加权</title>
    <url>/posts/61f0754c.html</url>
    <content><![CDATA[<p>  谱加权（Spectral
Weighting）技术主要研究对如何每个传感器输出进行加权，以获得具有理想性质的频率-波数响应和波束方向图。加权的过程在一些文献中也称为锐化
(tapering) 或赋形 (shading)
。许多阵列加权技术等价于时间序列谱分析中的加窗或锐化 (Taper) 技术。</p>
<p>  对于一个阵元间距小于或等于 <span class="math inline">\(\lambda/2\)</span>
的线阵，由于不需要考虑栅瓣和空域混迭，可以直接应用连续函数的傅里叶变换理论对权重和频率-波数响应之间存在的傅里叶变换关系进行分析。本文关注线性阵列，讨论如何在降低旁瓣的同时使主瓣宽度的增长最小（最小化方向性损失），将尝试不同的权值矢量，并分析它们的性能。</p>
<p>  考虑傅里叶变换对</p>
<p><span class="math display">\[\begin{equation}
  \varUpsilon(\omega,k) = \int_{-\infty}^\infty w_a^\ast (z) e^{-jkz}\,
\mathrm{d}z
\end{equation}\]</span></p>
<p><span class="math display">\[\begin{equation}
  w_a^\ast (z) = \frac{1}{2\pi} \int_{-\infty}^\infty
\varUpsilon(\omega,k) e^{jkz}\, \mathrm{d}k
\end{equation}\]</span></p>
<p>其中省略了 <span class="math inline">\(k_z\)</span> 的下标 <span class="math inline">\(z\)</span>。</p>
<span id="more"></span>
<h1 id="均匀加权">1. 均匀加权</h1>
<p>  均匀权值为</p>
<p><span class="math display">\[\begin{equation}
  w_n = \frac{1}{N}, \quad n = 0,\cdots,N-1
\end{equation}\]</span></p>
<p>在 <span class="math inline">\(u\)</span> 空间的波束方向图为</p>
<p><span class="math display">\[\begin{equation}
  \begin{aligned}
    B_u(u) &amp;= \frac{1}{N} \frac{\sin\left( \displaystyle\frac{\pi
Nd}{\lambda} u \right)}{\sin\left( \displaystyle\frac{\pi d}{\lambda} u
\right)} \\
    &amp;= \boldsymbol{w}^\mathrm{H}\boldsymbol{v}_u(u) =
e^{-j\left(\frac{N-1}{2} \right) \frac{2\pi d}{\lambda} u}
\sum_{n=0}^{N-1} w_n^\ast e^{j n \frac{2\pi d}{\lambda} u}
  \end{aligned}
\end{equation}\]</span></p>
<p>对于<strong>标准线阵</strong>，有</p>
<p><span class="math display">\[\begin{equation}
  B_u(u) = \frac{1}{N} \frac{\sin\left( \displaystyle\frac{\pi Nu}{2}
\right)}{\sin\left( \displaystyle\frac{\pi u}{2}  \right)}
\end{equation}\]</span></p>
<p>方向性</p>
<p><span class="math display">\[\begin{equation}
  D = N
\end{equation}\]</span></p>
<p>由于下面经考虑实对称的权值，因此将阵元的位置也对称地进行表示，第
<span class="math inline">\(n\)</span> 个阵元的位置表示为</p>
<p><span class="math display">\[\begin{equation}
  \tilde{n} = n - \frac{N-1}{2}, \quad n = 0,\cdots,N-1,\quad \tilde{n}
= -\frac{N-1}{2}, \cdots, \frac{N-1}{2}
\end{equation}\]</span></p>
<h1 id="cosine-加权">2. Cosine 加权</h1>
<p>  当 <span class="math inline">\(N\)</span> 为奇数时，Cosine
权值为</p>
<p><span class="math display">\[\begin{equation}
  w(\tilde{n}) = \sin\left( \frac{\pi}{2N} \right)\cos\left(
\pi\frac{\tilde{n}}{N} \right), \quad -\frac{N-1}{2} \leqslant \tilde{n}
\leqslant \frac{N-1}{2}
\end{equation}\]</span></p>
<p>其中归一化因子 <span class="math inline">\(\sin\left(
\displaystyle\frac{\pi}{2N} \right)\)</span> 是一个常数，使得 <span class="math inline">\(B_u (0) = 1\)</span>。把 Cosine
写成指数形式，有</p>
<p><span class="math display">\[\begin{equation}
  w(\tilde{n}) = \sin\left( \frac{\pi}{2N} \right)\left[
\frac{e^{j\frac{\pi\tilde{n}}{N}} + e^{-j\frac{\pi\tilde{n}}{N}}}{2}
\right], \quad -\frac{N-1}{2} \leqslant \tilde{n} \leqslant
\frac{N-1}{2}
\end{equation}\]</span></p>
<p>利用指数形式的阵列流形矢量，可得波束方向图</p>
<p><span class="math display">\[\begin{equation}
  B_u(u) = \frac{1}{2} \sin\left( \frac{\pi}{2N} \right) \left\{
\sum_{\tilde{n} = -\frac{N-1}{2}}^{\frac{N-1}{2}} e^{j\frac{\pi
\tilde{n}}{N}} e^{-j \tilde{n} \pi u} + \sum_{\tilde{n} =
-\frac{N-1}{2}}^{\frac{N-1}{2}} e^{-j\frac{\pi \tilde{n}}{N}} e^{-j
\tilde{n} \pi u} \right\}
\end{equation}\]</span></p>
<p>其中第一项和第二项分别对应指向 <span class="math inline">\(u_s =
1/N\)</span> 和 <span class="math inline">\(u_s = -1/N\)</span>
的常规波束方向图，因此</p>
<p><span class="math display">\[\begin{equation}
  B_u(u) = \frac{1}{2} \sin\left( \frac{\pi}{2N} \right) \left\{
\frac{\sin\left( \displaystyle\frac{N\pi}{2} \left( u - \frac{1}{N}
\right) \right)}{\sin\left( \displaystyle\frac{\pi}{2} \left( u -
\frac{1}{N} \right) \right)} + \frac{\sin\left(
\displaystyle\frac{N\pi}{2} \left( u + \frac{1}{N} \right)
\right)}{\sin\left( \displaystyle\frac{\pi}{2} \left( u + \frac{1}{N}
\right) \right)} \right\}
\end{equation}\]</span></p>
<p>下面将要介绍的很多方向图都是常规波束的叠加。<a href="#fig.2-1-1">图
2-1-1</a> 给出了一个 11 阵元阵列使用 Cosine
加权得到的波束方向图，同时还给出了常规波束方向图作为参考。可以看到，旁瓣得到了降低，但是主波束变得更宽。两个波束方向图的参数为</p>
<table>
<colgroup>
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
</colgroup>
<thead>
<tr>
<th style="text-align: center;">加权方式</th>
<th style="text-align: center;">HPBW</th>
<th style="text-align: center;"><span class="math inline">\(BW_{NN}\)</span></th>
<th style="text-align: center;">第一旁瓣高度</th>
<th style="text-align: center;"><span class="math inline">\(D_N\)</span><a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">Uniform</td>
<td style="text-align: center;"><span class="math inline">\(0.89
\displaystyle\frac{2}{N}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(2.0
\displaystyle\frac{2}{N}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(-13.0
\text{dB}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(1\)</span></td>
</tr>
<tr>
<td style="text-align: center;">Cosine</td>
<td style="text-align: center;"><span class="math inline">\(1.18
\displaystyle\frac{2}{N}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(3.0
\displaystyle\frac{2}{N}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(-23.5
\text{dB}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(0.816\)</span></td>
</tr>
</tbody>
</table>
<p><a id="fig.2-1-1"></a></p>
<figure>
<img data-src="../images/post/2023-06-19-josh-oap-part-2-1/2023-06-19-josh-oap-part-2-1-010-BeamPatternForUniformAndCosineWeighting.svg" width="700" alt="图 2-1-1 均匀加权和 Cosine 加权的波束方向图: N = 11">
<figcaption aria-hidden="true">图 2-1-1 均匀加权和 Cosine
加权的波束方向图: <span class="math inline">\(N =
11\)</span></figcaption>
</figure>
<details class="note primary"><summary><p>MATLAB Code</p>
</summary>
<figure class="highlight matlab"><figcaption><span>fig3_01.m</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% Figure 3.1</span></span><br><span class="line"><span class="comment">% Cosine weighting: Array beam patterns</span></span><br><span class="line"><span class="comment">% Kristine Bell</span></span><br><span class="line"><span class="comment">% Modified by Xin Zhang 3/17/99</span></span><br><span class="line"><span class="comment">% Lillian 04/16/2001, K. Bell 7/20/01, K. Bell 9/30/01</span></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"></span><br><span class="line">clear all</span><br><span class="line">close all</span><br><span class="line"></span><br><span class="line">M=<span class="number">11</span>;</span><br><span class="line">d=<span class="number">0.5</span>;                        <span class="comment">% sensor spacing wrt wavelength</span></span><br><span class="line">D = (-(M<span class="number">-1</span>)/<span class="number">2</span>:<span class="number">1</span>:(M<span class="number">-1</span>)/<span class="number">2</span>)*d;   <span class="comment">% sensor positions in wavelengths</span></span><br><span class="line"><span class="comment">% weights, normalized so that w(0)=1</span></span><br><span class="line">W_unf = <span class="built_in">ones</span>(<span class="number">1</span>,M);</span><br><span class="line">W_cos = <span class="built_in">cos</span>(<span class="built_in">pi</span>*D*<span class="number">2</span>/M);</span><br><span class="line"></span><br><span class="line"><span class="comment">% Beampatterns</span></span><br><span class="line">u = <span class="number">0</span>:<span class="number">0.001</span>:<span class="number">1</span>;</span><br><span class="line">A = <span class="built_in">exp</span>(<span class="number">-1</span><span class="built_in">i</span>*<span class="number">2</span>*<span class="built_in">pi</span>*D.'*u);</span><br><span class="line">G_unf = W_unf*A;</span><br><span class="line">G_unf = G_unf/(<span class="built_in">max</span>(<span class="built_in">abs</span>(G_unf)));</span><br><span class="line">G_cos = W_cos*A;</span><br><span class="line">G_cos = G_cos/(<span class="built_in">max</span>(<span class="built_in">abs</span>(G_cos)));</span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line"><span class="comment">% array only</span></span><br><span class="line">clf</span><br><span class="line"><span class="built_in">plot</span>(u,<span class="number">20</span>*<span class="built_in">log10</span>(<span class="built_in">abs</span>(G_unf)),<span class="string">'--'</span>)</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">plot</span>(u,<span class="number">20</span>*<span class="built_in">log10</span>(<span class="built_in">abs</span>(G_cos)),<span class="string">'-'</span>)</span><br><span class="line"><span class="built_in">hold</span> off</span><br><span class="line">axis([<span class="number">0</span> <span class="number">1</span> <span class="number">-80</span> <span class="number">0</span>])</span><br><span class="line"><span class="comment">%title([int2str(M) ' element array'])</span></span><br><span class="line">h=<span class="built_in">legend</span>(<span class="string">'Uniform'</span>,<span class="string">'Cosine'</span>);</span><br><span class="line">xlabel(<span class="string">'$u$'</span>,<span class="string">'Interpreter'</span>,<span class="string">'latex'</span>)</span><br><span class="line">ylabel(<span class="string">'Beam pattern (dB)'</span>)</span><br></pre></td></tr></tbody></table></figure>

</details>
<h1 id="升-cosine-加权">3. 升 Cosine 加权</h1>
<p>  可以把矩形均匀加权和 Cosine
加权组合起来，获得两种加权方法一些理想性质的组合。对应的阵列加权为</p>
<p><span class="math display">\[\begin{equation}
  w(\tilde{n}) = c(p) \left( p + (1-p) \cos \left( \pi
\frac{\tilde{n}}{N} \right)\right), \quad \tilde{n} = -\frac{N-1}{2},
\cdots, \frac{N-1}{2}
\end{equation}\]</span></p>
<p>其中归一化常数</p>
<p><span class="math display">\[\begin{equation}
  c(p) = \frac{p}{N} + \frac{1-p}{2} \sin\left( \frac{\pi}{2N} \right)
\end{equation}\]</span></p>
<p>使得 <span class="math inline">\(B_u(0) = 1\)</span>。</p>
<p>  在<a href="#fig.2-1-2">图 2.1.2</a> 中给出了 <span class="math inline">\(p = 0.31, 0.17, 0\)</span> 时的升 Cosine
加权的波束方向图。当 <span class="math inline">\(p\)</span>
减小时，第一旁瓣的高度减小，主波束宽度增加。波束方向图参数如下：</p>
<table>
<colgroup>
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
</colgroup>
<thead>
<tr>
<th style="text-align: center;"><span class="math inline">\(p\)</span></th>
<th style="text-align: center;">HPBW</th>
<th style="text-align: center;"><span class="math inline">\(BW_{NN}\)</span></th>
<th style="text-align: center;">第一旁瓣高度</th>
<th style="text-align: center;"><span class="math inline">\(D_N\)</span></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">0.31</td>
<td style="text-align: center;"><span class="math inline">\(1.03
\displaystyle\frac{2}{N}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(2.50
\displaystyle\frac{2}{N}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(-20.0
\text{dB}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(0.928\)</span></td>
</tr>
<tr>
<td style="text-align: center;">0.17</td>
<td style="text-align: center;"><span class="math inline">\(1.09
\displaystyle\frac{2}{N}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(3.70
\displaystyle\frac{2}{N}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(-22.0
\text{dB}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(0.886\)</span></td>
</tr>
<tr>
<td style="text-align: center;">0</td>
<td style="text-align: center;"><span class="math inline">\(1.18
\displaystyle\frac{2}{N}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(3.00
\displaystyle\frac{2}{N}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(-23.5
\text{dB}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(0.816\)</span></td>
</tr>
</tbody>
</table>
<p><a id="fig.2-1-2"></a></p>
<figure>
<img data-src="../images/post/2023-06-19-josh-oap-part-2-1/2023-06-19-josh-oap-part-2-1-020-BeamPatternForRaisedCosineWeighting.svg" width="700" alt="图 2-1-2 升 Cosine 加权的波束方向图: N = 11">
<figcaption aria-hidden="true">图 2-1-2 升 Cosine 加权的波束方向图:
<span class="math inline">\(N = 11\)</span></figcaption>
</figure>
<details class="note primary"><summary><p>MATLAB Code</p>
</summary>
<figure class="highlight matlab"><figcaption><span>fig3_02.m</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% Figure 3.2</span></span><br><span class="line"><span class="comment">% Raised cosine weighting function</span></span><br><span class="line"><span class="comment">% Kristine Bell</span></span><br><span class="line"><span class="comment">% Modified by Xin Zhang 3/17/99</span></span><br><span class="line"><span class="comment">% Lillian Xu 04/16/2001, K. Bell 7/20/01, 9/30/01</span></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"></span><br><span class="line">clear all</span><br><span class="line">close all</span><br><span class="line"></span><br><span class="line">M=<span class="number">11</span>;</span><br><span class="line">d=<span class="number">0.5</span>;                        <span class="comment">% sensor spacing wrt wavelength</span></span><br><span class="line">D = (-(M<span class="number">-1</span>)/<span class="number">2</span>:<span class="number">1</span>:(M<span class="number">-1</span>)/<span class="number">2</span>)*d;   <span class="comment">% sensor positions in wavelengths</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% weights, normalized so that w(0)=1</span></span><br><span class="line">p=[<span class="number">0</span>;<span class="number">0.17</span>;<span class="number">0.31</span>;<span class="number">1</span>];</span><br><span class="line">W_rcos = p*<span class="built_in">ones</span>(<span class="number">1</span>,M)+(<span class="built_in">ones</span>(<span class="number">4</span>,<span class="number">1</span>)-p)*<span class="built_in">cos</span>(<span class="built_in">pi</span>*D*<span class="number">2</span>/M);</span><br><span class="line"></span><br><span class="line"><span class="comment">% Beampatterns</span></span><br><span class="line">u = <span class="number">0</span>:<span class="number">0.001</span>:<span class="number">1</span>;</span><br><span class="line">c=p+(<span class="built_in">ones</span>(<span class="number">4</span>,<span class="number">1</span>)-p)*<span class="number">2</span>/<span class="built_in">pi</span>;</span><br><span class="line">A = <span class="built_in">exp</span>(<span class="number">-1</span><span class="built_in">i</span>*<span class="number">2</span>*<span class="built_in">pi</span>*D.'*u);</span><br><span class="line">G_rcos = W_rcos*A;</span><br><span class="line"><span class="keyword">for</span> m=<span class="number">1</span>:<span class="number">4</span></span><br><span class="line"> G_rcos(m,:) = G_rcos(m,:)/(<span class="built_in">max</span>(<span class="built_in">abs</span>(G_rcos(m,:))));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line">clf</span><br><span class="line"><span class="built_in">plot</span>(u,<span class="number">20</span>*<span class="built_in">log10</span>(<span class="built_in">abs</span>(G_rcos(<span class="number">3</span>,:))),<span class="string">'-.'</span>)</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">plot</span>(u,<span class="number">20</span>*<span class="built_in">log10</span>(<span class="built_in">abs</span>(G_rcos(<span class="number">2</span>,:))),<span class="string">'--'</span>)</span><br><span class="line"><span class="built_in">plot</span>(u,<span class="number">20</span>*<span class="built_in">log10</span>(<span class="built_in">abs</span>(G_rcos(<span class="number">1</span>,:))),<span class="string">'-'</span>)</span><br><span class="line"><span class="built_in">hold</span> off</span><br><span class="line">axis([<span class="number">0</span> <span class="number">1</span> <span class="number">-80</span> <span class="number">0</span>])</span><br><span class="line">h=<span class="built_in">legend</span>({<span class="string">'$p=0.31$'</span>,<span class="string">'$p=0.17$'</span>,<span class="string">'$p=0$'</span>},<span class="string">'Interpreter'</span>,<span class="string">'latex'</span>);</span><br><span class="line">xlabel(<span class="string">'$u$'</span>,<span class="string">'Interpreter'</span>,<span class="string">'latex'</span>)</span><br><span class="line">ylabel(<span class="string">'Beam pattern (dB)'</span>)</span><br></pre></td></tr></tbody></table></figure>

</details>
<p>  至此，我们已经可以使 HPBW
变窄，并使得第一旁瓣比均匀分布的情况要低得多。</p>
<h1 id="cosinem-加权">4. Cosine<span class="math inline">\(^m\)</span>
加权</h1>
<p>  下面考虑一系列 Cosine 加权，形式为 <span class="math inline">\(\cos^m(\pi \tilde{n} /
N)\)</span>。阵列的权值为</p>
<p><span class="math display">\[\begin{equation}
  w_m(\tilde{n}) = \begin{cases}
    c_2 \cos^2 \left( \displaystyle \frac{\pi \tilde{n}}{N}
\right),\quad m = 2 \\
    c_3 \cos^3 \left( \displaystyle \frac{\pi \tilde{n}}{N}
\right),\quad m = 3 \\
    c_4 \cos^4 \left( \displaystyle \frac{\pi \tilde{n}}{N}
\right),\quad m = 4 \\
  \end{cases}
\end{equation}\]</span></p>
<p>其中 <span class="math inline">\(c_2, c_3, c_4\)</span>
是归一化常数。</p>
<p>  <span class="math inline">\(m=2\)</span> 时的加权有时称为是 Hann
加权<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>。同样，波束方向图可以利用 Cosine
函数的指数形式来计算。波束方向图在<a href="#fig.2-1-3">图 2.1.3</a>
中给出。当 <span class="math inline">\(m\)</span>
增加时，旁瓣减小，但是主波束变宽。波束方向图的参数为:</p>
<table>
<colgroup>
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
</colgroup>
<thead>
<tr>
<th style="text-align: center;"><span class="math inline">\(m\)</span></th>
<th style="text-align: center;">HPBW</th>
<th style="text-align: center;"><span class="math inline">\(BW_{NN}\)</span></th>
<th style="text-align: center;">第一旁瓣高度</th>
<th style="text-align: center;"><span class="math inline">\(D_N\)</span></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">2</td>
<td style="text-align: center;"><span class="math inline">\(1.44
\displaystyle\frac{2}{N}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(4
\displaystyle\frac{2}{N}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(-31.4
\text{dB}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(0.667\)</span></td>
</tr>
<tr>
<td style="text-align: center;">3</td>
<td style="text-align: center;"><span class="math inline">\(1.66
\displaystyle\frac{2}{N}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(5
\displaystyle\frac{2}{N}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(-39.4
\text{dB}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(0.576\)</span></td>
</tr>
<tr>
<td style="text-align: center;">4</td>
<td style="text-align: center;"><span class="math inline">\(1.85
\displaystyle\frac{2}{N}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(6
\displaystyle\frac{2}{N}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(-46.7
\text{dB}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(0.514\)</span></td>
</tr>
</tbody>
</table>
<p><a id="fig.2-1-3"></a></p>
<figure>
<img data-src="../images/post/2023-06-19-josh-oap-part-2-1/2023-06-19-josh-oap-part-2-1-030-BeamPatternForCosineMWeighting.svg" width="700" alt="图 2-1-3 Cosine^m 加权的波束方向图: N = 11">
<figcaption aria-hidden="true">图 2-1-3 Cosine<span class="math inline">\(^m\)</span> 加权的波束方向图: <span class="math inline">\(N = 11\)</span></figcaption>
</figure>
<details class="note primary"><summary><p>MATLAB Code</p>
</summary>
<figure class="highlight matlab"><figcaption><span>fig3_03.m</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% Figure 3.3</span></span><br><span class="line"><span class="comment">% Cosine^m weighting: m = 2,3,and 4</span></span><br><span class="line"><span class="comment">% Kristine Bell</span></span><br><span class="line"><span class="comment">% Modified by Xin Zhang 3/17/99</span></span><br><span class="line"><span class="comment">% Lillian Xu 04/16/2001, K. Bell 7/20/01, 9/30/01</span></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"></span><br><span class="line">clear all</span><br><span class="line">close all</span><br><span class="line"></span><br><span class="line">M=<span class="number">11</span>;</span><br><span class="line">d=<span class="number">0.5</span>;                        <span class="comment">% sensor spacing wrt wavelength</span></span><br><span class="line">D = (-(M<span class="number">-1</span>)/<span class="number">2</span>:<span class="number">1</span>:(M<span class="number">-1</span>)/<span class="number">2</span>)*d;   <span class="comment">% sensor positions in wavelengths</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% weights, normalized so that w(0)=1</span></span><br><span class="line">W_cos2 = <span class="built_in">cos</span>(<span class="built_in">pi</span>*D*<span class="number">2</span>/M).^<span class="number">2</span>;</span><br><span class="line">W_cos3 = <span class="built_in">cos</span>(<span class="built_in">pi</span>*D*<span class="number">2</span>/M).^<span class="number">3</span>;</span><br><span class="line">W_cos4 = <span class="built_in">cos</span>(<span class="built_in">pi</span>*D*<span class="number">2</span>/M).^<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% Beampatterns</span></span><br><span class="line"></span><br><span class="line">u = <span class="number">0</span>:<span class="number">0.001</span>:<span class="number">1</span>;</span><br><span class="line">A = <span class="built_in">exp</span>(<span class="number">-1</span><span class="built_in">i</span>*<span class="number">2</span>*<span class="built_in">pi</span>*D.'*u);</span><br><span class="line">G_cos2 = W_cos2*A;</span><br><span class="line">G_cos2 = G_cos2/(<span class="built_in">max</span>(<span class="built_in">abs</span>(G_cos2)));</span><br><span class="line">G_cos3 = W_cos3*A;</span><br><span class="line">G_cos3 = G_cos3/(<span class="built_in">max</span>(<span class="built_in">abs</span>(G_cos3)));</span><br><span class="line">G_cos4 = W_cos4*A;</span><br><span class="line">G_cos4 = G_cos4/(<span class="built_in">max</span>(<span class="built_in">abs</span>(G_cos4)));</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line">clf</span><br><span class="line"><span class="built_in">plot</span>(u,<span class="number">20</span>*<span class="built_in">log10</span>(<span class="built_in">abs</span>(G_cos2)),<span class="string">'--'</span>)</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">plot</span>(u,<span class="number">20</span>*<span class="built_in">log10</span>(<span class="built_in">abs</span>(G_cos3)),<span class="string">'-'</span>)</span><br><span class="line"><span class="built_in">plot</span>(u,<span class="number">20</span>*<span class="built_in">log10</span>(<span class="built_in">abs</span>(G_cos4)),<span class="string">'-.'</span>)</span><br><span class="line"><span class="built_in">hold</span> off</span><br><span class="line">axis([<span class="number">0</span> <span class="number">1</span> <span class="number">-80</span> <span class="number">0</span>])</span><br><span class="line">h=<span class="built_in">legend</span>({<span class="string">'$m=2$'</span>,<span class="string">'$m=3$'</span>,<span class="string">'$m=4$'</span>},<span class="string">'Interpreter'</span>,<span class="string">'latex'</span>);</span><br><span class="line">xlabel(<span class="string">'$u$'</span>,<span class="string">'Interpreter'</span>,<span class="string">'latex'</span>)</span><br><span class="line">ylabel(<span class="string">'Beam pattern (dB)'</span>)</span><br></pre></td></tr></tbody></table></figure>

</details>
<h1 id="升-cosine-平方加权">5. 升 Cosine 平方加权</h1>
<p>  升 Cosine 平方系列的加权为</p>
<p><span class="math display">\[\begin{equation}
  \begin{aligned}
    w(\tilde{n}) &amp;= c_2 (p) \left\{ p + (1-p) \cos^2 \left(
\frac{\pi \tilde{n}}{N} \right) \right\} \\
    &amp;= \frac{c_2(p)}{2} \left\{ (1+p) + (1-p) \cos \left( \frac{2
\pi \tilde{n}}{N} \right) \right\}, \quad \tilde{n} = -\frac{N-1}{2},
\cdots, \frac{N-1}{2}
  \end{aligned}
\end{equation}\]</span></p>
<p>其中 <span class="math inline">\(c_2 (p)\)</span>
是归一化常数。下面考虑一个特别的加权，称为 Hamming 加权。</p>
<h1 id="hamming-加权">6. Hamming 加权</h1>
<p>  Hamming 加权利用了矩形方向图和 Cosine
平方方向图的特点，在第一旁瓣的峰值上放置了一个零点。加权函数为</p>
<p><span class="math display">\[\begin{equation}
  w(\tilde{n}) = g_0 + g_1 \cos \left( \frac{2 \pi \tilde{n}}{N}
\right), \quad \tilde{n} = -\frac{N-1}{2}, \cdots, \frac{N-1}{2}
\end{equation}\]</span></p>
<p>选择系数 <span class="math inline">\(g_0\)</span> 和 <span class="math inline">\(g_1\)</span> 的使 <span class="math inline">\(u =
3/N\)</span> 的位置上有一个零点，并将正侧向的响应归一化，有</p>
<p><span class="math display">\[\begin{equation}
  w(\tilde{n}) = 0.54 + 0.46 \cos \left( \frac{2 \pi \tilde{n}}{N}
\right), \quad -\frac{N-1}{2} \leqslant \tilde{n} \leqslant
\frac{N-1}{2}
\end{equation}\]</span></p>
<p>对应升 Cosine 平方加权中 <span class="math inline">\(p =
0.08\)</span> 的情况，得到的波束方向图是三个常规波束方向图的和</p>
<p><span class="math display">\[\begin{equation}
  B_u(u) = 0.54 \frac{\sin\left(\displaystyle\frac{N\pi
u}{2}\right)}{\sin\left(\displaystyle\frac{\pi u}{2}\right)} + 0.23
\left[ \frac{\sin\left( \displaystyle\frac{N\pi}{2} \left( u -
\frac{2}{N} \right) \right)}{\sin\left( \displaystyle\frac{\pi}{2}
\left( u - \frac{2}{N} \right) \right)} + \frac{\sin\left(
\displaystyle\frac{N\pi}{2} \left( u + \frac{2}{N} \right)
\right)}{\sin\left( \displaystyle\frac{\pi}{2} \left( u + \frac{2}{N}
\right) \right)} \right]
\end{equation}\]</span></p>
<p>  <a href="#fig.2-1-4">图 2.1.4</a> 给出了 Hamming 加权、Hann 加权和
Blackman-Harris 加权的波束方向图。第一个零点的位置在 <span class="math inline">\(u = 4/N\)</span>，第一个非零旁瓣的高度为 <span class="math inline">\(-39.5\text{dB}\)</span>。由于加权具有步进不连续性（step
discontinuity），旁瓣的衰减渐近为 <span class="math inline">\(O(1/n)\)</span>。但是，第一个旁瓣被完全对消掉了，尽管剩余的旁瓣衰减得比较慢，它们的幅度都不是很高。而且注意到
Hamming 窗的波束宽度小于 Hann 加权的波束宽度，且第一旁瓣更低。</p>
<p><a id="fig.2-1-4"></a></p>
<figure>
<img data-src="../images/post/2023-06-19-josh-oap-part-2-1/2023-06-19-josh-oap-part-2-1-040-BeamPatternForHannHammingAndBlackmanHarrisWeighting.svg" width="700" alt="图 2-1-4 Hann 加权、Hamming 加权和 Blackman-Harris 加权的波束方向图: N = 11">
<figcaption aria-hidden="true">图 2-1-4 Hann 加权、Hamming 加权和
Blackman-Harris 加权的波束方向图: <span class="math inline">\(N =
11\)</span></figcaption>
</figure>
<details class="note primary"><summary><p>MATLAB Code</p>
</summary>
<figure class="highlight matlab"><figcaption><span>fig3_04.m</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% Figure 3.4</span></span><br><span class="line"><span class="comment">% Beam patterns for Hann, Hamming, and Blackman-Harris</span></span><br><span class="line"><span class="comment">% Kristine Bell</span></span><br><span class="line"><span class="comment">% Modified by Xin Zhang 3/17/99</span></span><br><span class="line"><span class="comment">% Lillian Xu 04/16/2001, K. Bell 7/20/01, 9/30/01</span></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% Hann, Hamming, Blackman-Harris</span></span><br><span class="line"><span class="comment">% M-element array, d=lambda/2</span></span><br><span class="line"></span><br><span class="line">clear all</span><br><span class="line">close all</span><br><span class="line"></span><br><span class="line">M=<span class="number">11</span>;</span><br><span class="line">d=<span class="number">0.5</span>;                        <span class="comment">% sensor spacing wrt wavelength</span></span><br><span class="line">D = (-(M<span class="number">-1</span>)/<span class="number">2</span>:<span class="number">1</span>:(M<span class="number">-1</span>)/<span class="number">2</span>)*d;   <span class="comment">% sensor positions in wavelengths</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% weights, normalized so that w(0)=1</span></span><br><span class="line">W_Hann = <span class="number">0.5</span>*(<span class="built_in">ones</span>(<span class="number">1</span>,M)+<span class="built_in">cos</span>(<span class="number">2</span>*<span class="built_in">pi</span>*D*<span class="number">2</span>/M));</span><br><span class="line">W_Hamm = <span class="number">0.54</span>*<span class="built_in">ones</span>(<span class="number">1</span>,M)+<span class="number">0.46</span>*<span class="built_in">cos</span>(<span class="number">2</span>*<span class="built_in">pi</span>*D*<span class="number">2</span>/M);</span><br><span class="line">W_BH   = <span class="number">0.42</span>*<span class="built_in">ones</span>(<span class="number">1</span>,M)+<span class="number">0.5</span>*<span class="built_in">cos</span>(<span class="number">2</span>*<span class="built_in">pi</span>*D*<span class="number">2</span>/M)+<span class="number">0.08</span>*<span class="built_in">cos</span>(<span class="number">4</span>*<span class="built_in">pi</span>*D*<span class="number">2</span>/M);</span><br><span class="line"></span><br><span class="line"><span class="comment">% Beampatterns</span></span><br><span class="line"></span><br><span class="line">u = <span class="number">0</span>:<span class="number">0.001</span>:<span class="number">1</span>;</span><br><span class="line">A = <span class="built_in">exp</span>(<span class="number">-1</span><span class="built_in">i</span>*<span class="number">2</span>*<span class="built_in">pi</span>*D.'*u);</span><br><span class="line">G_Hann = W_Hann*A;</span><br><span class="line">G_Hann = G_Hann/(<span class="built_in">max</span>(<span class="built_in">abs</span>(G_Hann)));</span><br><span class="line">G_Hamm = W_Hamm*A;</span><br><span class="line">G_Hamm = G_Hamm/(<span class="built_in">max</span>(<span class="built_in">abs</span>(G_Hamm)));</span><br><span class="line">G_BH = W_BH*A;</span><br><span class="line">G_BH = G_BH/(<span class="built_in">max</span>(<span class="built_in">abs</span>(G_BH)));</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line">clf</span><br><span class="line"><span class="built_in">plot</span>(u,<span class="number">20</span>*<span class="built_in">log10</span>(<span class="built_in">abs</span>(G_Hann)),<span class="string">'--'</span>)</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">plot</span>(u,<span class="number">20</span>*<span class="built_in">log10</span>(<span class="built_in">abs</span>(G_Hamm)),<span class="string">'-'</span>)</span><br><span class="line"><span class="built_in">plot</span>(u,<span class="number">20</span>*<span class="built_in">log10</span>(<span class="built_in">abs</span>(G_BH)),<span class="string">'-.'</span>)</span><br><span class="line"><span class="built_in">hold</span> off</span><br><span class="line">axis([<span class="number">0</span> <span class="number">1</span> <span class="number">-80</span> <span class="number">0</span>])</span><br><span class="line">h=<span class="built_in">legend</span>(<span class="string">'Hann'</span>,<span class="string">'Hamming'</span>,<span class="string">'Blackman-Harris'</span>);</span><br><span class="line">xlabel(<span class="string">'$u$'</span>,<span class="string">'Interpreter'</span>,<span class="string">'latex'</span>)</span><br><span class="line">ylabel(<span class="string">'Beam pattern (dB)'</span>)</span><br></pre></td></tr></tbody></table></figure>

</details>
<h1 id="blackman-harris-加权">7. Blackman-Harris 加权</h1>
<p>  Blackman-Harris
加权把加权过程扩展到了更高阶谐波的情况，并在前两个旁瓣的峰值位置上放置了零点。加权函数为</p>
<p><span class="math display">\[\begin{equation}
  w(\tilde{n}) = 0.42 + 0.5 \cos\left( \frac{2\pi \tilde{n}}{N} \right)
+ 0.08 \cos\left( \frac{4\pi \tilde{n}}{N} \right), \quad \tilde{n} =
-\frac{N-1}{2}, \cdots, \frac{N-1}{2}
\end{equation}\]</span></p>
<p>对应的波束方向图是多个常规波束方向图的和，已在<a href="#fig.2-1-4">图
2.1.4</a> 中给出</p>
<p><span class="math display">\[\begin{equation}
  \begin{aligned}
    B_u(u) =&amp; 0.42 \frac{\sin\left( \displaystyle\frac{N\pi u}{2}
\right)}{\sin\left( \displaystyle\frac{\pi u}{2} \right)} + 0.25 \left[
\frac{\sin\left( \displaystyle\frac{N\pi}{2} \left( u - \frac{2}{N}
\right) \right)}{\sin\left( \displaystyle\frac{\pi}{2} \left( u -
\frac{2}{N} \right) \right)} + \frac{\sin\left(
\displaystyle\frac{N\pi}{2} \left( u + \frac{2}{N} \right)
\right)}{\sin\left( \displaystyle\frac{\pi}{2} \left( u + \frac{2}{N}
\right) \right)} \right] \\
    &amp;+ 0.04 \left[ \frac{\sin\left( \displaystyle\frac{N\pi}{2}
\left( u - \frac{2}{N} \right) \right)}{\sin\left(
\displaystyle\frac{\pi}{2} \left( u - \frac{2}{N} \right) \right)} +
\frac{\sin\left( \displaystyle\frac{N\pi}{4} \left( u + \frac{4}{N}
\right) \right)}{\sin\left( \displaystyle\frac{\pi}{4} \left( u +
\frac{4}{N} \right) \right)} \right]
  \end{aligned}
\end{equation}\]</span></p>
<p>波束方向图的参数为</p>
<table>
<colgroup>
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
</colgroup>
<thead>
<tr>
<th style="text-align: center;">加权方式</th>
<th style="text-align: center;">HPBW</th>
<th style="text-align: center;"><span class="math inline">\(BW_{NN}\)</span></th>
<th style="text-align: center;">第一旁瓣高度</th>
<th style="text-align: center;"><span class="math inline">\(D_N\)</span></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">Hann</td>
<td style="text-align: center;"><span class="math inline">\(1.44
\displaystyle\frac{2}{N}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(4.0
\displaystyle\frac{2}{N}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(-31.4
\text{dB}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(0.667\)</span></td>
</tr>
<tr>
<td style="text-align: center;">Hamming</td>
<td style="text-align: center;"><span class="math inline">\(1.31
\displaystyle\frac{2}{N}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(4.0
\displaystyle\frac{2}{N}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(-39.5
\text{dB}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(0.730\)</span></td>
</tr>
<tr>
<td style="text-align: center;">Blackman-Harris</td>
<td style="text-align: center;"><span class="math inline">\(1.65
\displaystyle\frac{2}{N}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(6.0
\displaystyle\frac{2}{N}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(-56.6
\text{dB}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(0.577\)</span></td>
</tr>
</tbody>
</table>
<p>至此，所有的加权方法都是基于各种正弦函数进行的。现在看看其他类型的阵列加权技术，试试能否更好在波束宽度和旁瓣之间的获得折中。</p>
<h1 id="长球函数-prolate-spheroidal-functions">8. 长球函数 (Prolate
Spheroidal Functions)</h1>
<p>  在设计加权方案时，我们的目标是使得一个给定角度范围内的能量占总能量的比例最大，也即最大化如下比值</p>
<p><span class="math display">\[\begin{equation}
  \alpha = \frac{\displaystyle\iint_{\varOmega_1}\left|
B(\theta,\varphi) \right|^2
\sin\theta\,\mathrm{d}\theta\,\mathrm{d}\varphi}{\displaystyle\int_0^\pi
\int_0^{2\pi}\left| B(\theta,\varphi) \right|^2
\sin\theta\,\mathrm{d}\varphi\,\mathrm{d}\theta}
\end{equation}\]</span></p>
<p>其中 <span class="math inline">\(\varOmega_1\)</span>
是主波束周围的一个区域。对于标准线性阵列，可以写成</p>
<p><span class="math display">\[\begin{equation}
  \alpha = \frac{\displaystyle\int_{-\psi_0}^{\psi_0}\left| B(\psi)
\right|^2\,\mathrm{d}\psi}{\displaystyle\int_{-\pi}^{\pi}\left| B(\psi)
\right|^2\,\mathrm{d}\psi}
\end{equation}\]</span></p>
<p>其分子和分母部分可分别写为</p>
<p>$$<span class="math display">\[\begin{align}
  &amp;\alpha_N &amp;&amp;\xlongequal{B(\psi) =
\boldsymbol{w}^\mathrm{H}\boldsymbol{v}_\psi(\psi)}
\int_{-\psi_0}^{\psi_0}\boldsymbol{w}^\mathrm{H}\boldsymbol{v}_\psi(\psi)
\boldsymbol{v}_\psi^\mathrm{H}(\psi)\boldsymbol{w}\,\mathrm{d}\psi
\notag \\
  &amp; &amp;&amp;= \boldsymbol{w}^\mathrm{H} \left[
\int_{-\psi_0}^{\psi_0} \boldsymbol{v}_\psi(\psi)
\boldsymbol{v}_\psi^\mathrm{H}(\psi) \,\mathrm{d}\psi
\right]\boldsymbol{w} \notag \\
  &amp; &amp;&amp;=
\boldsymbol{w}^\mathrm{H}\boldsymbol{A}\boldsymbol{w} \\

  &amp;\alpha_D &amp;&amp;\xlongequal{B(\psi) =
\boldsymbol{w}^\mathrm{H}\boldsymbol{v}_\psi(\psi)}  \int_{-\pi}^{\pi}\boldsymbol{w}^\mathrm{H}\boldsymbol{v}_\psi(\psi)
\boldsymbol{v} \notag \\
  &amp; &amp;&amp;=
\boldsymbol{w}^\mathrm{H}\boldsymbol{A}\boldsymbol{w}
\end{align}\]</span>$$</p>
<p>其中</p>
<p><span class="math display">\[\begin{align}
  \boldsymbol{A} &amp;\triangleq \int_{-\psi_0}^{\psi_0}
\boldsymbol{v}_\psi(\psi) \boldsymbol{v}_\psi^\mathrm{H}(\psi)
\,\mathrm{d}\psi \\
  \boldsymbol{B} &amp;\triangleq \int_{-\pi}^{\pi}
\boldsymbol{v}_\psi(\psi) \boldsymbol{v}_\psi^\mathrm{H}(\psi)
\,\mathrm{d}\psi = 2\pi \boldsymbol{I}
\end{align}\]</span></p>
<p><span class="math display">\[\begin{equation}
  [\boldsymbol{A}]_{mn} = \int_{-\psi_0}^{\psi_0} e^{jm\psi} e^{-jn\psi}
\,\mathrm{d}\psi = \frac{2\sin ((m-n)\psi_0)}{m-n} = 2\psi_0
\,\mathrm{sinc}((m-n)\psi_0)
\end{equation}\]</span></p>
<p>因此</p>
<p><span class="math display">\[\begin{equation}
  \alpha =
\frac{\boldsymbol{w}^\mathrm{H}\boldsymbol{A}\boldsymbol{w}}{2\pi
\boldsymbol{w}^\mathrm{H}\boldsymbol{w}}
\end{equation}\]</span></p>
<p>为了使 <span class="math inline">\(\alpha\)</span> 最大，求取矩阵
<span class="math inline">\(\boldsymbol{A}\)</span>
的特征值和特征矢量</p>
<p><span class="math display">\[\begin{equation}
  2\pi \lambda \boldsymbol{w} = \boldsymbol{A} \boldsymbol{w}
\end{equation}\]</span></p>
<p>并选择对应于最大特征值 <span class="math inline">\(\lambda\)</span>
的特征矢量，将 <span class="math inline">\([\boldsymbol{A}]_{mn}\)</span> 代入得到</p>
<p><span class="math display">\[\begin{equation}
  \label{DPSS}
  \sum_{n=1}^N \frac{\sin ((m-n)\psi_0)}{m-n} w_n = \pi \lambda
\omega_m,\quad m = 1,2,\cdots,N
\end{equation}\]</span></p>
<p>利用式 <span class="math inline">\(\eqref{DPSS}\)</span>
计算出的权值（或序列）称为<strong><mark class="label primary">离散长球序列（Discrete Prolate Spheroidal Sequences, DPSS</mark></strong>，对应的波束方向图称为<strong><mark class="label primary">离散长球函数（Discrete Prolate Spheroidal Functions）</mark></strong>。离散长球序列也称为<strong><mark class="label primary">Slepian 序列</mark></strong>。</p>
<p>  <a href="#fig.2-1-5">图 2.1.5</a>
给出了几个代表性的离散长球序列（归一化到 <span class="math inline">\(w_6\)</span>），<a href="#fig.2-1-6">图 2.1.6</a>
给出了对应的波束方向图：</p>
<ul>
<li>当 <span class="math inline">\(\psi_0\)</span> 接近于零的时候，<span class="math inline">\(w_0\)</span>
趋近于均匀加权，因为此时使方向性最大；</li>
<li>对于 <span class="math inline">\(\psi_0 =
0.2\pi\)</span>，大多数的能量集中在主波束，波束宽度略增大，旁瓣在 <span class="math inline">\(-20\text{dB}\)</span> 以下；</li>
<li>对于<span class="math inline">\(\psi_0 = 0.4\pi\)</span>，旁瓣为
<span class="math inline">\(-53\text{dB}\)</span>，但波束更宽。</li>
</ul>
<p>DPSS 加权的波束方向图参数为:</p>
<table>
<colgroup>
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
</colgroup>
<thead>
<tr>
<th style="text-align: center;"><span class="math inline">\(\psi_0\)</span></th>
<th style="text-align: center;">HPBW</th>
<th style="text-align: center;"><span class="math inline">\(BW_{NN}\)</span></th>
<th style="text-align: center;">第一旁瓣高度</th>
<th style="text-align: center;"><span class="math inline">\(D_N\)</span></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><span class="math inline">\(0.1\pi\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\displaystyle\frac{0.02}{N}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\displaystyle\frac{1.40\pi}{N}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(-15.6
\text{dB}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(0.981\)</span></td>
</tr>
<tr>
<td style="text-align: center;"><span class="math inline">\(0.2\pi\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\displaystyle\frac{2.20}{N}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\displaystyle\frac{1.79\pi}{N}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(-24.7
\text{dB}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(0.869\)</span></td>
</tr>
<tr>
<td style="text-align: center;"><span class="math inline">\(0.4\pi\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\displaystyle\frac{2.86}{N}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\displaystyle\frac{2.97\pi}{N}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(-52.2
\text{dB}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(0.665\)</span></td>
</tr>
</tbody>
</table>
<p><a id="fig.2-1-5"></a></p>
<figure>
<img data-src="../images/post/2023-06-19-josh-oap-part-2-1/2023-06-19-josh-oap-part-2-1-050-DiscreteProlateSpheroidalSequences.svg" width="700" alt="图 2-1-5 离散长球序列: \psi_0=0.1\pi,0.2\pi,0.4\pi">
<figcaption aria-hidden="true">图 2-1-5 离散长球序列: <span class="math inline">\(\psi_0=0.1\pi,0.2\pi,0.4\pi\)</span></figcaption>
</figure>
<p><a id="fig.2-1-6"></a></p>
<figure>
<img data-src="../images/post/2023-06-19-josh-oap-part-2-1/2023-06-19-josh-oap-part-2-1-060-BeamPatternForDPSSWeighting.svg" width="700" alt="图 2-1-6 DPSS 加权的波束方向图和 \psi_0 的关系: N = 11">
<figcaption aria-hidden="true">图 2-1-6 DPSS 加权的波束方向图和 <span class="math inline">\(\psi_0\)</span> 的关系: <span class="math inline">\(N = 11\)</span></figcaption>
</figure>
<details class="note primary"><summary><p>MATLAB Code</p>
</summary>
<figure class="highlight matlab"><figcaption><span>fig3_05_06_13.m</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% Figure 3.5</span></span><br><span class="line"><span class="comment">% DPSS psi0=0.1pi,0.2pi, and 0.4pi</span></span><br><span class="line"><span class="comment">% Figure 3.6</span></span><br><span class="line"><span class="comment">% Beampattern of a standard 11-element linear array as a function</span></span><br><span class="line"><span class="comment">% Figure 3.13</span></span><br><span class="line"><span class="comment">% Zero plots for DPSS(0.1pi,0.2pi,0.4pi) weightings</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% Lillian Xiaolan Xu</span></span><br><span class="line"><span class="comment">% Updated 4/14/99</span></span><br><span class="line"><span class="comment">% Lillian Xu 04/16/2001, K. Bell 7/22/01, 9/30/01</span></span><br><span class="line"><span class="comment">% Functions called: DPSS</span></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"></span><br><span class="line">close all</span><br><span class="line">clear all</span><br><span class="line">N=<span class="number">11</span>;</span><br><span class="line"></span><br><span class="line">us=<span class="number">0</span>;                           <span class="comment">% should change us between 0 and 0.2</span></span><br><span class="line">u=<span class="number">-1</span>:<span class="number">0.001</span>:<span class="number">1</span>;</span><br><span class="line">n=<span class="built_in">conj</span>(-(N<span class="number">-1</span>)/<span class="number">2</span>:(N<span class="number">-1</span>)/<span class="number">2</span>)';</span><br><span class="line">vs=<span class="built_in">exp</span>(<span class="number">1</span><span class="built_in">i</span>*n.*<span class="built_in">pi</span>.*us);</span><br><span class="line"></span><br><span class="line"><span class="comment">%------------------------ DPSS Weighting</span></span><br><span class="line">psi0=[<span class="number">0.1</span> <span class="number">0.2</span> <span class="number">0.4</span>]*<span class="built_in">pi</span>;</span><br><span class="line">w1=DPSS(psi0(<span class="number">1</span>),N);</span><br><span class="line">w2=DPSS(psi0(<span class="number">2</span>),N);</span><br><span class="line">w3=DPSS(psi0(<span class="number">3</span>),N);</span><br><span class="line"></span><br><span class="line">z1=roots(w1);</span><br><span class="line">z2=roots(w2);</span><br><span class="line">z3=roots(w3);</span><br><span class="line"></span><br><span class="line">w1=w1/<span class="built_in">max</span>(w1);</span><br><span class="line">w2=w2/<span class="built_in">max</span>(w2);</span><br><span class="line">w3=w3/<span class="built_in">max</span>(w3);</span><br><span class="line"></span><br><span class="line">m=<span class="number">-5</span>:<span class="number">5</span>;</span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line">h1 = <span class="built_in">plot</span>(m,w1);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line">h2 = <span class="built_in">plot</span>(m,w1,<span class="string">'o'</span>);</span><br><span class="line">h3 = <span class="built_in">plot</span>(m,w2,<span class="string">'--'</span>);</span><br><span class="line">h4 = <span class="built_in">plot</span>(m,w2,<span class="string">'o'</span>);</span><br><span class="line">h5 = <span class="built_in">plot</span>(m,w3,<span class="string">'-.'</span>);</span><br><span class="line">h6 = <span class="built_in">plot</span>(m,w3,<span class="string">'o'</span>);</span><br><span class="line"><span class="built_in">hold</span> off</span><br><span class="line">h=<span class="built_in">legend</span>([h1 h3 h5],{<span class="string">'$\psi_0=0.1\pi$'</span>,<span class="string">'$\psi_0=0.2\pi$'</span>, ...</span><br><span class="line">  <span class="string">'$\psi_0=0.4\pi$'</span>},Interpreter=<span class="string">"latex"</span>);</span><br><span class="line"><span class="comment">%title('DPSS for 11 elements');</span></span><br><span class="line">xticks(<span class="number">-5</span>:<span class="number">5</span>);</span><br><span class="line">xlabel(<span class="string">'Sensors'</span>);</span><br><span class="line">ylabel(<span class="string">'Weighting'</span>);</span><br><span class="line">grid on</span><br><span class="line"></span><br><span class="line"><span class="comment">%-----------------------------------------------------------%</span></span><br><span class="line"><span class="comment">% ---------------- Zero Plot.</span></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line"><span class="comment">%%%%%%%%%%%%      plot 1</span></span><br><span class="line"></span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">plot</span>(<span class="built_in">real</span>(z1),<span class="built_in">imag</span>(z1),<span class="string">'o'</span>);</span><br><span class="line">axis([<span class="number">-1.2</span> <span class="number">1.2</span> <span class="number">-1.2</span> <span class="number">1.2</span>])</span><br><span class="line">axis(<span class="string">'square'</span>)</span><br><span class="line">grid on;</span><br><span class="line">title(<span class="string">'$\psi_0=0.1\pi$'</span>,<span class="string">'Interpreter'</span>,<span class="string">'latex'</span>);</span><br><span class="line">xlabel(<span class="string">'Real'</span>)</span><br><span class="line">ylabel(<span class="string">'Imaginary'</span>)</span><br><span class="line">theta=<span class="number">2</span>*<span class="built_in">pi</span>*(<span class="number">0</span>:<span class="number">0.01</span>:<span class="number">1</span>);</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">plot</span>(<span class="built_in">cos</span>(theta),<span class="built_in">sin</span>(theta),<span class="string">'--'</span>);</span><br><span class="line"><span class="built_in">hold</span> off</span><br><span class="line"></span><br><span class="line"><span class="comment">%%%%%%%%%%%%  plot 2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">plot</span>(<span class="built_in">real</span>(z3),<span class="built_in">imag</span>(z3),<span class="string">'o'</span>);</span><br><span class="line">grid on;</span><br><span class="line">axis([<span class="number">-1.2</span> <span class="number">1.2</span> <span class="number">-1.2</span> <span class="number">1.2</span>])</span><br><span class="line">axis(<span class="string">'square'</span>)</span><br><span class="line">title(<span class="string">'$\psi_0=0.4\pi$'</span>,<span class="string">'Interpreter'</span>,<span class="string">'latex'</span>);</span><br><span class="line">xlabel(<span class="string">'Real'</span>)</span><br><span class="line">ylabel(<span class="string">'Imaginary'</span>)</span><br><span class="line">theta=<span class="number">2</span>*<span class="built_in">pi</span>*(<span class="number">0</span>:<span class="number">0.01</span>:<span class="number">1</span>);</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">plot</span>(<span class="built_in">cos</span>(theta),<span class="built_in">sin</span>(theta),<span class="string">'--'</span>);</span><br><span class="line"><span class="built_in">hold</span> off</span><br><span class="line"></span><br><span class="line">w1=w1./sum(w1);</span><br><span class="line">w2=w2./sum(w2);</span><br><span class="line">w3=w3./sum(w3);</span><br><span class="line"></span><br><span class="line">b=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> m=<span class="number">1</span>:N</span><br><span class="line">  b=b+w1(m)*<span class="built_in">exp</span>(<span class="number">1</span><span class="built_in">i</span>*(-(N+<span class="number">1</span>)/<span class="number">2</span>+m)*<span class="built_in">pi</span>*u);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">bdb1=<span class="number">20</span>*<span class="built_in">log10</span>(<span class="built_in">abs</span>(b));</span><br><span class="line">b1=<span class="built_in">real</span>(b);</span><br><span class="line">b=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> m=<span class="number">1</span>:N</span><br><span class="line">  b=b+w2(m)*<span class="built_in">exp</span>(<span class="number">1</span><span class="built_in">i</span>*(-(N+<span class="number">1</span>)/<span class="number">2</span>+m)*<span class="built_in">pi</span>*u);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">bdb2=<span class="number">20</span>*<span class="built_in">log10</span>(<span class="built_in">abs</span>(b));</span><br><span class="line">b2=<span class="built_in">real</span>(b);</span><br><span class="line">b=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> m=<span class="number">1</span>:N</span><br><span class="line">  b=b+w3(m)*<span class="built_in">exp</span>(<span class="number">1</span><span class="built_in">i</span>*(-(N+<span class="number">1</span>)/<span class="number">2</span>+m)*<span class="built_in">pi</span>*u);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">bdb3=<span class="number">20</span>*<span class="built_in">log10</span>(<span class="built_in">abs</span>(b));</span><br><span class="line">b3=<span class="built_in">real</span>(b);</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line"><span class="built_in">plot</span>(u,bdb1,u,bdb2,<span class="string">'--'</span>,u,bdb3,<span class="string">'-.'</span>);</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line">h=<span class="built_in">legend</span>({<span class="string">'$\psi_0=0.1\pi$'</span>,<span class="string">'$\psi_0=0.2\pi$'</span>,<span class="string">'$\psi_0=0.4\pi$'</span>}, ...</span><br><span class="line">  Interpreter=<span class="string">"latex"</span>);</span><br><span class="line">axis([<span class="number">-1</span> <span class="number">1</span> <span class="number">-80</span> <span class="number">0</span>])</span><br><span class="line">grid on</span><br><span class="line">xlabel(<span class="string">'$u$'</span>,<span class="string">'Interpreter'</span>,<span class="string">'latex'</span>)</span><br><span class="line">ylabel(<span class="string">'Beam pattern (dB)'</span>)</span><br></pre></td></tr></tbody></table></figure>

</details>
<h1 id="kaiser-加权">9. Kaiser 加权</h1>
<p>  Kaiser 利用 Bessel
函数提出了一个相对简单的长球序列的近似方法，在谱分析、滤波器设计和其他领域中,这种加权得到了广泛的应用。Kaiser
加权函数为</p>
<p><span class="math display">\[\begin{equation}
  w(\tilde{n}) = I_0 \left( \beta \sqrt{1 - \left[ \frac{2\tilde{n}}{N}
\right] ^2 } \right), \quad -\frac{N-1}{2} \leqslant \tilde{n} \leqslant
\frac{N-1}{2}
\end{equation}\]</span></p>
<p>其中 <span class="math inline">\(I_0(x)\)</span> 是零阶修正 Bessel
函数，参数 <span class="math inline">\(\beta\)</span>
决定了波束方向图在旁瓣峰值高度和主波束宽度之间的性能折中程度。</p>
<p>  <a href="#fig.2-1-7">图 2.1.7(a)</a> 给出了 <span class="math inline">\(N=11\)</span> 情况下 <span class="math inline">\(\beta=3\)</span> 和 <span class="math inline">\(\beta=6\)</span> 时的权值（归一化到 <span class="math inline">\(w_6\)</span>），<a href="#fig.2-1-7">图
2.1.7(b)</a> 给出了对应的波束方向图。注意到当 <span class="math inline">\(\beta\)</span> 减小时,权函数接近于均匀加权。当
<span class="math inline">\(N = 11\)</span> 时 Kaiser
加权的波束方向图参数为：</p>
<table>
<colgroup>
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
</colgroup>
<thead>
<tr>
<th style="text-align: center;"><span class="math inline">\(\beta\)</span></th>
<th style="text-align: center;">HPBW</th>
<th style="text-align: center;"><span class="math inline">\(BW_{NN}\)</span></th>
<th style="text-align: center;">第一旁瓣高度</th>
<th style="text-align: center;"><span class="math inline">\(D_N\)</span></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><span class="math inline">\(3\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\displaystyle\frac{2.18}{N}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\displaystyle\frac{1.75\pi}{N}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(-23.7
\text{dB}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(0.882\)</span></td>
</tr>
<tr>
<td style="text-align: center;"><span class="math inline">\(6\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\displaystyle\frac{2.80}{N}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\displaystyle\frac{2.76\pi}{N}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(-44.4
\text{dB}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(0.683\)</span></td>
</tr>
</tbody>
</table>
<p><a id="fig.2-1-7"></a></p>
<figure>
<img data-src="../images/post/2023-06-19-josh-oap-part-2-1/2023-06-19-josh-oap-part-2-1-070-KaiserWeighting.svg" width="700" alt="图 2-1-7 Kaiser 加权: (a) \beta=3 和 6 时的权值；(b) \beta=3 和 6 时的波束方向图">
<figcaption aria-hidden="true">图 2-1-7 Kaiser 加权: (a) <span class="math inline">\(\beta=3\)</span> 和 <span class="math inline">\(6\)</span> 时的权值；(b) <span class="math inline">\(\beta=3\)</span> 和 <span class="math inline">\(6\)</span> 时的波束方向图</figcaption>
</figure>
<details class="note primary"><summary><p>MATLAB Code</p>
</summary>
<figure class="highlight matlab"><figcaption><span>fig3_07.m</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% Figure 3.7</span></span><br><span class="line"><span class="comment">% Kaiser weighting</span></span><br><span class="line"><span class="comment">% (a)weighting for beta = 3 and 6</span></span><br><span class="line"><span class="comment">% (b)Beam patterns for beta = 3 and 6</span></span><br><span class="line"><span class="comment">% Xin Zhang updated 3/17/99</span></span><br><span class="line"><span class="comment">% Lillian Xiaolan Xu updated 09/20/2000</span></span><br><span class="line"><span class="comment">% Lillian Xiaolan Xu updated 04/16/2001, K. Bell 7/20/01, 9/30/01</span></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"></span><br><span class="line">clear all;</span><br><span class="line">close all;</span><br><span class="line"></span><br><span class="line">N = <span class="number">11</span>;</span><br><span class="line">Zl = (N<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">beta1 = <span class="number">3</span>;</span><br><span class="line">beta2 = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> n = -(N<span class="number">-1</span>)/<span class="number">2</span>:(N<span class="number">-1</span>)/<span class="number">2</span></span><br><span class="line">  x = <span class="number">1</span>-(<span class="number">2</span>*n/N)^<span class="number">2</span>;</span><br><span class="line">  wn1(n+<span class="number">1</span>+(N<span class="number">-1</span>)/<span class="number">2</span>,<span class="number">1</span>) = <span class="built_in">besseli</span>(<span class="number">0</span>,beta1*<span class="built_in">sqrt</span>(x));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> n = -(N<span class="number">-1</span>)/<span class="number">2</span>:(N<span class="number">-1</span>)/<span class="number">2</span></span><br><span class="line">  x = <span class="number">1</span>-(<span class="number">2</span>*n/N)^<span class="number">2</span>;</span><br><span class="line">  wn2(n+<span class="number">1</span>+(N<span class="number">-1</span>)/<span class="number">2</span>,<span class="number">1</span>) = <span class="built_in">besseli</span>(<span class="number">0</span>,beta2*<span class="built_in">sqrt</span>(x));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">nn = -Zl/<span class="number">2</span>:<span class="number">1</span>/<span class="number">2</span>:Zl/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">u=(<span class="number">-1</span>:<span class="number">0.001</span>:<span class="number">1</span>);</span><br><span class="line">amf=(-(N<span class="number">-1</span>)/<span class="number">2</span>:(N<span class="number">-1</span>)/<span class="number">2</span>)';</span><br><span class="line">Vo=<span class="built_in">exp</span>(<span class="number">1</span><span class="built_in">i</span>*amf*<span class="built_in">pi</span>*u);</span><br><span class="line">w1=wn1/sum(wn1);</span><br><span class="line">w2=wn2/sum(wn2);</span><br><span class="line">Beam1=<span class="number">20</span>*<span class="built_in">log10</span>(<span class="built_in">abs</span>(w1'*Vo));</span><br><span class="line">Beam2=<span class="number">20</span>*<span class="built_in">log10</span>(<span class="built_in">abs</span>(w2'*Vo));</span><br><span class="line"></span><br><span class="line">bes1 = <span class="built_in">besseli</span>(<span class="number">0</span>,beta1);</span><br><span class="line">bes2 = <span class="built_in">besseli</span>(<span class="number">0</span>,beta2);</span><br><span class="line">wn1 = wn1/bes1;</span><br><span class="line">wn2 = wn2/bes2;</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">plot</span>(nn,wn1,<span class="string">'-'</span>,nn,wn2,<span class="string">'--'</span>)</span><br><span class="line">xlabel(<span class="string">'$z/\lambda$'</span>,<span class="string">'Interpreter'</span>,<span class="string">'latex'</span>)</span><br><span class="line">ylabel(<span class="string">'Weights'</span>)</span><br><span class="line"><span class="comment">%title('Kaiser Window for 11 elements')</span></span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(nn,wn1,<span class="string">'o'</span>)</span><br><span class="line"><span class="built_in">plot</span>(nn,wn2,<span class="string">'o'</span>)</span><br><span class="line">axis([<span class="number">-2.5</span> <span class="number">2.5</span> <span class="number">-0.02</span> <span class="number">1.02</span>])</span><br><span class="line"><span class="built_in">hold</span> off;</span><br><span class="line"><span class="built_in">legend</span>({<span class="string">'$\beta = 3$'</span>,<span class="string">'$\beta = 6$'</span>},Interpreter=<span class="string">"latex"</span>);</span><br><span class="line">text(<span class="number">-0.0625</span>,<span class="number">-0.28</span>,<span class="string">'(a)'</span>)</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">plot</span>(u,Beam1,<span class="string">'-'</span>,u,Beam2,<span class="string">'--'</span>)</span><br><span class="line">h=<span class="built_in">legend</span>({<span class="string">'$\beta = 3$'</span>,<span class="string">'$\beta = 6$'</span>},Interpreter=<span class="string">"latex"</span>);</span><br><span class="line">axis([<span class="number">-1</span> <span class="number">1</span> <span class="number">-60</span> <span class="number">0</span>])</span><br><span class="line">text(<span class="number">-0.025</span>,<span class="number">-75</span>,<span class="string">'(b)'</span>)</span><br><span class="line">xlabel(<span class="string">'$u$'</span>,<span class="string">'Interpreter'</span>,<span class="string">'latex'</span>)</span><br><span class="line">ylabel(<span class="string">'Beam pattern (dB)'</span>)</span><br><span class="line"></span><br><span class="line">set(gcf,<span class="string">'Position'</span>,[<span class="number">0</span> <span class="number">0</span> <span class="number">600</span> <span class="number">600</span>])</span><br></pre></td></tr></tbody></table></figure>

</details>
<p>  <a href="#fig.2-1-8">图 2.1.8</a> 给出了固定 <span class="math inline">\(\beta=3\)</span>，<span class="math inline">\(N=11,21\)</span> 和 <span class="math inline">\(41\)</span>
时的波束方向图，三种情况具有相同的最高旁瓣。当 <span class="math inline">\(N\)</span> 改变时，最高旁瓣对应的 <span class="math inline">\(u\)</span> 值发生改变。</p>
<p><a id="fig.2-1-8"></a></p>
<figure>
<img data-src="../images/post/2023-06-19-josh-oap-part-2-1/2023-06-19-josh-oap-part-2-1-080-BeamPatternsForKaiserWeighting.svg" width="700" alt="图 2-1-8 Kaiser 加权的波束方向图：\beta = 3，N=11,21 和 41">
<figcaption aria-hidden="true">图 2-1-8 Kaiser 加权的波束方向图：<span class="math inline">\(\beta = 3\)</span>，<span class="math inline">\(N=11,21\)</span> 和 <span class="math inline">\(41\)</span></figcaption>
</figure>
<details class="note primary"><summary><p>MATLAB Code</p>
</summary>
<figure class="highlight matlab"><figcaption><span>fig3_08.m</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">% Figure 3.8</span></span><br><span class="line"><span class="comment">% Beam patterns for Kaiser weighting</span></span><br><span class="line"><span class="comment">% beta = 3, N = 11, 21, and 41</span></span><br><span class="line"><span class="comment">% Xin Zhang</span></span><br><span class="line"><span class="comment">% Last updated 04/16/2001 Lillian Xu, K. Bell 7/20/01,9/30/01</span></span><br><span class="line"><span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"></span><br><span class="line">clear all;</span><br><span class="line">close all;</span><br><span class="line"></span><br><span class="line">N1 = <span class="number">11</span>;</span><br><span class="line">N2 = <span class="number">21</span>;</span><br><span class="line">N3 = <span class="number">41</span>;</span><br><span class="line"><span class="built_in">beta</span> = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">bes = <span class="built_in">besseli</span>(<span class="number">0</span>,<span class="built_in">beta</span>);</span><br><span class="line"><span class="keyword">for</span> n = -(N1<span class="number">-1</span>)/<span class="number">2</span>:(N1<span class="number">-1</span>)/<span class="number">2</span></span><br><span class="line">  x = <span class="number">1</span>-(<span class="number">2</span>*n/N1)^<span class="number">2</span>;</span><br><span class="line">  wn1(n+<span class="number">1</span>+(N1<span class="number">-1</span>)/<span class="number">2</span>) = <span class="built_in">besseli</span>(<span class="number">0</span>,<span class="built_in">beta</span>*<span class="built_in">sqrt</span>(x));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">wn1 = wn1'/bes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> n = -(N2<span class="number">-1</span>)/<span class="number">2</span>:(N2<span class="number">-1</span>)/<span class="number">2</span></span><br><span class="line">  x = <span class="number">1</span>-(<span class="number">2</span>*n/N2)^<span class="number">2</span>;</span><br><span class="line">  wn2(n+<span class="number">1</span>+(N2<span class="number">-1</span>)/<span class="number">2</span>) = <span class="built_in">besseli</span>(<span class="number">0</span>,<span class="built_in">beta</span>*<span class="built_in">sqrt</span>(x));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">wn2 = wn2'/bes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> n = -(N3<span class="number">-1</span>)/<span class="number">2</span>:(N3<span class="number">-1</span>)/<span class="number">2</span></span><br><span class="line">  x = <span class="number">1</span>-(<span class="number">2</span>*n/N3)^<span class="number">2</span>;</span><br><span class="line">  wn3(n+<span class="number">1</span>+(N3<span class="number">-1</span>)/<span class="number">2</span>) = <span class="built_in">besseli</span>(<span class="number">0</span>,<span class="built_in">beta</span>*<span class="built_in">sqrt</span>(x));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">wn3 = wn3'/bes;</span><br><span class="line"></span><br><span class="line">u=(<span class="number">-1</span>:<span class="number">0.001</span>:<span class="number">1</span>);</span><br><span class="line">amf1=(-(N1<span class="number">-1</span>)/<span class="number">2</span>:(N1<span class="number">-1</span>)/<span class="number">2</span>)';</span><br><span class="line">Vo1=<span class="built_in">exp</span>(<span class="number">1</span><span class="built_in">i</span>*amf1*<span class="built_in">pi</span>*u);</span><br><span class="line">amf2=(-(N2<span class="number">-1</span>)/<span class="number">2</span>:(N2<span class="number">-1</span>)/<span class="number">2</span>)';</span><br><span class="line">Vo2=<span class="built_in">exp</span>(<span class="number">1</span><span class="built_in">i</span>*amf2*<span class="built_in">pi</span>*u);</span><br><span class="line">amf3=(-(N3<span class="number">-1</span>)/<span class="number">2</span>:(N3<span class="number">-1</span>)/<span class="number">2</span>)';</span><br><span class="line">Vo3=<span class="built_in">exp</span>(<span class="number">1</span><span class="built_in">i</span>*amf3*<span class="built_in">pi</span>*u);</span><br><span class="line">wn1=wn1/sum(wn1);</span><br><span class="line">wn2=wn2/sum(wn2);</span><br><span class="line">wn3=wn3/sum(wn3);</span><br><span class="line">Beam1=<span class="number">20</span>*<span class="built_in">log10</span>(<span class="built_in">abs</span>(wn1'*Vo1));</span><br><span class="line">Beam2=<span class="number">20</span>*<span class="built_in">log10</span>(<span class="built_in">abs</span>(wn2'*Vo2));</span><br><span class="line">Beam3=<span class="number">20</span>*<span class="built_in">log10</span>(<span class="built_in">abs</span>(wn3'*Vo3));</span><br><span class="line"><span class="built_in">plot</span>(u,Beam3,<span class="string">'-'</span>,u,Beam2,<span class="string">'--'</span>,u,Beam1,<span class="string">'-.'</span>)</span><br><span class="line">h=<span class="built_in">legend</span>({<span class="string">'$N = 41$'</span>,<span class="string">'$N = 21$'</span>,<span class="string">'$N = 11$'</span>},Interpreter=<span class="string">"latex"</span>);</span><br><span class="line">axis([<span class="number">-1</span> <span class="number">1</span> <span class="number">-50</span> <span class="number">0</span>])</span><br><span class="line">xlabel(<span class="string">'$u$'</span>,<span class="string">'Interpreter'</span>,<span class="string">'latex'</span>)</span><br><span class="line">ylabel(<span class="string">'Beam pattern (dB)'</span>)</span><br></pre></td></tr></tbody></table></figure>

</details>
<h1 id="参考文献">参考文献</h1>
<ol type="1">
<li>Harry L. Van Trees. <em>Optimum array processing: Part IV of
detection, estimation, and modulation theory.</em> New York, NY, USA:
John Wiley &amp; Sons, 2002.</li>
<li>Harry L. Van Trees, 汤俊. <em>最优阵列处理技术.</em>
北京：清华大学出版社. 2008.</li>
</ol>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr>
<ol>
<li id="fn1"><p>参数 <span class="math inline">\(D_N\)</span>
是阵列的归一化方向性。它是相对于一个均匀加权阵列的方向性进行归一化的。对于标准线阵,
<span class="math inline">\(D_N\)</span> 也是归一化的白噪声增益。<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>这个权值是奥地利气象学家 Von Hann 提出的，有时也称为
Hanning 加权。<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/css/markmap.css">

<script src="/js/markmap.js"></script>
]]></content>
      <categories>
        <category>Josh 的学习笔记</category>
        <category>最优阵列处理</category>
        <category>线形阵列和孔径的合成</category>
      </categories>
      <tags>
        <tag>阵列信号处理</tag>
        <tag>谱加权</tag>
        <tag>线阵</tag>
      </tags>
  </entry>
  <entry>
    <title>Source Localization and Sensing: A Nonparametric Iterative Adaptive Approach Based on Weighted Least Squares</title>
    <url>/posts/304dacfb.html</url>
    <content><![CDATA[<h1 id="meta-data">Meta Data</h1>
<ul>
<li><p>Title: Source Localization and Sensing: A Nonparametric Iterative
Adaptive Approach Based on Weighted Least Squares</p></li>
<li><p>Journal: IEEE Transactions on Aerospace and Electronic
Systems</p></li>
<li><p>Date: 2010</p></li>
<li><p>Author:</p>
<ul>
<li><p>Tarik Yardibi: Department of Electrical and Computer Engineering,
University of California</p></li>
<li><p>Jian Li: Department of Electrical and Computer Engineering,
University of California</p></li>
</ul></li>
<li><p><a href="https://www.connectedpapers.com/main/e2ca1a746f52d906458fb8ffc0d33e21b7877aa4/Source-Localization-and-Sensing%3A-A-Nonparametric-Iterative-Adaptive-Approach-Based-on-Weighted-Least-Squares/graph">Connected
Papers:</a></p>
<figure>
<img data-src="../images/post/2024-01-30-paper-yardibiSourceLocalizationSensing2010/2024-01-30-paper-yardibiSourceLocalizationSensing2010-010-ConnectedPaper.png" width="1200" alt="Connected Papers 引用关系">
<figcaption aria-hidden="true">Connected Papers 引用关系</figcaption>
</figure></li>
</ul>
<span id="more"></span>
<h1 id="abs-intro">Abs &amp; Intro</h1>
<ul>
<li><p>背景：</p>
<ul>
<li><p>阵列处理面临的问题：快拍数不足、低 SNR、邻近源</p></li>
<li><p>场景：水下阵列、SISO 雷达/声纳范围-多普勒成像、MISO
通信的信道估计</p></li>
<li><p>基本阵列处理方法：</p>
<ul>
<li><p>DAS：最基本的方法，分辨率低，旁瓣高</p></li>
<li><p>标准 Capon 波束成形器
（SCB）、MUSIC：对不想干信源，在快拍数足够多时具有超分辨能力</p></li>
<li><p>存在的问题：快拍数不足时、相干信源、低 SNR 时无法使用</p></li>
</ul></li>
<li><p>稀疏信号表出方法：</p>
<ul>
<li><p>原因：实际源的数量远小于可能的方向；</p></li>
<li><p>优点：可以处理很少快拍的情况，即使只有一个快拍</p></li>
<li><p>缺点：计算时间过长，需要调谐一个或数个超参数</p></li>
</ul></li>
</ul></li>
<li><p>问题：快拍数不足时难以估计信源参数</p></li>
<li><p>方法：</p>
<ul>
<li><p>基本算法：</p>
<ul>
<li><p><strong>方法</strong>：提出了一种<strong><em>非参数化、无超参数、基于最小二乘的迭代自适应方法</em></strong>，用于阵列处理中的幅度和相位估计（Iterative
Adaptive Approach for Amplitude and Phase EStimation,
IAA-APES）。</p></li>
<li><p><strong>效果</strong>：IAA-APES
可以在少量快拍数据（甚至只有一个快拍）、不相干、部分相干和相干源以及任意阵列几何结构的情况下表现出良好的性能。</p></li>
<li><p><strong>扩展应用</strong>：IAA-APES 还可应用于主动感知（Active
Sensing）应用，包括 SISO 雷达/声纳范围-多普勒成像以及用于通信的 MISO
信道估计。</p></li>
</ul></li>
<li><p>扩展算法：</p>
<ul>
<li><p>IAA-APES 可以通过模型阶数选择工具贝叶斯信息准则（Bayesian
Information Criterion, BIC）扩展以获得稀疏结果，进而进行点源估计（point
source estimation）。</p></li>
<li><p>可以进一步通过应用基于参数松弛的循环方法（RELAX）来改进
IAA-APES&amp;BIC 估计的分辨率和准确性。</p></li>
</ul></li>
</ul></li>
</ul>
<h1 id="method">Method</h1>
<h2 id="passive-sensing">Passive Sensing</h2>
<h3 id="基本模型">基本模型</h3>
<figure>
<img data-src="../images/post/2024-01-30-paper-yardibiSourceLocalizationSensing2010/2024-01-30-paper-yardibiSourceLocalizationSensing2010-020-FarFiledLinearArray.png" width="500" alt="远场线阵模型">
<figcaption aria-hidden="true">远场线阵模型</figcaption>
</figure>
<p>假设有 <span class="math inline">\(K\)</span> 个信源，位于 <span class="math inline">\(\boldsymbol{\theta}\triangleq[\theta_1,\cdots,\theta_K]\)</span>，设快拍数为
<span class="math inline">\(N\)</span>，则到达 <span class="math inline">\(M\)</span> 元阵列的接收快拍可表示为 <span class="math inline">\(M\)</span> 维矢量</p>
<p><span class="math display">\[
\mathbf{y}(n) = \mathbf{A}(\boldsymbol{\theta})
\mathbf{s}(n)+\mathbf{e}(n),\quad n=1,\cdots,N
\]</span></p>
<p>其中</p>
<ul>
<li><p>阵列流形/导向矩阵：<span class="math inline">\(\mathbf{A}(\boldsymbol{\theta})\triangleq[\mathbf{a}(\theta_1),\cdots,\mathbf{a}(\theta_K)]\)</span>，<span class="math inline">\(\{\mathbf{a}(\theta_k)\in\mathbb{C}^{M\times
1}\}_{k=1}^K\)</span>，由阵列几何结构和信源的相对位置关系决定</p></li>
<li><p>信源：<span class="math inline">\(\mathbf{s}(n)\triangleq[s_1(n),\cdots,s_K(n)]^\mathrm{T}\)</span></p></li>
<li><p>噪声：<span class="math inline">\(\mathbf{e}(n)\triangleq[e_1(n),\cdots,e_M(n)]^\mathrm{T}\)</span></p></li>
</ul>
<p>由于实际信号数量未知，因此 <span class="math inline">\(K\)</span>
可以看做是扫描格点的数量，这也是稀疏算法可以在 DOA
估计中应用的原因。</p>
<h3 id="iaa-apes">IAA-APES</h3>
<blockquote>
<p>IAA-APES 是一种基于加权最小二乘（Weighted Least Square,
WLS）的数据相关非参数化算法。</p>
</blockquote>
<p>将每个格点的功率记在对角阵的对角线元素中：<span class="math inline">\(\mathbf{P}\in\mathbb{C}^{K\times K}\)</span></p>
<p><span class="math display">\[
P_k = \frac{1}{N}\sum_{n=1}^N | s_k(n)|^2, \quad k = 1,\cdots,K
\]</span></p>
<p>则干扰（对于当前方向 <span class="math inline">\(\theta_k\)</span>
而言，其他方向的信号也算作干扰）和噪声协方差矩阵 <span class="math inline">\(\mathbf{Q}(\theta_k)\in\mathbb{C}^{M\times
M}\)</span></p>
<p><span class="math display">\[
\begin{align*}
  \mathbf{Q}(\theta_k) &amp;=
\mathbb{E}[\mathbf{y}(n)\mathbf{y}^{\mathrm{H}}(n)] -
\mathbb{E}\left[\left(\mathbf{a}\left(\theta_k\right)\mathbf{s}(n)\right)(\mathbf{a}(\theta_k)\mathbf{s}(n))^{\mathrm{H}}\right]\\
  &amp;=
\mathbb{E}\left[\mathbf{A}\left(\theta\right)\mathbf{s}(n)\mathbf{s}^{\mathrm{H}}(n)\mathbf{A}^\mathrm{H}(\theta)\right]
-
\mathbb{E}\left[\mathbf{a}\left(\theta_k\right)\mathbf{s}(n)\mathbf{s}^{\mathrm{H}}(n)\mathbf{a}^{\mathrm{H}}(\theta_k)\right]\\
  &amp;=\mathbf{A}(\boldsymbol{\theta}) \mathbf{P}
\mathbf{A}^{\mathrm{H}}(\boldsymbol{\theta}) - P_k
\mathbf{a}\left(\theta_k\right)
\mathbf{a}^{\mathrm{H}}\left(\theta_k\right) \\
  &amp;\triangleq \mathbf{R} - P_k \mathbf{a}\left(\theta_k\right)
\mathbf{a}^{\mathrm{H}}\left(\theta_k\right)
\end{align*}
\]</span></p>
<p>则 WLS 的代价函数为</p>
<p><span class="math display">\[
\sum_{n=1}^N \left\| \mathbf{y}(n) - s_k(n) \mathbf{a}(\theta_k)
\right\|^2_{\mathbf{Q}^{-1}(\theta_k)}
\]</span></p>
<p>其中 <span class="math inline">\(\left\| \mathbf{x}
\right\|^2_{\mathbf{Q}^{-1}(\theta_k)}\triangleq\mathbf{x}^{\mathrm{H}}\mathbf{Q}^{-1}(\theta_k)\mathbf{x}\)</span>。</p>
<blockquote>
<figure>
<img data-src="../images/post/2024-01-30-paper-yardibiSourceLocalizationSensing2010/2024-01-30-paper-yardibiSourceLocalizationSensing2010-030-ChatGPT1.png" width="700" alt="ChatGPT 问答">
<figcaption aria-hidden="true">ChatGPT 问答</figcaption>
</figure>
<figure>
<img data-src="../images/post/2024-01-30-paper-yardibiSourceLocalizationSensing2010/2024-01-30-paper-yardibiSourceLocalizationSensing2010-040-ChatGPT2.png" width="700" alt="ChatGPT 问答">
<figcaption aria-hidden="true">ChatGPT 问答</figcaption>
</figure>
</blockquote>
<p>最小化 WLS 的代价函数可得</p>
<p><span class="math display">\[
\begin{align*}
\hat{s}_k(n) &amp;= \frac{\mathbf{a}^{\mathrm{H}}(\theta_k)
\mathbf{Q}^{-1}(\theta_k)
\mathbf{y}(n)}{\mathbf{a}^{\mathrm{H}}(\theta_k)
\mathbf{Q}^{-1}(\theta_k) \mathbf{a}(\theta_k)} \\
  &amp;= \frac{\mathbf{a}^{\mathrm{H}}(\theta_k) \mathbf{R}^{-1}
\mathbf{y}(n)}{\mathbf{a}^{\mathrm{H}}(\theta_k) \mathbf{R}^{-1}
\mathbf{a}(\theta_k)} \\
\end{align*}, \quad n = 1,\cdots,N
\]</span></p>
<p>且对于每个扫描格点，<span class="math inline">\(\{\hat{s}(n)\}_{k=1}^K\)</span>
可以并行计算，因此可在并行硬件上实现。</p>
<figure>
<img data-src="../images/post/2024-01-30-paper-yardibiSourceLocalizationSensing2010/2024-01-30-paper-yardibiSourceLocalizationSensing2010-050-IAA-APES.png" width="600" alt="IAA-APES 算法">
<figcaption aria-hidden="true">IAA-APES 算法</figcaption>
</figure>
<ul>
<li><p>IAA-APES 由上表给出，由于 IAA-APES 需要 <span class="math inline">\(\mathbf{R}\)</span>，且 <span class="math inline">\(\mathbf{R}\)</span>
依赖于未知信号功率，因此必须用迭代来实现。</p></li>
<li><p><span class="math inline">\(\mathbf{P}\)</span> 和 <span class="math inline">\(\mathbf{R}\)</span>
由信号的估计得出，而非直接由快拍得出。</p></li>
<li><p>初始 <span class="math inline">\(P_k\)</span> 由 DAS
获得，并进行归一化</p>
<p><span class="math display">\[
\begin{align*}
  \hat{P}_k &amp;=
\displaystyle\frac{1}{(\mathbf{a}^{\mathrm{H}}(\theta_k)\mathbf{a}(\theta_k))^2
N} \sum_{n=1}^{N}\left| \mathbf{a}^{\mathrm{H}}(\theta_k) \mathbf{y}(n)
\right|^2
  \\
  &amp;=\displaystyle\frac{1}{(\mathbf{a}^{\mathrm{H}}(\theta_k)\mathbf{a}(\theta_k))^2
N} \sum_{n=1}^{N}\left| \mathbf{a}^{\mathrm{H}}(\theta_k)
\mathbf{a}(\theta_k) \mathbf{s}(n) \right|^2 \\
\end{align*}
\]</span></p></li>
<li><p>经验结论：IAA-APES 的性能在 15 次迭代后就提升不大了。</p></li>
<li><p>由于 <span class="math inline">\(\mathbf{P}\)</span>
具有对角结构，所以对少量快拍和相干源都适用。</p></li>
</ul>
<h3 id="iaa-apesbic">IAA-APES&amp;BIC</h3>
<p>引入模型阶数选择工具（model-order selection tool） BIC。</p>
<p>工作原理：令 <span class="math inline">\(\mathcal{P}\)</span> 为从
IAA-APES 空间功率谱估计中选择的峰值的索引集合；令 <span class="math inline">\(\mathcal{I}\)</span> 为到目前为止由 BIC
算法选择的峰值的索引集合。IAA-APES&amp;BIC
算法的工作原理如下：首先，从集合 <span class="math inline">\(\mathcal{P}\)</span> 中选择具有最小 BIC
值的峰值。然后，从集合 <span class="math inline">\(\mathcal{P}-\mathcal{I}\)</span>
中选择第二个峰值，它与第一个峰值一起使 BIC 值最小，依此类推，直到 BIC
值不再减小。</p>
<figure>
<img data-src="../images/post/2024-01-30-paper-yardibiSourceLocalizationSensing2010/2024-01-30-paper-yardibiSourceLocalizationSensing2010-060-IAA-APES-BIC.png" width="600" alt="IAA-APES&amp;BIC 算法">
<figcaption aria-hidden="true">IAA-APES&amp;BIC 算法</figcaption>
</figure>
<p>其中</p>
<ul>
<li><p><span class="math inline">\(\text{BIC}_i(\eta) = 2MN \ln \left(
\displaystyle\sum_{n=1}^N \left\| \mathbf{y}(n) - \sum_{j \in \{
\mathcal{I} \cup i \}} \mathbf{a}(\theta_j) \hat{\mathbf{s}}_j (n)
\right\|_2^2 \right) + 3\eta \ln (2MN)\)</span></p>
<ul>
<li>也即，将使得接收快拍 <span class="math inline">\(\mathbf{y}(n)\)</span> 和估计信号 <span class="math inline">\(\displaystyle\sum_{j \in \{ \mathcal{I} \cup i \}}
\mathbf{a}(\theta_j) \hat{\mathbf{s}}_j (n)\)</span> 的距离最小的 index
作为峰值的 index</li>
</ul></li>
<li><p><span class="math inline">\(\eta = |\mathcal{I}| +
1\)</span>，<span class="math inline">\(|\mathcal{I}|\)</span> 表示集合
<span class="math inline">\(\mathcal{I}\)</span> 的大小</p></li>
<li><p><span class="math inline">\(i\)</span> 表示当前峰的
index</p></li>
<li><p><span class="math inline">\(\{\hat{\mathbf{s}}_j
(n)\}_{n=1}^N\)</span> 是 IEE-APES 在 <span class="math inline">\(\theta_j,j\in\{\mathcal{I}\cup i\}\)</span>
方向的波形估计</p></li>
<li><p>第二项不影响峰值选择（选多少个峰），但是影响峰值数量的选择（留多少个峰）</p></li>
</ul>
<h3 id="iaa-apesrelax">IAA-APES&amp;RELAX</h3>
<p>RELAX 是一种参数循环算法，需要预先知道源数量。</p>
<p>工作原理：在 IAA-APEX
搜索结果的基础上，在每个峰的周围细化角度进行搜索，以功率为依据，修正信号来向和
DOA 估计波形。当两次估计的差小于一定门限（e.g.&nbsp;<span class="math inline">\(5\times10^4\)</span>）时可认为收敛。</p>
<figure>
<img data-src="../images/post/2024-01-30-paper-yardibiSourceLocalizationSensing2010/2024-01-30-paper-yardibiSourceLocalizationSensing2010-070-IAA-APES-RELAX.png" width="600" alt="IAA-APES&amp;BIC 算法">
<figcaption aria-hidden="true">IAA-APES&amp;BIC 算法</figcaption>
</figure>
<h2 id="active-sensing">Active Sensing</h2>
<h1 id="simulation">Simulation</h1>
<h2 id="passive-sensing-1">Passive Sensing</h2>
<ul>
<li><p>对比方法：</p>
<ul>
<li><p>DAS</p></li>
<li><p>IAA-APES</p></li>
<li><p>IAA-APES&amp;RELAX</p></li>
<li><p>M-FOCUSS（Multiple-snapshot Focal Underdetermined System
Solution）：稀疏参数 <span class="math inline">\(p=0.8\)</span>，根据实际源的位置精调正则化参数
<span class="math inline">\(\lambda\)</span> 以获得最佳结果，因此
impractical</p></li>
<li><p>M-SBL（Sparse Bayesian Learning）</p></li>
<li><p><span class="math inline">\(\ell_1\)</span>-SVD（Singular Value
Decomposition）：假定源数量已知，精调超参数，impractical</p></li>
</ul></li>
<li><p>仿真条件：</p>
<ul>
<li><p>扫描格点：1°~180°范围，1°步进</p></li>
<li><p>ULA，12个阵元，半波长间距</p></li>
<li><p>噪声：均值为零、方差为 <span class="math inline">\(\sigma^2\)</span>
的圆周对称独立同分布复高斯随机过程</p></li>
<li><p>信号：</p>
<ul>
<li><p>远场、窄带：</p></li>
<li><p>功率归一化，使得 <span class="math inline">\(\displaystyle\frac{1}{N}\sum_{n=1}^{N}|s_k(n)|^2=P_k,k=1,\cdots,K_0\)</span>，其中
<span class="math inline">\(N\)</span> 是快拍数，<span class="math inline">\(K_0\)</span> 是实际信源个数；</p></li>
<li><p>信噪比定义为 <span class="math inline">\(\text{SNR}_{\text{dB}}=10 \log_{10}
\displaystyle\frac{P_k}{\sigma^2},k=1,\cdots,K_0\)</span></p></li>
</ul></li>
</ul></li>
<li><p>仿真结果</p>
<ul>
<li><p>Case 1：</p>
<ul>
<li><p>三个<strong><em>不相干</em></strong>的源，分别位于 60°、82° 和
90°，SNR 分别为 5dB、10dB 和 10dB，单次迭代所用快拍数 <span class="math inline">\(N=3\)</span>，每种方法 10 次仿真</p></li>
<li><p>各种方法 DOA 估计结果：</p>
<ul>
<li><p>DAS：可能混叠</p></li>
<li><p>IAA-APES</p></li>
<li><p>IAA-APES&amp;RELAX：可以准确判断信源个数、方向和功率</p></li>
<li><p>M-FOCUSS、M-SBL、<span class="math inline">\(\ell_1\)</span>-SVD：均不准确</p></li>
</ul></li>
</ul>
<figure>
<img data-src="../images/post/2024-01-30-paper-yardibiSourceLocalizationSensing2010/2024-01-30-paper-yardibiSourceLocalizationSensing2010-080-Sim-PS-Case1.png" width="800" alt="Three uncorrelated sources at 60° (5 dB power), 82° (10 dB power), and 90° (10 dB power), as represented by circles and vertical dotted lines in each plot. N = 3, the noise power is 0 dB (which results in minimum SNR of 5 dB), and 10 Monte-Carlo trials are shown. (a) DAS spatial estimate. (b) IAA-APES spatial estimate. (c) IAA-APES&amp;RELAX point source estimates. (d) M-FOCUSS spatial estimate. (e) M-SBL spatial estimate. (f) \ell_1-SVD spatial estimate.">
<figcaption aria-hidden="true">Three uncorrelated sources at 60° (5 dB
power), 82° (10 dB power), and 90° (10 dB power), as represented by
circles and vertical dotted lines in each plot. <span class="math inline">\(N = 3\)</span>, the noise power is 0 dB (which
results in minimum SNR of 5 dB), and 10 Monte-Carlo trials are shown.
(a) DAS spatial estimate. (b) IAA-APES spatial estimate. (c)
IAA-APES&amp;RELAX point source estimates. (d) M-FOCUSS spatial
estimate. (e) M-SBL spatial estimate. (f) <span class="math inline">\(\ell_1\)</span>-SVD spatial estimate.</figcaption>
</figure></li>
<li><p>Case 2：</p>
<ul>
<li><p>三个<strong><em>相干</em></strong>的源，分别位于 60°、80° 和
90°，SNR 分别为 10dB、10dB 和 10dB，单次迭代所用快拍数 <span class="math inline">\(N=3\)</span>，每种方法 10 次仿真；</p></li>
<li><p>各种方法 DOA 估计结果：</p>
<ul>
<li><p>DAS：完全混叠</p></li>
<li><p>IAA-APES</p></li>
<li><p>IAA-APES&amp;RELAX：可以准确判断信源个数、方向和功率</p></li>
<li><p>M-FOCUSS、M-SBL、<span class="math inline">\(\ell_1\)</span>-SVD：均不准确</p></li>
</ul></li>
</ul>
<figure>
<img data-src="../images/post/2024-01-30-paper-yardibiSourceLocalizationSensing2010/2024-01-30-paper-yardibiSourceLocalizationSensing2010-090-Sim-PS-Case2.png" width="800" alt="Three coherent sources at 60°, 80°, and 90°, each with 10 dB power, as represented by circles and vertical dotted lines in each plot. N = 3, noise power is 0 dB (SNR = 10 dB), and 10 Monte-Carlo trials are shown. (a) DAS spatial estimate. (b) IAA-APES spatial estimate. (c) IAA-APES&amp;RELAX point source estimates. (d) M-FOCUSS spatial estimate. (e) M-SBL spatial estimate. (f) \ell_1-SVD spatial estimate.">
<figcaption aria-hidden="true">Three coherent sources at 60°, 80°, and
90°, each with 10 dB power, as represented by circles and vertical
dotted lines in each plot. <span class="math inline">\(N = 3\)</span>,
noise power is 0 dB (SNR = 10 dB), and 10 Monte-Carlo trials are shown.
(a) DAS spatial estimate. (b) IAA-APES spatial estimate. (c)
IAA-APES&amp;RELAX point source estimates. (d) M-FOCUSS spatial
estimate. (e) M-SBL spatial estimate. (f) <span class="math inline">\(\ell_1\)</span>-SVD spatial estimate.</figcaption>
</figure></li>
<li><p>Case 3:</p>
<ul>
<li><p>两个<strong><em>不相干</em></strong>的源，分别位于 77.51° 和
90.51°（避开 1° 的格点），单次迭代所用快拍数 <span class="math inline">\(N=1\)</span>，每种方法 100 次仿真；</p>
<ul>
<li><p>IAA-APES&amp;RELAX：原条件</p></li>
<li><p>FOCUSS、<span class="math inline">\(\ell_1\)</span>-SVD：分辨率
0.01°，950 个格点，即 <span class="math inline">\(K=950\)</span>，均具有两个超参数需要根据不同场景调节</p></li>
<li><p>SBL：复杂度过大，不展示</p></li>
</ul></li>
<li><p>结果：各算法在不同 SNR 下的 (a) 角度估计的总均方误差和 CRB；(b)
角度估计总偏差</p>
<ul>
<li>IAA-APES&amp;RELAX：低 SNR 下表现更好</li>
</ul></li>
</ul>
<figure>
<img data-src="../images/post/2024-01-30-paper-yardibiSourceLocalizationSensing2010/2024-01-30-paper-yardibiSourceLocalizationSensing2010-100-Sim-PS-Case3.png" width="800" alt="Two uncorrelated sources at 77.51° and 90.51° with N = 1. (a) Total angle estimation MSE in dB together with CRB. (b) Total angle estimation bias versus SNR. Each point is average of 100 Monte-Carlo trials. Recall that FOCUSS is single snapshot version of M-FOCUSS.">
<figcaption aria-hidden="true">Two uncorrelated sources at 77.51° and
90.51° with <span class="math inline">\(N = 1\)</span>. (a) Total angle
estimation MSE in dB together with CRB. (b) Total angle estimation bias
versus SNR. Each point is average of 100 Monte-Carlo trials. Recall that
FOCUSS is single snapshot version of M-FOCUSS.</figcaption>
</figure></li>
</ul></li>
<li><p>复杂度分析：假设 <span class="math inline">\(K\gg
M\)</span>，也即格点数远大于阵元数</p>
<ul>
<li><p>IAA-APES：每次迭代 <span class="math inline">\(\mathcal{O}(M^2K)\)</span></p></li>
<li><p>IAA-APES&amp;BIC：每次迭代 <span class="math inline">\(\mathcal{O}(M^2K)\)</span>，由 BIC
导致的复杂度增加相比原复杂度可以忽略不计</p></li>
<li><p>IAA-APES&amp;RELAX：取决于 IAA-APES&amp;BIC
得到的信源个数、终止条件和所选用的方法</p></li>
<li><p>M-FOCUSS、M-SBL：每次迭代 <span class="math inline">\(\mathcal{O}(M^2K)\)</span></p></li>
<li><p><span class="math inline">\(\ell_1\)</span>-SVD：每次迭代 <span class="math inline">\(\mathcal{O}(M^2K_{\text{SVD}}^3)\)</span>，其中<span class="math inline">\(K_{\text{SVD}}\)</span> 是估计的信源个数</p></li>
</ul>
<p>在作者的实验过程中：</p>
<ul>
<li><p>RELAX 通常比 IAA-APES 更快收敛</p></li>
<li><p>IAA-APES 总是比 M-FOCUSS、M-SBL 和 <span class="math inline">\(\ell_1\)</span>-SVD 更快收敛，特别是当 SNR
较低时</p></li>
</ul></li>
</ul>
<h2 id="active-sensing-1">Active Sensing</h2>
<h3 id="siso-range-doppler-imaging">SISO Range-Doppler Imaging</h3>
<figure>
<img data-src="../images/post/2024-01-30-paper-yardibiSourceLocalizationSensing2010/2024-01-30-paper-yardibiSourceLocalizationSensing2010-110-Sim-AS-Case1.png" width="800" alt="SISO range-Doppler imaging with three 5 dB and six 25 dB targets, indicated by circles. Noise power is 0 dB, resulting in minimum SNR of 5 dB. (a) Ground truth with power levels. (b) Matched filter. (c) MP and ground truth. (d) OMP and ground truth. (e) LSMP and ground truth. (f) IAA-APES. (g) IAA-APES&amp;BIC and ground truth. (h) IAA-APES&amp;RELAX and ground truth. All power levels are in dB.">
<figcaption aria-hidden="true">SISO range-Doppler imaging with three 5
dB and six 25 dB targets, indicated by circles. Noise power is 0 dB,
resulting in minimum SNR of 5 dB. (a) Ground truth with power levels.
(b) Matched filter. (c) MP and ground truth. (d) OMP and ground truth.
(e) LSMP and ground truth. (f) IAA-APES. (g) IAA-APES&amp;BIC and ground
truth. (h) IAA-APES&amp;RELAX and ground truth. All power levels are in
dB.</figcaption>
</figure>
<h3 id="miso-communication-channel-estimation">MISO Communication
Channel Estimation</h3>
<figure>
<img data-src="../images/post/2024-01-30-paper-yardibiSourceLocalizationSensing2010/2024-01-30-paper-yardibiSourceLocalizationSensing2010-120-Sim-AS-Case2.png" width="800" alt="MISO channel estimation with six transmitters and one receiver. Channel taps are indicated by circles. Channel tap power levels are in range of -30 dB to 0 dB, and noise level is -20 dB, which results in -10 dB minimum SNR. Estimates for first channel via (a) MP, (b) OMP, (c) LSMP, and (d) IAA-APES&amp;BIC. All power levels are in dB.">
<figcaption aria-hidden="true">MISO channel estimation with six
transmitters and one receiver. Channel taps are indicated by circles.
Channel tap power levels are in range of -30 dB to 0 dB, and noise level
is -20 dB, which results in -10 dB minimum SNR. Estimates for first
channel via (a) MP, (b) OMP, (c) LSMP, and (d) IAA-APES&amp;BIC. All
power levels are in dB.</figcaption>
</figure>
<h1 id="conclusion">Conclusion</h1>
<blockquote>
<p>IAA-APES is believed to be a viable candidate for practical
applications since it does not require any hyperparameters, has a simple
formulation, provides superresolution, facilitates parallel processing,
and shows good performance.</p>
</blockquote>
<h1 id="reference">Reference</h1>
<ol type="1">
<li>T. Yardibi, J. Li, P. Stoica, M. Xue, and A. B. Baggeroer, “Source
Localization and Sensing: A Nonparametric Iterative Adaptive Approach
Based on Weighted Least Squares,” IEEE Transactions on Aerospace and
Electronic Systems, vol.&nbsp;46, no. 1, pp.&nbsp;425–443, Jan.&nbsp;2010, doi:
10.1109/TAES.2010.5417172.</li>
</ol>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/css/markmap.css">

<script src="/js/markmap.js"></script>
]]></content>
      <categories>
        <category>Josh 的学习笔记</category>
        <category>论文阅读</category>
      </categories>
      <tags>
        <tag>IAA-APES</tag>
        <tag>BIC</tag>
        <tag>RELAX</tag>
        <tag>DoA</tag>
        <tag>波达方向估计</tag>
      </tags>
  </entry>
  <entry>
    <title>MVDR 算法仿真</title>
    <url>/posts/86ade7bc.html</url>
    <content><![CDATA[<p>  MVDR （Minimum Variance Distortionless
Response，最小方差无失真响应）算法是 Capon 于 1969
年提出的经典波束形成算法，其解决的是无失真约束下输出噪声加干扰功率最小化问题。</p>
<h1 id="阵列模型">阵列模型</h1>
<p>  首先对阵列接收信号进行建模。假设 <span class="math inline">\(N\)</span> 元阵列天线在 <span class="math inline">\(t\)</span> 时刻的阵列接收信号和阵列输出信号分别为
<span class="math inline">\(\mathbf{x}(t)\)</span> 和 <span class="math inline">\(y(t)\)</span>，则对于 <span class="math inline">\(K\)</span> 个入射信号，有</p>
<p><span class="math display">\[\begin{equation}
  \begin{cases}
    \mathbf{x}(t) = \mathbf{A}(\boldsymbol{\theta})\mathbf{s}(t) +
\mathbf{n}(t) \\
    y(t) = \mathbf{w}^\mathrm{H}\mathbf{x}(t)
  \end{cases},\quad t = 1,\cdots,T
\end{equation}\]</span></p>
<p>其中</p>
<ul>
<li><p>阵列接收信号 <span class="math inline">\(\mathbf{x}(t) =
[x_1(t),\cdots,x_N(t)]^\mathrm{T}\in\mathbb{C}^{N\times
1}\)</span></p></li>
<li><p>噪声 <span class="math inline">\(\mathbf{n}(t) =
[n_1(t),\cdots,n_N(t)]^\mathrm{T}\in\mathbb{C}^{N\times
1}\)</span></p></li>
<li><p>入射信号 <span class="math inline">\(\mathbf{s}(t) =
[s_1(t),\cdots,s_K(t)]^\mathrm{T}\in\mathbb{C}^{K\times
1}\)</span></p></li>
<li><p>阵列流形矩阵 <span class="math inline">\(\mathbf{A}(\boldsymbol{\theta}) =
[\mathbf{a}(\theta_1),\cdots,\mathbf{a}(\theta_K)]\in
\mathbb{C}^{N\times K}\)</span>，导向矢量 <span class="math inline">\(\mathbf{a}(\theta_i)\in\mathbb{C}^{N\times
1}\)</span>，<span class="math inline">\(K\)</span> 个信号来向集合 <span class="math inline">\(\boldsymbol{\theta} =
\{\theta_i\}_{i=1}^K\)</span></p></li>
<li><p>波束形成复加权 <span class="math inline">\(\mathbf{w} =
[w_1,\cdots,w_N]^\mathrm{T}\)</span></p></li>
</ul>
<span id="more"></span>
<h1 id="mvdr-算法简述">MVDR 算法简述</h1>
<p>  假设第 1 个信号是期望信号（desired signal），令其导向矢量 <span class="math inline">\(\mathbf{a}_\mathrm{d} =
\mathbf{a}(\theta_1)\)</span>，则阵列接收信号可以进一步写为</p>
<p><span class="math display">\[\begin{equation}
  \mathbf{x}(t) =
\underset{\mathbf{x}_\mathrm{d}(t)}{\underbrace{\mathbf{a}_\mathrm{d}s_1(t)}}
  +
  \underset{\mathbf{x}_\mathrm{i+n}(t)}{\underbrace{\sum_{k=2}^{K}\mathbf{a}(\theta_k)s_k(t)
+ \mathbf{n}(t)}}
\end{equation}\]</span></p>
<p>至此，可以给出 MVDR 问题的基本表述</p>
<p><span class="math display">\[\begin{equation}
  \begin{aligned}
    &amp;\underset{\mathbf{w}}{\text{minimize}}
&amp;&amp;\mathbf{w}^\mathrm{H}\mathbf{R}_{\mathrm{i+n}}\mathbf{w}
    \\
    &amp;\text{subject to} &amp;&amp;
\mathbf{w}^\mathrm{H}\mathbf{a}_\mathrm{d} = 1
  \end{aligned}
\end{equation}\]</span></p>
<p>其闭式解可以由 Lagrange 乘子法得到</p>
<p><span class="math display">\[\begin{equation}
  \mathbf{w} = \alpha\mathbf{R}_{\mathrm{i+n}}^{-1}\mathbf{a}_\mathrm{d}
\end{equation}\]</span></p>
<p>其中</p>
<ul>
<li><p>噪声加干扰协方差矩阵 <span class="math inline">\(\mathbf{R}_{\mathrm{i+n}} =
\displaystyle\frac{1}{T}
\sum_{t=1}^{T}\mathbf{x}_\mathrm{i+n}(t)\mathbf{x}_\mathrm{i+n}^\mathrm{H}(t)\)</span></p></li>
<li><p>归一化因子（使得复加权对于期望信号的增益为 1） <span class="math inline">\(\alpha =
\displaystyle\frac{1}{\mathbf{a}_\mathrm{d}^\mathrm{H}\mathbf{R}_{\mathrm{i+n}}^{-1}\mathbf{a}_\mathrm{d}}\)</span></p></li>
</ul>
<h1 id="mvdr-算法仿真">MVDR 算法仿真</h1>
<p>  使用 ULA（Uniform Linear Array，均匀线阵）对 MVDR
算法进行仿真，阵元间距为半波长。</p>
<h2 id="理想情况">理想情况</h2>
<p>  在理想情况下，各阵元的位置与预期一致，各阵元的复加权器是没有误差的，目标信号来向与期望方向一致，且信号和干扰加噪声可以分离。</p>
<h3 id="空域谱">空域谱</h3>
<p>  Capon 空域谱表示 MVDR 复加权在整个空域范围内的响应。假设 1 个信号和
6 个干扰同时入射，信噪比 <span class="math inline">\(\mathrm{SNR}=30\mathrm{dB}\)</span>，干噪比 <span class="math inline">\(\mathrm{INR} =
70\mathrm{dB}\)</span>，信号和干扰来向在 <span class="math inline">\([0^\circ,180^\circ]\)</span> 内服从均匀分布，使用
1000 个快拍进行仿真。</p>
<p>  得到的空域谱如<a href="#fig.1">图
1</a>，其中期望来向用红色点划线表示，干扰来向用绿色点划线表示。仿真同时还计算了输出
SINR，用于衡量残余干扰的大小。</p>
<p><a id="fig.1"></a></p>
<figure>
<img data-src="../images/post/2024-02-01-algo-MVDR/2024-02-01-algo-MVDR-010-IdealCaponSpectrum.svg" width="700" alt="图 1 理想 Capon 谱">
<figcaption aria-hidden="true">图 1 理想 Capon 谱</figcaption>
</figure>
<details class="note primary"><summary><p>MATLAB Code</p>
</summary>
<figure class="highlight matlab"><figcaption><span>mvdr_spec.m</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">%% High-Resolution Frequency-Wavenumber Spectrum Analysis</span></span><br><span class="line"><span class="comment">% J. Capon, “High-Resolution Frequency-Wavenumber Spectrum Analysis,” _Proceedings</span></span><br><span class="line"><span class="comment">% of the IEEE_, vol. 57, no. 8, pp. 1408–1418, Aug. 1969, doi: &lt;https://doi.org/10.1109/PROC.1969.7278</span></span><br><span class="line"><span class="comment">% 10.1109/PROC.1969.7278&gt;.</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% H. L. Van Trees, _Optimum Array Processing: Part IV of Detection, Estimation,</span></span><br><span class="line"><span class="comment">% and Modulation Theory_. New York, NY: Wiley, 2002.</span></span><br><span class="line"></span><br><span class="line">clear</span><br><span class="line">close all</span><br><span class="line"><span class="comment">%% Parameters</span></span><br><span class="line"></span><br><span class="line">rng(<span class="number">253</span>)</span><br><span class="line"><span class="comment">% Array Parameters</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% elements in array</span></span><br><span class="line">elemNum = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% spacing wrt wavelength</span></span><br><span class="line">elemSpac = <span class="number">0.5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% element locations</span></span><br><span class="line">elemLoc = <span class="number">0</span>:elemSpac:(elemNum<span class="number">-1</span>)*elemSpac;</span><br><span class="line"><span class="comment">% Signal Parameters</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% signal number</span></span><br><span class="line">sigNum = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% direction of arrival</span></span><br><span class="line">sigAng = <span class="built_in">rand</span>(<span class="number">1</span>,sigNum)*<span class="number">180</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% signal to noise ratio</span></span><br><span class="line">snr = [<span class="number">30</span>,<span class="number">70</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">% sample number</span></span><br><span class="line">sampleNum = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% parameter match check</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">length</span>(snr) ~= sigNum) | (<span class="built_in">length</span>(sigAng) ~= sigNum)</span><br><span class="line">  <span class="built_in">disp</span>(<span class="string">'WARN: Signal number and parameter number NOT match.'</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">%% Impinging Waves/Signals</span></span><br><span class="line"><span class="comment">% Transmitted Signals</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% wave generation, here are some sets of uncorrelated white noise</span></span><br><span class="line">txWave = <span class="built_in">randn</span>(sigNum,sampleNum);</span><br><span class="line"></span><br><span class="line"><span class="comment">% transmit power control based on given snr</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">length</span>(snr) == <span class="number">1</span></span><br><span class="line">  txWave = db2mag(snr)*txWave;</span><br><span class="line"><span class="keyword">elseif</span> <span class="built_in">length</span>(snr) &gt;= sigNum</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">length</span>(snr) &gt; sigNum</span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">'WARN: Extra SNRs are ignored.'</span>)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:sigNum</span><br><span class="line">    txWave(<span class="built_in">i</span>,:) = db2mag(snr(<span class="built_in">i</span>))*txWave(<span class="built_in">i</span>,:);</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">elseif</span> <span class="built_in">length</span>(snr) &lt; sigNum</span><br><span class="line">  <span class="built_in">disp</span>(<span class="string">'WARN: The last SNR is used for the rest of the signals.'</span>)</span><br><span class="line">  <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:sigNum</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">i</span> &lt;= <span class="built_in">length</span>(snr)</span><br><span class="line">      txWave(<span class="built_in">i</span>,:) = db2mag(snr(<span class="built_in">i</span>))*txWave(<span class="built_in">i</span>,:);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      txWave(<span class="built_in">i</span>,:) = db2mag(snr(<span class="keyword">end</span>))*txWave(<span class="built_in">i</span>,:);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">% Array Manifold Matrix</span></span><br><span class="line"><span class="comment">% For each signal, the array manifold vector is</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% $$\mathbf{a}\left(\theta \right)=\exp \left(-j\frac{2\pi \mathbf{d}}{\lambda</span></span><br><span class="line"><span class="comment">% \;}\cos \theta \;\right)$$</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% in which the element locations are</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% $$\mathbf{d}={\left\lbrack 0,\frac{\lambda }{2},\cdots ,\left(N-1\right)\frac{\lambda</span></span><br><span class="line"><span class="comment">% }{2}\right\rbrack }^{\mathrm{T}}$$</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">length</span>(sigAng) &gt; sigNum</span><br><span class="line">  <span class="built_in">disp</span>(<span class="string">'WARN: Extra angles are ignored.'</span>)</span><br><span class="line"><span class="keyword">elseif</span> <span class="built_in">length</span>(sigAng) &lt; sigNum</span><br><span class="line">  <span class="built_in">disp</span>(<span class="string">'ERROR: Angle number is less than signal number.'</span>)</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">arrayMF = <span class="built_in">exp</span>(<span class="number">-1</span><span class="built_in">i</span>*<span class="built_in">pi</span>*elemLoc'*<span class="built_in">cos</span>(sigAng(<span class="number">1</span>:sigNum)/<span class="number">180</span>*<span class="built_in">pi</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> sigNum &gt; <span class="number">1</span></span><br><span class="line">  <span class="comment">% signal &amp; interference manifold vector</span></span><br><span class="line">  sigMF = arrayMF(:,<span class="number">1</span>);</span><br><span class="line">  intMF = arrayMF(:,<span class="number">2</span>:<span class="keyword">end</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">% impinging signal &amp; interference</span></span><br><span class="line">  rxSig = sigMF*txWave(<span class="number">1</span>,:);</span><br><span class="line">  rxIpn = intMF*txWave(<span class="number">2</span>:<span class="keyword">end</span>,:) + <span class="built_in">randn</span>(elemNum,sampleNum);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="comment">% signal manifold vector</span></span><br><span class="line">  sigMF = arrayMF;</span><br><span class="line"></span><br><span class="line">  <span class="comment">% impinging signal</span></span><br><span class="line">  rxSig = sigMF*txWave;</span><br><span class="line">  rxIpn = <span class="built_in">randn</span>(elemNum,sampleNum);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">% Received Wave</span></span><br><span class="line"></span><br><span class="line">rxWave = rxSig + <span class="built_in">randn</span>(elemNum,sampleNum);</span><br><span class="line"><span class="comment">%% Array Processing</span></span><br><span class="line"><span class="comment">% The MVDR problem is to minimize output interference-plus-noise power under</span></span><br><span class="line"><span class="comment">% distortionless contraint of target signal</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% $$\begin{array}{l}\underset{\mathbf{w}}{\mathrm{minimize}\;\;} \;{\mathbf{w}}^{\mathrm{H}}</span></span><br><span class="line"><span class="comment">% {\mathbf{R}}_{\mathrm{i}+\mathrm{n}} \mathbf{w}\\\mathrm{subecto}\;\mathrm{to}\;\;{\mathbf{w}}^{\mathrm{H}}</span></span><br><span class="line"><span class="comment">% \mathbf{a}=1\end{array}$$</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% The problem can be solve using the Lagrange multiplier method, and the solution</span></span><br><span class="line"><span class="comment">% is</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% $$\mathbf{w}=\alpha {\mathbf{R}}_{\mathrm{i}+\mathrm{n}}^{-1} \mathbf{a}$$</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% where $\alpha \;$is the normalization factor that ensures the power of array</span></span><br><span class="line"><span class="comment">% input and output desired signal remains unchanged</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% $$\alpha =\frac{1}{{\mathbf{a}}^{\mathrm{H}} {\mathbf{R}}_{\mathrm{i}+\mathrm{n}}</span></span><br><span class="line"><span class="comment">% \mathbf{a}}$$</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% interference-plus-noise covariance matrix</span></span><br><span class="line">ipnCovar = rxIpn*rxIpn';</span><br><span class="line"></span><br><span class="line"><span class="comment">% MVDR weight vector</span></span><br><span class="line">weight = ipnCovar\sigMF/(sigMF'*(ipnCovar\sigMF));</span><br><span class="line"><span class="comment">%      = inv(ipnCovar)*sigMF/(sigMF'*inv(ipnCovar)*sigMF);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% output SINR</span></span><br><span class="line">sinrOut = pow2db(var(weight'*rxSig)/var(weight'*rxIpn));</span><br><span class="line"><span class="comment">%% Spectrum &amp; Figure</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% scan grid</span></span><br><span class="line">scanGrid = <span class="number">0</span>:<span class="number">0.1</span>:<span class="number">180</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% spectrum</span></span><br><span class="line">spec = <span class="built_in">zeros</span>(<span class="built_in">size</span>(scanGrid));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(scanGrid)</span><br><span class="line">  <span class="comment">% steering vector</span></span><br><span class="line">  scanMF = <span class="built_in">exp</span>(<span class="number">-1</span><span class="built_in">i</span>*<span class="built_in">pi</span>*elemLoc'*<span class="built_in">cos</span>(scanGrid(<span class="built_in">i</span>)/<span class="number">180</span>*<span class="built_in">pi</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">% MVDR spectrum</span></span><br><span class="line">  spec(<span class="built_in">i</span>) = weight'*scanMF;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% normalized spectrum</span></span><br><span class="line">specNorm = pow2db(<span class="built_in">abs</span>(spec));</span><br><span class="line"></span><br><span class="line"><span class="comment">% spectrum &amp; signal location indicator</span></span><br><span class="line"><span class="built_in">plot</span>(scanGrid,specNorm)</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:sigNum</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">i</span> == <span class="number">1</span></span><br><span class="line">    <span class="built_in">plot</span>([sigAng(<span class="built_in">i</span>),sigAng(<span class="built_in">i</span>)],[<span class="built_in">max</span>(specNorm),<span class="built_in">min</span>(specNorm)],<span class="string">'-.r'</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">plot</span>([sigAng(<span class="built_in">i</span>),sigAng(<span class="built_in">i</span>)],[<span class="built_in">max</span>(specNorm),<span class="built_in">min</span>(specNorm)],<span class="string">'-.g'</span>);</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">hold</span> off</span><br><span class="line"></span><br><span class="line"><span class="built_in">legend</span>({<span class="string">'Capon Spec'</span>,<span class="string">'Desired'</span>,<span class="string">'Interference'</span>},Location=<span class="string">"southeast"</span>)</span><br><span class="line"></span><br><span class="line">axis tight</span><br><span class="line">title(<span class="string">'Ideal Capon Spectrum'</span>)</span><br><span class="line">xlabel(<span class="string">'Degree/°'</span>)</span><br><span class="line">ylabel(<span class="string">'Magnitude/dB'</span>)</span><br><span class="line">grid on</span><br><span class="line">grid minor</span><br></pre></td></tr></tbody></table></figure>

</details>
<h3 id="分辨率">分辨率</h3>
<p>  MVDR 算法的分辨率用来衡量 MVDR
算法对接近目标方向的干扰的抑制能力。假设 1 个信号和 1
个干扰同时入射，信噪比 <span class="math inline">\(\mathrm{SNR}=0
\mathrm{dB}\)</span>，干噪比 <span class="math inline">\(\mathrm{INR} =
70\mathrm{dB}\)</span>，假定目标来向为 90°，干扰和信号来向差在 0°~50°
范围内扫描，对阵元数 <span class="math inline">\(N=4,8,12,16\)</span>
四种情况进行仿真。</p>
<p>  <a href="#fig.2">图 2</a> 以 MVDR 算法的输出 SINR
作为指标,给出了随期望、干扰信号来向的角度差的变化曲线，其中输出 SINR
归一化到 0 dB，便于不同阵元数情况的对比。点划线给出了低于理想 SINR 3 dB
的值，将点划线和实线的交点作为 MVDR 算法的分辨率。</p>
<p><a id="fig.2"></a></p>
<figure>
<img data-src="../images/post/2024-02-01-algo-MVDR/2024-02-01-algo-MVDR-020-IdealCaponResolution.svg" width="700" alt="图 2 Capon 分辨率">
<figcaption aria-hidden="true">图 2 Capon 分辨率</figcaption>
</figure>
<details class="note primary"><summary><p>MATLAB Code</p>
</summary>
<figure class="highlight matlab"><figcaption><span>mvdr_resolution.m</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">%% High-Resolution Frequency-Wavenumber Spectrum Analysis</span></span><br><span class="line"><span class="comment">% J. Capon, “High-Resolution Frequency-Wavenumber Spectrum Analysis,” _Proceedings</span></span><br><span class="line"><span class="comment">% of the IEEE_, vol. 57, no. 8, pp. 1408–1418, Aug. 1969, doi: &lt;https://doi.org/10.1109/PROC.1969.7278</span></span><br><span class="line"><span class="comment">% 10.1109/PROC.1969.7278&gt;.</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% H. L. Van Trees, _Optimum Array Processing: Part IV of Detection, Estimation,</span></span><br><span class="line"><span class="comment">% and Modulation Theory_. New York, NY: Wiley, 2002.</span></span><br><span class="line"></span><br><span class="line">clear</span><br><span class="line">close all</span><br><span class="line"></span><br><span class="line">rng(<span class="number">253</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">%% Scan Configuration</span></span><br><span class="line">elemNumArr = [<span class="number">4</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">16</span>];</span><br><span class="line">intAngArr = <span class="number">0.1</span>:<span class="number">0.1</span>:<span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">sinrOut = <span class="built_in">zeros</span>(<span class="built_in">length</span>(elemNumArr),<span class="built_in">length</span>(intAngArr));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> elemNumIdx = <span class="number">1</span>:<span class="built_in">length</span>(elemNumArr)</span><br><span class="line"><span class="keyword">for</span> intAngIdx = <span class="number">1</span>:<span class="built_in">length</span>(intAngArr)</span><br><span class="line"></span><br><span class="line"><span class="comment">%% Array Parameters</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% elements in array</span></span><br><span class="line">elemNum = elemNumArr(elemNumIdx);</span><br><span class="line"></span><br><span class="line"><span class="comment">% spacing wrt wavelength</span></span><br><span class="line">elemSpac = <span class="number">0.5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% element locations</span></span><br><span class="line">elemLoc = <span class="number">0</span>:elemSpac:(elemNum<span class="number">-1</span>)*elemSpac;</span><br><span class="line"></span><br><span class="line"><span class="comment">% Signal Parameters</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% signal number</span></span><br><span class="line">sigNum = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% direction of arrival</span></span><br><span class="line">desAng = <span class="number">90</span>;</span><br><span class="line">sigAng = [desAng,desAng+intAngArr(intAngIdx)];</span><br><span class="line"></span><br><span class="line"><span class="comment">% signal to noise ratio</span></span><br><span class="line">snr = [<span class="number">0</span>,<span class="number">70</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">% sample number</span></span><br><span class="line">sampleNum = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% Impinging Waves/Signal</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% wave generation, here are some sets of uncorrelated white noise</span></span><br><span class="line">txWave = <span class="built_in">randn</span>(sigNum,sampleNum);</span><br><span class="line"></span><br><span class="line"><span class="comment">% transmit power control based on given snr</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">length</span>(snr) == <span class="number">1</span></span><br><span class="line">  txWave = db2mag(snr)*txWave;</span><br><span class="line"><span class="keyword">elseif</span> <span class="built_in">length</span>(snr) &gt;= sigNum</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">length</span>(snr) &gt; sigNum</span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">'WARN: Extra SNRs are ignored.'</span>)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:sigNum</span><br><span class="line">    txWave(<span class="built_in">i</span>,:) = db2mag(snr(<span class="built_in">i</span>))*txWave(<span class="built_in">i</span>,:);</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">elseif</span> <span class="built_in">length</span>(snr) &lt; sigNum</span><br><span class="line">  <span class="built_in">disp</span>(<span class="string">'WARN: The last SNR is used for the rest of the signals.'</span>)</span><br><span class="line">  <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:sigNum</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">i</span> &lt;= <span class="built_in">length</span>(snr)</span><br><span class="line">      txWave(<span class="built_in">i</span>,:) = db2mag(snr(<span class="built_in">i</span>))*txWave(<span class="built_in">i</span>,:);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      txWave(<span class="built_in">i</span>,:) = db2mag(snr(<span class="keyword">end</span>))*txWave(<span class="built_in">i</span>,:);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% Array Manifold Matrix</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">length</span>(sigAng) &gt; sigNum</span><br><span class="line">  <span class="built_in">disp</span>(<span class="string">'WARN: Extra angles are ignored.'</span>)</span><br><span class="line"><span class="keyword">elseif</span> <span class="built_in">length</span>(sigAng) &lt; sigNum</span><br><span class="line">  <span class="built_in">disp</span>(<span class="string">'ERROR: Angle number is less than signal number.'</span>)</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">arrayMF = <span class="built_in">exp</span>(<span class="number">-1</span><span class="built_in">i</span>*<span class="built_in">pi</span>*elemLoc'*<span class="built_in">cos</span>(sigAng(<span class="number">1</span>:sigNum)/<span class="number">180</span>*<span class="built_in">pi</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">% signal &amp; interference manifold vector</span></span><br><span class="line">sigMF = arrayMF(:,<span class="number">1</span>);</span><br><span class="line">intMF = arrayMF(:,<span class="number">2</span>:<span class="keyword">end</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% impinging signal &amp; interference</span></span><br><span class="line">rxSig = sigMF*txWave(<span class="number">1</span>,:);</span><br><span class="line">rxIpn = intMF*txWave(<span class="number">2</span>:<span class="keyword">end</span>,:) + <span class="built_in">randn</span>(elemNum,sampleNum);</span><br><span class="line"></span><br><span class="line"><span class="comment">%% AWGN Channel &amp; Received Wave</span></span><br><span class="line">rxWave = rxSig + <span class="built_in">randn</span>(elemNum,sampleNum);</span><br><span class="line"></span><br><span class="line"><span class="comment">%% Array Processing</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% interference-plus-noise covariance matrix</span></span><br><span class="line">ipnCovar = rxIpn*rxIpn';</span><br><span class="line"></span><br><span class="line"><span class="comment">% MVDR weight vector</span></span><br><span class="line">weight = ipnCovar\sigMF/(sigMF'*(ipnCovar\sigMF));</span><br><span class="line"><span class="comment">%      = inv(ipnCovar)*sigMF/(sigMF'*inv(ipnCovar)*sigMF);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% normalized output SINR</span></span><br><span class="line">sinrIdeal = snr(<span class="number">1</span>)+pow2db(elemNum);</span><br><span class="line">sinrOut(elemNumIdx,intAngIdx) = pow2db(var(weight'*rxSig)/ ...</span><br><span class="line">  var(weight'*rxIpn)) - sinrIdeal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">plot</span>(intAngArr,smoothdata(sinrOut(elemNumIdx,:)),DisplayName=[<span class="string">'$N='</span>, ...</span><br><span class="line">  num2str(elemNumArr(elemNumIdx)),<span class="string">'$'</span>])</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% figures</span></span><br><span class="line"><span class="built_in">plot</span>([<span class="built_in">min</span>(intAngArr),<span class="built_in">max</span>(intAngArr)],[<span class="number">-3</span>,<span class="number">-3</span>],HandleVisibility=<span class="string">"off"</span>)</span><br><span class="line"><span class="built_in">hold</span> off</span><br><span class="line"></span><br><span class="line">title(<span class="string">'MVDR Output SINR v.s. Angular Difference'</span>)</span><br><span class="line">xlabel(<span class="string">'Angular Difference between Desired and Interference Signal (°)'</span>)</span><br><span class="line">ylabel(<span class="string">'Normalized Output SINR (dB)'</span>)</span><br><span class="line">ylim([<span class="number">-5</span> <span class="built_in">max</span>(smoothdata(sinrOut,<span class="number">2</span>),[],<span class="string">'all'</span>)+<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">legend</span>(Interpreter=<span class="string">"latex"</span>,Location=<span class="string">"southeast"</span>);</span><br><span class="line"></span><br><span class="line">grid on</span><br></pre></td></tr></tbody></table></figure>

</details>
<h3 id="理想误码率">理想误码率</h3>
<h2 id="失配情况">失配情况</h2>
<h3 id="分辨率-1">分辨率</h3>
<h3 id="误码率">误码率</h3>
<h1 id="reference">Reference</h1>
<ol type="1">
<li><p>J. Capon, “High-Resolution Frequency-Wavenumber Spectrum
Analysis,” <em>Proceedings of the IEEE</em>, vol.&nbsp;57, no. 8,
pp.&nbsp;1408–1418, Aug.&nbsp;1969, doi: <a href="https://doi.org/10.1109/PROC.1969.7278">10.1109/PROC.1969.7278</a>.</p></li>
<li><p>H. L. Van Trees, <em>Optimum Array Processing: Part IV of
Detection, Estimation, and Modulation Theory</em>. New York, NY: Wiley,
2002.</p></li>
</ol>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/css/markmap.css">

<script src="/js/markmap.js"></script>
]]></content>
      <categories>
        <category>Josh 的学习笔记</category>
        <category>算法仿真</category>
      </categories>
      <tags>
        <tag>Beamforming</tag>
        <tag>波束成形</tag>
        <tag>MVDR</tag>
        <tag>误码率分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Josh&#39;s Note — 凸优化&lt;br&gt;Part 1.3 凸集—保凸运算</title>
    <url>/posts/a4a69a4f.html</url>
    <content><![CDATA[<p>$
$  本文将描述一些保凸运算，利用保凸运算可以使用凸集构造出其他凸集。这些运算与<a href="https://josh-gao.top/posts/9293b739.html"><em>Part 1.2
凸集—一些重要的凸集</em></a>中描述的凸集的简单例子一起构成了凸集的演算，可以用来确定或构建集合的凸性。</p>
<h1 id="交集">1. 交集</h1>
<p>  交集运算是保凸的：如果 <span class="math inline">\(S_1\)</span> 和
<span class="math inline">\(S_2\)</span> 是凸集，那么 <span class="math inline">\(S_1 \cap S_2\)</span>
也是凸集。这个性质可以扩展到无穷个集合的交：如果对于任意 <span class="math inline">\(\alpha\in A\)</span>，<span class="math inline">\(S_\alpha\)</span> 都是凸的，那么 <span class="math inline">\(\displaystyle \bigcap_{\alpha \in A}
S_\alpha\)</span>
也是凸集。（子空间、仿射集合和凸锥对与任意交运算也是封闭的。）举一个简单的例子，多面体是半空间和超平面（它们都是凸集）的交集，因而是凸的。</p>
<blockquote>
<p><strong>举例</strong> 半正定锥 <span class="math inline">\(\mathbf{S}^n_+\)</span> 可以表示为</p>
<p><span class="math display">\[
\bigcap_{z\ne 0} \left\{ X \in \mathbf{S}^n\mid z^\mathrm{T}Xz \geqslant
0 \right\}
\]</span></p>
<p>对于任意 <span class="math inline">\(z\ne 0\)</span>，<span class="math inline">\(z^\mathrm{T}Xz\)</span> 是关于 <span class="math inline">\(X\)</span>
的（不恒等于零的）线性函数，因此集合</p>
<p><span class="math display">\[
\left\{ X \in \mathbf{S}^n\mid z^\mathrm{T}Xz \geqslant 0 \right\}
\]</span></p>
<p>实际上就是 <span class="math inline">\(\mathbf{S}^n\)</span>
的半空间。由此，半正定锥是无穷个半空间的交集，因此是凸的。</p>
</blockquote>
<span id="more"></span>
<blockquote>
<p><strong>举例</strong>  考虑集合</p>
<p><span class="math display">\[\begin{equation}\label{example2.8}
  S = \left\{ x \in \mathbf{R}^m\mid |p(t)|\leqslant 1\ 对于\ |t|
\leqslant \pi/3 \right\}
\end{equation}\]</span></p>
<p>其中 <span class="math inline">\(p(t) = \displaystyle\sum_{k=1}^m x_k
\cos kt\)</span>。集合 <span class="math inline">\(S\)</span>
可以表示为无穷个<strong>平板</strong>（<em>slab</em>）的交集：<span class="math inline">\(S = \displaystyle \bigcap_{|t|\leqslant\pi/3}
S_t\)</span>，其中</p>
<p><span class="math display">\[
S_t = \left\{x\mid -1\leqslant (\cos t,\cdots, \cos mt)^\mathrm{T}x
\leqslant 1\right\}
\]</span></p>
<p>因此，<span class="math inline">\(S\)</span> 是凸的。对于 <span class="math inline">\(m=2\)</span> 的情况，它的定义和集合可见<a href="#图13">图 13</a> 和<a href="#图14">图 14</a>。</p>
<p><a id="图13"></a></p>
<figure>
<img data-src="../images/post/2024-06-08-josh-cvx-1-3/2024-06-08-josh-cvx-1-3-130-ThreeTrigonometricPolynomials.png" width="500" alt="图 13. \eqref{example2.8} 定义的集合 (m=2) 中的点的三角多项式。虚线所示的三角多项式是另外两个的平均。">
<figcaption aria-hidden="true">图 13. <span class="math inline">\(\eqref{example2.8}\)</span> 定义的集合 (<span class="math inline">\(m=2\)</span>)
中的点的三角多项式。虚线所示的三角多项式是另外两个的平均。</figcaption>
</figure>
<p><a id="图14"></a></p>
<figure>
<img data-src="../images/post/2024-06-08-josh-cvx-1-3/2024-06-08-josh-cvx-1-3-140-TheSetS.png" width="470" alt="图 14. 图中央的白色区域显示了 m=2 情况下 \eqref{example2.8} 定义的集合 S。这个集合是无限多个（图中显示了其中 20 个）平板的交集，所以是凸的。">
<figcaption aria-hidden="true">图 14. 图中央的白色区域显示了 <span class="math inline">\(m=2\)</span> 情况下 <span class="math inline">\(\eqref{example2.8}\)</span> 定义的集合 <span class="math inline">\(S\)</span>。这个集合是无限多个（图中显示了其中 20
个）平板的交集，所以是凸的。</figcaption>
</figure>
</blockquote>
<p>  在上面这些例子中，我们通过将集合表示为（可能无穷多个）半空间的交集来表明集合的凸性。反过来我们也将看到：每一个闭的凸集
<span class="math inline">\(S\)</span>
是（通常为无限多个）半空间的交集。事实上，一个闭集 <span class="math inline">\(S\)</span> 是包含它的所有半空间的交集：</p>
<p><span class="math display">\[
S = \bigcap \left\{ \mathcal{H}\mid \mathcal{H}\ 是半空间,\ S\subseteq
\mathcal{H}\right\}
\]</span></p>
<h1 id="仿射函数">2. 仿射函数</h1>
<p>  函数 <span class="math inline">\(f: \mathbf{R}^n \to
\mathbf{R}^m\)</span>
是<strong>仿射</strong>（<em>affine</em>）的，如果它是一个线性函数和一个常数的和，即具有
<span class="math inline">\(f(x) = Ax+ b\)</span> 的形式，其中 <span class="math inline">\(A \in  \mathbf{R}^{m\times n}\)</span>，<span class="math inline">\(b \in \mathbf{R}^m\)</span>。假设 <span class="math inline">\(S \subseteq \mathbf{R}^n\)</span> 是凸的，并且
<span class="math inline">\(f: \mathbf{R}^n \to \mathbf{R}^m\)</span>
是仿射函数。那么，<span class="math inline">\(S\)</span> 在 <span class="math inline">\(f\)</span> 下的象</p>
<p><span class="math display">\[
f(S) = \left\{ f(x)\mid x\in S \right\}
\]</span></p>
<p>是凸的。类似地，如果 <span class="math inline">\(f:\mathbf{R}^k\to\mathbf{R}^n\)</span>
是仿射函数，那么 <span class="math inline">\(S\)</span> 在 <span class="math inline">\(f\)</span> 下的原象</p>
<p><span class="math display">\[
f^{-1}(S) = \left\{ x\mid f(x)\in S \right\}
\]</span></p>
<p>是凸的。</p>
<p>  两个简单的例子是<strong>伸缩</strong>（<em>scaling</em>）和<strong>平移</strong>（<em>translation</em>）。如果
<span class="math inline">\(S \subseteq \mathbf{R}^n\)</span>
是凸集，<span class="math inline">\(\alpha \in \mathbf{R}\)</span> 并且
<span class="math inline">\(a \in \mathbf{R}^n\)</span>，那么，集合
<span class="math inline">\(\alpha S\)</span> 和 <span class="math inline">\(S+a\)</span> 是凸的，其中</p>
<p><span class="math display">\[
\alpha S = \left\{ \alpha x\mid x \in S \right\},\qquad S + a = \left\{
x + a\mid x \in S \right\}
\]</span></p>
<p>一个凸集向它的某几个坐标的<strong>投影</strong>（<em>projection</em>）是凸的，即：如果
<span class="math inline">\(S \subseteq \mathbf{R}^m \times
\mathbf{R}^n\)</span> 是凸集，那么</p>
<p><span class="math display">\[
T = \left\{ x_1\in \mathbf{R}^m\mid (x_1,x_2)\in S\ 对于某些\ x_2 \in
\mathbf{R}^n \right\}
\]</span></p>
<p>是凸集。</p>
<p>  两个集合的<strong>和</strong>（<em>sum</em>）可以定义为：</p>
<p><span class="math display">\[
S_1 + S_2 = \left\{ x + y\mid x \in S_1, y \in S_2\right\}
\]</span></p>
<p>如果 <span class="math inline">\(S_1\)</span> 和 <span class="math inline">\(S_2\)</span> 是凸集，那么，<span class="math inline">\(S_1 + S_2\)</span> 是凸的。可以看出，如果 <span class="math inline">\(S_1\)</span> 和 <span class="math inline">\(S_2\)</span> 是凸的，那么其直积或 Cartesian
乘积</p>
<p><span class="math display">\[
S_1 \times S_2 = \left\{ (x_1,x_2)\mid x_1\in S_1, x_2\in S_2 \right\}
\]</span></p>
<p>也是凸集。这个集合在线性函数 <span class="math inline">\(f(x_1,x_2) =
x_1+x_2\)</span> 下的象是和 <span class="math inline">\(S_1 +
S_2\)</span>。</p>
<p>  也可以考虑 <span class="math inline">\(S_1,S_2 \in \mathbf{R}^m
\times \mathbf{R}^n\)</span> 的<strong>部分和</strong>（<em>partial
sum</em>），定义为</p>
<p><span class="math display">\[
S = \left\{ (x,y_1 + y_2)\mid (x,y_1)\in S_1,\ (x,y_2)\in S_2 \right\}
\]</span></p>
<p>其中 <span class="math inline">\(x\in\mathbf{R}^n\)</span>，<span class="math inline">\(y_i \in \mathbf{R}^m\)</span>。<span class="math inline">\(m=0\)</span> 时，部分和给出了 <span class="math inline">\(S_1\)</span> 和 <span class="math inline">\(S_2\)</span>的交集；<span class="math inline">\(n=0\)</span>
时，部分和等于集合之和。凸集的部分和是凸集。</p>
<blockquote>
<p><strong>举例</strong> <strong>多面体</strong>。<span class="math inline">\(\{ x\mid Ax \preceq b, Cx = d \}\)</span>
可以表示为非负象限和原点的 Cartesian 乘积在仿射函数 <span class="math inline">\(f(x) = (b -Ax, d - Cx)\)</span> 下的原象：</p>
<p><span class="math display">\[
\{x\mid Ax\preceq b, Cx = d\} = \{ x\mid f(x)  \in \mathbf{R}^m_+ \times
\{0\}\}
\]</span></p>
<div class="note info"><p>这里可以这样理解：函数 <span class="math inline">\(f(x) = (b -Ax, d -
Cx)\)</span> 在条件 <span class="math inline">\(Ax \preceq b, Cx =
d\)</span> 下的值域为 <span class="math inline">\(\mathbf{R}^m_+ \times
\{0\}\)</span>。</p>
</div>
</blockquote>
<blockquote>
<p><strong>举例</strong> <strong>线性矩阵不等式的解</strong>。条件</p>
<p><span class="math display">\[\begin{equation}
  A(x) = x_1 A_1 + \cdots + x_nA_n \preceq B
\end{equation}\]</span></p>
<p>称为关于 <span class="math inline">\(x\)</span>
的<strong>线性矩阵不等式</strong>（<em>Linear Matrix Inequality,
LMI</em>），其中 <span class="math inline">\(B,A_i \in
\mathbf{S}^m\)</span>（注意它与有序线性不等式</p>
<p><span class="math display">\[
a^\mathrm{T}x = x_1a_1+\cdots x_na_n \leqslant b
\]</span></p>
<p>的相似性，其中 <span class="math inline">\(b,a_i\in
\mathbf{R}\)</span>。）</p>
<p>线性矩阵不等式的解 <span class="math inline">\(\{ x\mid A(x) \preceq
B\}\)</span> 是凸集。事实上，它是半正定锥在由 <span class="math inline">\(f(x) = B-A(x)\)</span> 给定的仿射映射 <span class="math inline">\(f: \mathbf{R}^n \to \mathbf{S}^m\)</span>
下的原象。</p>
</blockquote>
<blockquote>
<p><strong>举例</strong> <strong>双曲锥</strong>。集合</p>
<p><span class="math display">\[
\{ x\mid x^\mathrm{T}Px \leqslant (c^\mathrm{T}x) ^2, c^\mathrm{T}x
\geqslant 0 \}
\]</span></p>
<p>是凸集，其中 <span class="math inline">\(P\in\mathbf{S}^n_+\)</span>，<span class="math inline">\(c\in\mathbf{R}\)</span>。这是因为它是二阶锥</p>
<p><span class="math display">\[
\{ (z,t)\mid z^\mathrm{T}z \leqslant t ^2 , t \geqslant 0 \}
\]</span></p>
<p>在仿射函数 <span class="math inline">\(f(x) =
(P^{1/2}x,c^\mathrm{T}x)\)</span> 下的原象。</p>
</blockquote>
<blockquote>
<p><strong>举例</strong> <strong>椭球</strong>。椭球</p>
<p><span class="math display">\[
\mathcal{E}= \{ x\mid (x-x_c)^\mathrm{T}P^{-1} (x-x_c) \leqslant 1 \}
\]</span></p>
<p>是单位 Euclid 球 <span class="math inline">\(\{ u\mid \|u\|_2
\leqslant 1 \}\)</span> 在仿射映射 <span class="math inline">\(f(u) =
P^{1/2}u + x_c\)</span> 下的象， 其中 <span class="math inline">\(P \in
\mathbf{S}^n_{++}\)</span>。（同时也是单位球在仿射映射 <span class="math inline">\(g(x) = P^{-1/2}(x — x_c)\)</span> 下的原象。）</p>
</blockquote>
<h1 id="线性分式及透视函数">3. 线性分式及透视函数</h1>
<p>  本节将讨论一类称为<strong>线性分式</strong>（<em>linear-fractional</em>）的函数，它比仿射函数更普遍，并且仍然保凸。</p>
<h2 id="透视函数">3.1 透视函数</h2>
<p>  定义 <span class="math inline">\(P:\mathbf{R}^{n+1}\to\mathbf{R}^n\)</span>，<span class="math inline">\(P(z,t) = z/t\)</span>
为<strong>透视函数</strong>（<em>perspective function</em>），其定义域为
<span class="math inline">\(\mathop{\bf dom}P = \mathbf{R}^n \times
\mathbf{R}_{++}\)</span>。（此处的 <span class="math inline">\(\mathbf{R}_{++}\)</span> 表示正实数集合，即 <span class="math inline">\(\mathbf{R}_{++} = \{ x\in\mathbf{R}\mid x &gt; 0
\}\)</span>。）透视函数对向量进行伸缩（scale），或称为规范化（normalize），使得最后一维分量为1
并舍弃之。</p>
<blockquote>
<p><strong>注释</strong> 我们用小孔成象来解释透视函数。(<span class="math inline">\(\mathbf{R}^3\)</span>
中的）小孔照相机由一个不透明的水平面 <span class="math inline">\(x_3 =
0\)</span> 和一个在原点的小孔组成，光线通过这个小孔在 <span class="math inline">\(x_3 = -1\)</span> 呈现出一个水平图像。在相机上方
<span class="math inline">\(x\)</span>（<span class="math inline">\(x_3
&gt; 0\)</span>）处的一个物体，在相平面的点 <span class="math inline">\(-(x_1/x_3,x_2/x_3,1)\)</span>
处形成一个图像。忽略象点的最后一维分量（因为它恒等于 <span class="math inline">\(-1\)</span>），<span class="math inline">\(x\)</span> 处的点的象在象平面上呈现于 <span class="math inline">\(y=-(x_1/x_3,x_2/x_3)\)</span> 处。<a href="#图15">图 15</a>显示了这个过程。</p>
<p><a id="图15"></a></p>
<figure>
<img data-src="../images/post/2024-06-08-josh-cvx-1-3/2024-06-08-josh-cvx-1-3-150-PinHoleCameraInterpretationOfPerspectiveFuncation.png" width="500" alt="图 15. 透视函数的小孔成象解释。深色的水平直线表示 \mathbf{R}^3 中的平面 x_3 = 0，除了在原点处有一个小孔外，它是不透光的。平面之上的物体或光源呈现在浅色水平直线所示的象平面 x_3 = -1 上。源位置向其象位置的映射对应于透视函数。">
<figcaption aria-hidden="true">图 15.
透视函数的小孔成象解释。深色的水平直线表示 <span class="math inline">\(\mathbf{R}^3\)</span> 中的平面 <span class="math inline">\(x_3 =
0\)</span>，除了在原点处有一个小孔外，它是不透光的。平面之上的物体或光源呈现在浅色水平直线所示的象平面
<span class="math inline">\(x_3 = -1\)</span>
上。源位置向其象位置的映射对应于透视函数。</figcaption>
</figure>
</blockquote>
<p>  如果 <span class="math inline">\(C \subseteq \mathop{\bf
dom}P\)</span> 是凸集，那么它的象</p>
<p><span class="math display">\[
P(C) = \{ P(x)\mid x\in C \}
\]</span></p>
<p>也是凸集。这个结论很直观：通过小孔观察一个凸的物体，可以得到凸的象。为解释这个事实，我们将说明在透视函数作用下，线段将被映射成线段。（也可以这样理解，通过小孔，一条线段的象是一条线段。）</p>
<blockquote>
<p><strong>解释</strong> 假设 <span class="math inline">\(x =
(\tilde{x},x_{n+1})\)</span>，<span class="math inline">\(y =
(\tilde{y}, y_{n+1}) \in \mathbf{R}^{n+1}\)</span>，并且 <span class="math inline">\(x_{n+1}&gt;0\)</span>，<span class="math inline">\(y_{n+1}&gt;0\)</span> 。那么，对于 <span class="math inline">\(0 \leqslant \theta \leqslant 1\)</span></p>
<p><span class="math display">\[
P(\theta x + (1-\theta)y) = \frac{\theta\tilde{x}+
(1-\theta)\tilde{y}}{\theta x_{n+1} + (1-\theta)y_{n+1}} = \mu P(x) +
(1-\mu) P(y)
\]</span></p>
<p>其中</p>
<p><span class="math display">\[
\mu = \frac{\theta x_{n+1}}{\theta x_{n+1} + (1-\theta) y_{n+1}}\in[0,1]
\]</span></p>
<p><span class="math inline">\(\theta\)</span> 和 <span class="math inline">\(\mu\)</span> 之间的关系是单调的：当 <span class="math inline">\(\theta\)</span> 在 <span class="math inline">\(0\)</span>、<span class="math inline">\(1\)</span>
间变化时（形成线段 <span class="math inline">\([x,y]\)</span>），<span class="math inline">\(\mu\)</span> 也在 <span class="math inline">\(0\)</span>、<span class="math inline">\(1\)</span>
间变化（形成线段 <span class="math inline">\([P(x),P(y)]\)</span>。这说明 <span class="math inline">\(P([x,y]) = [P(x),P(y)]\)</span>。</p>
</blockquote>
<p>  现在假设 <span class="math inline">\(C\)</span> 是凸的，并且有
<span class="math inline">\(C \subseteq \mathop{\bf
dom}P\)</span>（即对于所有 <span class="math inline">\(x\in
C\)</span>，<span class="math inline">\(x_{n+1} &gt; 0\)</span>）及
<span class="math inline">\(x,y\in C\)</span>。为显示 <span class="math inline">\(P(C)\)</span> 的凸性，需要说明线段 <span class="math inline">\([P(x), P(y)]\)</span> 在 <span class="math inline">\(P(C)\)</span> 中。这条线段是线段 <span class="math inline">\([x,y]\)</span> 在 <span class="math inline">\(P\)</span> 的象，因而属于 <span class="math inline">\(P(C)\)</span>。</p>
<p>  一个凸集在透视函数下的原象也是凸的：如果 <span class="math inline">\(C\subseteq \mathbf{R}^n\)</span> 为凸集，那么</p>
<p><span class="math display">\[
P^{-1}(C) = \{ (x,t)\in\mathbf{R}^{n+1}\mid x/t\in C, t &gt; 0 \}
\]</span></p>
<p>是凸集。为证明这点，假设 <span class="math inline">\((x,t)\in
P^{-1}(C)\)</span>，<span class="math inline">\((y,s)\in
P^{-1}(C)\)</span>，<span class="math inline">\(0 \leqslant \theta
\leqslant 1\)</span>。我们需要说明</p>
<p><span class="math display">\[
\theta(x,t) + (1-\theta)(y,s) \in P^{-1} (C)
\]</span></p>
<p>即</p>
<p><span class="math display">\[
\frac{\theta x + (1-\theta)y}{\theta t + (1-\theta)s} \in C
\]</span></p>
<p>（显然，<span class="math inline">\(\theta
t+(1-\theta)s&gt;0\)</span>）。这可从下式看出，</p>
<p><span class="math display">\[
\frac{\theta x+(1-\theta)y}{\theta t+(1-\theta)s}=\mu(x/t)+(1-\mu)(y/s)
\]</span></p>
<p>其中</p>
<p><span class="math display">\[
\mu=\frac{\theta t}{\theta t+(1-\theta)s}\in[0,1]
\]</span></p>
<h2 id="线性分式函数">3.2 线性分式函数</h2>
<p>  <strong>线性分式函数</strong>（<em>linear-fractional
function</em>）由透视函数和仿射函数复合而成。设 <span class="math inline">\(g:\mathbf{R}^n \to \mathbf{R}^{m+1}\)</span>
是仿射的，即</p>
<p><span class="math display">\[\begin{equation}\label{AffineFunction}
  g(x) = \left[\begin{array}{c}
    A \\ c^\mathrm{T}
  \end{array}\right]x + \left[\begin{array}{c}
    b \\ d
  \end{array}\right]
\end{equation}\]</span></p>
<p>其中 <span class="math inline">\(A \in \mathbf{R}^{m\times
n}\)</span>，<span class="math inline">\(b \in
\mathbf{R}^m\)</span>，<span class="math inline">\(c \in
\mathbf{R}^n\)</span> 并且 <span class="math inline">\(d\in\mathbf{R}^n\)</span>。则由 <span class="math inline">\(f =P\circ g\)</span> 给出的函数 <span class="math inline">\(f:\mathbf{R}^n \to \mathbf{R}^m\)</span></p>
<p><span class="math display">\[\begin{equation}\label{LinearFractionalFunction}
  f(x) = (Ax+b)/(c^\mathrm{T}x + d),\qquad \mathop{\bf dom}f = \{x\mid
c^\mathrm{T}x + d &gt; 0\}
\end{equation}\]</span></p>
<p>称为<strong>线性分式</strong>（<em>linear-fractional</em>）（或<strong>投射</strong>（<em>projective</em>））函数。如果
<span class="math inline">\(c = 0\)</span>，<span class="math inline">\(d &gt; 0\)</span>，则 <span class="math inline">\(f\)</span> 的定义域为 <span class="math inline">\(\mathbf{R}^n\)</span> 并且 <span class="math inline">\(f\)</span>
是仿射函数。因此，我们可以将仿射和线性函数视为特殊的线性分式函数。</p>
<blockquote>
<p><strong>注释</strong> <strong>投射解释</strong>。可以很方便地将一个线性分式函数表示为：将矩阵</p>
<p><span class="math display">\[\begin{equation}
  Q = \left[\begin{array}{c}
  A &amp; b \\ c^\mathrm{T}&amp; d
\end{array}\right] \in \mathbf{R}^{(m+1)\times (n+1)}
\end{equation}\]</span></p>
<p>作用于（即左乘）点 <span class="math inline">\((x,1)\)</span>，得到
<span class="math inline">\((Ax + b,c^\mathrm{T}x +
d)\)</span>；然后将所得结果做伸缩变换或归一化，以使得其最后一个分量为一，得到
<span class="math inline">\((f(x), 1)\)</span>。</p>
<p>也可以从儿何上进行解释，即这个表达式将 <span class="math inline">\(\mathbf{R}^n\)</span> 与 <span class="math inline">\(\mathbf{R}^{n+1}\)</span>
空间上的一组射线联系了起来。也就是说，对于 <span class="math inline">\(\mathbf{R}^n\)</span> 空间的一个点 <span class="math inline">\(z\)</span>，我们可以构造一个 <span class="math inline">\(\mathbf{R}^{n+1}\)</span> 空间的（开）射线 <span class="math inline">\(\mathcal{P}(z) = \{t(z,1)\mid t &gt;
0\}\)</span>。这条射线上每个点的最后一个分量均是正值。反之， <span class="math inline">\(\mathbf{R}^{n+1}\)</span>
空间中每条以原点为顶点并且最后一个分量为正值的射线均可以由一些 <span class="math inline">\(v\in\mathbf{R}^n\)</span> 表示为 <span class="math inline">\(\mathcal{P}(v) = \{t(v, 1)\mid t \geqslant
0\}\)</span>。<span class="math inline">\(\mathcal{P}\)</span> 表示了
<span class="math inline">\(\mathbf{R}^n\)</span>
与最后一个分量为正的射线之间的（投射）关系，这种关系是一一对应和满的。</p>
<p>线性分式函数 <span class="math inline">\(\eqref{LinearFractionalFunction}\)</span>
可以表示为</p>
<p><span class="math display">\[
f(x) = \mathcal{P}^{-1}(Q\mathcal{P}(x))
\]</span></p>
<p>因此，从 <span class="math inline">\(x\in\mathop{\bf dom}f\)</span>
出发，即由一个满足 <span class="math inline">\(c^\mathrm{T}x +d &gt;
0\)</span> 的点，可以得到 <span class="math inline">\(\mathbf{R}^{n+1}\)</span> 空间的一条射线 <span class="math inline">\(\mathcal{P}(x)\)</span>。将线性变换矩阵 <span class="math inline">\(Q\)</span> 作用于这条射线，就可以得到另一条射线
<span class="math inline">\(Q\mathcal{P}(x)\)</span>。因为 <span class="math inline">\(x \in \mathop{\bf
dom}f\)</span>，这条射线的最后一个分量为正。最后，我们也可以通过逆投射变换恢复出
<span class="math inline">\(f(x)\)</span>。</p>
</blockquote>
<p>  类似于透视函数，线性分式函数也是保凸的。如果 <span class="math inline">\(C\)</span> 是凸集并且在 <span class="math inline">\(f\)</span> 的定义域中（即任意 <span class="math inline">\(x\in C\)</span> 满足 <span class="math inline">\(c^\mathrm{T}x+d &gt; 0\)</span>），那么 <span class="math inline">\(C\)</span> 的象 <span class="math inline">\(f(C)\)</span>
也是凸集。根据前述的结果可以直接得到这个结论： <span class="math inline">\(C\)</span> 在仿射映射 <span class="math inline">\(\eqref{AffineFunction}\)</span>
下的象是凸的，并且在透视函数 <span class="math inline">\(P\)</span>
下的映射（即 <span class="math inline">\(f(C)\)</span>）是凸的。类似地，如果 <span class="math inline">\(C \subseteq \mathbf{R}^m\)</span>
是凸集，那么其原象 <span class="math inline">\(f^{-1}(C)\)</span>
也是凸的。</p>
<blockquote>
<p><strong>举例</strong> <strong>条件概率</strong>。设 <span class="math inline">\(u\)</span> 和 <span class="math inline">\(v\)</span> 是分别在 <span class="math inline">\(\{1, \cdots, n\}\)</span> 和 <span class="math inline">\(\{1, \cdots, m\}\)</span> 中取值的随机变量，并且
<span class="math inline">\(p_{ij}\)</span> 表示概率 <span class="math inline">\(\mathop{\bf prob}(u = i,v =
j)\)</span>。那么条件概率 <span class="math inline">\(f_{ij} =
\mathop{\bf prob}(u = i\mid v = j)\)</span> 由下式给出</p>
<p><span class="math display">\[
f_{ij} = \frac{p_{ij}}{\displaystyle\sum_{k=1}^n p_{kj}}
\]</span></p>
<p>因此，<span class="math inline">\(f\)</span>
可以通过一个线性分式映射从 <span class="math inline">\(p\)</span>
得到。</p>
<p>可以知道，如果 <span class="math inline">\(C\)</span> 是一个关于
<span class="math inline">\((u,v)\)</span> 的联合密度的凸集，那么相应的
<span class="math inline">\(u\)</span> 的条件密度（给定 <span class="math inline">\(v\)</span>）的集合也是凸集。</p>
</blockquote>
<p>  <a href="#图16">图 16</a> 表示了集合 <span class="math inline">\(C\subseteq \mathbf{R}^2\)</span>
及其在下面的线性分式函数下的象</p>
<p><span class="math display">\[
f(x) = \frac{1}{x_1 + x_2 + 1} x,\qquad \mathop{\bf dom}f =
\{(x_1,x_2)\mid x_1+x_2+1&gt;0\}
\]</span></p>
<p><a id="图15"></a></p>
<figure>
<img data-src="../images/post/2024-06-08-josh-cvx-1-3/2024-06-08-josh-cvx-1-3-160-ASetAndItsImageUnderLFF.png" width="800" alt="图 16. 左：集合 C\subseteq \mathbf{R}^2。虚线显示了线性分式函数 f(x) = x/(x_1 + x_2 + 1) 的定义域的边界，其中 \mathop{\bf dom}f = \{(x_1,x_2)\mid x_1+x_2+1>0\}。右：C 在 f 下的象。虚线显示了 f^{-1} 的定义域的边界。">
<figcaption aria-hidden="true">图 16. <strong>左</strong>：集合 <span class="math inline">\(C\subseteq
\mathbf{R}^2\)</span>。虚线显示了线性分式函数 <span class="math inline">\(f(x) = x/(x_1 + x_2 + 1)\)</span>
的定义域的边界，其中 <span class="math inline">\(\mathop{\bf dom}f =
\{(x_1,x_2)\mid x_1+x_2+1&gt;0\}\)</span>。<strong>右</strong>：<span class="math inline">\(C\)</span> 在 <span class="math inline">\(f\)</span> 下的象。虚线显示了 <span class="math inline">\(f^{-1}\)</span> 的定义域的边界。</figcaption>
</figure>
<h1 id="参考文献">参考文献</h1>
<ol type="1">
<li>Stephen P. Boyd and Lieven Vandenberghe, <em>Convex
optimization</em>. Cambridge, UK: Cambridge University Press, 2004.</li>
<li>Stephen P. Boyd and Lieven Vandenberghe, <em>凸优化</em>. 北京:
清华大学出版社, 2013.</li>
</ol>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/css/markmap.css">

<script src="/js/markmap.js"></script>
]]></content>
      <categories>
        <category>Josh 的学习笔记</category>
        <category>凸优化</category>
        <category>凸集</category>
        <category>数学</category>
        <category>凸优化</category>
      </categories>
      <tags>
        <tag>凸优化</tag>
        <tag>凸集</tag>
        <tag>保凸运算</tag>
        <tag>交集</tag>
        <tag>仿射函数</tag>
        <tag>伸缩</tag>
        <tag>平移</tag>
        <tag>线性分式</tag>
        <tag>透视函数</tag>
      </tags>
  </entry>
  <entry>
    <title>Josh&#39;s Note — 凸优化&lt;br&gt;Part 1.2 凸集—一些重要的凸集</title>
    <url>/posts/9293b739.html</url>
    <content><![CDATA[<p><span class="math inline">\(\newcommand{\bfR}{\mathbf{R}}
\newcommand{\bfS}{\mathbf{S}}
\newcommand{\TT}{\mathrm{T}}
\newcommand{\E}{\mathcal{E}}
\newcommand{\P}{\mathcal{P}}
\def\conv{\mathop{\bf
conv}}\)</span>  本文将描述一些重要的凸集。首先介绍一些简单的例子。</p>
<ul>
<li><p>空集 <span class="math inline">\(\emptyset\)</span>、任意一个点（即单点集（singleton））<span class="math inline">\(\{x_0\}\)</span> 、全空间 <span class="math inline">\(\bfR^n\)</span> 都是 <span class="math inline">\(\bfR^n\)</span>
的仿射（自然也是凸的）子集。</p></li>
<li><p>任意直线是仿射的。如果直线通过零点，则是子空间，因此，也是凸锥。</p></li>
<li><p>一条线段是凸的，但不是仿射的（除非退化为一个点）。</p></li>
<li><p>一条<strong>射线</strong>（<em>ray</em>），即具有形式 <span class="math inline">\(\left\{x_0 + \theta v\mid \theta \geqslant 0
\right\}, v \ne 0\)</span> 的集合，是凸的，但不是仿射的。如果射线的基点
<span class="math inline">\(x_0\)</span> 是 <span class="math inline">\(0\)</span>，则它是凸锥。</p></li>
<li><p>任意子空间是仿射的、凸锥（自然是凸的）。</p></li>
</ul>
<span id="more"></span>
<h1 id="超平面与半空间">1. 超平面与半空间</h1>
<p>  <strong>超平面</strong>（<em>hyperplane</em>）是具有如下形式的集合</p>
<p><span class="math display">\[
\left\{ x\mid a^\TT x = b \right\}
\]</span></p>
<p>其中 <span class="math inline">\(a \in \bfR^n, a \ne 0\)</span> 且
<span class="math inline">\(b \in
\bfR\)</span>。解析地来看，超平面是关于 <span class="math inline">\(x\)</span>
的非平凡线性方程的解空间（因此是一个仿射集合）。几何上，超平面 <span class="math inline">\(\left\{ x\mid a^\TT x = b \right\}\)</span>
可以理解为与给定向量 <span class="math inline">\(a\)</span>
的内积为常数的点的集合；也可以看成法线方向为 <span class="math inline">\(a\)</span> 的超平面，而常数 <span class="math inline">\(b \in \bfR\)</span>
决定了这个平面从原点的偏移。为更好地理解几何含义，可以将超平面表示成</p>
<p><span class="math display">\[
\left\{ x\mid a^\TT (x - x_0) = 0 \right\}
\]</span></p>
<p>其中 <span class="math inline">\(x_0\)</span>
是超平面上的任意一点（即任意满足 <span class="math inline">\(a^\TT x_0 =
b\)</span> 的点）。进一步，可以表示为</p>
<p><span class="math display">\[
\left\{ x\mid a^\TT (x - x_0) = 0 \right\} = x_0 + a^\perp
\]</span></p>
<p>其中 <span class="math inline">\(a^\perp\)</span> 表示 <span class="math inline">\(a\)</span> 的正交补，即与 <span class="math inline">\(a\)</span> 正交的向量的集合：</p>
<p><span class="math display">\[
a^\perp = \left\{ v\mid a^\TT v = 0 \right\}
\]</span></p>
<p>从中可以看出，超平面由偏移 <span class="math inline">\(x_0\)</span>
加上所有正交于（法）向量 <span class="math inline">\(a\)</span>
的向量构成，具体可见<a href="#图6">图 6</a> 。</p>
<p><a id="图6"></a></p>
<figure>
<img data-src="../images/post/2024-06-08-josh-cvx-1-2/2024-06-08-josh-cvx-1-2-060-HyperplaneInR2.png" width="400" alt="图 6. \bfR^2 中由法向量 a 和超平面上一点 x_0 确定的超平面。对于超平面上任意一点 x，x - x_0（如深色箭头所示）都垂直于 a。">
<figcaption aria-hidden="true">图 6. <span class="math inline">\(\bfR^2\)</span> 中由法向量 <span class="math inline">\(a\)</span> 和超平面上一点 <span class="math inline">\(x_0\)</span> 确定的超平面。对于超平面上任意一点
<span class="math inline">\(x\)</span>，<span class="math inline">\(x -
x_0\)</span>（如深色箭头所示）都垂直于 <span class="math inline">\(a\)</span>。</figcaption>
</figure>
<p>  一个超平面将 <span class="math inline">\(\bfR^n\)</span>
划分为两个<strong>半空间</strong>（<em>halfspaces</em>）。（闭的）半空间是具有下列形式的集合，</p>
<p><span class="math display">\[\begin{equation}\label{HalfSpace}
  \left\{x\mid a^\TT x \leqslant b \right\}
\end{equation}
\]</span></p>
<p>即（非平凡的）线性不等式的解空间，其中 <span class="math inline">\(a\ne 0\)</span>。半空间是凸的，但不是仿射的，如<a href="#图7">图 7</a> 所示。</p>
<p><a id="图7"></a></p>
<figure>
<img data-src="../images/post/2024-06-08-josh-cvx-1-2/2024-06-08-josh-cvx-1-2-070-AHyperplaneAndTwoHalfspaces.png" width="400" alt="图 7. \bfR^2 上由 a^\TT x = b 定义的超平面决定了两个半空间。由 a^x b 决定的半空间（无阴影）是向 a 扩展的半空间。由 a^x b 确定的半空间（阴影所示）向 -a 方向扩展。向量 a 是这个半空间向外的法向量。">
<figcaption aria-hidden="true">图 7. <span class="math inline">\(\bfR^2\)</span> 上由 <span class="math inline">\(a^\TT x = b\)</span>
定义的超平面决定了两个半空间。由 a^x b 决定的半空间（无阴影）是向 <span class="math inline">\(a\)</span> 扩展的半空间。由 a^x b
确定的半空间（阴影所示）向 <span class="math inline">\(-a\)</span>
方向扩展。向量 <span class="math inline">\(a\)</span>
是这个半空间向外的法向量。</figcaption>
</figure>
<p>  半空间 <span class="math inline">\(\eqref{HalfSpace}\)</span>
也可以表示为</p>
<p><span class="math display">\[
\left\{x\mid a^\TT (x - x_0) \leqslant 0 \right\}
\]</span></p>
<p>其中 <span class="math inline">\(x_0\)</span>
是相应超平面上的任意一点，即 <span class="math inline">\(x_0\)</span>
满足 <span class="math inline">\(a^\TT x_0 =
b\)</span>。上式有一个简单的几何解释：半空间由 <span class="math inline">\(x_0\)</span> 加上任意与（向外的法）向量 <span class="math inline">\(a\)</span> 呈钝角（或直角）的向量组成，如<a href="#图8">图 8</a> 所示。</p>
<p><a id="图8"></a></p>
<figure>
<img data-src="../images/post/2024-06-08-josh-cvx-1-2/2024-06-08-josh-cvx-1-2-080-VectorsAndHalfspaces.png" width="400" alt="图 8. 阴影所示集合是由 a^\TT (x - x_0) \leqslant 0 决定的半空间。向量 x_1 - x_0 与 a 的夹角为锐角，所以 x_1不在这个半空间中。向量 x_2 - x_1 与 a 的夹角为钝角，所以 x_2 在半空间中。">
<figcaption aria-hidden="true">图 8. 阴影所示集合是由 <span class="math inline">\(a^\TT (x - x_0) \leqslant 0\)</span>
决定的半空间。向量 <span class="math inline">\(x_1 - x_0\)</span> 与
<span class="math inline">\(a\)</span> 的夹角为锐角，所以 <span class="math inline">\(x_1\)</span>不在这个半空间中。向量 <span class="math inline">\(x_2 - x_1\)</span> 与 <span class="math inline">\(a\)</span> 的夹角为钝角，所以 <span class="math inline">\(x_2\)</span> 在半空间中。</figcaption>
</figure>
<p>  半空间 <span class="math inline">\(\eqref{HalfSpace}\)</span>
的边界是超平面 <span class="math inline">\(\left\{x\mid a^\TT x = b
\right\}\)</span>。集合 <span class="math inline">\(\left\{x\mid a^\TT x
&lt; b \right\}\)</span> 是半空间 <span class="math inline">\(\left\{x\mid a^\TT x \leqslant b \right\}\)</span>
的内部，称为<strong>开半空间</strong>（<em>open halfspace</em>）。</p>
<h1 id="euclid球和椭球">2. Euclid球和椭球</h1>
<p>  <span class="math inline">\(\bfR^n\)</span> 中的空间 <strong>Euclid
球</strong>（<em>Euclidean ball</em>）（或简称为球）具有下面的形式：</p>
<p><span class="math display">\[
B(x_c,r) = \left\{x\mid \left\| x - x_c \right\|_2 \leqslant r \right\}
= \left\{ x\mid (x-x_c)^\TT(x-x_c) \leqslant r^2 \right\}
\]</span></p>
<p>其中 <span class="math inline">\(r &gt; 0\)</span>，<span class="math inline">\(\| \cdot \|_2\)</span> 表示 Euclid 范数，即 <span class="math inline">\(\|u\|_2 = (u^\TT u)^{1/2}\)</span>。向量 <span class="math inline">\(x_r\)</span>
是<strong>球心</strong>（<em>center</em>），标量 <span class="math inline">\(r\)</span>
为<strong>半径</strong>（<em>radius</em>）。<span class="math inline">\(B (x_c, r)\)</span> 由距离球心 <span class="math inline">\(x_r\)</span> 距离不超过 <span class="math inline">\(r\)</span> 的所有点组成。 Euclid
球的另一个常见的表达式为：</p>
<p><span class="math display">\[
B(x_c,r) = \left\{ x_c + ru\mid \|u\|_2 \leqslant 1 \right\}
\]</span></p>
<p>  Euclid 球是凸集，即如果 <span class="math inline">\(\|x_1-x_2\|\leqslant r\)</span>，<span class="math inline">\(\|x_2-x_c\|\leqslant r\)</span>，并且 <span class="math inline">\(0 \leqslant \theta \leqslant 1\)</span>，那么</p>
<p><span class="math display">\[\begin{aligned}
  \left\| \theta x_1 + (1- \theta)x_2 - x_c\right\|_2 &amp;= \left\|
\theta(x_1 - x_c) + (1-\theta)(x_2 - x_c)\right\|_2
  \\
  &amp;\leqslant \theta \left\|x_1 - x_c\right\|_2 + (1-\theta) \left\|
x_2 - x_c \right\|_2
  \\
  &amp; \leqslant r
\end{aligned}\]</span></p>
<p>（这里利用了 <span class="math inline">\(\| \cdot \|_2\)</span>
的齐次性和三角不等式。）</p>
<p>  一类相关的凸集是<strong>椭球</strong>（<em>ellipsoid</em>），它们具有如下的形式：</p>
<p><span class="math display">\[\begin{equation}\label{ellipsoid-1}
  \E = \left\{ x\mid (x-x_c)^\TT P^{-1}(x-x_c) \leqslant 1 \right\}
\end{equation}\]</span></p>
<p>其中 <span class="math inline">\(P = P^\TT \succ 0\)</span>，即 <span class="math inline">\(P\)</span> 是对称正定矩阵。向量 <span class="math inline">\(x_c \in \bfR^n\)</span> 为椭球的中心。矩阵 <span class="math inline">\(P\)</span> 决定了椭球从 <span class="math inline">\(x_c\)</span> 向各个方向扩展的幅度。<span class="math inline">\(\E\)</span> 的半轴长度由 <span class="math inline">\(\sqrt{\lambda_i}\)</span> 给出，这里 <span class="math inline">\(\lambda_i\)</span> 为 <span class="math inline">\(P\)</span> 的特征值。球可以看成 <span class="math inline">\(P = r^2I\)</span> 的椭球。<a href="#图9">图 9</a>
给出了 <span class="math inline">\(\bfR^2\)</span> 上的一个椭球。</p>
<p><a id="图9"></a></p>
<figure>
<img data-src="../images/post/2024-06-08-josh-cvx-1-2/2024-06-08-josh-cvx-1-2-090-EllipsoidInR2.png" width="300" alt="图 9. 阴影所示为 \bfR^2 中的一个椭球。中心 x_c 由点显示，两个半轴由线段显示">
<figcaption aria-hidden="true">图 9. 阴影所示为 <span class="math inline">\(\bfR^2\)</span> 中的一个椭球。中心 <span class="math inline">\(x_c\)</span>
由点显示，两个半轴由线段显示</figcaption>
</figure>
<p>  椭球另一个常用的表示形式是</p>
<p><span class="math display">\[\begin{equation}\label{ellipsoid-2}
  \E = \left\{ x_c + Au\mid \|u\|_2 \leqslant 1 \right\}
\end{equation}\]</span></p>
<p>其中 <span class="math inline">\(A\)</span>
是非奇异的方阵。在此类表示形式中，可以不失一般性地假设 <span class="math inline">\(A\)</span> 对称正定。取 <span class="math inline">\(A=P^{1/2}\)</span>，这个表达式给出了由式 <span class="math inline">\(\eqref{ellipsoid-1}\)</span> 定义的椭球。当式
<span class="math inline">\(\eqref{ellipsoid-2}\)</span> 中的矩阵 <span class="math inline">\(A\)</span> 为对称半正定矩阵，但奇异时，集合 <span class="math inline">\(\eqref{ellipsoid-2}\)</span>
称为<strong>退化的椭球</strong>（<em>degenerate
ellipsoid</em>），其仿射维数等于 <span class="math inline">\(A\)</span>
的秩。退化的椭球也是凸的。</p>
<h1 id="范数球和范数锥">3. 范数球和范数锥</h1>
<p>  设 <span class="math inline">\(\| \cdot \|\)</span> 是 <span class="math inline">\(\bfR^n\)</span> 中的范数。由范数的一般性质可知，以
<span class="math inline">\(r\)</span> 为半径，<span class="math inline">\(x_c\)</span>
为球心的<strong>范数球</strong>（<em>norm ball</em>） <span class="math inline">\(\left\{ x\mid \|x-x_c\| \leqslant r
\right\}\)</span> 是凸的。关于范数 <span class="math inline">\(\| \cdot
\|\)</span> 的<strong>范数锥</strong>（<em>norm cone</em>）是集合</p>
<p><span class="math display">\[
C = \left\{ (x,t)\mid \|x\| \leqslant t \right\} \subseteq \bfR^{n+1}
\]</span></p>
<p>顾名思义，它是一个凸锥。</p>
<blockquote>
<p><strong>举例</strong> <strong>二阶锥</strong>（<em>second-order
cone</em>）是由 Euclid 范数定义的范数锥，即</p>
<p><span class="math display">\[\begin{aligned}
  C &amp;= \left\{ (x,t) \in \bfR^{n+1}\mid \|x\|_2 \leqslant t\right\}
  \\
  &amp;= \left\{ \left[\begin{array}{c}
    x \\ t
  \end{array} \right]\middle| \left[\begin{array}{c}
    x \\ t
  \end{array} \right]^\TT\left[\begin{array}{c}
    I &amp; 0 \\ 0 &amp; -1
  \end{array} \right] \left[\begin{array}{c}
    x \\ t
  \end{array} \right] \leqslant 0,\ t\geqslant 0 \right\}
\end{aligned}\]</span></p>
<p>二阶锥的其他名字也常常被使用。它由二次不等式定义，因此也被称为<strong>二次锥</strong>（<em>quadratic
cone</em>）。同时，也称其为 <strong>Lorentz 锥</strong>（<em>Lorentz
cone</em>）或<strong>冰激凌锥</strong>（<em>ice-cream cone</em>）。<a href="#图10">图 10</a> 显示了 <span class="math inline">\(\bfR^3\)</span> 上一个的二阶锥。</p>
<p><a id="图10"></a></p>
<figure>
<img data-src="../images/post/2024-06-08-josh-cvx-1-2/2024-06-08-josh-cvx-1-2-100-BoundaryOfSecondOrderCone.png" width="500" alt="图 10. \bfR^3 中二阶锥 \left\{(x_1,x_2,t)\mid  (x_1^2 + x_2^2)^{1/2} \leqslant t\right\} 的边界">
<figcaption aria-hidden="true">图 10. <span class="math inline">\(\bfR^3\)</span> 中二阶锥 <span class="math inline">\(\left\{(x_1,x_2,t)\mid  (x_1^2 + x_2^2)^{1/2}
\leqslant t\right\}\)</span> 的边界</figcaption>
</figure>
</blockquote>
<h1 id="多面体">4. 多面体</h1>
<p>  <strong>多面体</strong>（<em>polyhedron</em>）被定义为有限个线性等式和不等式的解集：</p>
<p><span class="math display">\[\begin{equation}\label{polyhedron-1}
  \P = \left\{ x\mid a_j^\TT x \leqslant b_j,\ j = 1,\cdots,m,\ c_j^\TT
x = d_j,\ j = 1,\cdots,p\right\}
\end{equation}\]</span></p>
<p>因此，多面体是有限个半空间和超平面的交集。仿射集合（例如子空间、超平面、直线）、射线、线段和半空间都是多面体。显而易见，多面体是凸集。有界的多面体有时也称为<strong>多胞形</strong>（<em>polytope</em>），但也有一些作者反过来使用这两个概念（即用多胞形表示具有
<span class="math inline">\(\eqref{polyhedron-1}\)</span>
形式的集合，而当其有界时称为多面体）。<a href="#图11">图 11</a>
显示了一个由五个半空间的交集定义的多面体。</p>
<p><a id="图11"></a></p>
<figure>
<img data-src="../images/post/2024-06-08-josh-cvx-1-2/2024-06-08-josh-cvx-1-2-110-Polyhydron.png" width="400" alt="图 11. 多面体 \P（阴影所示）是外法向量为 a_1,\cdots,a_5 的五个半空间的交集。">
<figcaption aria-hidden="true">图 11. 多面体 <span class="math inline">\(\P\)</span>（阴影所示）是外法向量为 <span class="math inline">\(a_1,\cdots,a_5\)</span>
的五个半空间的交集。</figcaption>
</figure>
<p>  可以方便地使用紧凑表达式</p>
<p><span class="math display">\[\begin{equation}\label{polyhedron-2}
  \P = \left\{ x\mid Ax \preceq b,\ Cx = d \right\}
\end{equation}\]</span></p>
<p>来表示 <span class="math inline">\(\eqref{polyhedron-1}\)</span>，其中</p>
<p><span class="math display">\[
A = \left[\begin{array}{c}
  a_1^\TT \\ \vdots \\ a_m^\TT
\end{array}\right],\qquad C = \left[\begin{array}{c}
  c_1^\TT \\ \vdots \\ c_p^\TT
\end{array}\right]
\]</span></p>
<p>此处的 <span class="math inline">\(\preceq\)</span> 代表 <span class="math inline">\(\bfR^m\)</span>
上的<strong>向量不等式</strong>（<em>vector
inequality</em>）或<strong>分量不等式</strong>（<em>componentwise
inequality</em>）：<span class="math inline">\(u \preceq v\)</span> 表示
<span class="math inline">\(u_i \leqslant v_i, i = 1,\cdots,
m\)</span>。</p>
<blockquote>
<p><strong>举例</strong> <strong>非负象限</strong>（<em>nonnegative
orthant</em>）是具有非负分量的点的集合，即</p>
<p><span class="math display">\[
\bfR_+^n = \left\{ x\in\bfR^n\mid x_i \geqslant 0,\ i = 1,\cdots,n
\right\} = \left\{ x\in \bfR^n\mid x \succeq 0 \right\}
\]</span></p>
<p>（此处 <span class="math inline">\(\bfR_+\)</span>
表示非负实数的集合，即 <span class="math inline">\(\bfR_+ = \left\{
x\in\bfR\mid x \geqslant 0
\right\}\)</span>。）非负象限既是多面体也是锥（因此称为<strong>多面体锥</strong>（<em>polyhedral
cone</em>））。</p>
</blockquote>
<h2 id="单纯形">4.1 单纯形</h2>
<p>  <strong>单纯形</strong>（<em>simplex</em>）是一类重要的多面体。设
<span class="math inline">\(k+1\)</span> 个点 <span class="math inline">\(v_0,\cdots,v_k \in \bfR^n\)</span> 仿射独立，即
<span class="math inline">\(v_1 - v_0, \cdots, v_k-v_0\)</span>
线性独立，那么，这些点决定了一个单纯形：</p>
<p><span class="math display">\[\begin{equation}\label{simplex}
  C = \conv{\{v_0,\cdots,v_k\}} = \left\{ \theta_0v_0 + \cdots +
\theta_k v_k\mid \theta \succeq 0,\ \mathbf{1}^\TT\theta = 1 \right\}
\end{equation}\]</span></p>
<p>其中 <span class="math inline">\(\mathbf{1}\)</span> 表示所有分量均为
<span class="math inline">\(1\)</span> 的向量。这个单纯形的仿射维数为
<span class="math inline">\(k\)</span>，因此也称为 <span class="math inline">\(\bfR^n\)</span> 空间的 <span class="math inline">\(k\)</span> 维单纯形。</p>
<blockquote>
<p><strong>举例</strong> <strong>一些常见的单纯形</strong>。1
维单纯形是一条线段；2 维单纯形是一个三角形（包含其内部）； 3
维单纯形是一个四面体。</p>
<p><strong>单位单纯形</strong>（<em>unit
simplex</em>）是由零向量和单位向量 <span class="math inline">\(\mathbf{0}, e_1,\cdots, e_n \in \bfR^n\)</span>
决定的 <span class="math inline">\(n\)</span>
维单纯形。它可以表示为满足下列条件的向量的集合：</p>
<p><span class="math display">\[
x \succeq 0,\qquad \mathbf{1}^\TT x\leqslant 1
\]</span></p>
<p><strong>概率单纯形</strong>（<em>probability
simplex</em>）是由单位向量 <span class="math inline">\(e_1,\cdots, e_n
\in \bfR^n\)</span> 决定的 <span class="math inline">\(n - 1\)</span>
维单纯形。它是满足下列条件的向量的集合：</p>
<p><span class="math display">\[
x \succeq 0,\qquad \mathbf{1}^\TT x= 1
\]</span></p>
<p>概率单纯形中的向量对应于含有 <span class="math inline">\(n\)</span>
个元素的集合的概率分布，<span class="math inline">\(x_i\)</span>
可理解为第 <span class="math inline">\(i\)</span> 个元素的概率。</p>
</blockquote>
<p>  为了用多面体来描述单纯形 <span class="math inline">\(\eqref{simplex}\)</span>，采用以下步骤将其变换为
<span class="math inline">\(\eqref{polyhedron-2}\)</span>
的形式。由定义可知，<span class="math inline">\(x\in C\)</span>
的充要条件是，对于某些 <span class="math inline">\(\theta\succeq 0,
\mathbf{1}^\TT\theta=1\)</span>, 有 <span class="math inline">\(x =
\theta_0 v_0 + \theta_1 v_1 + \cdots + \theta_k
v_k\)</span>。等价地，如果定义 <span class="math inline">\(y =
(\theta_1,\cdots,\theta_k)\)</span> 和</p>
<p><span class="math display">\[
B = \left[ \begin{array}{c}
  v_1-v_0 &amp; \cdots &amp; v_k-v_0
\end{array} \right] \in \bfR ^{n\times k}
\]</span></p>
<p>则 <span class="math inline">\(x\in C\)</span> 的充要条件是</p>
<p><span class="math display">\[\begin{equation}\label{IFFCondition}
  x = v_0 + By
\end{equation}
\]</span></p>
<p>对于 <span class="math inline">\(y \succeq 0\)</span>，<span class="math inline">\(\mathbf{1}^\TT y \leqslant 1\)</span> 成立。注意到
<span class="math inline">\(v_0,\cdots,v_k\)</span> 仿射独立意味着矩阵
<span class="math inline">\(B\)</span> 的秩为 <span class="math inline">\(k\)</span>。因此，存在非奇异矩阵 <span class="math inline">\(A=(A_1,A_2)\in\bfR^{n\times n}\)</span> 使得</p>
<p><span class="math display">\[
AB = \left[ \begin{array}{c}
  A_1 \\ A_2
\end{array} \right] B = \left[ \begin{array}{c}
  I \\ 0
\end{array} \right]
\]</span></p>
<p>用 <span class="math inline">\(A\)</span> 左乘 <span class="math inline">\(\eqref{IFFCondition}\)</span>，得到</p>
<p><span class="math display">\[
A_1 x = A_1 v_0 + y,\qquad A_2 x = A_2 v_0
\]</span></p>
<p>从中可以看出，<span class="math inline">\(x\in C\)</span> 当且仅当
<span class="math inline">\(A_2 x = A_2 v_0\)</span> 并且向量 <span class="math inline">\(y = A_1 x - A_1 v_0\)</span> 满足 <span class="math inline">\(y\succeq 0\)</span> 和 <span class="math inline">\(\mathbf{1}^\TT y \leqslant
1\)</span>。换言之得到了 <span class="math inline">\(x\in C\)</span>
的充要条件，</p>
<p><span class="math display">\[
A_2 x = A_2 v_0, \qquad A_1 x \succeq A_1 v_0, \qquad \mathbf{1}^\TT A_1
x \leqslant 1 + \mathbf{1}^\TT A_1 v_0
\]</span></p>
<p>这些是 <span class="math inline">\(x\)</span>
的线性等式和不等式，因此，描述了一个多面体。</p>
<h2 id="多面体的凸包描述">4.2 多面体的凸包描述</h2>
<p>  有限集合 <span class="math inline">\(\{v_1,\cdots,v_k\}\)</span>
的凸包是</p>
<p><span class="math display">\[
\conv\{v_1,\cdots,v_k\} = \left\{ \theta_1 v_1 + \cdots + \theta_k
v_k\mid \theta \succeq 0, \ \mathbf{1}^\TT \theta = 1 \right\}
\]</span></p>
<p>它是一个有界的多面体，但是（除非是例如单纯形这样的特殊情况）无法简单地用形如
<span class="math inline">\(\eqref{polyhedron-1}\)</span>
的式子，即用线性等式和不等式的集合将其表示。</p>
<p>  凸包表达式的一个扩展表示是，</p>
<p><span class="math display">\[\begin{equation}\label{ExtendedHull}
  \left\{ \theta_1 v_1 + \cdots + \theta_k v_k\mid \theta_1 + \cdots +
\theta_m = 1,\ \theta_i\geqslant 0, \ i=1,\cdots,k \right\}
\end{equation}\]</span></p>
<p>其中 <span class="math inline">\(m\leqslant k\)</span>。此处我们考虑
<span class="math inline">\(v_i\)</span> 的非负线性组合，但是仅仅要求前
<span class="math inline">\(m\)</span> 个系数之和为一。此外，我们可以将
<span class="math inline">\(\eqref{ExtendedHull}\)</span> 解释为点 <span class="math inline">\(v_1,\cdots,v_m\)</span> 的凸包加上点 <span class="math inline">\(v_{m+1},\cdots,v_k\)</span> 的锥包。集合 <span class="math inline">\(\eqref{ExtendedHull}\)</span>
定义了一个多面体，反之亦然，每个多面体都可以表示为此类形式（虽然这一点此处并未证明）。</p>
<p>  “如何表示多面体”这一问题的求解是十分巧妙的，并且有一些非常实用的结果。一个简单的例子是定义在
<span class="math inline">\(\ell_\infty\)</span>-范数空间的 <span class="math inline">\(\bfR^n\)</span> 上的单位球，</p>
<p><span class="math display">\[
C = \left\{x\mid |x_i| \leqslant 1, \ i = 1,\cdots n\right\}
\]</span></p>
<p><span class="math inline">\(C\)</span> 可以由 <span class="math inline">\(2n\)</span> 个线性不等式 <span class="math inline">\(\pm e_i^\TT x \leqslant 1\)</span> 表示为 <span class="math inline">\(\eqref{polyhedron-1}\)</span> 的形式，其中 <span class="math inline">\(e_i\)</span> 表示第 <span class="math inline">\(i\)</span> 维的单位向量。为了将其描述为形如 <span class="math inline">\(\eqref{ExtendedHull}\)</span> 的凸包，需要至少
<span class="math inline">\(2^n\)</span> 个点：</p>
<p><span class="math display">\[
C = \conv\{v_1,\cdots,v_{2^n}\}
\]</span></p>
<p>其中 <span class="math inline">\(v_1,\cdots,v_{2^n}\)</span> 是以
<span class="math inline">\(1\)</span> 和 <span class="math inline">\(-1\)</span> 为分量的全部向量，共 <span class="math inline">\(2^n\)</span> 个。可见，当 <span class="math inline">\(n\)</span>
很大时，这两种描述方式的规模相差极大。</p>
<h1 id="半正定锥">5. 半正定锥</h1>
<p>  用 <span class="math inline">\(\bfS^n\)</span> 表示对称 <span class="math inline">\(n\times n\)</span> 矩阵的集合，即</p>
<p><span class="math display">\[
\bfS^n = \left\{ X \in \bfR ^{n\times n}\mid X = X^\TT \right\}
\]</span></p>
<p>这是一个维数为 <span class="math inline">\(n(n + 1)/2\)</span>
的向量空间。用 <span class="math inline">\(\bfS^n_+\)</span>
表示对称半正定矩阵的集合：</p>
<p><span class="math display">\[
\bfS^n_+ = \left\{ X \in \bfS^n\mid X \succeq 0 \right\}
\]</span></p>
<p>用 <span class="math inline">\(\bfS^n_{++}\)</span>
表示对称正定矩阵的集合：</p>
<p><span class="math display">\[
\bfS^n_{++} = \left\{ X \in \bfS^n\mid X \succ 0 \right\}
\]</span></p>
<p>（这些符号与 <span class="math inline">\(\bfR_+\)</span>
相对应：<span class="math inline">\(\bfR_+\)</span> 表示非负实数，而
<span class="math inline">\(\bfR_{++}\)</span> 表示正实数。）</p>
<p>  集合 <span class="math inline">\(\bfS^n_+\)</span> 是一个凸锥：如果
<span class="math inline">\(\theta_1,\theta_2 \geqslant 0\)</span> 并且
<span class="math inline">\(A,B\in\bfS^n_+\)</span>，那么 <span class="math inline">\(\theta_1 A + \theta_2
B\in\bfS^n_+\)</span>。从半正定矩阵的定义可以直接得到：对于任意 <span class="math inline">\(x \in \bfR^n\)</span>，如果 <span class="math inline">\(A\succeq 0\)</span>，<span class="math inline">\(B\succeq 0\)</span> 并且 <span class="math inline">\(\theta_1,\theta_2 \geqslant 0\)</span>，那么有</p>
<p><span class="math display">\[
x^\TT (\theta_1 A + \theta_2 B)x = \theta_1 x^\TT A x + \theta_2 x^\TT
Bx \geqslant 0
\]</span></p>
<blockquote>
<p><strong>举例</strong> <span class="math inline">\(\bfS^2\)</span>
上的<strong>半正定锥</strong>（<em>Positive semideﬁnite
cone</em>）。我们有</p>
<p><span class="math display">\[
X = \left[\begin{array}{c}
x &amp; y \\ y &amp; z
\end{array}\right] \in \bfS^2_+ \quad \Longleftrightarrow \quad
x\geqslant 0, \quad z \geqslant 0, \quad xz\geqslant y^2
\]</span></p>
<p><a href="#图12">图 12</a> 给出了这个锥的边界，按 <span class="math inline">\((x,y,z)\)</span> 表示在 <span class="math inline">\(\bfR^3\)</span> 中。</p>
<p><a id="图12"></a></p>
<figure>
<img data-src="../images/post/2024-06-08-josh-cvx-1-2/2024-06-08-josh-cvx-1-2-120-BoundaryOfPostiveSemidefiniteCone.png" width="500" alt="图 12. \bfS^2 中半正定锥的边界。">
<figcaption aria-hidden="true">图 12. <span class="math inline">\(\bfS^2\)</span> 中半正定锥的边界。</figcaption>
</figure>
</blockquote>
<h1 id="参考文献">参考文献</h1>
<ol type="1">
<li>Stephen P. Boyd and Lieven Vandenberghe, <em>Convex
optimization</em>. Cambridge, UK: Cambridge University Press, 2004.</li>
<li>Stephen P. Boyd and Lieven Vandenberghe, <em>凸优化</em>. 北京:
清华大学出版社, 2013.</li>
</ol>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/css/markmap.css">

<script src="/js/markmap.js"></script>
]]></content>
      <categories>
        <category>Josh 的学习笔记</category>
        <category>凸优化</category>
        <category>凸集</category>
        <category>数学</category>
        <category>凸优化</category>
      </categories>
      <tags>
        <tag>凸优化</tag>
        <tag>凸集</tag>
        <tag>射线</tag>
        <tag>超平面</tag>
        <tag>半空间</tag>
        <tag>Euclid球</tag>
        <tag>椭球</tag>
        <tag>范数球</tag>
        <tag>范数锥</tag>
        <tag>二阶锥</tag>
        <tag>多面体</tag>
        <tag>单纯形</tag>
        <tag>半正定锥</tag>
      </tags>
  </entry>
  <entry>
    <title>Josh&#39;s Note — 凸优化&lt;br&gt;Part 1.4 凸集—广义不等式</title>
    <url>/posts/aff3a091.html</url>
    <content><![CDATA[<h1 id="正常锥与广义不等式">1. 正常锥与广义不等式</h1>
<p>$ $  称锥 <span class="math inline">\(K \subseteq
\mathbf{R}^n\)</span> 即为<strong>正常锥</strong>（<em>proper
cone</em>），如果它满足下列条件</p>
<ul>
<li>K 是凸的。</li>
<li>K 是闭的。</li>
<li>K 是<strong>实</strong>（<em>solid</em>）的，即具有非空内部。</li>
<li>K
是<strong>尖</strong>（<em>pointed</em>）的，即不包含直线（或者等价地，<span class="math inline">\(x\in K, -x \in K \Longrightarrow x =
0\)</span>）。</li>
</ul>
<p>正常锥 <span class="math inline">\(K\)</span>
可以用来定义<strong>广义不等式</strong>（<em>generalized
inequality</em>），即 <span class="math inline">\(\mathbf{R}^n\)</span>
上的偏序关系。这种偏序关系和 <span class="math inline">\(\mathbf{R}\)</span>
上的标准序有很多相同的性质。用正常锥 <span class="math inline">\(K\)</span> 可以定义 <span class="math inline">\(\mathbf{R}^n\)</span> 上的偏序关系如下</p>
<p><span class="math display">\[
x \preceq_K y \Longleftrightarrow y - x \in K
\]</span></p>
<p><span class="math inline">\(y \preceq_K x\)</span> 也可以写为 <span class="math inline">\(x \succeq_K
y\)</span>。类似地，定义相应的严格偏序关系为</p>
<p><span class="math display">\[
x \prec_K y \Longleftrightarrow y - x \in \mathop{\bf int}K
\]</span></p>
<p>并且可以同样地定义 <span class="math inline">\(x \succ_K
y\)</span>。（为将广义不等式 <span class="math inline">\(\preceq_K\)</span>
与严格的广义不等式区分开，有时也称 <span class="math inline">\(\preceq_K\)</span> 为不严格的广义不等式）。</p>
<span id="more"></span>
<p>  当 <span class="math inline">\(K = \mathbf{R}_+\)</span>
时，偏序关系 <span class="math inline">\(\preceq_K\)</span>
就是通常意义上 <span class="math inline">\(\mathbf{R}\)</span> 中的序
<span class="math inline">\(\leqslant\)</span>；相应地，严格偏序关系
<span class="math inline">\(\prec_K\)</span> 与 <span class="math inline">\(\mathbf{R}\)</span> 上的严格序 <span class="math inline">\(&lt;\)</span> 相同。因此，广义不等式包含了 <span class="math inline">\(\mathbf{R}\)</span>
上的（不严格和严格）不等式，它是广义不等式的一种特殊情况。</p>
<blockquote>
<p><strong>举例</strong> <strong>非负象限及分量不等式</strong>。非负象限
<span class="math inline">\(K = \mathbf{R}^n_+\)</span>
是一个正常锥。相应的广义不等式 <span class="math inline">\(\preceq_K\)</span> 对应于向量间的分量不等式，即
<span class="math inline">\(x \preceq_K y\)</span> 等价于 <span class="math inline">\(x_i \leqslant y_i, i =
1,\cdots,n\)</span>。相应地，其严格不等式对应于严格的分量不等式，即
<span class="math inline">\(x \prec_K y\)</span> 等价于 <span class="math inline">\(x_i &lt; y_i, i = 1,\cdots,n\)</span>。</p>
<p>我们会经常使用对应于非负象限的不严格和严格的偏序关系，因此省略下标
<span class="math inline">\(K\)</span>。当 <span class="math inline">\(\preceq\)</span> 或 <span class="math inline">\(\prec\)</span>
出现在向量间的时候，该符号应被理解为分量不等式。</p>
</blockquote>
<blockquote>
<p><strong>举例</strong> <strong>半正定锥和矩阵不等式</strong>。半正定锥是
<span class="math inline">\(\mathbf{S}^n\)</span>
空间中的正常锥，相应的广义不等式 <span class="math inline">\(\preceq_K\)</span> 就是通常的矩阵不等式，即 <span class="math inline">\(X \preceq_K Y\)</span> 等价于 <span class="math inline">\(Y - X\)</span> 为半正定矩阵。（在 <span class="math inline">\(\mathbf{S}^n\)</span> 中）<span class="math inline">\(\mathbf{S}^n_+\)</span>
的内部由正定矩阵组成，因此严格广义不等式也等同于通常的对称矩阵的严格不等式，即
<span class="math inline">\(X \prec_K Y\)</span> 等价于 <span class="math inline">\(Y - X\)</span> 为正定矩阵。</p>
<p>这里，也是由于经常使用这种偏序关系，因此省略其下标，即对于对称矩阵，我们将广义不等式简写为
<span class="math inline">\(X \preceq Y\)</span> 或 <span class="math inline">\(X \prec Y\)</span>,
它们表示关于半正定锥的广义不等式。</p>
</blockquote>
<blockquote>
<p><strong>举例</strong> <strong><span class="math inline">\([0,
1]\)</span> 上非负的多项式锥</strong>。<span class="math inline">\(K\)</span> 定义如下</p>
<p><span class="math display">\[\begin{equation}
K = \{ c\in\mathbf{R}^n\mid c_1 + c_2 t + \cdots + c_n t^{n-1} \geqslant
0\ 对于\ t \in [0,1]\}
\end{equation}\]</span></p>
<p>即 <span class="math inline">\(K\)</span> 是 <span class="math inline">\([0, 1]\)</span> 上最高 <span class="math inline">\(n - 1\)</span> 阶的非负多项式（系数）锥。可以看出
<span class="math inline">\(K\)</span> 是一个正常锥，其内部是 <span class="math inline">\([0, 1]\)</span> 上为正的多项式的系数集合。</p>
<p>两个向量 <span class="math inline">\(c, d \in \mathbf{R}^n\)</span>
满足 <span class="math inline">\(c \preceq_K d\)</span>
的充要条件是，对于所有 <span class="math inline">\(t \in [0, 1]\)</span>
有</p>
<p><span class="math display">\[
c_1 + c_2 t + \cdots + c_n t^{n-1} \leqslant d_1 + d_2 t + \cdots + d_n
t^{n-1}
\]</span></p>
</blockquote>
<h2 id="广义不等式的性质">1.1 广义不等式的性质</h2>
<p>  广义不等式 <span class="math inline">\(\preceq_K\)</span>
满足许多性质，例如</p>
<ul>
<li><strong><span class="math inline">\(\preceq_K\)</span>
对于加法是保序的</strong>：如果 <span class="math inline">\(x \preceq_K
y\)</span> 并且 <span class="math inline">\(u \preceq_K v\)</span>，那么
<span class="math inline">\(x + u \preceq_K y + v\)</span>。</li>
<li><strong><span class="math inline">\(\preceq_K\)</span>
具有传递性</strong>：如果 <span class="math inline">\(x \preceq_K
y\)</span> 并且 <span class="math inline">\(y \preceq_K z\)</span>，那么
<span class="math inline">\(x \preceq_K z\)</span>。</li>
<li><strong><span class="math inline">\(\preceq_K\)</span>
对于非负数乘是保序的</strong>：如果 <span class="math inline">\(x
\preceq_K y\)</span> 并且 <span class="math inline">\(\alpha \geqslant
0\)</span>，那么 <span class="math inline">\(\alpha x \preceq_K \alpha
y\)</span>。</li>
<li><strong><span class="math inline">\(\preceq_K\)</span>
是自反的</strong>：<span class="math inline">\(x \preceq_K
x\)</span>。</li>
<li><strong><span class="math inline">\(\preceq_K\)</span>
是反对称的</strong>：如果 <span class="math inline">\(x \preceq_K
y\)</span> 并且 <span class="math inline">\(y \preceq_K x\)</span>，那么
<span class="math inline">\(x = y\)</span>。</li>
<li><strong><span class="math inline">\(\preceq_K\)</span>
对于极限运算是保序的</strong>：如果对于 <span class="math inline">\(i =
1,2,\dots\)</span> 均有 <span class="math inline">\(x_i \preceq_K
y_i\)</span>，当 <span class="math inline">\(i \to \infty\)</span>
时，有 <span class="math inline">\(x_i \to x\)</span> 和 <span class="math inline">\(y_i \to y\)</span>，那么 <span class="math inline">\(x \preceq_K y\)</span>。</li>
</ul>
<p>相应的广义不等式 <span class="math inline">\(\prec_K\)</span>
也满足一些性质，例如</p>
<ul>
<li>如果 <span class="math inline">\(x \prec_K y\)</span>，那么 <span class="math inline">\(x \preceq_K y\)</span>。</li>
<li>如果 <span class="math inline">\(x \prec_K y\)</span> 并且 <span class="math inline">\(u \prec_K v\)</span>, 那么 <span class="math inline">\(x + u \prec_K y + v\)</span>。</li>
<li>如果 <span class="math inline">\(x \prec_K y\)</span> 并且 <span class="math inline">\(\alpha &gt; 0\)</span>，那么 <span class="math inline">\(\alpha x \prec_K \alpha y\)</span>。</li>
<li><span class="math inline">\(x \nprec_K x\)</span>。</li>
<li>如果 <span class="math inline">\(x \prec_K
y\)</span>，那么对于足够小的 <span class="math inline">\(u\)</span> 和
<span class="math inline">\(v\)</span> 有 <span class="math inline">\(x
+ u \prec_K y + v\)</span>。</li>
</ul>
<p>这些性质可以从 <span class="math inline">\(\preceq_K\)</span> 和
<span class="math inline">\(\prec_K\)</span>
的定义以及正常锥的性质中直接得到。</p>
<h1 id="最小与极小元">2. 最小与极小元</h1>
<p>  广义不等式的符号（<span class="math inline">\(\preceq_K\)</span>，<span class="math inline">\(\prec_K\)</span>）似乎表明它们与 <span class="math inline">\(\mathbf{R}\)</span> 上的普通不等式（<span class="math inline">\(\leqslant\)</span>，<span class="math inline">\(&lt;\)</span>）有着相同的性质。虽然普通不等式的许多性质对于广义不等式确实成立，但很多重要的性质并不如此。最明显的区别在于，<span class="math inline">\(\mathbf{R}\)</span> 上的 <span class="math inline">\(\leqslant\)</span>
是一个<strong>线性序</strong>（<em>linear
ordering</em>），即任意两点都是<strong>可比的</strong>（<em>comparable</em>），也就是说
<span class="math inline">\(x\leqslant y\)</span> 和 <span class="math inline">\(y \leqslant x\)</span>
二者必居其一。这个性质对于其他广义不等式并不成立。这导致了最小、最大这些概念在广义不等式环境下变得更加复杂。本节将对此进行简要的讨论。</p>
<p>  如果对于每个 <span class="math inline">\(y \in S\)</span>，均有
<span class="math inline">\(x \preceq_K y\)</span>，称 <span class="math inline">\(x\in S\)</span> 是 <span class="math inline">\(S\)</span>（关于广义不等式 <span class="math inline">\(\preceq_K\)</span>）的<strong>最小元</strong>（<em>minimum
element</em>）。类似地，我们可以定义关于广义不等式的<strong>最大元</strong>（<strong>maximum
element</strong>）。如果一个集合有最小（或最大）元，那么它们是唯一的。</p>
<p>  相对应的概念是<strong>极小元</strong>（<em>minimal
element</em>）。如果 <span class="math inline">\(y \in S\)</span>，<span class="math inline">\(y \preceq_K x\)</span> 可以推得 <span class="math inline">\(y=x\)</span>，那么称 <span class="math inline">\(x\in S\)</span> 是 <span class="math inline">\(S\)</span> 上（关于广义不等式 <span class="math inline">\(\preceq_K\)</span>）的<strong>极小元</strong>（<em>minimal
element</em>）。同样地，可以定义<strong>极大元</strong>（<em>maximal
element</em>）。一个集合可以有多个极小（或极大）元。</p>
<p>  可以用简单的集合符号对最小元和极小元进行描述。元素 <span class="math inline">\(x\in S\)</span> 是 <span class="math inline">\(S\)</span> 中的一个最小元，当且仅当</p>
<p><span class="math display">\[
S \subseteq x + K
\]</span></p>
<p>这里 <span class="math inline">\(x+K\)</span> 表示可以与 <span class="math inline">\(x\)</span> 相比并且大于或等于（根据 <span class="math inline">\(\preceq_K\)</span>）<span class="math inline">\(x\)</span> 的所有元素。元素 <span class="math inline">\(x\in S\)</span> 是极小元，当且仅当</p>
<p><span class="math display">\[
(x - K) \cap S = \{x\}
\]</span></p>
<p>这里 <span class="math inline">\(x-K\)</span> 表示可以与 <span class="math inline">\(x\)</span> 相比并且小于或等于（根据立<span class="math inline">\(\preceq_K\)</span>）<span class="math inline">\(x\)</span> 的所有元素，它与 <span class="math inline">\(S\)</span> 的唯一共同点即是 <span class="math inline">\(x\)</span>。</p>
<p>  <span class="math inline">\(K=\mathbf{R}^n\)</span>
导出的实际上就是 <span class="math inline">\(\mathbf{R}\)</span>
上一般的序。此时，极小和最小的概念是一致的，也符合集合最小元素的通常定义。</p>
<blockquote>
<p><strong>举例</strong> 考虑锥 <span class="math inline">\(\mathbf{R}^2_+\)</span>，它导出的是 <span class="math inline">\(\mathbf{R}^2\)</span>
上的关于分量的不等式。对此，可以给出一些关于极小元和最小元的简单的几何描述。不等式
<span class="math inline">\(x \preceq y\)</span> 的含义是 <span class="math inline">\(y\)</span> 在 <span class="math inline">\(x\)</span> 之上、之右。<span class="math inline">\(x \in S\)</span>是集合 <span class="math inline">\(S\)</span> 的最小元，表明 <span class="math inline">\(S\)</span> 的其他所有点都在它之上、之右。而 <span class="math inline">\(x\)</span> 为集合 <span class="math inline">\(S\)</span> 的极小元，是指 <span class="math inline">\(S\)</span> 中没有任何一个点在 <span class="math inline">\(x\)</span> 之下、之左，其区别可见<a href="#图17">图 17</a>。</p>
<p><a id="图17"></a></p>
<figure>
<img data-src="../images/post/2024-06-12-josh-cvx-1-4/2024-06-12-josh-cvx-1-4-170-MinimalAndMinimum.png" width="700" alt="图 17. 左：集合出关于 \mathbf{R}^2 上的分量不等式有最小元 x_1。集合 x_1+K 由浅色阴影所示；x_1 是 S_1 的最小元，因为 S_1 \subseteq x_1 + K。右：点 x_2 是 S_2 的极小元。集合 x_2-K 由浅色阴影所示。点 x_2 是极小的，因为 x_2-K 和 S_2 只相交于 x_2">
<figcaption aria-hidden="true">图 17. <strong>左</strong>：集合出关于
<span class="math inline">\(\mathbf{R}^2\)</span> 上的分量不等式有最小元
<span class="math inline">\(x_1\)</span>。集合 <span class="math inline">\(x_1+K\)</span> 由浅色阴影所示；<span class="math inline">\(x_1\)</span> 是 <span class="math inline">\(S_1\)</span> 的最小元，因为 <span class="math inline">\(S_1 \subseteq x_1 +
K\)</span>。<strong>右</strong>：点 <span class="math inline">\(x_2\)</span> 是 <span class="math inline">\(S_2\)</span> 的极小元。集合 <span class="math inline">\(x_2-K\)</span> 由浅色阴影所示。点 <span class="math inline">\(x_2\)</span> 是极小的，因为 <span class="math inline">\(x_2-K\)</span> 和 <span class="math inline">\(S_2\)</span> 只相交于 <span class="math inline">\(x_2\)</span></figcaption>
</figure>
</blockquote>
<blockquote>
<p><strong>举例</strong> <strong>对称矩阵集合中的最小元和极小元</strong>。用
<span class="math inline">\(A \in \mathbf{S}^n_{++}\)</span>
表示一个圆心在原点的椭圆，即</p>
<p><span class="math display">\[
\mathcal{E}_A = \{ x\mid x^\mathrm{T}A^{-1} x \leqslant 1 \}
\]</span></p>
<p>我们知道 <span class="math inline">\(A \preceq B\)</span> 等价于
<span class="math inline">\(\mathcal{E}_A \subseteq
\mathcal{E}_B\)</span>。</p>
<p>给定 <span class="math inline">\(v_1,\cdots,v_k \in
\mathbf{R}^n\)</span> 并定义</p>
<p><span class="math display">\[
S = \{ P \in \mathbf{S}^n_{++}\mid v_i^\mathrm{T}P^{-1} v_i \leqslant
1,\ i = 1,\dots k \}
\]</span></p>
<p>它对应于包含了点 <span class="math inline">\(v_1,\cdots,v_k\)</span>
的椭圆的集合。集合 <span class="math inline">\(S\)</span>
没有最小元：对于任意包含点<span class="math inline">\(v_1,\cdots,v_k\)</span>
的椭圆，总可以找到另一个包含这些点但不可比的椭圆。一个椭圆是极小的，如果它包含这些点但没有更小的椭圆也包含这些点。<a href="#图18">图 18</a>显示了 <span class="math inline">\(\mathbf{R}^2\)</span> 上 <span class="math inline">\(k = 2\)</span> 时的一个例子。</p>
<p><a id="图18"></a></p>
<figure>
<img data-src="../images/post/2024-06-12-josh-cvx-1-4/2024-06-12-josh-cvx-1-4-180-ThreeEllipsoids.png" width="300" alt="图 18. \mathbf{R}^2 中的三个椭球，它们均以原点（图中较低的点所示）为中心，并且包含较高处的点。椭球 \mathcal{E}_1 不是极小的，因为存在包含这些点并且更小的椭球（例如，\mathcal{E}_3）。由于同样的原因，\mathcal{E}_3 也不是极小的。椭球 \mathcal{E}_2 是极小的，因为没有其他（以原点为中心）包含这些点并被 \mathcal{E}_2 包含的椭球。">
<figcaption aria-hidden="true">图 18. <span class="math inline">\(\mathbf{R}^2\)</span>
中的三个椭球，它们均以原点（图中较低的点所示）为中心，并且包含较高处的点。椭球
<span class="math inline">\(\mathcal{E}_1\)</span>
不是极小的，因为存在包含这些点并且更小的椭球（例如，<span class="math inline">\(\mathcal{E}_3\)</span>）。由于同样的原因，<span class="math inline">\(\mathcal{E}_3\)</span> 也不是极小的。椭球 <span class="math inline">\(\mathcal{E}_2\)</span>
是极小的，因为没有其他（以原点为中心）包含这些点并被 <span class="math inline">\(\mathcal{E}_2\)</span> 包含的椭球。</figcaption>
</figure>
</blockquote>
<h1 id="参考文献">参考文献</h1>
<ol type="1">
<li>Stephen P. Boyd and Lieven Vandenberghe, <em>Convex
optimization</em>. Cambridge, UK: Cambridge University Press, 2004.</li>
<li>Stephen P. Boyd and Lieven Vandenberghe, <em>凸优化</em>. 北京:
清华大学出版社, 2013.</li>
</ol>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/css/markmap.css">

<script src="/js/markmap.js"></script>
]]></content>
      <categories>
        <category>Josh 的学习笔记</category>
        <category>凸优化</category>
        <category>凸集</category>
        <category>数学</category>
        <category>凸优化</category>
      </categories>
      <tags>
        <tag>凸优化</tag>
        <tag>凸集</tag>
        <tag>广义不等式</tag>
        <tag>正常锥</tag>
        <tag>最小元</tag>
        <tag>极小元</tag>
        <tag>最大元</tag>
        <tag>极大元</tag>
      </tags>
  </entry>
  <entry>
    <title>Josh&#39;s Note — 凸优化&lt;br&gt;Part 1.5 凸集—分离与支撑超平面</title>
    <url>/posts/bc5bb04.html</url>
    <content><![CDATA[<h1 id="超平面分离定理">1. 超平面分离定理</h1>
<p>$
$  本节将阐述一个在之后非常重要的想法：用超平面或仿射函数将两个不相交的凸集分离开来。其基本结果就是<strong>超平面分离定理</strong>（<em>separating
hyperplane theorem</em>）：假设 <span class="math inline">\(C\)</span>
和 <span class="math inline">\(D\)</span> 是两个不相交的凸集，即 <span class="math inline">\(C \cap D = \emptyset\)</span>，那么存在 <span class="math inline">\(a \ne 0\)</span> 和 <span class="math inline">\(b\)</span> 使得对于所有 <span class="math inline">\(x\in C\)</span> 有 <span class="math inline">\(a^\mathrm{T}x \leqslant b\)</span>，对于所有 <span class="math inline">\(x\in D\)</span> 有 <span class="math inline">\(a^\mathrm{T}x \geqslant
b\)</span>。换言之，仿射函数 <span class="math inline">\(a^\mathrm{T}x-b\)</span> 在 <span class="math inline">\(C\)</span> 中非正，而在 <span class="math inline">\(D\)</span> 中非负。超平面 <span class="math inline">\(\{ x\mid a^\mathrm{T}x = b \}\)</span> 称为集合
<span class="math inline">\(C\)</span> 和 <span class="math inline">\(D\)</span>
的<strong>分离超平面</strong>（<em>separating
hyperplane</em>），或称超平面<strong>分离</strong>（<em>separate</em>）了集合
<span class="math inline">\(C\)</span> 和 <span class="math inline">\(D\)</span>，如<a href="#图19">图 19</a>。</p>
<p><a id="图19"></a></p>
<figure>
<img data-src="../images/post/2024-06-12-josh-cvx-1-5/2024-06-12-josh-cvx-1-5-190-Hyperplane.png" width="400" alt="图 19. 超平面 \{ x\mid a^\mathrm{T}x = b \} 分离了两个不相交的凸集 C 和 D。仿射函数 a^\mathrm{T}x-b 在 C 上非正而在 D 上非负。">
<figcaption aria-hidden="true">图 19. 超平面 <span class="math inline">\(\{ x\mid a^\mathrm{T}x = b \}\)</span>
分离了两个不相交的凸集 <span class="math inline">\(C\)</span> 和 <span class="math inline">\(D\)</span>。仿射函数 <span class="math inline">\(a^\mathrm{T}x-b\)</span> 在 <span class="math inline">\(C\)</span> 上非正而在 <span class="math inline">\(D\)</span> 上非负。</figcaption>
</figure>
<span id="more"></span>
<h2 id="超平面分离定理的证明">1.1 超平面分离定理的证明</h2>
<p>  这里我们考虑一个特殊的情况下的证明。假设 <span class="math inline">\(C\)</span> 和 <span class="math inline">\(D\)</span>
的（Euclid）<strong>距离</strong>（<em>distance</em>）为正，这里的距离定义为</p>
<p><span class="math display">\[
\mathop{\bf dist}(C,D) = \inf\{ \|u,v\|_2\mid u \in C,\ v \in D\}
\]</span></p>
<p>并且存在 <span class="math inline">\(c\in C\)</span> 和 <span class="math inline">\(d\in D\)</span> 达到这个最小距离，即 <span class="math inline">\(\|c-d\|_2=\mathop{\bf
dist}(C,D)\)</span>。（这些条件是可以被满足的，例如当 <span class="math inline">\(C\)</span> 和 <span class="math inline">\(D\)</span> 是闭的并且其中之一是有界的。）</p>
<p>  定义</p>
<p><span class="math display">\[
a = d - c,\qquad b = \frac{\|d\|_2^2 - \|c\|_2^2}{2}
\]</span></p>
<p>我们将显示仿射函数</p>
<p><span class="math display">\[
f(a) = a^\mathrm{T}x - b = (d-c)^\mathrm{T}(x - (1/2)(d+c))
\]</span></p>
<p>在 <span class="math inline">\(C\)</span> 中非正而在 <span class="math inline">\(D\)</span> 中非负，即超平面 <span class="math inline">\(\{ x\mid a^\mathrm{T}x = b \}\)</span> 分离了
<span class="math inline">\(C\)</span> 和 <span class="math inline">\(D\)</span>。这个超平面与连接 <span class="math inline">\(c\)</span> 和 <span class="math inline">\(d\)</span> 之间的线段相垂直并且穿过其中点，如<a href="#图20">图 20</a> 所示。</p>
<p><a id="图20"></a></p>
<figure>
<img data-src="../images/post/2024-06-12-josh-cvx-1-5/2024-06-12-josh-cvx-1-5-200-SeparateHyperplane.png" width="400" alt="图 20. 两个凸集间分离超平面的构造。c \in C 和 d\in D 是两个集合中最靠近彼此的一个点对。分离超平面垂直并且等分 c 和 d 之间的线段。">
<figcaption aria-hidden="true">图 20. 两个凸集间分离超平面的构造。<span class="math inline">\(c \in C\)</span> 和 <span class="math inline">\(d\in D\)</span>
是两个集合中最靠近彼此的一个点对。分离超平面垂直并且等分 <span class="math inline">\(c\)</span> 和 <span class="math inline">\(d\)</span> 之间的线段。</figcaption>
</figure>
<p>  首先证明 <span class="math inline">\(f\)</span> 在 <span class="math inline">\(D\)</span> 中非负。关于 <span class="math inline">\(f\)</span> 在 <span class="math inline">\(C\)</span> 中非正的证明是相似的（只需将 <span class="math inline">\(C\)</span> 和 <span class="math inline">\(D\)</span> 交换并考虑 <span class="math inline">\(-f\)</span> 即可）。</p>
<blockquote>
<p><strong>证明</strong> 假设存在一个点 <span class="math inline">\(u\in
D\)</span>，并且</p>
<p><span class="math display">\[\begin{equation}\label{ufunction}
  f(u) = (d-c)^\mathrm{T}(u - (1/2)(d+c)) &lt; 0
\end{equation}\]</span></p>
<p>可以将 <span class="math inline">\(f(u)\)</span> 表示为</p>
<p><span class="math display">\[
f(u) = (d-c)^\mathrm{T}(u - d + (1/2)(d-c)) = (d-c)^\mathrm{T}(u-d) +
(1/2) \| d-c \|_2^2
\]</span></p>
<p>可以看出式 <span class="math inline">\(\eqref{ufunction}\)</span>
意味着 <span class="math inline">\((d-c)^\mathrm{T}(u-d) &lt;
0\)</span>。于是，观察到</p>
<p><span class="math display">\[
\left. \frac{\mathrm{d}}{\mathrm{d}t} \|d + t(u-d) - c\|_2^2
\right|_{t=0} = 2(d-c)^\mathrm{T}(u-d) &lt; 0
\]</span></p>
<p>因此，对于足够小的 <span class="math inline">\(t&gt;0\)</span> 及
<span class="math inline">\(t\leqslant 1\)</span>，有</p>
<p><span class="math display">\[
\| d + t(u-d) - c \|_2 &lt; \| d -c \|_2
\]</span></p>
<p>即点 <span class="math inline">\(d+t(u-d)\)</span> 比 <span class="math inline">\(d\)</span> 更靠近 <span class="math inline">\(c\)</span>。因为 <span class="math inline">\(D\)</span> 是包含 <span class="math inline">\(d\)</span> 和 <span class="math inline">\(u\)</span> 的凸集，我们有 <span class="math inline">\(d+t(u-d) \in
D\)</span>。但这是不可能的，因为根据假设，<span class="math inline">\(d\)</span> 应当是 <span class="math inline">\(D\)</span> 中离 <span class="math inline">\(C\)</span> 最近的点。</p>
</blockquote>
<blockquote>
<p><strong>举例</strong> <strong>仿射集与凸集的分离</strong>。设 <span class="math inline">\(C\)</span> 是凸集，而 <span class="math inline">\(D\)</span> 是仿射的，即 <span class="math inline">\(D = \{ Fu + g\mid u \in
\mathbf{R}^m\}\)</span>，其中 <span class="math inline">\(F \in
\mathbf{R}^{n\times m}\)</span>。设 <span class="math inline">\(C\)</span> 和 <span class="math inline">\(D\)</span> 不相交，那么根据超平面分离定理，存在
<span class="math inline">\(a \ne 0\)</span> 和 <span class="math inline">\(b\)</span> 使得对于所有 <span class="math inline">\(x \in C\)</span> 有 <span class="math inline">\(a^\mathrm{T}x \leqslant b\)</span>，对于所有 <span class="math inline">\(x \in D\)</span> 有 <span class="math inline">\(a^\mathrm{T}x \geqslant b\)</span>。</p>
<p>这里 <span class="math inline">\(a^\mathrm{T}x \geqslant b\)</span>
对于所有 <span class="math inline">\(x \in D\)</span>
均成立，表明对于任意 <span class="math inline">\(u \in
\mathbf{R}^m\)</span> 均有 <span class="math inline">\(a^\mathrm{T}Fu
\geqslant b - a^\mathrm{T}g\)</span>。但是在 <span class="math inline">\(\mathbf{R}^m\)</span>
上，只有当一个线性函数为零时，它才是有界的。因此，可以推知 <span class="math inline">\(a^\mathrm{T}F=0\)</span> （并且因此有 <span class="math inline">\(b \leqslant a^\mathrm{T}g\)</span>）。</p>
<p>所以可知，存在 <span class="math inline">\(a \ne 0\)</span> 使得
<span class="math inline">\(F^\mathrm{T}a =0\)</span> 和 <span class="math inline">\(a^\mathrm{T}x \leqslant a^\mathrm{T}g\)</span>
对于所有 <span class="math inline">\(x\in C\)</span> 均成立。</p>
</blockquote>
<h2 id="严格分离">1.2 严格分离</h2>
<p>  如果之前构造的分离超平面满足更强的条件，即对于任意 <span class="math inline">\(x\in C\)</span> 有 <span class="math inline">\(a^\mathrm{T}x &lt; b\)</span> 并且对于任意 <span class="math inline">\(x\in D\)</span> 有 <span class="math inline">\(a^\mathrm{T}x &gt; b\)</span>, 则称其为集合 <span class="math inline">\(C\)</span> 和 <span class="math inline">\(D\)</span> 的<strong>严格分离</strong>（<em>strict
separation</em>）。简单的例子就可以看出，对于一般的情况，不相交的凸集并不一定能够被超平面严格分离（即使集合是闭集）。但是，在很多特殊的情况下，可以构造严格分离。</p>
<blockquote>
<p><strong>举例</strong> <strong>点和闭凸集的严格分离</strong>。令 <span class="math inline">\(C\)</span> 为闭凸集，而 <span class="math inline">\(x_0 \notin C\)</span>，那么存在将 <span class="math inline">\(x_0\)</span> 与 <span class="math inline">\(C\)</span> 严格分离的超平面。</p>
<p>为说明这一点，需要注意，对于足够小的 <span class="math inline">\(\epsilon &gt; 0\)</span>，存在两个不相交的集合
<span class="math inline">\(C\)</span> 和 <span class="math inline">\(B(x_0,
\epsilon)\)</span>。根据超平面分离定理，存在 <span class="math inline">\(a \ne 0\)</span> 和 <span class="math inline">\(b\)</span>，使得对于任意 <span class="math inline">\(x\in C\)</span> 有 <span class="math inline">\(a^\mathrm{T}x \leqslant b\)</span>；对于任意 <span class="math inline">\(x \in B(x_0, \epsilon)\)</span> 有 <span class="math inline">\(a^\mathrm{T}x \geqslant b\)</span>。</p>
<p>利用 <span class="math inline">\(B(x_0, \epsilon) = \{ x_0 + u\mid
\|u\|_2 \leqslant \epsilon \}\)</span>，可以将前述第二个条件表示为</p>
<p><span class="math display">\[
a^\mathrm{T}(x_0 + u) \geqslant b\ 对于所有\ \|u\|_2 \leqslant \epsilon
\]</span></p>
<p><span class="math inline">\(u = -\epsilon a / \|a\|_2\)</span>
极小化了上式的左端，代入可得</p>
<p><span class="math display">\[
a^\mathrm{T}x_0 - \epsilon \| a \|_2 \geqslant b
\]</span></p>
<p>所以，仿射函数</p>
<p><span class="math display">\[
f(x) = a^\mathrm{T}x - b - \epsilon \|a\|_2/2
\]</span></p>
<p>在 <span class="math inline">\(C\)</span> 上是负的，而在 <span class="math inline">\(x_0\)</span> 点是正的。</p>
<p>由此可以得到前面已提及的事实：一个闭凸集是包含它的所有半空间的交集。事实上，令
<span class="math inline">\(C\)</span> 为闭和凸的，<span class="math inline">\(S\)</span> 为所有包含 <span class="math inline">\(C\)</span> 的半空间。显然，<span class="math inline">\(x\in C \Rightarrow x \in
S\)</span>。为证明反方向，假设存在 <span class="math inline">\(x\in
S\)</span> 并且 <span class="math inline">\(x \notin
C\)</span>。根据严格分离的结果，存在一个将 <span class="math inline">\(x\)</span> 与 <span class="math inline">\(C\)</span> 严格分离的超平面，即存在一个包含 <span class="math inline">\(C\)</span> 但不包含 <span class="math inline">\(x\)</span> 的半空间。也就是说，<span class="math inline">\(x \notin S\)</span>。</p>
</blockquote>
<h2 id="超平面分离定理的逆定理">1.3 超平面分离定理的逆定理</h2>
<p>  超平面分离定理的逆定理（即分离超平面的存在表明 <span class="math inline">\(C\)</span> 和 <span class="math inline">\(D\)</span> 不相交）是不成立的，除非在凸性之外再给
<span class="math inline">\(C\)</span> 或 <span class="math inline">\(D\)</span> 附加其他约束。</p>
<blockquote>
<p><strong>反例</strong> 考虑 <span class="math inline">\(C = D = \{0\}
\subseteq \mathbf{R}\)</span>，超平面 <span class="math inline">\(x=0\)</span> 可以分离 <span class="math inline">\(C\)</span> 和 <span class="math inline">\(D\)</span>。</p>
</blockquote>
<p>  通过给 <span class="math inline">\(C\)</span> 和 <span class="math inline">\(D\)</span>
增加一些条件，可以得到超平面分离定理的多种逆定理。</p>
<blockquote>
<p><strong>举例</strong> 设 <span class="math inline">\(C\)</span> 和
<span class="math inline">\(D\)</span> 是凸集，<span class="math inline">\(C\)</span> 是开集，如果存在一个仿射函数 <span class="math inline">\(f\)</span>，它在 <span class="math inline">\(C\)</span> 中非正而在 <span class="math inline">\(D\)</span> 中非负，那么 <span class="math inline">\(C\)</span> 和 <span class="math inline">\(D\)</span> 不相交。（为说明此结论，首先可知 <span class="math inline">\(f\)</span> 在 <span class="math inline">\(C\)</span> 上是负的。否则，如果 <span class="math inline">\(f\)</span> 在 <span class="math inline">\(C\)</span> 中的某一点为零，那么 <span class="math inline">\(f\)</span>
在这个点附近会取得正值，这与前述矛盾。因此 <span class="math inline">\(C\)</span> 和 <span class="math inline">\(D\)</span> 一定是不相交的，因为 <span class="math inline">\(f\)</span> 在 <span class="math inline">\(C\)</span> 中为负，而在 <span class="math inline">\(D\)</span>
中非负。）将逆定理与超平面分离定理相结合，我们可以得到下面的结论：任何两个凸集
<span class="math inline">\(C\)</span> 和 <span class="math inline">\(D\)</span>，如果其中至少有一个是开集，那么当且仅当存在分离超平面时，它们不相交。</p>
</blockquote>
<blockquote>
<p><strong>举例</strong> <strong>严格线性不等式的择一定理</strong>。我们导出严格线性不等式</p>
<p><span class="math display">\[\begin{equation}\label{StrictLinearInequality}
  Ax \prec b
\end{equation}\]</span></p>
<p>有解的充要条件。该不等式不可行的充要条件是（凸）集</p>
<p><span class="math display">\[
C = \{ b = Ax\mid x \in \mathbf{R}^n\},\qquad D = \mathbf{R}^m_{++} = \{
y \in \mathbf{R}^m\mid y \succ 0 \}
\]</span></p>
<p>不相交。集合 <span class="math inline">\(D\)</span> 是开集，而 <span class="math inline">\(C\)</span> 是仿射集合。根据前述的结论，<span class="math inline">\(C\)</span> 和 <span class="math inline">\(D\)</span>
不相交的充要条件是，存在分离超平面，即存在非零的 <span class="math inline">\(\lambda \in \mathbf{R}^m\)</span> 和 <span class="math inline">\(\mu \in \mathbf{R}\)</span> 使得 <span class="math inline">\(C\)</span> 中 <span class="math inline">\(\lambda^\mathrm{T}y \leqslant \mu\)</span> 而
<span class="math inline">\(D\)</span> 中 <span class="math inline">\(\lambda^\mathrm{T}y \geqslant \mu\)</span>。</p>
<p>这些条件可以被简化。第一个条件意味着对于所有 <span class="math inline">\(x\)</span> 都有 <span class="math inline">\(\lambda^TT (b - Ax) \leqslant \mu\)</span>。这表明
<span class="math inline">\(A^\mathrm{T}\lambda = 0\)</span>，<span class="math inline">\(\lambda^\mathrm{T}b \leqslant
\mu\)</span>。第二个不等式意味着 <span class="math inline">\(\lambda^\mathrm{T}y \geqslant \mu\)</span>
对于所有 <span class="math inline">\(y \succ 0\)</span> 均成立。这表明
<span class="math inline">\(\mu \leqslant 0\)</span> 且 <span class="math inline">\(\lambda \preceq 0\)</span>，<span class="math inline">\(\lambda\ne 0\)</span>。</p>
<p>将这些结果放在一起，我们可以得知严格不等式组 <span class="math inline">\(\eqref{StrictLinearInequality}\)</span>
无解的充要条件是存在 <span class="math inline">\(\lambda \in
\mathbf{R}^m\)</span> 使得</p>
<p><span class="math display">\[\begin{equation}\label{IFFCondition}
  \lambda = 0,\qquad \lambda\succeq 0,\qquad A^\mathrm{T}\lambda =
0,\qquad \lambda^\mathrm{T}b \leqslant 0
\end{equation}\]</span></p>
<p>这些不等式和等式关于 <span class="math inline">\(\lambda\in\mathbf{R}^m\)</span>
也是线性的。我们称式 <span class="math inline">\(\eqref{StrictLinearInequality}\)</span> 和式 <span class="math inline">\(\eqref{IFFCondition}\)</span>
构成一对<strong>择一选择</strong>（alternatives）：对于任意的 <span class="math inline">\(A\)</span> 和 <span class="math inline">\(b\)</span>，两者中仅有一组有解。</p>
</blockquote>
<h1 id="支撑超平面">2. 支撑超平面</h1>
<p>  设 <span class="math inline">\(C \subseteq \mathbf{R}^n\)</span> 而
<span class="math inline">\(x_0\)</span> 是其边界 <span class="math inline">\(\mathop{\bf bd}C\)</span> 上的一点，即</p>
<p><span class="math display">\[
x_0 \in \mathop{\bf bd}C = \mathop{\bf cl}C\ \backslash\ \mathop{\bf
int}C
\]</span></p>
<p>如果 <span class="math inline">\(a \ne 0\)</span>，并且对任意 <span class="math inline">\(x \in C\)</span> 满足 <span class="math inline">\(a^\mathrm{T}x \leqslant
a^\mathrm{T}x_0\)</span>，那么称超平面 <span class="math inline">\(\{
x\mid a^\mathrm{T}x = a^\mathrm{T}x_0 \}\)</span> 为集合 <span class="math inline">\(C\)</span> 在点 <span class="math inline">\(x_0\)</span>
处的<strong>支撑超平面</strong>（<em>supporting
hyperplane</em>）。这等于说点 <span class="math inline">\(x_0\)</span>
与集合 <span class="math inline">\(C\)</span> 被超平面 <span class="math inline">\(\{ x\mid a^\mathrm{T}x = a^\mathrm{T}x_0
\}\)</span> 所分离。其几何解释是超平面 <span class="math inline">\(\{
x\mid a^\mathrm{T}x = a^\mathrm{T}x_0 \}\)</span> 与 <span class="math inline">\(C\)</span> 相切于点 <span class="math inline">\(x_0\)</span>，而且半空间 <span class="math inline">\(\{ x\mid a^\mathrm{T}x \leqslant a^\mathrm{T}x_0
\}\)</span> 包含 <span class="math inline">\(C\)</span>，如<a href="#图21">图 21</a>。</p>
<p><a id="图21"></a></p>
<figure>
<img data-src="../images/post/2024-06-12-josh-cvx-1-5/2024-06-12-josh-cvx-1-5-210-SupportingHyperplane.png" width="400" alt="图 21. 超平面 \{ x\mid a^\mathrm{T}x = a^\mathrm{T}x_0 \} 在 x_0 处支撑 C。">
<figcaption aria-hidden="true">图 21. 超平面 <span class="math inline">\(\{ x\mid a^\mathrm{T}x = a^\mathrm{T}x_0
\}\)</span> 在 <span class="math inline">\(x_0\)</span> 处支撑 <span class="math inline">\(C\)</span>。</figcaption>
</figure>
<p>  一个基本的结论，称为<strong>支撑超平面定理</strong>（<em>supporting
hyperplane theorem</em>），表明对于任意非空的凸集 <span class="math inline">\(C\)</span> 和任意 <span class="math inline">\(x_0
\in \mathop{\bf bd}C\)</span>，在 <span class="math inline">\(x_0\)</span> 处存在 <span class="math inline">\(C\)</span>
的支撑超平面。支撑超平面定理从超平面分离定理很容易得到证明。需要区分两种情况。如果
<span class="math inline">\(C\)</span> 的内部非空，对于 <span class="math inline">\(\{x_0\}\)</span> 和 <span class="math inline">\(\mathop{\bf int}C\)</span>
应用超平面分离定理可以直接得到所需的结论。如果 <span class="math inline">\(C\)</span> 的内部是空集，则 <span class="math inline">\(C\)</span> 必处于小于 <span class="math inline">\(n\)</span>
维的一个仿射集合中，并且任意包含这个仿射集合的超平面一定包含 <span class="math inline">\(C\)</span> 和 <span class="math inline">\(x_0\)</span>，这是一个（平凡的）支撑超平面。</p>
<p>  支撑超平面定理也有一个不完全的逆定理：如果一个集合是闭的，具有非空内部，并且其边界上每个点均存在支撑超平面，那么它是凸的。</p>
<h1 id="参考文献">参考文献</h1>
<ol type="1">
<li>Stephen P. Boyd and Lieven Vandenberghe, <em>Convex
optimization</em>. Cambridge, UK: Cambridge University Press, 2004.</li>
<li>Stephen P. Boyd and Lieven Vandenberghe, <em>凸优化</em>. 北京:
清华大学出版社, 2013.</li>
</ol>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/css/markmap.css">

<script src="/js/markmap.js"></script>
]]></content>
      <categories>
        <category>Josh 的学习笔记</category>
        <category>凸优化</category>
        <category>凸集</category>
        <category>数学</category>
        <category>凸优化</category>
      </categories>
      <tags>
        <tag>凸优化</tag>
        <tag>凸集</tag>
      </tags>
  </entry>
  <entry>
    <title>Josh&#39;s Note — 凸优化&lt;br&gt;Part 1.6 凸集—对偶锥与广义不等式</title>
    <url>/posts/b2aac0f7.html</url>
    <content><![CDATA[<h1 id="对偶锥">1. 对偶锥</h1>
<p>$ $  令 <span class="math inline">\(K\)</span> 为一个锥。集合</p>
<p><span class="math display">\[\begin{equation}
  K^\ast = \{ y\mid x^\mathrm{T}y \geqslant 0,\ \forall x \in K \}
\end{equation}\]</span></p>
<p>称为 K 的<strong>对偶锥</strong>（<em>dual
cone</em>）。顾名思义，<span class="math inline">\(K^\ast\)</span>
是一个锥，并且它总是凸的，即使 <span class="math inline">\(K\)</span>
不是凸锥。</p>
<p>  从几何上看，<span class="math inline">\(y \in K^\ast\)</span>
当且仅当 <span class="math inline">\(-y\)</span> 是 <span class="math inline">\(K\)</span> 在原点的一个支撑超平面的法线，如<a href="#图22">图 22</a> 所示。</p>
<p><a id="图22"></a></p>
<figure>
<img data-src="../images/post/2024-06-13-josh-cvx-1-6/2024-06-13-josh-cvx-1-6-220-DualCone.png" width="600" alt="图 22. 左：以 y 为内法向量的半空间包含锥 K，因此，y \in K^\ast。右：以 z 为内法向量的半空间不包含 K，因此，z \notin K^\ast。">
<figcaption aria-hidden="true">图 22. <strong>左</strong>：以 <span class="math inline">\(y\)</span> 为内法向量的半空间包含锥 <span class="math inline">\(K\)</span>，因此，<span class="math inline">\(y
\in K^\ast\)</span>。<strong>右</strong>：以 <span class="math inline">\(z\)</span> 为内法向量的半空间不包含 <span class="math inline">\(K\)</span>，因此，<span class="math inline">\(z
\notin K^\ast\)</span>。</figcaption>
</figure>
<blockquote>
<p><strong>举例</strong> <strong>子空间</strong>。子空间 <span class="math inline">\(V \subseteq
\mathbf{R}^n\)</span>（这是一个锥）的对偶锥是其正交补 <span class="math inline">\(V^\perp = \{y\mid y^\mathrm{T}v = 0,\ \forall v
\in V\}\)</span>。</p>
</blockquote>
<span id="more"></span>
<blockquote>
<p><strong>举例</strong> <strong>非负象限</strong>。锥 <span class="math inline">\(\mathbf{R}^n_+\)</span> 的对偶是它本身：</p>
<p><span class="math display">\[
y^\mathrm{T}x \geqslant 0,\ \forall x \succeq 0 \Longleftrightarrow y
\succeq 0
\]</span></p>
<p>称这种锥<strong>自对偶</strong>（<em>self-dual</em>）。</p>
</blockquote>
<blockquote>
<p><strong>举例</strong> <strong>半正定锥</strong>。在 <span class="math inline">\(n \times n\)</span> 对称矩阵的集合 <span class="math inline">\(\mathbf{S}^n\)</span> 上，其标准内积 <span class="math inline">\(\mathop{\bf tr}(XY) =
\displaystyle\sum_{i,j=1}^{n} X_{ij}Y_{ij}\)</span>。半正定锥 <span class="math inline">\(\mathbf{S}^n_+\)</span> 是自对偶的，即对于任意的
<span class="math inline">\(X,Y\in\mathbf{S}^n\)</span></p>
<p><span class="math display">\[
\mathop{\bf tr}(XY) \geqslant 0,\ \forall X \succeq 0
\Longleftrightarrow Y \succeq 0
\]</span></p>
<p>下面说明这一结论。</p>
<blockquote>
<p><strong>证明</strong> 假设 <span class="math inline">\(Y \notin
\mathbf{S}^n_+\)</span>，那么存在 <span class="math inline">\(q \in
\mathbf{R}^n\)</span> 并且</p>
<p><span class="math display">\[
q^\mathrm{T}Yq = \mathop{\bf tr}(qq^\mathrm{T}Y) &lt; 0
\]</span></p>
<p>于是半正定矩阵 <span class="math inline">\(X = qq^\mathrm{T}\)</span>
满足 <span class="math inline">\(\mathop{\bf tr}(XY) &lt;
0\)</span>，由此可知 <span class="math inline">\(Y \notin
(\mathbf{S}^n_+)^\ast\)</span>。</p>
<p>假设 <span class="math inline">\(X,Y\in\mathbf{S}^n_+\)</span>，可以利用特征值分解将
<span class="math inline">\(X\)</span> 表述为 <span class="math inline">\(X = \displaystyle\sum_{i=1}^n \lambda_i q_i
q_i^\mathrm{T}\)</span>，其中（特征值）<span class="math inline">\(\lambda_i \geqslant 0,\ i =
1,\cdots,n\)</span>。于是有</p>
<p><span class="math display">\[
\mathop{\bf tr}(XY) = \mathop{\bf tr}\left( Y \sum_{i=1}^n \lambda_i q_i
q_i^\mathrm{T}\right) = \sum_{i=1}^n \lambda_i q^\mathrm{T}Y q_i
\geqslant 0
\]</span></p>
<p>以上表明 <span class="math inline">\(Y \in
(\mathbf{S}^n_+)^\ast\)</span>。</p>
</blockquote>
</blockquote>
<blockquote>
<p><strong>举例</strong> <strong>范数锥的对偶</strong>。令 <span class="math inline">\(\|\cdot\|\)</span> 为定义在 <span class="math inline">\(\mathbf{R}^n\)</span> 上的范数。与之相关的锥 <span class="math inline">\(K = \{ (x,t) \in \mathbf{R}^{n+1}\mid
\|x\|\leqslant t \}\)</span> 的对偶锥由其对偶范数定义，</p>
<p><span class="math display">\[
K^\ast = \{(u,v) \in \mathbf{R}^{n+1}\mid \|u\|_\ast \leqslant v\}
\]</span></p>
<p>这里的对偶范数由 <span class="math inline">\(\|u\|_\ast =
\sup\{u^\mathrm{T}x\mid \| x \|\leqslant 1\}\)</span> 给出。</p>
<p>为证明这个结论，我们需要说明</p>
<p><span class="math display">\[\begin{equation}\label{DualOfNormCone}
  x^\mathrm{T}u + tv \geqslant 0\ 只要\ \|x\|\leqslant t
\Longleftrightarrow \|u\|_\ast \leqslant v
\end{equation}\]</span></p>
<blockquote>
<p><strong>证明</strong> 首先，证明由右端关于 <span class="math inline">\((u,v)\)</span> 的条件可以得出左端的条件。设 <span class="math inline">\(\|u\|_\ast \leqslant v\)</span>，并且对于一些
<span class="math inline">\(t&gt;0\)</span> 有 <span class="math inline">\(\|x\| \leqslant t\)</span>。（如果 <span class="math inline">\(t = 0\)</span>，<span class="math inline">\(x\)</span> 必须是零，因此显然有 <span class="math inline">\(u^\mathrm{T}x + vt \geqslant
0\)</span>。）根据对偶锥的定义以及 <span class="math inline">\(\|-x/t\|\leqslant 1\)</span>，我们有</p>
<p><span class="math display">\[
u^\mathrm{T}(-x/t) \leqslant \|u\|_\ast \leqslant v
\]</span></p>
<p>因此，<span class="math inline">\(u^\mathrm{T}x + vt \geqslant
0\)</span>。</p>
<p>其次，我们证明 <span class="math inline">\(\eqref{DualOfNormCone}\)</span> 左端的条件可以导出
<span class="math inline">\(\eqref{DualOfNormCone}\)</span>
右端的条件。假设 <span class="math inline">\(\|u\|_\ast&gt;
v\)</span>，即右端不成立。那么，根据对偶锥的定义，存在 <span class="math inline">\(x\)</span> 满足 <span class="math inline">\(\|x\|\leqslant 1\)</span> 及 <span class="math inline">\(x^\mathrm{T}u &gt; v\)</span>。取 <span class="math inline">\(t=1\)</span>，我们有</p>
<p><span class="math display">\[
u^\mathrm{T}(-x) + v &lt; 0
\]</span></p>
<p>这与 <span class="math inline">\(\eqref{DualOfNormCone}\)</span>
的左端相矛盾。</p>
</blockquote>
</blockquote>
<p>  对偶锥满足一些性质，例如</p>
<ul>
<li><span class="math inline">\(K^\ast\)</span> 是闭凸锥。</li>
<li><span class="math inline">\(K_1 \subseteq K_2\)</span> 可导出 <span class="math inline">\(K_2^\ast \subseteq K_1^\ast\)</span>。</li>
<li>如果 <span class="math inline">\(K\)</span> 有非空内部，那么 <span class="math inline">\(K^\ast\)</span> 是尖的。</li>
<li>如果 <span class="math inline">\(K\)</span> 的闭包是尖的，那么 <span class="math inline">\(K^\ast\)</span> 有非空内部。</li>
<li><span class="math inline">\(K^{\ast\ast}\)</span> 是 <span class="math inline">\(K\)</span> 的凸包的闭包。（因此，如果 <span class="math inline">\(K\)</span> 是凸和闭的，则 <span class="math inline">\(K^{\ast\ast} = K\)</span>。）这些性质表明如果
<span class="math inline">\(K\)</span> 是一个正常锥，那么它的对偶 <span class="math inline">\(K^\ast\)</span> 也是，进一步地，有 <span class="math inline">\(K^{\ast\ast} = K\)</span>。</li>
</ul>
<h1 id="广义不等式的对偶">2. 广义不等式的对偶</h1>
<p>  现在假设凸锥 <span class="math inline">\(K\)</span>
是正常锥，因此它可以导出一个广义不等式 <span class="math inline">\(\preceq_K\)</span>。其对偶锥 <span class="math inline">\(K^\ast\)</span>
也是正常的，所以也能导出一个广义不等式。我们称广义不等式立 <span class="math inline">\(\preceq_{K^\ast}\)</span> 为广义不等式 <span class="math inline">\(\preceq_K\)</span>
的<strong>对偶</strong>（<em>dual</em>）。</p>
<p>  关于广义不等式及其对偶有一些重要的性质</p>
<ul>
<li><span class="math inline">\(x \preceq_K y\)</span> 当且仅当对于任意
<span class="math inline">\(\lambda \succeq_{K^\ast}\)</span>，有 <span class="math inline">\(\lambda^\mathrm{T}x \leqslant
\lambda^\mathrm{T}y\)</span>。</li>
<li><span class="math inline">\(x \prec_K y\)</span> 当且仅当对于任意
<span class="math inline">\(\lambda \succeq_{K^\ast}\)</span> 和 <span class="math inline">\(\lambda\ne 0\)</span>，有 <span class="math inline">\(\lambda^\mathrm{T}T x &lt;
\lambda^\mathrm{T}y\)</span>。</li>
</ul>
<p>  因为 <span class="math inline">\(K = K^{\ast\ast}\)</span>，与
<span class="math inline">\(\preceq_{K^\ast}\)</span>
相关的对偶广义不等式为 <span class="math inline">\(\preceq_{K}\)</span>，因此交换广义不等式及其对偶后，这些性质依然成立。作为一个具体的例子，我们可知
<span class="math inline">\(\lambda\preceq_{K^\ast} \mu\)</span>
的充要条件是对于所有 <span class="math inline">\(x \succeq_K 0\)</span>
有 <span class="math inline">\(\lambda^\mathrm{T}x \leqslant
\mu^\mathrm{T}x\)</span>。</p>
<blockquote>
<p><strong>举例</strong> <strong>线性严格广义不等式的择一定理</strong>。设
<span class="math inline">\(K \subseteq \mathbf{R}^m\)</span>
为正常锥。考虑严格广义不等式</p>
<p><span class="math display">\[\begin{equation}\label{StrictGeneralInequality}
  Ax \prec_K b
\end{equation}\]</span></p>
<p>其中 <span class="math inline">\(x \in \mathbf{R}^n\)</span></p>
<p>下面推导对于这个不等式的择一定理。假设它是不可行的，即仿射集合 <span class="math inline">\(\{b-Ax\mid x\in\mathbf{R}^n\}\)</span> 与开凸集
<span class="math inline">\(\mathop{\bf int}K\)</span>
不相交。那么存在一个分离超平面，即非零的 <span class="math inline">\(\lambda\in\mathbf{R}^m\)</span> 和 <span class="math inline">\(\mu\in \mathbf{R}\)</span> 使得对于任意 <span class="math inline">\(x\)</span> 有灯 <span class="math inline">\(\lambda^\mathrm{T}(b-Ax) \leqslant
\mu\)</span>，对于任意 <span class="math inline">\(y \in \mathop{\bf
int}K\)</span> 有 <span class="math inline">\(\lambda^\mathrm{T}y
\geqslant \mu\)</span>。第一个条件表明 <span class="math inline">\(A^\mathrm{T}\lambda = 0\)</span> 及 <span class="math inline">\(\lambda^\mathrm{T}b \leqslant
\mu\)</span>。第二个条件表明对于任意 <span class="math inline">\(y\in
K\)</span> 有 <span class="math inline">\(\lambda^\mathrm{T}y \geqslant
\mu\)</span>，这种情况仅当 <span class="math inline">\(\lambda \in
K^\ast\)</span> 和 <span class="math inline">\(\mu \leqslant 0\)</span>
时才可能发生。</p>
<p>综上，我们可知当 <span class="math inline">\(\eqref{StrictGeneralInequality}\)</span>
不可行时，存在 <span class="math inline">\(\lambda\)</span> 使得</p>
<p><span class="math display">\[\begin{equation}\label{StrictGeneralInequalityInfeasible}
\lambda \ne 0,\qquad \lambda \preceq_{K^\ast} 0,\qquad
A^\mathrm{T}\lambda = 0,\qquad \lambda^\mathrm{T}b \leqslant 0
\end{equation}\]</span></p>
<p>现在我们证明反方向，即如果 <span class="math inline">\(\eqref{StrictGeneralInequalityInfeasible}\)</span>
成立，那么，不等式组 <span class="math inline">\(\eqref{StrictGeneralInequality}\)</span>
不可能可行。假设不等式均成立，因为 <span class="math inline">\(\lambda\ne 0\)</span>，<span class="math inline">\(\lambda \succeq_{K^\ast}\)</span> 及 <span class="math inline">\(b - Ax \succ_K 0\)</span>，我们有 <span class="math inline">\(\lambda^\mathrm{T}(b-Ax)&gt;0\)</span>。但是根据
<span class="math inline">\(A^\mathrm{T}\lambda =
0\)</span>，我们可以找到 <span class="math inline">\(\lambda^\mathrm{T}(b-Ax) = \lambda^\mathrm{T}b
\leqslant 0\)</span>，而这是一个矛盾。</p>
<p>因此，不等式组 <span class="math inline">\(\eqref{StrictGeneralInequality}\)</span> 和 <span class="math inline">\(\eqref{StrictGeneralInequalityInfeasible}\)</span>
构成一对择一：对于任意 <span class="math inline">\(A,
b\)</span>，它们中仅有一个是可行的。（这是严格线性不等式的择一定理的推广；严格线性不等式的择一定理是
<span class="math inline">\(K = \mathbf{R}^m_+\)</span>
时的特殊情况。）</p>
</blockquote>
<h1 id="对偶不等式定义的最小元和极小元">3.
对偶不等式定义的最小元和极小元</h1>
<p>  可以利用对偶广义不等式来刻画集合 <span class="math inline">\(S\subseteq\mathbf{R}^m\)</span>（可能非凸）关于正常锥
<span class="math inline">\(K\)</span>
导出的广义不等式的最小元和极小元。</p>
<h2 id="最小元的对偶性质">3.1 最小元的对偶性质</h2>
<p>  首先考虑<strong>最小</strong>（<em>minimum</em>）元的性质。<span class="math inline">\(x\)</span> 是 <span class="math inline">\(S\)</span> 上关于广义不等式 <span class="math inline">\(\preceq _K\)</span> 的最小元的充要条件是，对于所有
<span class="math inline">\(\lambda\succ_{K^*}0\)</span>，<span class="math inline">\(x\)</span> 是在 <span class="math inline">\(z\in
S\)</span> 上极小化 <span class="math inline">\(\lambda^\mathrm{T}z\)</span>
的唯一最优解。几何上看，这意味着对于任意 <span class="math inline">\(\lambda\succ_{K^*}0\)</span>，超平面</p>
<p><span class="math display">\[
\{z\mid \lambda^\mathrm{T}(z-x)=0\}
\]</span></p>
<p>是在 <span class="math inline">\(x\)</span> 处对 <span class="math inline">\(S\)</span>
的一个严格支撑超平面。（用严格支撑超平面表明这个超平面与 <span class="math inline">\(S\)</span> 只相交于 <span class="math inline">\(x\)</span>。）注意此处并不要求 <span class="math inline">\(S\)</span> 是凸集。这可由<a href="#图23">图
23</a>来表示。</p>
<p><a id="图23"></a></p>
<figure>
<img data-src="../images/post/2024-06-13-josh-cvx-1-6/2024-06-13-josh-cvx-1-6-230-DualCharacterizationOfMinimumElement.png" width="400" alt="图 23. 最小元的对偶性质。点 x 是集合 S 中关于 \mathbf{R}_+^2 的极小元。这等价于：对于任意 \lambda\succ0，超平面 \{z\mid\lambda^\mathrm{T}(z-x)=0\} 在 x 处对 S 严格支撑，即在超平面的一边包含了 S，并只在 x 处与 S 接触。">
<figcaption aria-hidden="true">图 23. 最小元的对偶性质。点 <span class="math inline">\(x\)</span> 是集合 <span class="math inline">\(S\)</span> 中关于 <span class="math inline">\(\mathbf{R}_+^2\)</span>
的极小元。这等价于：对于任意 <span class="math inline">\(\lambda\succ0\)</span>，超平面 <span class="math inline">\(\{z\mid\lambda^\mathrm{T}(z-x)=0\}\)</span> 在
<span class="math inline">\(x\)</span> 处对 <span class="math inline">\(S\)</span> 严格支撑，即在超平面的一边包含了 <span class="math inline">\(S\)</span>，并只在 <span class="math inline">\(x\)</span> 处与 <span class="math inline">\(S\)</span> 接触。</figcaption>
</figure>
<p>  为说明这个结论，设 <span class="math inline">\(x\)</span> 是 <span class="math inline">\(S\)</span> 的最小元，即对于任意 <span class="math inline">\(z\in S\)</span> 有 <span class="math inline">\(x\preceq_Kz\)</span>，同时，令 <span class="math inline">\(\lambda\succ_{K^*} 0\)</span>，而<span class="math inline">\(z\in S\)</span>，<span class="math inline">\(z\neq
x\)</span>。因为 <span class="math inline">\(x\)</span> 是 <span class="math inline">\(S\)</span> 上的最小元，所以有 <span class="math inline">\(z-x\succeq_K0\)</span>。根据 <span class="math inline">\(\lambda\succ_{K^*}0\)</span> 及 <span class="math inline">\(z-x\succeq_K0\)</span>，<span class="math inline">\(z-x\neq0\)</span>，可以得到 <span class="math inline">\(\lambda^\mathrm{T}(z-x)&gt;0\)</span>。因为 <span class="math inline">\(z\)</span> 是 <span class="math inline">\(S\)</span> 上任意一个不等于 <span class="math inline">\(x\)</span> 的元素，所以 <span class="math inline">\(x\)</span> 是在 <span class="math inline">\(z\in
S\)</span> 上极小化 <span class="math inline">\(\lambda^\mathrm{T}z\)</span>
的唯一解。反之，假设对于所有 <span class="math inline">\(\lambda\succ_{K^*}0\)</span>，<span class="math inline">\(x\)</span> 是 <span class="math inline">\(z\in
S\)</span> 上极小化 <span class="math inline">\(\lambda^\mathrm{T}z\)</span> 的唯一解，但 <span class="math inline">\(x\)</span> 不是 <span class="math inline">\(S\)</span> 的最小元。那么存在 <span class="math inline">\(z\in S\)</span> 满足 <span class="math inline">\(z\nsucceq_Kx\)</span>。因为 <span class="math inline">\(z-x\nsucceq_K0\)</span>，存在 <span class="math inline">\(\tilde{\lambda}\succeq_{K^*} 0\)</span> 并且 <span class="math inline">\(\tilde{\lambda}^\mathrm{T}(z-x)&lt;0\)</span>。因此，对于
<span class="math inline">\(\lambda\succ_{K^*} 0\)</span>，在 <span class="math inline">\(\tilde{\lambda}\)</span> 的邻域内有 <span class="math inline">\(\lambda^\mathrm{T}(z-x)&lt;0\)</span>。这与 <span class="math inline">\(x\)</span> 是 <span class="math inline">\(S\)</span> 上极小化 <span class="math inline">\(\lambda^\mathrm{T}z\)</span> 的唯一解相矛盾。</p>
<h2 id="极小元的对偶性质">3.2 极小元的对偶性质</h2>
<p>  现在讨论<strong>极小</strong>（<em>minimal</em>）元的类似性质。此时，在必要和充分条件间存在一定的间隙。如果
<span class="math inline">\(\lambda\succ_{K^*} 0\)</span> 并且 <span class="math inline">\(x\)</span> 在 <span class="math inline">\(z\in
S\)</span> 上极小化 <span class="math inline">\(\lambda^\mathrm{T}z\)</span>，那么 <span class="math inline">\(x\)</span> 是极小的，如<a href="#图24">图
24</a>所示。</p>
<p><a id="图24"></a></p>
<figure>
<img data-src="../images/post/2024-06-13-josh-cvx-1-6/2024-06-13-josh-cvx-1-6-240-ASetAndItsSetOfMinimalPoints.png" width="400" alt="图 24. 集合 S\subseteq\mathbf{R}^2。其关于 \mathbf{R}_+^2 的极小点集合由其边界的（左下）深色部分所示。S 上极小化 \lambda_1^\mathrm{T}z 的解为 x_1，因为 \lambda_1\succ0，所以 x_1 是极小的。S 上极小化 \lambda_2^\mathrm{T}z 的解为 x_2，因为 \lambda_2\succ0，所以它是 S 的另一个极小点。">
<figcaption aria-hidden="true">图 24. 集合 <span class="math inline">\(S\subseteq\mathbf{R}^2\)</span>。其关于 <span class="math inline">\(\mathbf{R}_+^2\)</span>
的极小点集合由其边界的（左下）深色部分所示。<span class="math inline">\(S\)</span> 上极小化 <span class="math inline">\(\lambda_1^\mathrm{T}z\)</span> 的解为 <span class="math inline">\(x_1\)</span>，因为 <span class="math inline">\(\lambda_1\succ0\)</span>，所以 <span class="math inline">\(x_1\)</span> 是极小的。<span class="math inline">\(S\)</span> 上极小化 <span class="math inline">\(\lambda_2^\mathrm{T}z\)</span> 的解为 <span class="math inline">\(x_2\)</span>，因为 <span class="math inline">\(\lambda_2\succ0\)</span>，所以它是 <span class="math inline">\(S\)</span> 的另一个极小点。</figcaption>
</figure>
<blockquote>
<p><strong>证明</strong> 假设 <span class="math inline">\(\lambda\succ_{K^*} 0\)</span> 并且 <span class="math inline">\(x\)</span> 在 <span class="math inline">\(S\)</span> 上极小化 <span class="math inline">\(\lambda^\mathrm{T}z\)</span>，但 <span class="math inline">\(x\)</span> 不是极小元，即存在 <span class="math inline">\(z\in S\)</span> 满足 <span class="math inline">\(z\neq x\)</span>，<span class="math inline">\(z\preceq_Kx\)</span>。那么 <span class="math inline">\(\lambda^\mathrm{T}(x-z)&gt;0\)</span>，这与我们的假设，即
<span class="math inline">\(x\)</span> 在 <span class="math inline">\(S\)</span> 上极小化了 <span class="math inline">\(\lambda^\mathrm{T}z\)</span>，相矛盾。</p>
</blockquote>
<p>  其逆命题在一般情况下不成立：<span class="math inline">\(S\)</span>
上的极小元 <span class="math inline">\(x\)</span> 可以对于任何 <span class="math inline">\(\lambda\)</span> 都不是 <span class="math inline">\(z\in S\)</span> 上极小化 <span class="math inline">\(\lambda^\mathrm{T}z\)</span> 的解，如<a href="#图25">图
25</a>所示。此图表明了凸性在这个逆定理中的重要作用，当凸性成立时，逆定理是成立的。假设集合
<span class="math inline">\(S\)</span> 是凸集，可以说对于任意极小元
<span class="math inline">\(x\)</span>，存在非零的 <span class="math inline">\(\lambda\succeq_{K^*} 0\)</span> 使得 <span class="math inline">\(x\)</span> 在 <span class="math inline">\(z\in
S\)</span> 上极小化 <span class="math inline">\(\lambda^\mathrm{T}z\)</span>。</p>
<p><a id="图25"></a></p>
<figure>
<img data-src="../images/post/2024-06-13-josh-cvx-1-6/2024-06-13-josh-cvx-1-6-250-MinimalElement.png" width="350" alt="图 25. 点 x 是 S\subseteq\mathbf{R}^2 关于 \mathbf{R}_+^2 的极小元。但是，不存在 \lambda，使得 x 在 z\in S 上极小化 \lambda^\mathrm{T}z">
<figcaption aria-hidden="true">图 25. 点 <span class="math inline">\(x\)</span> 是 <span class="math inline">\(S\subseteq\mathbf{R}^2\)</span> 关于 <span class="math inline">\(\mathbf{R}_+^2\)</span> 的极小元。但是，不存在
<span class="math inline">\(\lambda\)</span>，使得 <span class="math inline">\(x\)</span> 在 <span class="math inline">\(z\in
S\)</span> 上极小化 <span class="math inline">\(\lambda^\mathrm{T}z\)</span></figcaption>
</figure>
<blockquote>
<p><strong>证明</strong> 假设 <span class="math inline">\(x\)</span>
是极小的，也就是说 <span class="math inline">\(((x-K)\setminus\{x\})\cap
S=\emptyset\)</span>。对凸集 <span class="math inline">\((x-K)\setminus\{x\}\)</span> 和 <span class="math inline">\(S\)</span> 应用超平面分离定理，可以得出：存在
<span class="math inline">\(\lambda\neq0\)</span> 和 <span class="math inline">\(\mu\)</span>，使得对于所有 <span class="math inline">\(y\in K\)</span> 有 <span class="math inline">\(\lambda^\mathrm{T}(x-y)\leqslant\mu\)</span>，对于所有
<span class="math inline">\(z\in S\)</span> 有 <span class="math inline">\(\lambda^\mathrm{T}z\geqslant\mu\)</span>。根据第一个不等式，可知
<span class="math inline">\(\lambda\succeq_{K^*} 0\)</span>。由于 <span class="math inline">\(x\in S\)</span> 和 <span class="math inline">\(x\in x-K\)</span>，所以有 <span class="math inline">\(\lambda^\mathrm{T}x=\mu\)</span>，所以第二个不等式表明
<span class="math inline">\(\mu\)</span> 是 <span class="math inline">\(S\)</span> 上 <span class="math inline">\(\lambda^\mathrm{T}z\)</span> 的最小值。因此，<span class="math inline">\(x\)</span> 是 <span class="math inline">\(S\)</span> 上极小化 <span class="math inline">\(\lambda^\mathrm{T}z\)</span> 的一个解，这里 <span class="math inline">\(\lambda\neq0\)</span>，<span class="math inline">\(\lambda\succeq_{K^*}0\)</span>。</p>
</blockquote>
<p>  这个逆定理无法加强为 <span class="math inline">\(\lambda\succ_{K^*}
0\)</span>。反例表明，凸集 <span class="math inline">\(S\)</span>
上的极小元 <span class="math inline">\(x\)</span>，可以对于任意 <span class="math inline">\(\lambda\succ_{K^*}0\)</span>，都不是 <span class="math inline">\(z\in S\)</span> 中极小化 <span class="math inline">\(\lambda ^\mathrm{T}z\)</span> 的解（参见<a href="#图26">图 26，左图</a>）。同时，并不是对于任意 <span class="math inline">\(\lambda\succeq_{K^*} 0\)</span>，在 <span class="math inline">\(z\in S\)</span> 上极小化 <span class="math inline">\(\lambda^\mathrm{T}z\)</span>
的解都一定是极小的（参见<a href="#右26">图 26，左图</a>）。</p>
<p><a id="图26"></a></p>
<figure>
<img data-src="../images/post/2024-06-13-josh-cvx-1-6/2024-06-13-josh-cvx-1-6-260-MinimalAndMinimizer.png" width="700" alt="图 26. 左：点 x_1\in S_1 是极小的，但对于任意 \lambda\succ0，它都没有在 S_1 上极小化 \lambda^\mathrm{T}z。（但是，对于 \lambda=(1,0)，它确实在所有 z\in S_1中极小化了\lambda^\mathrm{T}z。）右：点 x_2\in S_2 不是极小的，但对于 \lambda=(0,1)\succeq0，它确实在所有 z\in S_2 中极小化了\lambda^\mathrm{T}z。">
<figcaption aria-hidden="true">图 26. <strong>左</strong>：点 <span class="math inline">\(x_1\in S_1\)</span> 是极小的，但对于任意 <span class="math inline">\(\lambda\succ0\)</span>，它都没有在 <span class="math inline">\(S_1\)</span> 上极小化 <span class="math inline">\(\lambda^\mathrm{T}z\)</span>。（但是，对于 <span class="math inline">\(\lambda=(1,0)\)</span>，它确实在所有 <span class="math inline">\(z\in S_1\)</span>中极小化了<span class="math inline">\(\lambda^\mathrm{T}z\)</span>。）<strong>右</strong>：点
<span class="math inline">\(x_2\in S_2\)</span> 不是极小的，但对于 <span class="math inline">\(\lambda=(0,1)\succeq0\)</span>，它确实在所有 <span class="math inline">\(z\in S_2\)</span> 中极小化了<span class="math inline">\(\lambda^\mathrm{T}z\)</span>。</figcaption>
</figure>
<h1 id="参考文献">参考文献</h1>
<ol type="1">
<li>Stephen P. Boyd and Lieven Vandenberghe, <em>Convex
optimization</em>. Cambridge, UK: Cambridge University Press, 2004.</li>
<li>Stephen P. Boyd and Lieven Vandenberghe, <em>凸优化</em>. 北京:
清华大学出版社, 2013.</li>
</ol>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/css/markmap.css">

<script src="/js/markmap.js"></script>
]]></content>
      <categories>
        <category>Josh 的学习笔记</category>
        <category>凸优化</category>
        <category>凸集</category>
        <category>数学</category>
        <category>凸优化</category>
      </categories>
      <tags>
        <tag>凸优化</tag>
        <tag>凸集</tag>
      </tags>
  </entry>
  <entry>
    <title>Josh&#39;s Note — 凸优化&lt;br&gt;Part 2.1 凸函数—基本性质和例子</title>
    <url>/posts/320f661c.html</url>
    <content><![CDATA[<h1 id="定义">1. 定义</h1>
<p>$ $  函数 <span class="math inline">\(f:\mathbf{R}^n\to\mathbf{R}\)</span>
是<strong>凸</strong>（<em>Convex</em>）的，若 <span class="math inline">\(\mathop{\bf dom}f\)</span> 是凸集，且对于任意
<span class="math inline">\(x,y\in\mathop{\bf dom}f\)</span> 和任意
<span class="math inline">\(0\leqslant\theta\leqslant1\)</span>，有</p>
<p><span class="math display">\[\begin{equation}\label{DefinitionOfConvexFunction}
  f(\theta x+(1-\theta)y)\leqslant\theta f(x)+(1-\theta)f(y)
\end{equation}\]</span></p>
<p>  从几何意义上看，上述不等式意味着点 <span class="math inline">\((x,f(x))\)</span> 和 <span class="math inline">\((y,f(y))\)</span> 之间的线段，即从 <span class="math inline">\(x\)</span> 到 <span class="math inline">\(y\)</span>
的<strong>弦</strong>（<em>chord</em>），在函数 <span class="math inline">\(f\)</span> 的图像上方（如<a href="#图1">图
1</a>所示）。称函数 <span class="math inline">\(f\)</span>
是<strong>严格凸</strong>（<em>strictly convex</em>）的，若式 <span class="math inline">\(\eqref{DefinitionOfConvexFunction}\)</span>
中的不等式当 <span class="math inline">\(x\neq y\)</span> 以及 <span class="math inline">\(0&lt;\theta&lt;1\)</span> 时严格成立。称函数 <span class="math inline">\(f\)</span>
是<strong>凹</strong>（<em>concave</em>）的，若函数 <span class="math inline">\(-f\)</span> 是凸的；称函数 <span class="math inline">\(f\)</span> 是<strong>严格凹</strong>（<em>strictly
concave</em>）的，若 <span class="math inline">\(-f\)</span>
严格凸。</p>
<p><a id="图1"></a></p>
<figure>
<img data-src="../images/post/2024-06-14-josh-cvx-2-1/2024-06-14-josh-cvx-2-1-010-ConvexFunction.png" width="400" alt="图 1. 凸函数示意图。图上任意两点之间的弦（即线段）都在函数图像之上。">
<figcaption aria-hidden="true">图 1.
凸函数示意图。图上任意两点之间的弦（即线段）都在函数图像之上。</figcaption>
</figure>
<span id="more"></span>
<p>  对于仿射函数，式 <span class="math inline">\(\eqref{DefinitionOfConvexFunction}\)</span>
始终可以取等号，因此所有的<a href="https://josh-gao.top/posts/a4a69a4f.html?#%E4%BB%BF%E5%B0%84%E5%87%BD%E6%95%B0">仿射函数</a>（包括线性函数）是既凸且凹的。反之，若某个函数是既凸又凹的，则其是仿射函数。</p>
<p>  函数是凸的，当且仅当其在与其定义域相交的任何直线上都是凸的。换言之，函数
<span class="math inline">\(f\)</span> 是凸的，当且仅当对于任意 <span class="math inline">\(x\in\mathop{\bf dom}f\)</span> 和任意向量 <span class="math inline">\(v\)</span>，函数 <span class="math inline">\(g(t)=f(x+tv)\)</span> 是凸的（其定义域为 <span class="math inline">\(\{t\mid x+tv\in\mathop{\bf
dom}f\}\)</span>）。这个性质非常有用，因为它让我们可以通过将函数限制在直线上来判断其是否是凸函数。</p>
<details class="note info"><summary><p>注解</p>
</summary>
<p>这里可能是由于翻译问题导致不是很好理解，我们先看原文：</p>
<blockquote>
<p>A function is convex if and only if it is convex when restricted to
any line that intersects its domain. In other words <span class="math inline">\(f\)</span> is convex if and only if for all <span class="math inline">\(x\in\mathbf{dom}\, f\)</span> and all <span class="math inline">\(v\)</span>, the function <span class="math inline">\(g(t) = f(x + tv)\)</span> is convex (on its
domain, <span class="math inline">\(\{t\mid x+tv\in\mathbf{dom}\,
f\}\)</span>). This property is very useful, since it allows us to check
whether a function is convex by restricting it to a line.</p>
</blockquote>
<p>仍然不是很好理解。因此询问 ChatGPT 得到如下解释：</p>
<ul>
<li><p>限制在直线上：考虑一个函数 <span class="math inline">\(f\)</span>
和其定义域内的任意一点 <span class="math inline">\(x\)</span>。再选择一个任意方向向量 <span class="math inline">\(v\)</span>。我们沿着这个方向 <span class="math inline">\(v\)</span> 从点 <span class="math inline">\(x\)</span> 出发，得到一条直线。任何点 <span class="math inline">\(x+tv\)</span>（其中 <span class="math inline">\(t\)</span>
是一个实数）都在这条直线上。这就叫做将函数限制在直线上。</p></li>
<li><p>直线上的函数：我们定义一个新的函数 <span class="math inline">\(g(t)=f(x+tv)\)</span>。这个新的函数 <span class="math inline">\(g(t)\)</span> 表示原函数 <span class="math inline">\(f\)</span> 在直线 <span class="math inline">\(x+tv\)</span> 上的值。</p></li>
<li><p>检查凸性：若对于任意 <span class="math inline">\(x\)</span> 和
<span class="math inline">\(v\)</span>，新的函数 <span class="math inline">\(g(t)\)</span> 是凸的，则我们就说原函数 <span class="math inline">\(f\)</span> 是凸的。也就是说，若 <span class="math inline">\(f\)</span> 在所有限制的直线上都是凸的，则 <span class="math inline">\(f\)</span> 本身就是凸的。</p></li>
</ul>
<p>通过限制在直线上，我们将原来的多变量问题简化为单变量问题。对于单变量函数，判断凸性要比多变量情况简单得多。这使得我们可以用更简单的方法来判断一个函数是否是凸的。</p>
<blockquote>
<p><strong>举例</strong> 假设我们有一个二次函数 <span class="math inline">\(f(x)=x_1^2+x_2^2\)</span>。我们选一个点 <span class="math inline">\(x=(a,b)\)</span> 和一个方向 <span class="math inline">\(v=(c,d)\)</span>，沿着这个方向得到直线 <span class="math inline">\((a,b)+t(c,d)\)</span>，然后我们可以定义一个新函数：</p>
<p><span class="math display">\[
g(t)=f((a,b)+t(c,d))=f(a+tc,b+td)=(a+tc)^2+(b+td)^2
\]</span></p>
<p>我们需要检查这个新函数 <span class="math inline">\(g(t)\)</span>
是否是凸的。若对所有 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(v\)</span> 新函数 <span class="math inline">\(g(t)\)</span> 都是凸的，则原函数 <span class="math inline">\(f\)</span> 就是凸的。在这个例子中，显然 <span class="math inline">\(g(t)=(a+tc)^2+(b+td)^2\)</span> 是一个关于 <span class="math inline">\(t\)</span> 的二次函数，它是凸的。因此，原函数
<span class="math inline">\(f(x)=x_1^2+x_2^2\)</span> 是凸的。</p>
</blockquote>
<p>总的来说，“将函数限制在直线上”意味着通过沿着任意方向取直线来简化判断多变量函数的凸性，从而可以更方便地确定函数的整体凸性。</p>

</details>
<p>  对凸函数的<strong>分析</strong>（<em>analysis</em>）已经相当地透彻，这里不再继续深入。例如有这样一个简单的结论，凸函数在其定义域相对内部是连续的；它只可能在相对边界上不连续。</p>
<h1 id="扩展值延伸">2. 扩展值延伸</h1>
<p>  通常可以定义凸函数在定义域外的值为 <span class="math inline">\(\infty\)</span>，从而将这个凸函数延伸至全空间
<span class="math inline">\(\mathbf{R}^n\)</span>。若 <span class="math inline">\(f\)</span>
是凸函数，我们定义它的<strong>扩展值延伸</strong>（<em>extended-value
extension</em>）<span class="math inline">\(\tilde{f}:\mathbf{R}^n\to\mathbf{R}\cup\{\infty\}\)</span>
如下 <span class="math display">\[
\tilde{f}(x)=\begin{cases}
  f(x)&amp;x\in\textbf{dom}f\\\infty&amp;x\not\in\textbf{dom}f
\end{cases}
\]</span></p>
<p>延伸函数 <span class="math inline">\(\tilde{f}\)</span>
是定义在全空间 <span class="math inline">\(\mathbf{R}^n\)</span>
上的，取值集合为 <span class="math inline">\(\mathbf{R}\cup\{\infty\}\)</span>。我们也可以从延伸函数
<span class="math inline">\(\tilde{f}\)</span> 的定义中确定原函数 <span class="math inline">\(f\)</span> 的定义域，即 <span class="math inline">\(\mathop{\bf
dom}f=\{x\mid\tilde{f}(x)&lt;\infty\}\)</span>。</p>
<p>  这种延伸可以简化符号描述，此时我们就不需要明确描述定义域或者每次提到
<span class="math inline">\(f(x)\)</span> 时都限定“对于所有的 <span class="math inline">\(x\in\mathop{\bf dom}f\)</span>”。以基本不等式
<span class="math inline">\(\eqref{DefinitionOfConvexFunction}\)</span>
为例，对于延伸函数 <span class="math inline">\(\tilde{f}\)</span>，可以描述为：对于<strong>任意</strong>（<em>any</em>）<span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span>，以及 <span class="math inline">\(0&lt;\theta&lt;1\)</span>，有</p>
<p><span class="math display">\[
\tilde{f}(\theta
x+(1-\theta)y)\leqslant\theta\tilde{f}(x)+(1-\theta)\tilde{f}(y)
\]</span></p>
<p>（当 <span class="math inline">\(\theta=0\)</span> 或 <span class="math inline">\(\theta=1\)</span>
时不等式总成立。）当然此时应当利用扩展运算和扩展序来理解这个不等式。</p>
<ul>
<li>若 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span> 在 <span class="math inline">\(\mathop{\bf dom}f\)</span>
内，上述不等式即为不等式 <span class="math inline">\(\eqref{DefinitionOfConvexFunction}\)</span>；</li>
<li>若 <span class="math inline">\(x\)</span> 或 <span class="math inline">\(y\)</span> 在 <span class="math inline">\(\mathop{\bf dom}f\)</span> 外，上述不等式的右端为
<span class="math inline">\(\infty\)</span>，不等式仍然成立。</li>
</ul>
<blockquote>
<p><strong>举例</strong> 设 <span class="math inline">\(f_1\)</span> 和
<span class="math inline">\(f_2\)</span> 是 <span class="math inline">\(\mathbf{R}^n\)</span> 上的两个凸函数。逐点和函数
<span class="math inline">\(f=f_1+f_2\)</span> 的定义域为 <span class="math inline">\(\mathop{\bf dom}f=\mathop{\bf
dom}f_1\cap\mathop{\bf dom}f_2\)</span>，对于任意 <span class="math inline">\(x\in\mathop{\bf dom}f\)</span>，有 <span class="math inline">\(f(x)=f_1(x)+f_2(x)\)</span>。利用扩展值延伸我们可以简单地描述为，对于任意
<span class="math inline">\(x\)</span>，<span class="math inline">\(\tilde{f}(x)=\tilde{f}_1(x)+\tilde{f}_2(x)\)</span>。在这个方程里，函数
<span class="math inline">\(f\)</span> 的定义域被自动定义为 <span class="math inline">\(\mathop{\bf dom}f=\mathop{\bf
dom}f_1\cap\mathop{\bf dom}f_2\)</span>，因为当 <span class="math inline">\(x\not\in\mathop{\bf dom}f_1\)</span> 或者 <span class="math inline">\(x\not\in\mathop{\bf dom}f_2\)</span> 时，<span class="math inline">\(\tilde{f}(x)=\infty\)</span>。在此例中，我们就可以利用扩展运算来自动定义定义域。</p>
</blockquote>
<p>  在不会造成歧义的情况下，可以用同样的符号来表示一个凸函数及其延伸函数。即假设所有的凸函数都隐含地被延伸了，也就是在定义域外都被定义为
<span class="math inline">\(\infty\)</span>。</p>
<blockquote>
<p><strong>举例</strong> <strong>凸集的示性函数</strong>。设 <span class="math inline">\(C\subseteq\mathbf{R}^n\)</span>
是一个凸集，考虑（凸）函数 <span class="math inline">\(I_C\)</span>，其定义域为 <span class="math inline">\(C\)</span>，对于所有的 <span class="math inline">\(x\in C\)</span>，有 <span class="math inline">\(I_C(x)=0\)</span>。换言之，此函数在集合 <span class="math inline">\(C\)</span>
上一直为零。其扩展值延伸可以描述如下</p>
<p><span class="math display">\[
\tilde{I}_C(x)=\begin{cases}0&amp;x\in C\\\infty&amp;x\not\in
C.\end{cases}
\]</span></p>
<p>凸函数 <span class="math inline">\(\tilde{I}_C\)</span> 被称作集合
<span class="math inline">\(C\)</span>
的<strong>示性函数</strong>（<em>indicator function</em>）。</p>
<p>利用示性函数 <span class="math inline">\(\tilde{I}_C\)</span>，可以更加灵活地定义符号描述。例如，对于在集合
<span class="math inline">\(C\)</span> 上极小化函数 <span class="math inline">\(f\)</span> 的问题（假设 <span class="math inline">\(f\)</span> 定义在整个 <span class="math inline">\(\mathbf{R}^n\)</span>
空间），可以给出等价的问题，即在 <span class="math inline">\(\mathbf{R}^n\)</span> 上极小化函数 <span class="math inline">\(f+\tilde{I}_C\)</span>。事实上，按照不会造成歧义的约定，函数
<span class="math inline">\(f+\tilde{I}_C\)</span> 等价于定义在集合
<span class="math inline">\(C\)</span> 上的函数 <span class="math inline">\(f\)</span>。</p>
</blockquote>
<p>  类似地，可以通过定义凹函数在定义域外都为 <span class="math inline">\(-\infty\)</span> 对其进行延伸。</p>
<h1 id="一阶条件">3. 一阶条件</h1>
<p>  假设 <span class="math inline">\(f\)</span> 可微（即其梯度 <span class="math inline">\(\nabla f\)</span> 在开集 <span class="math inline">\(\mathop{\bf dom}f\)</span> 内处处存在），则函数
<span class="math inline">\(f\)</span> 是凸函数的充要条件是 <span class="math inline">\(\mathop{\bf dom}f\)</span> 是凸集且对于任意 <span class="math inline">\(x,y\in\mathop{\bf dom}f\)</span>，下式成立</p>
<p><span class="math display">\[\begin{equation}\label{FirstOrderCondition}
  f(y)\geqslant f(x)+\nabla f(x)^\mathrm{T}(y-x)
\end{equation}\]</span></p>
<p><a href="#图2">图 2</a>
描述了上述不等式，也即沿函数上任意一点作切线，函数始终位于切线上方。</p>
<p><a id="图2"></a></p>
<figure>
<img data-src="../images/post/2024-06-14-josh-cvx-2-1/2024-06-14-josh-cvx-2-1-020-FirstOrderCondition.png" width="500" alt="图 2. 若函数 f 是凸的且可微，则对于任意 x,y\in\mathop{\bf dom}f，有 f(x)+\nabla f(x)^\mathrm{T}(y-x)\leqslant f( y)。">
<figcaption aria-hidden="true">图 2. 若函数 <span class="math inline">\(f\)</span> 是凸的且可微，则对于任意 <span class="math inline">\(x,y\in\mathop{\bf dom}f\)</span>，有 <span class="math inline">\(f(x)+\nabla f(x)^\mathrm{T}(y-x)\leqslant f(
y)\)</span>。</figcaption>
</figure>
<p>  由 <span class="math inline">\(f(x)+\nabla
f(x)^\mathrm{T}(y-x)\)</span> 得出的仿射函数 <span class="math inline">\(y\)</span> 即为函数 <span class="math inline">\(f\)</span> 在点 <span class="math inline">\(x\)</span> 附近的 Taylor 近似。不等式 <span class="math inline">\(\eqref{FirstOrderCondition}\)</span>
表明，对于一个凸函数，其一阶 Taylor
近似实质上是原函数的一个<strong>全局下估计</strong>（<em>global
underestimator</em>）。反之，若某个函数的一阶 Taylor
近似总是其全局下估计，则这个函数是凸的。</p>
<p>  不等式 <span class="math inline">\(\eqref{FirstOrderCondition}\)</span>
说明从一个凸函数的<strong>局部信息</strong>（<em>local
information</em>）（即它在某点的函数值及导数），可以得到一些<strong>全局信息</strong>（<em>global
information</em>）（如它的全局下估计）。这也许是凸函数的最重要的信息，由此可以解释凸函数以及凸优化问题的一些非常重要的性质。</p>
<blockquote>
<p><strong>举例</strong> 由不等式 <span class="math inline">\(\eqref{FirstOrderCondition}\)</span> 可以知道，若
<span class="math inline">\(\nabla f(x)=0\)</span>，则对于所有的 <span class="math inline">\(y\in\mathop{\bf dom}f\)</span>，存在 <span class="math inline">\(f(y)\geqslant f(x)\)</span>，即 <span class="math inline">\(x\)</span> 是函数 <span class="math inline">\(f\)</span> 的全局极小点。</p>
</blockquote>
<p>  严格凸性同样可以由一阶条件刻画：函数 <span class="math inline">\(f\)</span> 严格凸的充要条件是 <span class="math inline">\(\mathop{\bf dom}f\)</span> 是凸集且对于任意 <span class="math inline">\(x,y\in\mathop{\bf dom}f\)</span>，<span class="math inline">\(x\neq y\)</span>，有</p>
<p><span class="math display">\[\begin{equation}\label{StrictFirstOrderCondition}
  f(y)&gt;f(x)+\nabla f(x)^\mathrm{T}(y-x)
\end{equation}\]</span></p>
<p>  对于凹函数，亦存在与之对应的一阶条件：函数 <span class="math inline">\(f\)</span> 是凹函数的充要条件是 <span class="math inline">\(\mathop{\bf dom}f\)</span> 是凸集且对于任意 <span class="math inline">\(x,y\in\mathop{\bf dom}f\)</span>，下式成立</p>
<p><span class="math display">\[
f(y)\leqslant f(x)+\nabla f(x)^\mathrm{T}(y-x)
\]</span></p>
<h2 id="一阶凸性条件的证明">3.1 一阶凸性条件的证明</h2>
<p>  为了证明式 <span class="math inline">\(\eqref{FirstOrderCondition}\)</span>，先考虑 <span class="math inline">\(n=1\)</span> 的情况：我们证明可微函数 <span class="math inline">\(f:\mathbf{R}\to\mathbf{R}\)</span>
是凸函数的充要条件是对于 <span class="math inline">\(\mathop{\bf
dom}f\)</span> 内的任意 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span>，有</p>
<p><span class="math display">\[\begin{equation}\label{FirstOrderConditionWhenNEquals1}
  f(y)\geqslant f(x)+f'(x)(y-x)
\end{equation}\]</span></p>
<p>  首先证明必要性。假设 <span class="math inline">\(f\)</span>
是凸函数，且 <span class="math inline">\(x,y\in\mathop{\bf
dom}f\)</span>。因为 <span class="math inline">\(\mathop{\bf
dom}f\)</span> 是凸集（某个区间），对于任意 <span class="math inline">\(0&lt;t\leqslant1\)</span>，我们有 <span class="math inline">\(x+t(y-x)\in\mathop{\bf dom}f\)</span>，由函数
<span class="math inline">\(f\)</span> 的凸性可得</p>
<p><span class="math display">\[
f(x+t(y-x))\leqslant(1-t)f(x)+tf(y)
\]</span></p>
<p>将上式两端同除 <span class="math inline">\(t\)</span> 可得</p>
<p><span class="math display">\[
f(y)\geqslant f(x)+\frac{f(x+t(y-x))-f(x)}{t}
\]</span></p>
<p>令 <span class="math inline">\(t\to 0\)</span>，可以得到不等式 <span class="math inline">\(\eqref{FirstOrderConditionWhenNEquals1}\)</span>。</p>
<p>  为了证明充分性，假设对 <span class="math inline">\(\mathop{\bf
dom}f\)</span>（某个区间）内的任意 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span>，函数满足不等式 <span class="math inline">\(\eqref{FirstOrderConditionWhenNEquals1}\)</span>。选择任意
<span class="math inline">\(x\neq y\)</span>，<span class="math inline">\(0\leqslant\theta\leqslant1\)</span>，令 <span class="math inline">\(z=\theta x+(1-\theta)y\)</span>。两次应用不等式
<span class="math inline">\(\eqref{FirstOrderConditionWhenNEquals1}\)</span>
可得</p>
<p><span class="math display">\[
f(x)\geqslant f(z)+f'(z)(x-z),\quad f(y)\geqslant
f(z)+f'(z)(y-z)
\]</span></p>
<p>将第一个不等式乘以 <span class="math inline">\(\theta\)</span>，第二个不等式乘以 <span class="math inline">\(1-\theta\)</span>，并将二者相加可得</p>
<p><span class="math display">\[
\theta f(x)+(1-\theta)f(y)\geqslant f(z)
\]</span></p>
<p>从而说明了函数 <span class="math inline">\(f\)</span> 是凸的。</p>
<p>  现在来证明一般情况，即 <span class="math inline">\(f:\mathbf{R}^n\to\mathbf{R}\)</span>。设 <span class="math inline">\(x,y\in\mathbf{R}^n\)</span>，考虑过这两点的直线上的函数
<span class="math inline">\(f\)</span>，即函数 <span class="math inline">\(g(t)=f(ty+(1-t)x)\)</span>，此函数对 <span class="math inline">\(t\)</span> 求导可得 <span class="math inline">\(g'(t)=\nabla
f(ty+(1-t)x)^\mathrm{T}(y-x)\)</span>。</p>
<p>  首先假设函数 <span class="math inline">\(f\)</span> 是凸的，则函数
<span class="math inline">\(g\)</span> 是凸的，由前面的讨论可得 <span class="math inline">\(g(1)\geqslant g(0)+g'(0)\)</span>，即</p>
<p><span class="math display">\[
f(y)\geqslant f(x)+\nabla f(x)^\mathrm{T}(y-x)
\]</span></p>
<p>再假设此不等式对于任意 <span class="math inline">\(x\)</span> 和
<span class="math inline">\(y\)</span> 均成立，因此若 <span class="math inline">\(ty+(1-t)x\in\mathop{\bf dom}f\)</span> 以及 <span class="math inline">\(\tilde{t}y+(1-\tilde{t})x\in\mathop{\bf
dom}f\)</span>，有</p>
<p><span class="math display">\[
f(ty+(1-t)x)\geqslant f(\tilde{t}y+(1-\tilde{t})x)+\nabla
f(\tilde{t}y+(1-\tilde{t})x)^\mathrm{T}(y-x)(t-\tilde{t})
\]</span></p>
<p>即 <span class="math inline">\(g(t)\geqslant
g(\tilde{t})+g'(\tilde{t})(t-\tilde{t})\)</span>，说明了函数 <span class="math inline">\(g\)</span> 是凸的。</p>
<h1 id="二阶条件">4 二阶条件</h1>
<p>  现在假设函数 <span class="math inline">\(f\)</span>
二阶可微，即对于开集 <span class="math inline">\(\mathop{\bf
dom}f\)</span> 内的任意一点，它的 <strong>Hessian
矩阵</strong>或者二阶导数 <span class="math inline">\(\nabla^2f\)</span>
存在，则函数 <span class="math inline">\(f\)</span>
是凸函数的充要条件是，其 Hessian 矩阵是半正定阵：即对于所有的 <span class="math inline">\(x\in\mathop{\bf dom}f\)</span>，有</p>
<p><span class="math display">\[
\nabla^2f(x)\succeq0
\]</span></p>
<p>对于 <span class="math inline">\(\mathbf{R}\)</span>
上的函数，上式可以简化为一个简单的条件 <span class="math inline">\(f''(x)\geqslant0\)</span>（<span class="math inline">\(\mathop{\bf dom}f\)</span>
是凸的，即一个区间），此条件说明函数 <span class="math inline">\(f\)</span> 的导数是非减的。条件 <span class="math inline">\(\nabla^2f(x)\succeq0\)</span>
从几何上可以理解为函数图像在点 <span class="math inline">\(x\)</span>
处具有正（向上）的曲率。</p>
<p>  类似地，函数 <span class="math inline">\(f\)</span>
是凹函数的充要条件是，<span class="math inline">\(\mathop{\bf
dom}f\)</span> 是凸集且对于任意 <span class="math inline">\(x\in\)</span> <span class="math inline">\(\mathop{\bf dom}f\)</span>，<span class="math inline">\(\nabla ^{2}f( x)\)</span> <span class="math inline">\(\preceq\)</span>
0。严格凸的条件可以部分由二阶条件刻画。若对于任意的 <span class="math inline">\(x\in\mathop{\bf dom}f\)</span> 有 <span class="math inline">\(\nabla^2f(x)\succ0\)</span>，则函数 <span class="math inline">\(f\)</span> 严格凸。反过来则不一定成立：例如，函数
<span class="math inline">\(f:\mathbf{R}\to\mathbf{R}\)</span>，其表达式为
<span class="math inline">\(f(x)=x^4\)</span>，它是严格凸的，但是在
<span class="math inline">\(x=0\)</span> 处，二阶导数为零。</p>
<blockquote>
<p><strong>举例</strong> <strong>二次函数</strong>。考虑二次函数 <span class="math inline">\(f:\mathbf{R}^n\to\mathbf{R}\)</span>，其定义域为
<span class="math inline">\(\mathop{\bf
dom}f=\mathbf{R}^n\)</span>，其表达式为</p>
<p><span class="math display">\[
f(x)=(1/2)x^\mathrm{T}Px+q^\mathrm{T}x+r
\]</span></p>
<p>其中 <span class="math inline">\(P\in\mathbf{S}^{n}\)</span>，<span class="math inline">\(q\in\mathbf{R}^{n}\)</span>，<span class="math inline">\(r\in\mathbf{R}\)</span>。因为对于任意 <span class="math inline">\(x\)</span>，<span class="math inline">\(\nabla^2f(x)=P\)</span>，所以函数 <span class="math inline">\(f\)</span> 是凸的，当且仅当 <span class="math inline">\(P\succeq0\)</span>（<span class="math inline">\(f\)</span> 是凹的当且仅当 <span class="math inline">\(P\preceq0\)</span>）。</p>
<p>对于二次函数，严格凸比较容易表达：函数 <span class="math inline">\(f\)</span> 是严格凸的，当且仅当 <span class="math inline">\(P\succ0\)</span>（函数是严格凹的当且仅当 <span class="math inline">\(P\prec0\)</span>）。</p>
</blockquote>
<blockquote>
<p><strong>注释</strong> 在判断函数的凸性和凹性时，不管是一阶条件还是二阶条件，<span class="math inline">\(\mathop{\bf dom}f\)</span>
必须是凸集这个前提条件必须满足。例如，考虑函数 <span class="math inline">\(f(x)=1/x^2\)</span>，其定义域为 <span class="math inline">\(\mathop{\bf dom}f=\{x\in\)</span> <span class="math inline">\(\mathbf{R}\mid x\neq0\}\)</span>，对于所有 <span class="math inline">\(x\in\mathop{\bf dom}f\)</span> 均满足 <span class="math inline">\(f''(x)&gt;0\)</span>，但是函数 <span class="math inline">\(f(x)\)</span> 并不是凸函数。</p>
</blockquote>
<h1 id="例子">5. 例子</h1>
<p>  前文已经提到所有的线性函数和仿射函数均为凸函数（同时也是凹函数），并描述了凸和凹的二次函数。本节绘出更多的凸函数和凹函数的例子。</p>
<h2 id="mathbfr-上的例子"><span class="math inline">\(\mathbf{R}\)</span> 上的例子</h2>
<p>  首先考虑 <span class="math inline">\(\mathbf{R}\)</span>
上的一些函数，其自变量为 <span class="math inline">\(x\)</span>。</p>
<ul>
<li><strong>指数函数</strong>（<em>Exponential</em>）。对任意 <span class="math inline">\(a\in\mathbf{R}\)</span>，函数 <span class="math inline">\(e^{ax}\)</span> 在 <span class="math inline">\(\mathbf{R}\)</span> 上是凸的。</li>
<li><strong>幂函数</strong>（<em>Power</em>）。当 <span class="math inline">\(a\geqslant1\)</span> 或 <span class="math inline">\(a\leqslant0\)</span> 时，<span class="math inline">\(x^a\)</span> 在 <span class="math inline">\(\mathbf{R}_{++}\)</span> 上是凸函数；当 <span class="math inline">\(0\leqslant a\leqslant1\)</span> 时，<span class="math inline">\(x^a\)</span> 在 <span class="math inline">\(\mathbf{R}_{++}\)</span> 上是凹函数。</li>
<li><strong>绝对值幂函数</strong>（<em>Power of absolute
value</em>）。当 <span class="math inline">\(p\geqslant1\)</span>
时，函数 <span class="math inline">\(|x|^p\)</span> 在 <span class="math inline">\(\mathbf{R}\)</span> 上是凸函数。</li>
<li><strong>对数函数</strong>（<em>Logarithm</em>）。函数 <span class="math inline">\(\log x\)</span> 在 <span class="math inline">\(\mathbf{R}_{++}\)</span> 上是凹函数。</li>
<li><strong>负熵</strong>（<em>Negative entropy</em>）。函数 <span class="math inline">\(x\log x\)</span> 在其定义域上是凸函数。（定义域为
<span class="math inline">\(\mathbf{R}_{++}\)</span> 或者 <span class="math inline">\(\mathbf{R}_+\)</span>，当 <span class="math inline">\(x=0\)</span> 时定义函数值为 0。）</li>
</ul>
<p>  我们可以通过基本不等式 <span class="math inline">\(\eqref{DefinitionOfConvexFunction}\)</span>
或者二阶导数半正定或半负定来判断上述函数是凸的或是凹的。以函数 <span class="math inline">\(f(x)=x\log x\)</span> 为例，其导数和二阶导数为</p>
<p><span class="math display">\[
f'(x)=\log x+1,\quad f''(x)=1/x
\]</span></p>
<p>即对于 <span class="math inline">\(x&gt;0\)</span>，有 <span class="math inline">\(f''(x)&gt;0\)</span>。所以负熵函数是（严格）凸的。</p>
<h2 id="mathbfrn-上的例子"><span class="math inline">\(\mathbf{R}^n\)</span> 上的例子</h2>
<p>  下面给出 <span class="math inline">\(\mathbf{R}^n\)</span>
上的一些例子。</p>
<p><strong>范数</strong>（<em>Norm</em>）。 <span class="math inline">\(\mathbf{R}^n\)</span> 上的任意范数均为凸函数。</p>
<p><strong>最大值函数</strong>（<em>Max function</em>）。函数 <span class="math inline">\(f(x)=\max\{x_1,\cdots,x_n\}\)</span> 在 <span class="math inline">\(\mathbf{R}^n\)</span> 上是凸的。</p>
<p><strong>二次-线性分式函数</strong>（<em>Quadratic-over-linear
function</em>）。函数 <span class="math inline">\(f(x,y)=x^2/y\)</span>，其定义域为 <span class="math display">\[
\mathop{\bf dom}f= \mathbf{R} \times \mathbf{R} _{+ + }= \{ ( x, y) \in
\mathbf{R} ^{2}\mid y&gt; 0\}
\]</span> 是凸函数（如<a href="#图3">图 3</a>所示）。</p>
<p><a id="图3"></a></p>
<figure>
<img data-src="../images/post/2024-06-14-josh-cvx-2-1/2024-06-14-josh-cvx-2-1-030-QuadraticOverLinearFunction.png" width="400" alt="图 3. 函数 f(x, y) = x^2/y 的图像。">
<figcaption aria-hidden="true">图 3. 函数 <span class="math inline">\(f(x, y) = x^2/y\)</span> 的图像。</figcaption>
</figure>
<p><strong>指数和的对数</strong>（<em>Log-sum-exp</em>）。函数 <span class="math inline">\(f(x)=\log\left(e^{x_1}+\cdots+e^{x_n}\right)\)</span>
在 <span class="math inline">\(\mathbf{R}^n\)</span>上是凸函数。这个函数可以看成最大值函数的可微（实际上是解析）近似，因为对任意
<span class="math inline">\(x\)</span>，下面的不等式成立 <span class="math display">\[
\max\{x_{1},\cdots,x_{n}\}\leqslant
f(x)\leqslant\max\{x_{1},\cdots,x_{n}\}+\log n
\]</span> （第二个不等式当 <span class="math inline">\(x\)</span>
的所有分量都相等时是紧的。）<a href="#图4">图 4</a> 描述了当 <span class="math inline">\(n=2\)</span> 时 <span class="math inline">\(f\)</span> 的图像。</p>
<p><a id="图4"></a></p>
<figure>
<img data-src="../images/post/2024-06-14-josh-cvx-2-1/2024-06-14-josh-cvx-2-1-040-LogSumExo.png" width="400" alt="图 4. 函数 f(x, y) = log(e^x + e^y) 的图像。">
<figcaption aria-hidden="true">图 4. 函数 <span class="math inline">\(f(x, y) = log(e^x + e^y)\)</span>
的图像。</figcaption>
</figure>
<p><strong>几何平均</strong>（<em>Geometric
mean</em>）。几何平均函数<span class="math inline">\(f(x)=\left(\displaystyle\prod_{i=1}^n
x_i\right)^{1/n}\)</span>在定义域 <span class="math inline">\(\mathop{\bf dom}f=\mathbf{R}_{++}^n\)</span>
上是凹函数。</p>
<p><strong>对数-行列式</strong>（<em>Log-determinant</em>）。函数 <span class="math inline">\(f(X)=\log\det X\)</span> 在定义域 <span class="math inline">\(\mathop{\bf dom}f=\mathbf{S}_{++}^n\)</span>
上是凹函数。</p>
<p>  判断上述函数的凸性（或者凹性）可以有多种途径，可以直接验证不等式
<span class="math inline">\(\eqref{DefinitionOfConvexFunction}\)</span>
是否成立，亦可以验证其 Hessian
矩阵是否半正定，或者可以将函数转换到与其定义域相交的任意直线上，通过得到的单变量函数判断原函数的凸性。</p>
<p><strong>范数</strong>。若函数 <span class="math inline">\(f:\mathbf{R}^n\to\mathbf{R}\)</span> 是范数，任取
<span class="math inline">\(0\leqslant\theta\leqslant1\)</span>，有</p>
<p><span class="math display">\[
f(\theta x+(1-\theta)y)\leqslant f(\theta x)+f((1-\theta)y)=\theta
f(x)+(1-\theta)f(y)
\]</span></p>
<p>上述不等式可以由三角不等式得到，当范数满足齐次性时，上述不等式取等号。</p>
<p><strong>最大值函数</strong>。对任意 <span class="math inline">\(0\leqslant\theta\leqslant1\)</span>，函数 <span class="math inline">\(f(x)=\displaystyle\max_i x_i\)</span> 满足</p>
<p><span class="math display">\[\begin{aligned}
f(\theta x+(1-\theta)y)&amp;=\max_{i}(\theta x_{i}+(1-\theta)y_{i})
\\
&amp;\leqslant\theta\max_{i}x_{i}+(1-\theta)\max_{i}y_{i}
\\
&amp;=\theta f(x)+(1-\theta)f(y)
\end{aligned}\]</span></p>
<p><strong>二次线性分式函数</strong>。为了说明二次-线性分式函数 <span class="math inline">\(f( x, y) = x^2/ y\)</span>
是凸的，我们注意到，对于 <span class="math inline">\(y&gt;0\)</span>，有</p>
<p><span class="math display">\[
\nabla^2f(x,y)=\dfrac{2}{y^3}\left[\begin{array}{cc}
y^2&amp;-xy\\-xy&amp;x^2
\end{array}\right]=\dfrac{2}{y^3}\left[\begin{array}{c}
y\\-x
\end{array}\right]\left[\begin{array}{c}
y\\-x
\end{array}\right]^\mathrm{T}\succeq0
\]</span></p>
<p><strong>指数和的对数</strong>。指数和的对数函数的 Hessian 矩阵为</p>
<p><span class="math display">\[
\nabla^{2}f(x)=\frac{1}{(\mathbf{1}^\mathrm{T}z)^{2}}\left((\mathbf{1}^\mathrm{T}z)\mathop{\bf
diag}(z)-zz^\mathrm{T}\right)
\]</span></p>
<p>其中 <span class="math inline">\(z=(e^{x_1},\cdots,e^{x_n})\)</span>。为了说明
<span class="math inline">\(\nabla^2f(x)\succeq0\)</span>，我们证明对任意
<span class="math inline">\(v\)</span>，有 <span class="math inline">\(v^\mathrm{T}\nabla^2f(x)v\geqslant0\)</span>，即</p>
<p><span class="math display">\[
v^\mathrm{T}\nabla^{2}f(x)v=\frac{1}{(\mathbf{1}^\mathrm{T}z)^{2}}\left(\left(\sum_{i=1}^{n}z_{i}\right)\left(\sum_{i=1}^{n}v_{i}^{2}z_{i}\right)-\left(\sum_{i=1}^{n}v_{i}z_{i}\right)^{2}\right)\geqslant0
\]</span></p>
<p>上述不等式可以应用 Cauchy-Schwarz 不等式 <span class="math inline">\((a^\mathrm{T}a)(b^\mathrm{T}b)\geqslant(a^\mathrm{T}b)^2\)</span>
得到，此时向量 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 的分量为 <span class="math inline">\(a_i= v_i\sqrt {z_i}\)</span>，<span class="math inline">\(b_i= \sqrt {z_i}\)</span>。</p>
<p><strong>几何平均</strong>。类似地，我们说明，几何平均函数 <span class="math inline">\(f(x)=\left(\displaystyle\prod_{i=1}^nx_i\right)^{1/n}\)</span>
在定义域 <span class="math inline">\(\mathop{\bf
dom}f=\mathbf{R}_{++}^{n}\)</span>上是凹的。其 Hessian 矩阵 <span class="math inline">\(\nabla^2f(x)\)</span> 可以通过下面两个式子给出</p>
<p><span class="math display">\[
\frac{\partial^{2}f(x)}{\partial
x_{k}^{2}}=-(n-1)\frac{\left(\displaystyle\prod_{i=1}^{n}x_{i}\right)^{1/n}}{n^{2}x_{k}^{2}},\quad\frac{\partial^{2}f(x)}{\partial
x_{k}\partial
x_{l}}=\frac{\left(\displaystyle\prod_{i=1}^{n}x_{i}\right)^{1/n}}{n^{2}x_{k}x_{l}}\quad\forall\:k\neq
l
\]</span></p>
<p>因此 <span class="math inline">\(\nabla^2f(x)\)</span>
具有如下表达式</p>
<p><span class="math display">\[\nabla^{2}f(x)=-\frac{\displaystyle\prod_{i=1}^{n}x_{i}^{1/n}}{n^{2}}\left(n
\mathop{\bf diag}(1/x_{1}^{2},\cdots,1/x_{n}^{2})-qq^\mathrm{T}\right)
\]</span></p>
<p>其中，<span class="math inline">\(q_i=1/x_i\)</span>。我们需要证明
<span class="math inline">\(\nabla^2f(x)\preceq0\)</span>，即对于任意向量
<span class="math inline">\(v\)</span>，有</p>
<p><span class="math display">\[
v^\mathrm{T}\nabla^2f(x)v=-\frac{\displaystyle\prod_{i=1}^nx_i^{1/n}}{n^2}\left(n\sum_{i=1}^nv_i^2/x_i^2-\left(\sum_{i=1}^nv_i/x_i\right)^2\right)\leqslant0
\]</span></p>
<p>这同样可以应用 Cauchy-Schwarz 不等式 <span class="math inline">\((a^\mathrm{T}a)(b^\mathrm{T}b)\geqslant(a^\mathrm{T}b)^2\)</span>
得到，只需令向量 <span class="math inline">\(a=\mathbf{1}\)</span>，向量
<span class="math inline">\(b\)</span> 的分量 <span class="math inline">\(b_i=v_i/x_i\)</span>。</p>
<p><strong>对数-行列式</strong>。对于函数 <span class="math inline">\(f(X)=\log\det
X\)</span>，我们可以将其转化为任意直线上的单变量函数来验证它是凹的。令
<span class="math inline">\(X=Z+tV\)</span>，其中 <span class="math inline">\(Z,V\in\mathbf{S}^n\)</span>，定义 <span class="math inline">\(g(t)=f(Z+tV)\)</span>，自变量 <span class="math inline">\(t\)</span> 满足 <span class="math inline">\(Z+tV\succ0\)</span>。不失一般性，假设 <span class="math inline">\(t=0\)</span> 满足条件，即 <span class="math inline">\(Z\succ0\)</span>。我们有</p>
<p><span class="math display">\[\begin{aligned}
g(t)&amp;=\log\det(Z+tV)
\\
&amp;=\log\det(Z^{1/2}(I+tZ^{-1/2}VZ^{-1/2})Z^{1/2})
\\
&amp;=\sum_{i=1}^{n}\log(1+t\lambda_{i})+\log\det Z
\end{aligned}\]</span></p>
<p>其中 <span class="math inline">\(\lambda_1,\cdots,\lambda_n\)</span>
是矩阵 <span class="math inline">\(Z^{-1/2}VZ^{-1/2}\)</span>
的特征值。因此下式成立</p>
<p><span class="math display">\[
g'(t)=\sum_{i=1}^{n}\frac{\lambda_{i}}{1+t\lambda_{i}},\qquad
g''(t)=-\sum_{i=1}^{n}\frac{\lambda_{i}^{2}}{(1+t\lambda_{i})^{2}}
\]</span></p>
<p>因为 <span class="math inline">\(g''(t)\leqslant0\)</span>，函数 <span class="math inline">\(f\)</span> 是凹的。</p>
<h1 id="下水平集">6. 下水平集</h1>
<p>  函数 <span class="math inline">\(f: \mathbf{R} ^{n}\to
\mathbf{R}\)</span> 的 <strong><span class="math inline">\(\alpha\)</span>-下水平集</strong>（<em><span class="math inline">\(\alpha\)</span>-sublevel set</em>）定义为</p>
<p><span class="math display">\[
C_{\alpha}=\{x\in\mathop{\bf dom}f\mid f(x)\leqslant\alpha\}
\]</span></p>
<p>对于任意 <span class="math inline">\(\alpha\)</span>
值，凸函数的下水平集仍然是凸集。证明可以由凸集的定义直接得到：若 <span class="math inline">\(x,y\in C_{\alpha }\)</span>，则有 <span class="math inline">\(f( x) \leqslant \alpha\)</span>，<span class="math inline">\(f( y) \leqslant \alpha\)</span>，因此对于任意<span class="math inline">\(0\leqslant\theta\leqslant1\)</span>，<span class="math inline">\(f(\theta
x+(1-\theta)y)\leqslant\alpha\)</span>，即 <span class="math inline">\(\theta x+(1-\theta)y\in C_{\alpha}\)</span>。</p>
<p>  反过来不一定正确：某个函数的所有下水平集都是凸集，但这个函数可能不是凸函数。例如，函数
<span class="math inline">\(f(x)=-e^x\)</span> 在 <span class="math inline">\(\mathbf{R}\)</span>
上不是凸函数（实质上，它是严格凹函数），但是其所有下水平集均为凸集。</p>
<p>  若 <span class="math inline">\(f\)</span> 是凹函数，则由 <span class="math inline">\(\{x\in\mathop{\bf dom}f\mid
f(x)\geqslant\alpha\}\)</span> 定义的 <strong><span class="math inline">\(\alpha\)</span>-上水平集</strong>（<em><span class="math inline">\(\alpha\)</span>-superlevel
set</em>）也是凸集。下水平集的性质可以用来判断集合的凸性，若某个集合可以描述为一个凸函数的下水平集，或者一个凹函数的上水平集，则其是凸集。</p>
<blockquote>
<p><strong>举例</strong> 对于 <span class="math inline">\(x\in\mathbf{R}_+^n\)</span>，其几何平均和算术平均分别为</p>
<p><span class="math display">\[
G(x)=\left(\prod_{i=1}^{n}x_{i}\right)^{1/n},\qquad
A(x)=\frac{1}{n}\sum_{i=1}^{n}x_{i}
\]</span></p>
<p>（在 <span class="math inline">\(G\)</span> 中，定义 <span class="math inline">\(0^{1/n}=0\)</span>）。算术几何平均不等式为 <span class="math inline">\(G(x)\leqslant A(x)\)</span>。</p>
<p>设 <span class="math inline">\(0\leqslant\alpha\leqslant1\)</span>，考虑集合</p>
<p><span class="math display">\[
\{x\in\mathbf{R}_{+}^{n}\mid G(x)\geqslant\alpha A(x)\}
\]</span></p>
<p>即使得几何平均至少大于等于算术平均的 <span class="math inline">\(\alpha\)</span>
倍的集合。此集合是凸集，因为它是凹函数 <span class="math inline">\(G(x)=\alpha A(x)\)</span> 的 <span class="math inline">\(0\)</span>-上水平集。事实上，这个每合是正齐次的，因此它是凸锥</p>
</blockquote>
<h1 id="上境图">7. 上境图</h1>
<p>  函数 <span class="math inline">\(f:\mathbf{R}^{n}\to\mathbf{R}\)</span>
的图像定义为</p>
<p><span class="math display">\[
\{(x,f(x))\mid x\in\mathop{\bf dom}f\}
\]</span></p>
<p>它是 <span class="math inline">\(\mathbf{R}^{n+1}\)</span>
空间的子集。函数 <span class="math inline">\(f:\mathbf{R}^n\to\mathbf{R}\)</span>
的<strong>上境图</strong>（<em>epigraph</em>）定义为</p>
<p><span class="math display">\[
\mathop{\bf epi}f=\{(x,t)\mid x\in\mathop{\bf dom}f,f(x)\leqslant t\}
\]</span></p>
<p>它也是 <span class="math inline">\(\mathbf{R}^{n+1}\)</span>
空间的子集。（“Epi”是之上的意思，所以上境图的英文 epigraph
是“在函数图像之上”的意思。）<a href="#图5">图
5</a>说明了上境图的定义。</p>
<p><a id="图5"></a></p>
<figure>
<img data-src="../images/post/2024-06-14-josh-cvx-2-1/2024-06-14-josh-cvx-2-1-050-EpigraphOfF.png" width="400" alt="图 5. 函数 f 的上境图，见阴影部分。深颜色的下边界是函数 f 的图像。">
<figcaption aria-hidden="true">图 5. 函数 <span class="math inline">\(f\)</span>
的上境图，见阴影部分。深颜色的下边界是函数 <span class="math inline">\(f\)</span> 的图像。</figcaption>
</figure>
<p>  凸集和凸函数的联系可以通过上境图来建立：一个函数是凸函数，当且仅当其上境图是凸集。一个函数是凹函数，当且仅当其<strong>亚图</strong>（<em>hypograph</em>）</p>
<p><span class="math display">\[
\mathop{\bf hypo}f=\{(x,t)\mid t\leqslant f(x)\},
\]</span></p>
<p>是凸集。</p>
<blockquote>
<p><strong>举例</strong> <strong>矩阵分式函数</strong>。矩阵分式函数
<span class="math inline">\(f:\mathbf{R}^n\times\mathbf{S}^n\to\mathbf{R}\)</span></p>
<p><span class="math display">\[
f(x,Y)=x^\mathrm{T}Y^{-1}x
\]</span></p>
<p>在定义域 <span class="math inline">\(\mathop{\bf
dom}f=\mathbf{R}^n\times\mathbf{S}_{++}^n\)</span>
上是凸的。（这实质上是定义域为 <span class="math inline">\(\mathop{\bf
dom}f=\mathbf{R}\times\mathbf{R}_{++}\)</span> 的二次-线性分式函数 <span class="math inline">\(f(x,y)=x^2/y\)</span> 的一个扩展。）</p>
<p>一个简单的方式来验证矩阵分式函数 <span class="math inline">\(f\)</span> 的凸性是通过其上境图</p>
<p><span class="math display">\[\begin{aligned}
  \mathop{\bf epi}f &amp;= \left\{(x,Y,t)\mid Y\succ0,\
x^\mathrm{T}Y^{-1}x\leqslant t\right\}
  \\
  &amp;=\left\{(x,Y,t)\:\middle|\left[\begin{array}{cc}
    Y&amp;x
    \\
    x^\mathrm{T}&amp;t
  \end{array}\right]\succeq0,\:Y\succ0\right\}
\end{aligned}\]</span></p>
<p>并应用 Schur 补条件判断分块矩阵的半正定性。最后一个条件是关于 <span class="math inline">\((x,Y,t)\)</span> 的线性矩阵不等式，因此 <span class="math inline">\(\mathop{\bf epi}f\)</span> 是凸集。</p>
<p>对于 <span class="math inline">\(n=1\)</span>
的特殊情况，矩阵分式函数简化为二次-线性分式函数 <span class="math inline">\(x^2/y\)</span>，相应的线性矩阵不等式表示为 <span class="math display">\[
\left[\begin{array}{cc}y&amp;x\\x&amp;t\end{array}\right]\succeq0,\quad
y&gt;0
\]</span></p>
<p>（函数图像如<a href="#图3">图 3</a> 所示）。</p>
</blockquote>
<p>  关于凸函数的很多结果可以从几何的角度利用上境图并结合凸集的一些结论来证明（或理解），例如，考虑凸函数的一阶条件</p>
<p><span class="math display">\[
f(y)\geqslant f(x)+\nabla f(x)^\mathrm{T}(y-x)
\]</span></p>
<p>其中函数 <span class="math inline">\(f\)</span> 是凸的，<span class="math inline">\(x,y\in\mathop{\bf dom}f\)</span>。我们可以利用
<span class="math inline">\(\mathop{\bf epi}f\)</span>
从几何角度理解上述基本不等式。若 <span class="math inline">\((y,t)\in\mathop{\bf epi}f\)</span>，有</p>
<p><span class="math display">\[
t\geqslant f(y)\geqslant f(x)+\nabla f(x)^\mathrm{T}(y-x)
\]</span></p>
<p>上式可以描述为</p>
<p><span class="math display">\[
(y,t)\in\mathop{\bf epi}f\implies\left[\begin{array}{c}\nabla
f(x)\\-1\end{array}\right]^\mathrm{T}\left(\left[\begin{array}{c}y\\t\end{array}\right]-\left[\begin{array}{c}x\\f(x)\end{array}\right]\right)\leqslant0
\]</span></p>
<p>这意味着法向量为 <span class="math inline">\((\nabla
f(x),-1)\)</span> 的超平面在边界点 <span class="math inline">\((x,f(x))\)</span> 支撑着 <span class="math inline">\(\mathop{\bf epi}f\)</span>，如<a href="#图6">图
6</a> 所示。</p>
<p><a id="图6"></a></p>
<figure>
<img data-src="../images/post/2024-06-14-josh-cvx-2-1/2024-06-14-josh-cvx-2-1-060-EpigraphAndSupportingHyperplane.png" width="400" alt="图 6. 对于可微凸函数 f，向量 (\nabla f(x),-1) 定义了函数 f 在点 x 处的上境图的一个支撑超平面。">
<figcaption aria-hidden="true">图 6. 对于可微凸函数 <span class="math inline">\(f\)</span>，向量 <span class="math inline">\((\nabla f(x),-1)\)</span> 定义了函数 <span class="math inline">\(f\)</span> 在点 <span class="math inline">\(x\)</span>
处的上境图的一个支撑超平面。</figcaption>
</figure>
<h1 id="jensen-不等式及其扩展">8. Jensen 不等式及其扩展</h1>
<p>  基本不等式</p>
<p><span class="math display">\[
f(\theta x+(1-\theta)y)\leqslant\theta f(x)+(1-\theta)f(y)
\]</span></p>
<p>有时也称作 <strong>Jensen 不等式</strong>（<em>Jensen’s
inequality</em>）。此不等式可以很方便地扩展至更多点的凸组合：若函数
<span class="math inline">\(f\)</span> 是凸函数，<span class="math inline">\(x_1,\cdots,x_k\in\mathop{\bf dom}f\)</span>，<span class="math inline">\(\theta_1,\cdots,\theta_k\geqslant0\)</span> 且
<span class="math inline">\(\theta_1+\cdots+\theta_k=1\)</span>，则下式成立</p>
<p><span class="math display">\[
f(\theta_1x_1+\cdots+\theta_kx_k)\leqslant\theta_1f(x_1)+\cdots+\theta_kf(x_k)
\]</span></p>
<p>考虑凸集时，此不等式可以扩展至无穷项和、积分以及期望。例如，若在
<span class="math inline">\(S\subseteq\mathop{\bf dom}f\)</span> 上
<span class="math inline">\(p(x)\geqslant0\)</span> 且 <span class="math inline">\(\displaystyle\int_Sp(x) \mathrm{d}x =
1\)</span>，则当相应的积分存在时，下式成立</p>
<p><span class="math display">\[
f\left(\int_Sp(x)x\mathrm{d}x\right)\leqslant\int_Sf(x)p(x)\mathrm{d}x
\]</span></p>
<p>扩展到更一般的情况，我们可以采用其支撑属于 <span class="math inline">\(\mathop{\bf dom}f\)</span> 的任意概率测度。若
<span class="math inline">\(x\)</span> 是随机变量，事件 <span class="math inline">\(x\in\mathop{\bf dom}f\)</span> 发生的概率为
1，函数 <span class="math inline">\(f\)</span>
是凸函数，当相应的期望存在时，我们有</p>
<p><span class="math display">\[\begin{equation}\label{GeneralJensenInequality}
  f(\mathbb{E}x)\leqslant\mathbb{E}f(x)
\end{equation}\]</span></p>
<p>设随机变量 <span class="math inline">\(x\)</span> 的可能取值为 <span class="math inline">\(\{ x_1, x_2\}\)</span> 相应地取值概率为 <span class="math inline">\(\mathop{\bf prob}( x= x_1) =
\theta\)</span>，<span class="math inline">\(\mathop{\bf prob}(
x=x_2)=1-\theta\)</span>，则由一般形式 <span class="math inline">\(\eqref{GeneralJensenInequality}\)</span>
可以得到基本不等式 <span class="math inline">\(\eqref{DefinitionOfConvexFunction}\)</span>。所以不等式
<span class="math inline">\(\eqref{GeneralJensenInequality}\)</span>
可以刻画凸性：若函数 <span class="math inline">\(f\)</span>
不是凸函数，则存在随机变量 <span class="math inline">\(x\)</span>，<span class="math inline">\(x\in\mathop{\bf dom}f\)</span> 以概率 <span class="math inline">\(1\)</span> 发生，使得 <span class="math inline">\(f(\mathbb{E}x)&gt;\mathbb{E}f(x)\)</span>。</p>
<p>  上述所有不等式均被称为 <strong>Jensen 不等式</strong>（<em>Jensen’s
inequality</em>），而实际上最初由 Jensen 提出的不等式相当简单</p>
<p><span class="math display">\[
f\left(\frac{x+y}2\right)\leqslant\frac{f(x)+f(y)}2
\]</span></p>
<blockquote>
<p><strong>注释</strong> 我们可以这样理解式 <span class="math inline">\(\eqref{GeneralJensenInequality}\)</span>。假设
<span class="math inline">\(x\in\mathop{\bf
dom}f\subseteq\mathbf{R}^n\)</span>，<span class="math inline">\(z\)</span> 是 <span class="math inline">\(\mathbf{R}^n\)</span>
中的随机变量，其均值为零，则有</p>
<p><span class="math display">\[
\mathbb{E}f(x+z)\geqslant f(x)
\]</span></p>
<p>因此，随机化或者扰动（即在自变量上增加一个零均值的随机变量）从平均效果上不会减小凸函数的值。</p>
</blockquote>
<h1 id="不等式">9. 不等式</h1>
<p>  很多著名的不等式都可以通过将 Jensen
不等式应用于合适的凸函数得到。（事实上，凸性和 Jensen
不等式可以构成不等式理论的基础。）</p>
<blockquote>
<p><strong>举例</strong> 考虑算术-几何平均不等式</p>
<p><span class="math display">\[\begin{equation}\label{ArithmeticGeometricMeanInequality}
  \sqrt{a b} \leqslant( a+b ) / 2
\end{equation}\]</span></p>
<p>其中 <span class="math inline">\(a, b
\geqslant0\)</span>。我们可以利用凸性和 Jensen 不等式得到此不等式。函数
<span class="math inline">\(-\log x\)</span> 是凸函数：利用 Jensen
不等式，令 <span class="math inline">\(\theta=1 / 2\)</span> ，可得</p>
<p><span class="math display">\[
-\log \left( \frac{a+b} {2} \right) \leqslant\frac{-\log a-\log b} {2}
\]</span></p>
<p>等式两边取指数即可得到式 <span class="math inline">\(\eqref{ArithmeticGeometricMeanInequality}\)</span>。</p>
</blockquote>
<blockquote>
<p><strong>举例</strong> 证明 Hölder 不等式：对 <span class="math inline">\(p &gt; 1\)</span>，<span class="math inline">\(1 /
p+1 / q=1\)</span>，以及 <span class="math inline">\(x,y
\in\mathbf{R}^{n}\)</span> 有</p>
<p><span class="math display">\[
\sum_{i=1}^{n} x_{i} y_{i} \leqslant\left( \sum_{i=1}^{n} | x_{i} |^{p}
\right)^{1 / p} \left( \sum_{i=1}^{n} | y_{i} |^{q} \right)^{1 / q}
\]</span></p>
<p>由 <span class="math inline">\(-\log x\)</span> 的凸性以及 Jensen
不等式，可以得到更为一般的算术-几何平均不等式</p>
<p><span class="math display">\[
a^{\theta} b^{1-\theta} \leqslant\theta a+( 1-\theta) b,
\]</span></p>
<p>其中 <span class="math inline">\(a,b \geqslant0\)</span>，<span class="math inline">\(0 \leqslant\theta\leqslant1\)</span>。令</p>
<p><span class="math display">\[
a=\frac{| x_{i} |^{p}} {\displaystyle\sum_{j=1}^{n} | x_{j} |^{p}},
\qquad b=\frac{| y_{i} |^{q}} {\displaystyle\sum_{j=1}^{n} | y_{j}
|^{q}}, \qquad\theta=1 / p,
\]</span></p>
<p>可以得到如下不等式</p>
<p><span class="math display">\[
\left( \frac{| x_{i} |^{p}} {\displaystyle\sum_{j=1}^{n} | x_{j} |^{p}}
\right)^{1 / p} \left( \frac{| y_{i} |^{q}} {\displaystyle\sum_{j=1}^{n}
| y_{j} |^{q}} \right)^{1 / q} \leqslant\frac{| x_{i} |^{p}} {p
\displaystyle\sum_{j=1}^{n} | x_{j} |^{p}}+\frac{| y_{i} |^{q}} {q
\displaystyle\sum_{j=1}^{n} | y_{j} |^{q}}.
\]</span></p>
<p>对 <span class="math inline">\(i\)</span> 进行求和可以得到 Hölder
不等式。</p>
</blockquote>
<h1 id="参考文献">参考文献</h1>
<ol type="1">
<li>Stephen P. Boyd and Lieven Vandenberghe, <em>Convex
optimization</em>. Cambridge, UK: Cambridge University Press, 2004.</li>
<li>Stephen P. Boyd and Lieven Vandenberghe, <em>凸优化</em>. 北京:
清华大学出版社, 2013.</li>
</ol>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/css/markmap.css">

<script src="/js/markmap.js"></script>
]]></content>
      <categories>
        <category>Josh 的学习笔记</category>
        <category>凸优化</category>
        <category>数学</category>
        <category>凸优化</category>
        <category>凸函数</category>
      </categories>
      <tags>
        <tag>凸优化</tag>
        <tag>凸函数</tag>
      </tags>
  </entry>
  <entry>
    <title>Zynq MPSoC / RFSoC 动态配置 DIMM DDR</title>
    <url>/posts/11cd1dc.html</url>
    <content><![CDATA[<p>对于 DIMM 拓扑的 DDR，通常可以使用 I2C 对搭载在 DIMM 上的 SPD EEPROM
进行读取后获得配置参数，然后对 DDR 控制器进行配置。</p>
<p>AMD Xilinx UG1085 的 <a href="https://docs.amd.com/r/en-US/ug1085-zynq-ultrascale-trm/Dynamic-DDR-Configuration">Dynamic
DDR Configuration</a> 一节指出，当 DDR
控制器处于复位状态时，可以在运行时通过 FSBL 获取 DDR 参数并对 DDR
控制器进行初始化。</p>
<p>本文基于 Zynq RFSoC，对 PS 端的 SO-DIMM DDR 进行动态配置。</p>
<span id="more"></span>
<h1 id="名词释义">名词释义</h1>
<ul>
<li><a href="https://xilinx-wiki.atlassian.net/wiki/spaces/A/pages/18842276/Standalone+Board+Support+Package+BSP">BSP</a>：Board
Support Package，板级支持包</li>
<li><a href="https://en.wikipedia.org/wiki/EEPROM">EEPROM</a>：Electrically-Erasable
Programmable Read-Only Memory，电子擦除式可复写只读存储器</li>
<li><a href="https://xilinx-wiki.atlassian.net/wiki/spaces/A/pages/18842019/Zynq+UltraScale+FSBL#ZynqUltraScale+FSBL-WhatisFSBL?">FSBL</a>：First
Stage Bootloader，第一阶段引导加载程序</li>
<li><a href="https://en.wikipedia.org/wiki/DDR_SDRAM">DDR
DRAM</a>：Double Data Rate Synchronous Dynamic Random-Access
Memory，双倍数据率同步动态随机存取存储器</li>
<li><a href="https://en.wikipedia.org/wiki/DIMM">DIMM</a>：Dual In-line
Memory Modules，双列直插式存储模块</li>
<li>PCW：Processing System Configuration Wizard，处理系统配置向导</li>
<li><a href="https://en.wikipedia.org/wiki/DIMM#SO-DIMM">SO-DIMM</a>：Small
Outline Dual In-line Memory Modules，小外形双列直插式内存模块</li>
<li><a href="https://en.wikipedia.org/wiki/Serial_presence_detect">SPD</a>：Serial
Presence Detect，串行存在检测</li>
</ul>
<h1 id="硬软件版本">硬软件版本</h1>
<table>
<thead>
<tr>
<th style="text-align: center;">硬软件</th>
<th style="text-align: center;">型号/版本</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">FPGA</td>
<td style="text-align: center;">Zynq RFSoC XCZU48DR-2-FSVG1517-I</td>
</tr>
<tr>
<td style="text-align: center;">DDR4</td>
<td style="text-align: center;">Micron MTA4ATF51264HZ-2G6E1</td>
</tr>
<tr>
<td style="text-align: center;">I2C Mux</td>
<td style="text-align: center;">TI TCA9548APWR</td>
</tr>
<tr>
<td style="text-align: center;">Vivado</td>
<td style="text-align: center;">2024.1</td>
</tr>
<tr>
<td style="text-align: center;">Vitis Classic</td>
<td style="text-align: center;">2024.1</td>
</tr>
</tbody>
</table>
<h1 id="zynq-mpsoc-rfsoc-动态-ddr-配置简介">Zynq MPSoC / RFSoC 动态 DDR
配置简介</h1>
<p>Zynq MPSoC / RFSoC 动态 DDR 配置具有如下特性：</p>
<ul>
<li>无需在 Vivado 中进行改动即可更换 DIMM，并使用动态 DDR 配置初始化
DDR；</li>
<li>支持 DDR3 和 DDR4 DIMM；</li>
<li>单一的 PetaLinux BSP 即可支持任何可安装的 DIMM 器件。</li>
</ul>
<div class="note warning"><p>动态 DDR 配置功能仅可用于 PS DIMM DDR，不支持颗粒 DDR。</p>
</div>
<h1 id="具体操作方法">具体操作方法</h1>
<h2 id="pcw-gui-配置">PCW GUI 配置</h2>
<p>在使用动态 DDR 配置之前，需要在如<a href="#图1">图 1</a> 的 Vivado 的
PCW GUI 中启用 DDR 控制器，且将“DDR Controller Options”部分设置为：</p>
<ul>
<li>Memory Type：DDR4 或 DDR3</li>
<li>Components：UDIMM 或 RDIMM</li>
<li>ECC：Enabled 或 Disabled</li>
<li>Effective DRAM Bus Width：64 Bit</li>
</ul>
<p><a id="图1"></a></p>
<figure>
<img data-src="../images/post/2024-06-27-zynq-mpsoc-ddr-spd/2024-06-27-zynq-mpsoc-ddr-spd-010-ZynqGui.png" alt="图 1. Zynq UltraScale+ MPSoC 配置 GUI">
<figcaption aria-hidden="true">图 1. Zynq UltraScale+ MPSoC 配置
GUI</figcaption>
</figure>
<p>动态 DDR 配置将自动读取 SPD 表，并设置“DDR Memory
Option”部分的所有参数，如下表。</p>
<table>
<colgroup>
<col style="width: 30%">
<col style="width: 19%">
<col style="width: 30%">
<col style="width: 19%">
</colgroup>
<thead>
<tr>
<th>Option</th>
<th>Value Example</th>
<th>Option</th>
<th>Value Example</th>
</tr>
</thead>
<tbody>
<tr>
<td>Speed Bin (Use Tooltip)</td>
<td>DDR42133P</td>
<td>DRAM IC Bus Width (per die)</td>
<td>8 Bits</td>
</tr>
<tr>
<td>Cas Latency</td>
<td>15</td>
<td>DRAM Device Capacity(per die)</td>
<td>4096 MBits</td>
</tr>
<tr>
<td>RAS to CAS Delay (Cycles)</td>
<td>15</td>
<td>Bank Group Address Count (Bits)</td>
<td>2</td>
</tr>
<tr>
<td>Pre-charge Time (Cycles)</td>
<td>15</td>
<td>Bank Address Count (Bits)</td>
<td>2</td>
</tr>
<tr>
<td>Cas Write Latency (Cycles)</td>
<td>14</td>
<td>Row Address Count (Bits)</td>
<td>15</td>
</tr>
<tr>
<td>tRC (ns)</td>
<td>46.5</td>
<td>Column Address Count</td>
<td>10</td>
</tr>
<tr>
<td>tRASmin (ns)</td>
<td>33</td>
<td>Dual Rank</td>
<td></td>
</tr>
<tr>
<td>tFAW (ns)</td>
<td>21</td>
<td>DDR Size (in hexa)</td>
<td>0XFFFFFFFF (4GB)</td>
</tr>
<tr>
<td>Additive Latency (Cycles)</td>
<td>0</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>而“Other Options”部分的所有值都需要用户根据需要设置，无法从 SPD
表中获得，如下表。</p>
<table>
<colgroup>
<col style="width: 30%">
<col style="width: 19%">
<col style="width: 30%">
<col style="width: 19%">
</colgroup>
<thead>
<tr>
<th>Option</th>
<th>Value Example</th>
<th>Option</th>
<th>Value Example</th>
</tr>
</thead>
<tbody>
<tr>
<td>Memory Address Map</td>
<td>ROW BANK COL</td>
<td>Power Mode Settings</td>
<td>Power Down Enable</td>
</tr>
<tr>
<td>Data Mask and DBI</td>
<td>DM NO DBI</td>
<td>Clock Stop</td>
<td></td>
</tr>
<tr>
<td>Address Mirroring</td>
<td></td>
<td><strong>Refresh Mode Settings</strong></td>
<td></td>
</tr>
<tr>
<td>2nd Clock</td>
<td></td>
<td>Lower-Power Auto Self-Refresh</td>
<td>Manual Normal</td>
</tr>
<tr>
<td>Parity</td>
<td></td>
<td>Temp Controlled Refresh</td>
<td></td>
</tr>
<tr>
<td>2Tck Command Timing (2T)</td>
<td></td>
<td>Max. Operating Temperature</td>
<td>Normal (0-85)</td>
</tr>
<tr>
<td></td>
<td></td>
<td>Fine Granularity Refresh Mode</td>
<td>1x</td>
</tr>
<tr>
<td></td>
<td></td>
<td>Self-Refresh Abort</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="启用动态-ddr-配置功能">启用动态 DDR 配置功能</h2>
<p>要启用动态 DDR 配置功能，需要在 Vivado 中使用 TCL 命令将参数
<code>CONFIG.PSU_DYNAMIC_DDR_CONFIG_EN</code> 置为 1：</p>
<figure class="highlight tcl"><table><tbody><tr><td class="code"><pre><span class="line">set_property CONFIG.PSU_DYNAMIC_DDR_CONFIG_EN <span class="number">1</span> [get_bd_cells /zynq_ultra_ps_e]</span><br></pre></td></tr></tbody></table></figure>
<p>这里的 <code>zynq_ultra_ps_e</code> 需要替换为实际 Block Design 中
Zynq UltraScale+ MPSoC IP 核的名称，如<a href="#图2">图 2</a>。</p>
<p><a id="图2"></a></p>
<figure>
<img data-src="../images/post/2024-06-27-zynq-mpsoc-ddr-spd/2024-06-27-zynq-mpsoc-ddr-spd-020-BlockDesign.png" alt="图 2. Block Design 整体">
<figcaption aria-hidden="true">图 2. Block Design 整体</figcaption>
</figure>
<p>然后重新生成 Output Products 即可（若除 PS
处理器外还有其他逻辑，则需要重新生成比特流）。FSBL
将会在启动过程中使用该参数，并执行动态 DDR 配置。</p>
<div class="note info"><p>如果设置了上述参数却出现了如下警告，是因为 GUI 中 DDR 类型必须为
UDIMM 或 RDIMM，不能为 Component。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">WARNING: [BD 41-721] Attempt to set value '1' on disabled parameter 'PSU_DYNAMIC_DDR_CONFIG_EN' of cell '/zynq_ultra_ps_e_0' is ignored</span><br></pre></td></tr></tbody></table></figure>
</div>
<h2 id="i2c-硬件要求">I2C 硬件要求</h2>
<p>由于动态 DDR 配置需要在 FSBL 中使用 I2C 读取 DDR SPD EEPROM
中的数据，而在 Xilinx 自动生成 FSBL 中，I2C 读取 DDR SPD EEPROM
的方式是固定的，因此<strong>若不想对生成的 FSBL
进行修改，则需要在硬件上适配 FSBL</strong>。</p>
<p>Xilinx FSBL 使用 I2C1（1 号 I2C 控制器），借助一个 I2C Mux 与 SPD
EEPROM 进行通信，使用的地址为：</p>
<ul>
<li>I2C Mux 地址： 0x75</li>
<li>I2C Slave 地址： 0b1010001 (0x51)</li>
<li>SODIMM SA[2:0]： 0b001</li>
</ul>
<div class="note info"><p>从 Vivado 2019.1 开始，动态 DDR 配置对于所有使用 DIMM DDR 的 Zynq
MPSoC / RFSoC 评估板均启用，在使用预置硬件配置时无需额外用户操作。</p>
</div>
<h2 id="根据硬件修改-fsbl">根据硬件修改 FSBL</h2>
<p>若 I2C 硬件连接不满足上述要求，还可以按照实际连接关系修改 FSBL。FSBL
中使用 I2C 读取 DDR SPD EEPROM 的函数为
<code>u32 XFsbl_IicReadSpdEeprom(u8 *SpdData)</code>。</p>
<figure class="highlight c"><figcaption><span>xfsbl_ddr_init.c</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">u32 <span class="title function_">XFsbl_DdrInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">/* Get the Model Part Number from the SPD stored in EEPROM */</span></span><br><span class="line">  Status = XFsbl_IicReadSpdEeprom(SpdData);</span><br><span class="line">  <span class="keyword">if</span> (Status != XFSBL_SUCCESS) {</span><br><span class="line">    Status = XFSBL_FAILURE;</span><br><span class="line">    <span class="keyword">goto</span> END;</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>下面对函数进行拆解，结合注释可以更好理解操作的过程。</p>
<h3 id="初始化-i2c-控制器">初始化 I2C 控制器</h3>
<p>首先对 I2C 控制器 I2C1 进行初始化。值得一提的是，从 Vivado / Vitis
2023.2 版本开始，对设备进行寻址时，不再依赖于设备的 Device
ID，而是直接使用基地址 Base Address，少了从 Device ID 到 Base Address
这一步操作，从开发的角度来看更为合理了。</p>
<div class="note info"><p>若设计使用了 I2C 控制器 I2C0，则可以改为使用基地址
<code>XPAR_I2C0_BASEADDR</code> 或 Device ID
<code>XPAR_PSU_I2C_0_DEVICE_ID</code> 来寻找设备。</p>
</div>
<figure class="highlight c"><figcaption><span>xfsbl_ddr_init.c</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">static</span> u32 <span class="title function_">XFsbl_IicReadSpdEeprom</span><span class="params">(u8 *SpdData)</span></span><br><span class="line">{</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">/* Lookup for I2C-1U device */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SDT</span></span><br><span class="line">  ConfigIic = XIicPs_LookupConfig(XPAR_I2C1_BASEADDR);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  ConfigIic = XIicPs_LookupConfig(XPAR_PSU_I2C_1_DEVICE_ID);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="keyword">if</span> (!ConfigIic) {</span><br><span class="line">    UStatus = XFSBL_FAILURE;</span><br><span class="line">    <span class="keyword">goto</span> END;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Initialize the I2C device */</span></span><br><span class="line">  Status = XIicPs_CfgInitialize(&amp;IicInstance, ConfigIic,</span><br><span class="line">      ConfigIic-&gt;BaseAddress);</span><br><span class="line">  <span class="keyword">if</span> (Status != XST_SUCCESS) {</span><br><span class="line">    UStatus = XFSBL_FAILURE;</span><br><span class="line">    <span class="keyword">goto</span> END;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set the Serial Clock for I2C */</span></span><br><span class="line">  Status = XIicPs_SetSClk(&amp;IicInstance, XFSBL_IIC_SCLK_RATE);</span><br><span class="line">  <span class="keyword">if</span> (Status != XST_SUCCESS) {</span><br><span class="line">    UStatus = XFSBL_FAILURE;</span><br><span class="line">    <span class="keyword">goto</span> END;</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="选择-i2c-mux-的-slave">选择 I2C Mux 的 Slave</h3>
<p>由于开发板搭载了较多 I2C 外设，而 Zynq MPSoC / RFSoC 的 I2C
控制器数量有限，因此需要通过 I2C Mux 来扩展所连 I2C Slave 的数量。</p>
<p>本板卡 I2C1 原理图如<a href="#图3">图 3</a>，所用 I2C Mux 的型号为
TCA9548A，其地址配置方式如<a href="#图4">图 4</a>，Slave 选择方式如<a href="#图5">图 5</a>，这里均和评估板保持一致，因此可以与自动生成的 FSBL
兼容。</p>
<p>结合<a href="#图3">图 3</a> 和<a href="#图4">图 4</a> 可知 I2C Mux
的地址为 <code>0x75</code>，从<a href="#图3">图 3</a> 中可知 PS DDR4
SODIMM 的 I2C 连接在了第 3 号 Slave 的位置，因此按照<a href="#图5">图
5</a> 需要将 B3 置 1，也即需要向地址为 <code>0x75</code> 的 I2C Mux
TCA9548A 的控制寄存器中写入 <code>0x08</code>。</p>
<p><a id="图3"></a></p>
<figure>
<img data-src="../images/post/2024-06-27-zynq-mpsoc-ddr-spd/2024-06-27-zynq-mpsoc-ddr-spd-030-I2C1Schematic.png" alt="图 3. I2C Mux 原理图">
<figcaption aria-hidden="true">图 3. I2C Mux 原理图</figcaption>
</figure>
<p><a id="图4"></a></p>
<figure>
<img data-src="../images/post/2024-06-27-zynq-mpsoc-ddr-spd/2024-06-27-zynq-mpsoc-ddr-spd-040-tca9548aAddress.png" width="600" alt="图 4. TCA9548A 地址配置">
<figcaption aria-hidden="true">图 4. TCA9548A 地址配置</figcaption>
</figure>
<p><a id="图5"></a></p>
<figure>
<img data-src="../images/post/2024-06-27-zynq-mpsoc-ddr-spd/2024-06-27-zynq-mpsoc-ddr-spd-050-tca9548aConfig.png" width="1000" alt="图 5. TCA9548A Slave选择">
<figcaption aria-hidden="true">图 5. TCA9548A Slave选择</figcaption>
</figure>
<p>按照上述分析，下面的代码就不难理解了，首先向地址为
<code>XFSBL_MUX_ADDR</code>（默认为 <code>0x75</code>）的 I2C Mux
写入选通配置
<code>0x08</code>，然后从同样的地址回读，验证配置是否正确。</p>
<div class="note info"><ul>
<li>若设计中没有使用到 I2C Mux，而是直接将 I2C 控制器连接到了
DIMM，则可以删去这部分代码；</li>
<li>若设计中 I2C Mux 地址不同，则可以修改 <code>XFSBL_MUX_ADDR</code>
的宏定义；</li>
<li>若设计中 I2C Mux 连接的 Slave 不同，可以修改 I2C 发送的
<code>TxArray</code>。</li>
</ul>
</div>
<figure class="highlight c"><figcaption><span>xfsbl_ddr_init.c</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">static</span> u32 <span class="title function_">XFsbl_IicReadSpdEeprom</span><span class="params">(u8 *SpdData)</span></span><br><span class="line">{</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * Configure I2C Mux to select DDR4 SODIMM Slave</span></span><br><span class="line"><span class="comment">   * 0x08U - Enable DDR4 SODIMM module</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  TxArray = <span class="number">0x08U</span>;</span><br><span class="line">  XIicPs_MasterSendPolled(&amp;IicInstance, &amp;TxArray, <span class="number">1U</span>, XFSBL_MUX_ADDR);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * Wait until bus is idle to start another transfer.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  Status = Xil_WaitForEvent(IicInstance.Config.BaseAddress +</span><br><span class="line">      XIICPS_SR_OFFSET, XIICPS_SR_BA_MASK, <span class="number">0U</span>, XFSBL_IIC_BUS_TIMEOUT);</span><br><span class="line">  <span class="keyword">if</span> (Status != XST_SUCCESS) {</span><br><span class="line">    UStatus = XFSBL_FAILURE;</span><br><span class="line">    <span class="keyword">goto</span> END;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * Get Configuration to confirm the selection of the slave</span></span><br><span class="line"><span class="comment">   * device.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  Status = XIicPs_MasterRecvPolled(&amp;IicInstance, SpdData, <span class="number">1U</span>,</span><br><span class="line">      XFSBL_MUX_ADDR);</span><br><span class="line">  <span class="keyword">if</span> (Status != XST_SUCCESS) {</span><br><span class="line">    UStatus = XFSBL_FAILURE;</span><br><span class="line">    <span class="keyword">goto</span> END;</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * Wait until bus is idle to start another transfer.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  Status = Xil_WaitForEvent(IicInstance.Config.BaseAddress +</span><br><span class="line">      XIICPS_SR_OFFSET, XIICPS_SR_BA_MASK, <span class="number">0U</span>, XFSBL_IIC_BUS_TIMEOUT);</span><br><span class="line">  <span class="keyword">if</span> (Status != XST_SUCCESS) {</span><br><span class="line">    UStatus = XFSBL_FAILURE;</span><br><span class="line">    <span class="keyword">goto</span> END;</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="读取-eeprom-的第一页">读取 EEPROM 的第一页</h3>
<p>配置完 I2C Mux 后，即可开始读取 SPD EEPROM 中的内容了。<a href="#图6">图 6</a> 给出了 EEPROM 支持的指令表，由于 EEPROM
一次读的最大长度为一页，也即一个 Page，因此需要分两次对其中的两个 Page
进行读取。</p>
<p><a id="图6"></a></p>
<figure>
<img data-src="../images/post/2024-06-27-zynq-mpsoc-ddr-spd/2024-06-27-zynq-mpsoc-ddr-spd-060-DDR4SPDAddress.png" width="800" alt="图 6. DDR4 SPD EEPROM 指令表">
<figcaption aria-hidden="true">图 6. DDR4 SPD EEPROM 指令表</figcaption>
</figure>
<p>首先设置 Page Address 为 0，也即向地址 <code>0x36</code> 中写入
<code>0x00</code>，表示从 Page 0 中进行读取，一次读取 256 Byte。</p>
<div class="note info"><p>通常 SPD EEPROM 的 Page 选择地址是固定的，如果 Page Address 0
的地址有变更，修改 <code>XFSBL_SODIMM_CONTROL_ADDR_LOW</code>
的宏定义即可。</p>
</div>
<figure class="highlight c"><figcaption><span>xfsbl_ddr_init.c</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">static</span> u32 <span class="title function_">XFsbl_IicReadSpdEeprom</span><span class="params">(u8 *SpdData)</span></span><br><span class="line">{</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * Set SODIMM control address to enable access to lower</span></span><br><span class="line"><span class="comment">   * EEPROM page (0U to 255U Bytes).</span></span><br><span class="line"><span class="comment">   * 0x00U - Enable Read of Lower Page from EEPROM</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  TxArray = <span class="number">0x00U</span>;</span><br><span class="line">  XIicPs_MasterSendPolled(&amp;IicInstance, &amp;TxArray, <span class="number">1U</span>,</span><br><span class="line">      XFSBL_SODIMM_CONTROL_ADDR_LOW);</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * Wait until bus is idle to start another transfer.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  Status = Xil_WaitForEvent(IicInstance.Config.BaseAddress +</span><br><span class="line">      XIICPS_SR_OFFSET, XIICPS_SR_BA_MASK, <span class="number">0U</span>, XFSBL_IIC_BUS_TIMEOUT);</span><br><span class="line">  <span class="keyword">if</span> (Status != XST_SUCCESS) {</span><br><span class="line">    UStatus = XFSBL_FAILURE;</span><br><span class="line">    <span class="keyword">goto</span> END;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * Configure SODIMM Slave address to select starting address of the</span></span><br><span class="line"><span class="comment">   * read bytes.</span></span><br><span class="line"><span class="comment">   * 0x00U - Set starting byte address of read Lowe Page from EEPROM</span></span><br><span class="line"><span class="comment">   * This will result in to starting address of 0x149U (0x100U + 0x49U) in</span></span><br><span class="line"><span class="comment">   * the EEPROM.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  TxArray = <span class="number">0x00U</span>;</span><br><span class="line">  XIicPs_MasterSendPolled(&amp;IicInstance, &amp;TxArray, <span class="number">1U</span>,</span><br><span class="line">      XFSBL_SODIMM_SLAVE_ADDR);</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * Wait until bus is idle to start another transfer.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  Status = Xil_WaitForEvent(IicInstance.Config.BaseAddress +</span><br><span class="line">      XIICPS_SR_OFFSET, XIICPS_SR_BA_MASK, <span class="number">0U</span>, XFSBL_IIC_BUS_TIMEOUT);</span><br><span class="line">  <span class="keyword">if</span> (Status != XST_SUCCESS) {</span><br><span class="line">    UStatus = XFSBL_FAILURE;</span><br><span class="line">    <span class="keyword">goto</span> END;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * Receive the Data of 256U Bytes from SPD EEPROM via I2C.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  Status = XIicPs_MasterRecvPolled(&amp;IicInstance, SpdData, <span class="number">256U</span>,</span><br><span class="line">      XFSBL_SODIMM_SLAVE_ADDR);</span><br><span class="line">  <span class="keyword">if</span> (Status != XST_SUCCESS) {</span><br><span class="line">    UStatus = XFSBL_FAILURE;</span><br><span class="line">    <span class="keyword">goto</span> END;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * Wait until bus is idle.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  Status = Xil_WaitForEvent(IicInstance.Config.BaseAddress +</span><br><span class="line">      XIICPS_SR_OFFSET, XIICPS_SR_BA_MASK, <span class="number">0U</span>, XFSBL_IIC_BUS_TIMEOUT);</span><br><span class="line">  <span class="keyword">if</span> (Status != XST_SUCCESS) {</span><br><span class="line">    UStatus = XFSBL_FAILURE;</span><br><span class="line">    <span class="keyword">goto</span> END;</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="读取-eeprom-的第二页">读取 EEPROM 的第二页</h3>
<p>然后设置 Page Address 为 1，也即向地址 <code>0x37</code> 中写入
<code>0x00</code>，表示从 Page 0 中进行读取，一次读取 256 Byte。</p>
<div class="note info"><p>通常 SPD EEPROM 的 Page 选择地址是固定的，如果 Page Address 1
的地址有变更，修改 <code>XFSBL_SODIMM_CONTROL_ADDR_HIGH</code>
的宏定义即可。</p>
</div>
<figure class="highlight c"><figcaption><span>xfsbl_ddr_init.c</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">static</span> u32 <span class="title function_">XFsbl_IicReadSpdEeprom</span><span class="params">(u8 *SpdData)</span></span><br><span class="line">{</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * Set SODIMM control address to enable access to upper</span></span><br><span class="line"><span class="comment">   * EEPROM page (256U to 511U Bytes).</span></span><br><span class="line"><span class="comment">   * 0x01U - Enable Read of Upper Page from EEPROM</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  TxArray = <span class="number">0x01U</span>;</span><br><span class="line">  XIicPs_MasterSendPolled(&amp;IicInstance, &amp;TxArray, <span class="number">1U</span>,</span><br><span class="line">      XFSBL_SODIMM_CONTROL_ADDR_HIGH);</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * Wait until bus is idle to start another transfer.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  Status = Xil_WaitForEvent(IicInstance.Config.BaseAddress +</span><br><span class="line">      XIICPS_SR_OFFSET, XIICPS_SR_BA_MASK, <span class="number">0U</span>, XFSBL_IIC_BUS_TIMEOUT);</span><br><span class="line">  <span class="keyword">if</span> (Status != XST_SUCCESS) {</span><br><span class="line">    UStatus = XFSBL_FAILURE;</span><br><span class="line">    <span class="keyword">goto</span> END;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * Configure SODIMM Slave address to select starting address of the</span></span><br><span class="line"><span class="comment">   * read bytes.</span></span><br><span class="line"><span class="comment">   * 0x00U - Set starting byte address of read Upper Page from EEPROM</span></span><br><span class="line"><span class="comment">   * This will result in to starting address of 0x149U (0x100U + 0x49U) in</span></span><br><span class="line"><span class="comment">   * the EEPROM.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  TxArray = <span class="number">0x00U</span>;</span><br><span class="line">  XIicPs_MasterSendPolled(&amp;IicInstance, &amp;TxArray, <span class="number">1U</span>,</span><br><span class="line">      XFSBL_SODIMM_SLAVE_ADDR);</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * Wait until bus is idle to start another transfer.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  Status = Xil_WaitForEvent(IicInstance.Config.BaseAddress +</span><br><span class="line">      XIICPS_SR_OFFSET, XIICPS_SR_BA_MASK, <span class="number">0U</span>, XFSBL_IIC_BUS_TIMEOUT);</span><br><span class="line">  <span class="keyword">if</span> (Status != XST_SUCCESS) {</span><br><span class="line">    UStatus = XFSBL_FAILURE;</span><br><span class="line">    <span class="keyword">goto</span> END;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * Receive the Data of 256U Bytes from SPD EEPROM via I2C.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  Status = XIicPs_MasterRecvPolled(&amp;IicInstance, &amp;SpdData[<span class="number">256U</span>], <span class="number">256U</span>,</span><br><span class="line">      XFSBL_SODIMM_SLAVE_ADDR);</span><br><span class="line">  <span class="keyword">if</span> (Status != XST_SUCCESS) {</span><br><span class="line">    UStatus = XFSBL_FAILURE;</span><br><span class="line">    <span class="keyword">goto</span> END;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * Wait until bus is idle.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  Status = Xil_WaitForEvent(IicInstance.Config.BaseAddress +</span><br><span class="line">      XIICPS_SR_OFFSET, XIICPS_SR_BA_MASK, <span class="number">0U</span>, XFSBL_IIC_BUS_TIMEOUT);</span><br><span class="line">  <span class="keyword">if</span> (Status != XST_SUCCESS) {</span><br><span class="line">    UStatus = XFSBL_FAILURE;</span><br><span class="line">    <span class="keyword">goto</span> END;</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h1 id="调试">调试</h1>
<p>配置完成后可以实测了，这里对 FSBL 进行
Debug，观察整个读写的过程。在单独调试 FSBL 的时候，可以不勾选“Program
FPGA”和“Initialize using FSBL”，如<a href="#图7">图 7</a>。</p>
<p><a id="图7"></a></p>
<figure>
<img data-src="../images/post/2024-06-27-zynq-mpsoc-ddr-spd/2024-06-27-zynq-mpsoc-ddr-spd-070-DebugConfig.png" alt="图 7. Debug 配置">
<figcaption aria-hidden="true">图 7. Debug 配置</figcaption>
</figure>
<p>将断点设置在函数 <code>XFsbl_IicReadSpdEeprom()</code>
被调用的地方。</p>
<p><a id="图8"></a></p>
<figure>
<img data-src="../images/post/2024-06-27-zynq-mpsoc-ddr-spd/2024-06-27-zynq-mpsoc-ddr-spd-080-Breakpoint.png" alt="图 8. XFsbl_IicReadSpdEeprom() 函数断点">
<figcaption aria-hidden="true">图 8.
<code>XFsbl_IicReadSpdEeprom()</code> 函数断点</figcaption>
</figure>
<p>观察 I2C Mux 回读的数据。回读的数据存储在 <code>SpdData</code>
数组中，可以观察到数组的第 0 个字节为
<code>0x08</code>，与写入的数据一致。</p>
<p><a id="图9"></a></p>
<figure>
<img data-src="../images/post/2024-06-27-zynq-mpsoc-ddr-spd/2024-06-27-zynq-mpsoc-ddr-spd-090-IICMuxRead.png" alt="图 9. I2C Mux 回读">
<figcaption aria-hidden="true">图 9. I2C Mux 回读</figcaption>
</figure>
<p>然后观察 I2C EEPROM 回读的数据，并与 Micron 给出的 <a href="https://www.micron.com/products/memory/dram-modules/sodimm/part-catalog/part-detail/spd-data/mta4atf51264hz-2g6e1">MTA4ATF51264HZ-2G6E1
的 SPD 数据</a>进行对比，可以观察到数据是一致的。</p>
<p><a id="图10"></a></p>
<figure>
<img data-src="../images/post/2024-06-27-zynq-mpsoc-ddr-spd/2024-06-27-zynq-mpsoc-ddr-spd-100-IICEEPROMRead.png" alt="图 10. I2C EEPROM 回读">
<figcaption aria-hidden="true">图 10. I2C EEPROM 回读</figcaption>
</figure>
<p>最后，<code>XFsbl_DdrInit()</code> 函数的剩余部分会完成 DDR
参数的解析与 DDR 控制器的初始化。</p>
<h1 id="参考文档">参考文档</h1>
<p><a href="https://support.xilinx.com/s/article/75768">75768 - Zynq
MPSoC Dynamic DDR Configuration Support for DIMM Devices</a></p>
<p><a href="https://electronics.stackexchange.com/questions/554703/spd-i2c-address-for-ddr4-sodimm">SPD
I2c Address for DDR4 SODIMM</a></p>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/css/markmap.css">

<script src="/js/markmap.js"></script>
]]></content>
      <categories>
        <category>调试记录</category>
      </categories>
      <tags>
        <tag>调试记录</tag>
        <tag>DDR</tag>
        <tag>MPSoC</tag>
        <tag>RFSoC</tag>
        <tag>SPD</tag>
        <tag>Zynq</tag>
      </tags>
  </entry>
  <entry>
    <title>信息论角度推导高斯分布的概率密度函数</title>
    <url>/posts/741621e3.html</url>
    <content><![CDATA[<p><span class="math inline">\(\newcommand\diff{\mathop{}\!\mathrm{d}}\)</span></p>
<h1 id="背景与目标">背景与目标</h1>
<p>在统计建模中，我们常常面临这样一个问题：<strong>已知某个连续随机变量的期望和方差，如何合理地确定它的概率分布？</strong>
最大熵原理（Maximum Entropy
Principle）提供了一个具有信息论意义的答案：</p>
<blockquote>
<p>在已知约束（如期望与方差）下，熵最大的概率密度函数是最“中立”或最“无偏”的选择。</p>
</blockquote>
<p>熵在此表示不确定性或信息量。连续型随机变量的微分熵定义为：</p>
<p><span class="math display">\[
\begin{equation*}
H[p] = -\int_{-\infty}^{\infty} p(x) \ln p(x) \, \diff x
\end{equation*}
\]</span></p>
<p>我们的目标是：<strong>在已知期望和方差的约束下，最大化熵 <span class="math inline">\(H[p]\)</span>，求出最优概率密度函数 <span class="math inline">\(p(x)\)</span></strong>。</p>
<span id="more"></span>
<h1 id="约束条件">约束条件</h1>
<p>我们假设随机变量 <span class="math inline">\(X\)</span> 满足：</p>
<ul>
<li><p>归一化约束：</p>
<p><span class="math display">\[
\begin{equation*}
\int_{-\infty}^{\infty} p(x) \, \diff x = 1
\end{equation*}
\]</span></p></li>
<li><p>期望约束：</p>
<p><span class="math display">\[
\begin{equation*}
\int_{-\infty}^{\infty} x \, p(x) \, \diff x = \mu
\end{equation*}
\]</span></p></li>
<li><p>方差约束：</p>
<p><span class="math display">\[
\begin{equation*}
\int_{-\infty}^{\infty} (x - \mu)^2 \, p(x) \, \diff x = \sigma^2
\end{equation*}
\]</span></p></li>
</ul>
<h1 id="构造拉格朗日泛函">构造拉格朗日泛函</h1>
<p>引入拉格朗日乘子 <span class="math inline">\(\lambda_0, \lambda_1,
\lambda_2\)</span>，构造带约束的目标泛函：</p>
<p><span class="math display">\[
\begin{equation*}
\mathcal{L}[p] = -\int p(x) \ln p(x) \diff x
+ \lambda_0 \left( \int p(x) \diff x - 1 \right)
+ \lambda_1 \left( \int x p(x) \diff x - \mu \right)
+ \lambda_2 \left( \int (x - \mu)^2 p(x) \diff x - \sigma^2 \right)
\end{equation*}
\]</span></p>
<p>将所有积分项合并为：</p>
<p><span class="math display">\[
\begin{equation*}
\mathcal{L}[p] = \int \left[
- p(x) \ln p(x)
+ \lambda_0 p(x)
+ \lambda_1 x p(x)
+ \lambda_2 (x - \mu)^2 p(x)
\right] \diff x
\end{equation*}
\]</span></p>
<h1 id="变分法求极值">变分法求极值</h1>
<p>我们考虑一个扰动：</p>
<p><span class="math display">\[
\begin{equation*}
p(x) \rightarrow p(x) + \epsilon \eta(x)
\end{equation*}
\]</span></p>
<p>其中 <span class="math inline">\(\epsilon\)</span>
是足够小的实数，<span class="math inline">\(\eta(x)\)</span>
是任意光滑、在积分区间内有界且满足边界条件的函数（可理解为“任意小的扰动”）。为了求出
<span class="math inline">\(\dfrac{\delta \mathcal{L}}{\delta
p(x)}\)</span>，我们代入扰动项进行展开：</p>
<p><span class="math display">\[
\begin{equation*}
\mathcal{L}[p + \epsilon \eta]
= -\int (p(x) + \epsilon \eta(x)) \ln (p(x) + \epsilon \eta(x)) \, \diff
x + \text{其余约束项}
\end{equation*}
\]</span></p>
<blockquote>
<p>注意：这里只展开了主熵项 <span class="math inline">\(-\displaystyle\int p \ln
p\)</span>，约束项形式类似，将在后面统一处理。</p>
</blockquote>
<hr>
<p>对主项使用泰勒展开（忽略高阶小量）：</p>
<blockquote>
<p><strong>泰勒展开回顾：</strong></p>
<p>设 <span class="math inline">\(f(p) = p \ln p\)</span>，我们对 <span class="math inline">\(p(x) + \epsilon \eta(x)\)</span> 展开，有： <span class="math display">\[
f(p + \epsilon \eta) = p \ln p + \epsilon \eta (1 + \ln p) + o(\epsilon)
\]</span> 其中： <span class="math display">\[
\frac{\diff }{\diff p}(p \ln p) = \ln p + 1
\]</span></p>
</blockquote>
<p>将其代入：</p>
<p><span class="math display">\[
\begin{align*}
\mathcal{L}[p + \epsilon \eta]
&amp;= -\int \left[ p(x) \ln p(x) + \epsilon \eta(x)(1 + \ln p(x))
\right] \diff x + o(\epsilon) + \text{约束项} \\
&amp;= \mathcal{L}[p] - \epsilon \int \eta(x) (1 + \ln p(x)) \diff x +
o(\epsilon) + \text{约束项}
\end{align*}
\]</span></p>
<p>对约束项也类似展开：</p>
<ul>
<li><p>对归一化项：</p>
<p><span class="math display">\[
\begin{equation*}
\lambda_0 \left( \int (p + \epsilon \eta) \diff x - 1 \right)
= \lambda_0 \left( \int p \, \diff x - 1 + \epsilon \int \eta \, \diff x
\right)
\end{equation*}
\]</span></p></li>
<li><p>对期望项：</p>
<p><span class="math display">\[
\begin{equation*}
\lambda_1 \left( \int x (p + \epsilon \eta) \diff x - \mu \right)
= \lambda_1 \left( \int x p \, \diff x - \mu + \epsilon \int x \eta \,
\diff x \right)
\end{equation*}
\]</span></p></li>
<li><p>对方差项：</p>
<p><span class="math display">\[
\begin{equation*}
\lambda_2 \left( \int (x - \mu)^2 (p + \epsilon \eta) \diff x - \sigma^2
\right)
= \lambda_2 \left( \int (x - \mu)^2 p \, \diff x - \sigma^2 + \epsilon
\int (x - \mu)^2 \eta(x) \diff x \right)
\end{equation*}
\]</span></p></li>
</ul>
<hr>
<p>将所有一阶 <span class="math inline">\(\epsilon\)</span>
项收集起来：</p>
<p><span class="math display">\[
\begin{equation*}
\mathcal{L}[p + \epsilon \eta] = \mathcal{L}[p]
+ \epsilon \int \eta(x) \left[ - (1 + \ln p(x)) + \lambda_0 + \lambda_1
x + \lambda_2 (x - \mu)^2 \right] \diff x + o(\epsilon)
\end{equation*}
\]</span></p>
<p>对 <span class="math inline">\(\epsilon\)</span> 求导并令其在 <span class="math inline">\(\epsilon = 0\)</span> 处为零：</p>
<p><span class="math display">\[
\begin{equation*}
\left. \frac{\diff}{\diff \epsilon} \mathcal{L}[p + \epsilon \eta]
\right|_{\epsilon=0}
= \int \eta(x) \left[ -\ln p(x) - 1 + \lambda_0 + \lambda_1 x +
\lambda_2 (x - \mu)^2 \right] \diff x = 0
\end{equation*}
\]</span></p>
<p>根据变分法基本引理，这个积分当且仅当括号内为 <span class="math inline">\(0\)</span> 时对所有扰动函数 <span class="math inline">\(\eta(x)\)</span> 为零：</p>
<blockquote>
<p>变分法基本引理：</p>
<p>若函数 <span class="math inline">\(F(x)\)</span> 满足 <span class="math display">\[
\int_{a}^{b} F(x) \cdot \eta(x) dx = 0
\]</span> 对所有合适扰动 <span class="math inline">\(\eta(x)\)</span>
成立，则必有 <span class="math display">\[
F(x) = 0 \quad \forall x \in (a, b)
\]</span></p>
<p>这是因为若 <span class="math inline">\(F(x_0) \ne
0\)</span>，则可构造在 <span class="math inline">\(x_0\)</span>
附近支持的 <span class="math inline">\(\eta(x)\)</span>
使得积分不为零，导致矛盾。</p>
</blockquote>
<p><span class="math display">\[
\begin{equation*}
\frac{\delta \mathcal{L}}{\delta p(x)} = -\ln p(x) - 1 + \lambda_0 +
\lambda_1 x + \lambda_2 (x - \mu)^2 = 0
\end{equation*}
\]</span></p>
<p>也即求得了变分导数。移项得：</p>
<p><span class="math display">\[
\begin{equation*}
\ln p(x) = \lambda_0' + \lambda_1 x + \lambda_2 (x - \mu)^2
\end{equation*}
\]</span></p>
<p>两边取指数：</p>
<p><span class="math display">\[
\begin{equation*}
p(x) = \exp\left( \lambda_0' + \lambda_1 x + \lambda_2 (x - \mu)^2
\right)
\end{equation*}
\]</span></p>
<p>要满足可积性，需 <span class="math inline">\(\lambda_2 &lt;
0\)</span>。设</p>
<p><span class="math display">\[
\begin{equation*}
p(x) = A \cdot \exp\left( -\alpha (x - \mu)^2 \right)
\end{equation*}
\]</span></p>
<h1 id="归一化与确定参数">归一化与确定参数</h1>
<p>根据归一化条件：</p>
<p><span class="math display">\[
\begin{equation*}
A \cdot \int_{-\infty}^{\infty} \exp\left( -\alpha (x - \mu)^2 \right)
\diff x = 1
\end{equation*}
\]</span></p>
<p>已知高斯积分结果：</p>
<p><span class="math display">\[
\begin{equation*}
\int_{-\infty}^{\infty} \exp\left( -\alpha (x - \mu)^2 \right) \diff x =
\sqrt{\frac{\pi}{\alpha}}
\end{equation*}
\]</span></p>
<p>得到：</p>
<p><span class="math display">\[
\begin{equation*}
A = \sqrt{\frac{\alpha}{\pi}}
\end{equation*}
\]</span></p>
<p>若令 <span class="math inline">\(\alpha =
\dfrac{1}{2\sigma^2}\)</span>，则最终得：</p>
<p><span class="math display">\[
\begin{equation*}
p(x) = \frac{1}{\sqrt{2\pi\sigma^2}} \exp\left( -\frac{(x -
\mu)^2}{2\sigma^2} \right)
\end{equation*}
\]</span></p>
<h1 id="总结">总结</h1>
<p>从最大熵原理出发，在已知均值与方差的约束下，最“无偏”或熵最大的概率密度函数是：</p>
<p><span class="math display">\[
\begin{equation*}
p(x) = \frac{1}{\sqrt{2\pi\sigma^2}} \exp\left( -\frac{(x -
\mu)^2}{2\sigma^2} \right)
\end{equation*}
\]</span></p>
<p>这正是<strong>高斯分布</strong>的标准形式，说明它不仅数学上方便，<strong>信息论上也是最合理的选择</strong>。</p>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/css/markmap.css">

<script src="/js/markmap.js"></script>
]]></content>
      <categories>
        <category>数学</category>
        <category>概率论</category>
      </categories>
      <tags>
        <tag>高斯分布</tag>
        <tag>信息论</tag>
      </tags>
  </entry>
  <entry>
    <title>Josh&#39;s Note — 凸优化&lt;br&gt;Part 2.2 凸函数—保凸运算</title>
    <url>/posts/c3476904.html</url>
    <content><![CDATA[<p>$
$  本文讨论几种保持函数凸性或者凹性的运算，这样可以构造新的凸函数或者凹函数。首先从一些简单的运算开始，如求和、伸缩以及逐点上确界，之后再介绍一些更为复杂的运算（其中一些运算的特例即为简单运算）。</p>
<h1 id="非负加权求和">1. 非负加权求和</h1>
<p>  显然，若函数 <span class="math inline">\(f\)</span> 是凸函数且
<span class="math inline">\(\alpha\geqslant0\)</span>，则函数 <span class="math inline">\(\alpha f\)</span> 也是凸函数。若函数 <span class="math inline">\(f_1\)</span> 和 <span class="math inline">\(f_2\)</span> 都是凸函数，则它们的和 <span class="math inline">\(f_1+f_2\)</span>
也是凸函数。将非负伸缩以及求和运算结合起来，可以看出，凸函数的集合本身是一个凸锥：凸函数的非负加权求和仍然是凸函数，即函数</p>
<p><span class="math display">\[
f=w_1f_1+\cdots+w_mf_m
\]</span></p>
<p>是凸函数。类似地，凹函数的非负加权求和仍然是凹函数。严格凸（凹）函数的非负，非零加权求和是严格凸（凹）函数。</p>
<p>  这个性质可以扩展至无限项的求和以及积分的情形。例如，若对于每一个
<span class="math inline">\(y\in\mathcal{A}\)</span>，函数 <span class="math inline">\(f(x,y)\)</span> 关于 <span class="math inline">\(x\)</span> 都是凸函数，且 <span class="math inline">\(w(y)\geqslant 0\)</span>，则函数</p>
<p><span class="math display">\[
g(x)=\int_{\mathcal{A}}w(y)f(x,y)\mathrm{d}y
\]</span></p>
<p>关于 <span class="math inline">\(x\)</span>是凸函数（若此积分存在）。</p>
<span id="more"></span>
<p>  容易验证非负伸缩以及求和运算是保凸运算，或者可以根据相关的上境图得到此结论。例如，若
<span class="math inline">\(w\geqslant 0\)</span> 且 <span class="math inline">\(f\)</span> 是凸函数，则有</p>
<p><span class="math display">\[
\mathop{\bf epi}(wf)=\left[\begin{array}{cc}
I&amp;0\\
0&amp;w
\end{array}\right]\mathop{\bf epi}f
\]</span></p>
<p>因为凸集通过线性变换得到的像仍然是凸集，所以 <span class="math inline">\(\mathop{\bf epi}(wf)\)</span> 是凸集。</p>
<details class="note info"><summary><p>注解</p>
</summary>
<p>这里对上镜图的相关结论进行解释。函数 <span class="math inline">\(f:\mathbf{R}^{n}\to\mathbf{R}\)</span>
的上镜图定义为</p>
<p><span class="math display">\[
\epi f=\{(x,t)\mid f(x)\leqslant t\}
\]</span></p>
<p>则有</p>
<p><span class="math display">\[\begin{aligned}
  \left[\begin{array}{cc}
    I&amp;0\\
    0&amp;w
  \end{array}\right]\epi f&amp;=\left\{\left[\begin{array}{cc}
    I&amp;0\\
    0&amp;w
  \end{array}\right](x,t)\:\middle|\: f(x)\leqslant t\right\}
  \\
  &amp;= \{(x,wt)\mid f(x)\leqslant t\}
  \\
  &amp;= \{(x,t)\mid wf(x)\leqslant t\}
  \\
  &amp;= \epi (wf)
\end{aligned}
\]</span></p>

</details>
<h1 id="复合仿射映射">2. 复合仿射映射</h1>
<p>  假设函数 <span class="math inline">\(f:\mathbf{R}^n\to\mathbf{R}\)</span>，<span class="math inline">\(A\in\mathbf{R}^{n\times m}\)</span>，<span class="math inline">\(b\in\mathbf{R}^n\)</span>，定义<strong>复合仿射映射</strong>（<em>composition
with an affine mapping</em>）$ g:^m$ 为</p>
<p><span class="math display">\[
g(x)=f(Ax+b)
\]</span></p>
<p>其中 <span class="math inline">\(\mathop{\bf dom}g=\{x\mid
Ax+b\in\mathop{\bf dom}f\}\)</span>。若函数 <span class="math inline">\(f\)</span> 是凸函数，则函数 <span class="math inline">\(g\)</span> 是凸函数；若函数 <span class="math inline">\(f\)</span> 是凹函数，则函数 <span class="math inline">\(g\)</span> 是凹函数。</p>
<h1 id="逐点最大和逐点上确界">3. 逐点最大和逐点上确界</h1>
<h2 id="逐点最大">3.1 逐点最大</h2>
<p>  若函数 <span class="math inline">\(f_{1}\)</span> 和 <span class="math inline">\(f_{2}\)</span>
均为凸函数，则二者的<strong>逐点最大</strong>（<em>pointwise
maximum</em>）函数</p>
<p><span class="math display">\[
f(x)=\max\{f_1(x),f_2(x)\}
\]</span></p>
<p>其定义域为 <span class="math inline">\(\mathop{\bf dom}f=\mathop{\bf
dom}f_1\cap\mathop{\bf
dom}f_2\)</span>，仍然是凸函数。这个性质很容易验证：任取 <span class="math inline">\(0\leqslant \theta \leqslant 1\)</span> 以及 <span class="math inline">\(x,y\in\mathop{\bf dom}f\)</span>，有</p>
<p><span class="math display">\[\begin{aligned}
f(\theta x+(1-\theta)y)&amp;=\max\{f_1(\theta x+(1-\theta)y),f_2(\theta
x+(1-\theta)y)\}
\\
&amp;\leqslant\max\{\theta f_1(x)+(1-\theta)f_1(y),\theta
f_2(x)+(1-\theta)f_2(y)\}
\\
&amp;\leqslant\theta\max\{f_1(x),f_2(x)\}+(1-\theta)\max\{f_1(y),f_2(y)\}
\\
&amp;=\theta f(x)+(1-\theta)f(y)
\end{aligned}\]</span></p>
<p>从而得到了函数 <span class="math inline">\(f\)</span>
的凸性。同样很容易证明，若函数 <span class="math inline">\(f_1,\cdots,f_m\)</span>
为凸函数，则它们的逐点最大函数</p>
<p><span class="math display">\[
f(x)=\max\{f_1(x),\cdots,f_m(x)\}
\]</span></p>
<p>仍然是凸函数。</p>
<blockquote>
<p><strong>举例</strong> <strong>分段线性函数</strong>（<em>Piecewise-linear
functions</em>）。函数</p>
<p><span class="math display">\[
f(x)=\max\left\{a_1^\mathrm{T}x+b_1,\cdots,a_L^\mathrm{T}x+b_L\right\}
\]</span></p>
<p>定义了一个（具有不大于 <span class="math inline">\(L\)</span>
个子区域的）分段线性函数（实际上是仿射函数）。因为它是一系列仿射函数的逐点最大函数，所以它是凸函数。反之亦成立：任意具有不大于
<span class="math inline">\(L\)</span>
个子区域的分段线性凸函数都可以表述成上述形式。</p>
<details class="note info"><summary><p>注解</p>
</summary>
<blockquote>
<p>参考 Wikipedia，<a href="https://en.wikipedia.org/wiki/Piecewise_linear_function">分段线性函数词条</a>即为我们通常理解的分段函数，但是这里的分段线性函数有所不同，定义为多个分段函数的逐点最大，因此数凸的。</p>
<p>关于子区域数量，可以这样理解：若 <span class="math inline">\(L\)</span>
个仿射函数相邻两段各不相同，则每一段仿射函数均对应着一个子区域，因此最多共有
<span class="math inline">\(L\)</span> 个子区域。</p>
</blockquote>

</details>
</blockquote>
<blockquote>
<p><strong>举例</strong> <strong>最大 <span class="math inline">\(r\)</span> 个分量之和</strong>。对于任意 <span class="math inline">\(x\in\mathbf{R}^n\)</span>，用 <span class="math inline">\(x_{[i]}\)</span> 表示 <span class="math inline">\(x\)</span> 中第 <span class="math inline">\(i\)</span> 大的分量，将 <span class="math inline">\(x\)</span> 的分量按照非升序进行排列</p>
<p><span class="math display">\[
x_{[1]}\geqslant x_{[2]}\geqslant\cdots\geqslant x_{[n]}
\]</span></p>
<p>则对 <span class="math inline">\(x\)</span> 的最大 <span class="math inline">\(r\)</span> 个分量进行求和所得到的函数</p>
<p><span class="math display">\[
f(x)=\sum_{i=1}^rx_{[i]}
\]</span></p>
<p>是凸函数。事实上，此函数可以表述为</p>
<p><span class="math display">\[
f(x)=\sum_{i=1}^rx_{[i]}=\max\{x_{i_1}+\cdots+x_{i_r}\mid1\leqslant
i_1&lt;i_2&lt;\cdots&lt;i_r\leqslant n\}
\]</span></p>
<p>即从 <span class="math inline">\(x\)</span> 的分量中选取 <span class="math inline">\(r\)</span>
个不同分量进行求和的所有可能组合的最大值。因为函数 <span class="math inline">\(f\)</span> 是 <span class="math inline">\(\displaystyle\frac{n!}{r!(n-r)!}\)</span>
个线性函数的逐点最大，所以是凸函数。</p>
<p>进一步可以证明，当 <span class="math inline">\(w_1\geqslant
w_2\geqslant\cdots\geqslant w_r\geqslant 0\)</span> 时，函数 <span class="math inline">\(\displaystyle\sum_{i=1}^rw_ix_{[i]}\)</span>
是凸函数。</p>
</blockquote>
<h2 id="逐点上确界">3.2 逐点上确界</h2>
<p>  逐点最大的性质可以扩展至无限个凸函数的<strong>逐点上确界</strong>（<em>pointwise
supremum</em>）。</p>
<details class="note info"><summary><p>上确界和下确界</p>
</summary>
<p>  假定 <span class="math inline">\(C\subseteq\mathbf{R}\)</span>。若对每个 <span class="math inline">\(x\in C\)</span> 均有 <span class="math inline">\(x\leqslant a\)</span>，则称 <span class="math inline">\(a\)</span> 是 <span class="math inline">\(C\)</span> 的<strong>上界</strong>（<em>upper
bound</em>）。<span class="math inline">\(C\)</span>
的上界组成的集合或是空集（此时称 <span class="math inline">\(C\)</span>
无上界），或等于 <span class="math inline">\(\mathbf{R}\)</span>（仅当
<span class="math inline">\(C=\emptyset\)</span> 时），或是闭的无限区间
<span class="math inline">\([b,\infty)\)</span>。称 <span class="math inline">\(b\)</span> 为 <span class="math inline">\(C\)</span> 的<strong>最小上界</strong>（<em>least
upper bound</em>）或<strong>上确界</strong>（<em>supremum</em>），用
<span class="math inline">\(\sup C\)</span> 表示。规定 <span class="math inline">\(\sup\emptyset=-\infty\)</span>，当 <span class="math inline">\(C\)</span> 无上界时取 <span class="math inline">\(\sup C=\infty\)</span>。当 <span class="math inline">\(\sup C\in C\)</span> 时，称 <span class="math inline">\(C\)</span> 的上确界是可达的。</p>
<p>  当 <span class="math inline">\(C\)</span> 是有限集时，<span class="math inline">\(\sup C\)</span>
是它所有元素的最大值。一些作者用符号 <span class="math inline">\(\max
C\)</span> 表示可达的上确界，但我们采用标准的数学习惯，只在 <span class="math inline">\(C\)</span> 是有限集时用 <span class="math inline">\(\max C\)</span>。</p>
<p>  类似地，可以定义下界和下确界。若对每个 <span class="math inline">\(x\in C\)</span> 均有 <span class="math inline">\(a\leqslant x\)</span>，则称 <span class="math inline">\(a\)</span> 是 <span class="math inline">\(C\subseteq\mathbf{R}\)</span> 的下界。<span class="math inline">\(C\subseteq\mathbf{R}\)</span>
的<strong>下确界</strong>（<em>infimum</em>）或<strong>最大下界</strong>（<em>greatest
lower bound</em>）定义为 <span class="math inline">\(\inf
C=-\sup(-C)\)</span>。当 <span class="math inline">\(C\)</span>
是有限集时，下确界是它所有元素的最小值。规定 <span class="math inline">\(\inf\emptyset=\infty\)</span>，并在 <span class="math inline">\(C\)</span> 无下界时，取 <span class="math inline">\(\inf C=-\infty\)</span>。</p>

</details>
<p>  若对于任意 <span class="math inline">\(y\in\mathcal{A}\)</span>，函数 <span class="math inline">\(f(x,y)\)</span> 关于 <span class="math inline">\(x\)</span> 都是凸的，则函数</p>
<p><span class="math display">\[\begin{equation}\label{PointwiseMaximum}
g(x)=\sup_{y\in\mathcal{A}}f(x,y)
\end{equation}\]</span></p>
<p>关于 <span class="math inline">\(x\)</span> 亦是凸的。此时，函数
<span class="math inline">\(g\)</span> 的定义域为</p>
<p><span class="math display">\[
\mathop{\bf dom}g=\{x\mid(x,y)\in\mathop{\bf dom}f\:\forall
y\in\mathcal{A},\sup_{y\in\mathcal{A}}f(x,y)&lt;\infty\}
\]</span></p>
<p>类似地，一系列凹函数的逐点下确界仍然是凹函数。</p>
<p>  从上境图的角度理解，一系列函数的逐点上确界函数对应着这些函数上境图的交集：对于函数
<span class="math inline">\(f\)</span>，<span class="math inline">\(g\)</span> 以及式 <span class="math inline">\(\eqref{PointwiseMaximum}\)</span> 定义的 <span class="math inline">\(\mathcal{A}\)</span>，有</p>
<p><span class="math display">\[
\mathop{\bf epi}g=\bigcap_{y\in\mathcal{A}}\mathop{\bf
epi}f(\:\cdot\:,y)
\]</span></p>
<p>因此，函数 <span class="math inline">\(g\)</span>
的凸性可由一系列凸集的交集仍然是凸集得到。</p>
<blockquote>
<p><strong>举例</strong> <strong>集合的支撑函数</strong>。令集合 <span class="math inline">\(C\subseteq\mathbf{R}^n\)</span>，且 <span class="math inline">\(C\neq\emptyset\)</span>，定义集合 <span class="math inline">\(C\)</span>
的<strong>支撑函数</strong>（<em>support function</em>）<span class="math inline">\(S_C\)</span> 为</p>
<p><span class="math display">\[
S_C(x)=\sup\{x^\mathrm{T}y\mid y\in C\}
\]</span></p>
<p>（自然地，函数 <span class="math inline">\(S_C\)</span> 的定义域为
<span class="math inline">\(\mathop{\bf dom}S_{C}=\left\{x\mid\sup_{y\in
C}x^\mathrm{T}y&lt;\infty\right\}\)</span>）。</p>
<p>对于任意 <span class="math inline">\(y\in C\)</span>，<span class="math inline">\(x^\mathrm{T}y\)</span> 是 <span class="math inline">\(x\)</span> 的线性函数，所以 <span class="math inline">\(S_{C}\)</span>
是一系列线性函数的逐点上确界函数，因此是凸函数。</p>
</blockquote>
<blockquote>
<p><strong>举例</strong> <strong>到集合中最远点的距离</strong>。令集合
<span class="math inline">\(C\subseteq\mathbf{R}^n\)</span>，定义点
<span class="math inline">\(x\)</span>
与集合中最远点的距离（范数）为</p>
<p><span class="math display">\[
f(x)=\sup_{y\in C}\|x-y\|
\]</span></p>
<p>此函数是凸函数。为了说明这一点，我们注意到，对于任意 <span class="math inline">\(y\)</span>，函数 <span class="math inline">\(\|x-y\|\)</span> 关于 <span class="math inline">\(x\)</span> 是凸函数。因为函数 <span class="math inline">\(f\)</span> 是一族凸函数（对应不同的 <span class="math inline">\(y\in C\)</span>）的逐点上确界，所以是凸函数。</p>
</blockquote>
<blockquote>
<p><strong>举例</strong> <strong>以权为变量的最小二乘代价函数</strong>。令
<span class="math inline">\(a_1,\cdots,a_n\in\mathbf{R}^m\)</span>，在加权最小二乘问题中我们对所有的
<span class="math inline">\(x\in\mathbf{R}^m\)</span> 极小化目标函数
<span class="math inline">\(\displaystyle\sum_{i=1}^nw_i(a_i^\mathrm{T}x-b_i)^2\)</span>。我们称
<span class="math inline">\(w_i\)</span>
为<strong>权</strong>（<em>weight</em>），并允许 <span class="math inline">\(w_i\)</span> 为负（则目标函数有可能无下界）。</p>
<p>定义（最优）<strong>加权最小二乘代价</strong>（<em>weighted
least-squares cost</em>）函数为</p>
<p><span class="math display">\[
g(w)=\inf_{x}\sum_{i=1}^{n}w_{i}(a_{i}^{\mathrm{T}}x-b_{i})^{2}
\]</span></p>
<p>其定义域为</p>
<p><span class="math display">\[\mathop{\bf
dom}g=\left\{w\,\middle|\,\inf_{x}\sum_{i=1}^{n}w_{i}(a_{i}^{\mathrm{T}}x-b_{i})^{2}&gt;-\infty\right\}\]</span></p>
<p>因为函数 <span class="math inline">\(g\)</span> 是一族关于 <span class="math inline">\(w\)</span> 的线性函数的下确界（对应于不同的 <span class="math inline">\(x\in\mathbf{R}^m\)</span>），它是 <span class="math inline">\(w\)</span> 的凹函数。</p>
<p>至少在部分定义域上，我们可以得到函数 <span class="math inline">\(g\)</span> 的一个显式表达式。令 <span class="math inline">\(W=\mathop{\bf diag}(w)\)</span>
是一对角阵，其对角线元素为 <span class="math inline">\(w_1,\cdots,w_n\)</span>，令 <span class="math inline">\(A\in\mathbf{R}^{n\times m}\)</span>，其行向量为
<span class="math inline">\(a_i^\mathrm{T}\)</span>，有</p>
<p><span class="math display">\[
g(w)=\inf_{x}(Ax-b)^{\mathrm{T}}W(Ax-b)=\inf_{x}(x^{\mathrm{T}}A^{\mathrm{T}}WAx-2b^{\mathrm{T}}WAx+b^{\mathrm{T}}Wb)
\]</span></p>
<p>从上式可以看出，若 <span class="math inline">\(A^{\mathrm{T}}WA\not\succeq0\)</span>，括号里的二次函数关于
<span class="math inline">\(x\)</span> 无下界，故 <span class="math inline">\(g(w)=-\infty\)</span>，即 <span class="math inline">\(w\not\in\mathop{\bf dom}g\)</span>。当 <span class="math inline">\(A^\mathrm{T}WA\succ0\)</span>
时（即定义了一个严格的线性矩阵不等式），通过解析求解二次函数的极小值，可以得到函数
<span class="math inline">\(g\)</span> 的一个简单的表达式</p>
<p><span class="math display">\[\begin{aligned}
  g(w)&amp;=b^{\mathrm{T}}Wb-b^{\mathrm{T}}WA(A^{\mathrm{T}}WA)^{-1}A^{\mathrm{T}}Wb
  \\
  &amp;=\sum_{i=1}^{n}w_{i}b_{i}^{2}-\sum_{i=1}^{n}w_{i}^{2}b_{i}^{2}a_{i}^{\mathrm{T}}\left(\sum_{j=1}^{n}w_{j}a_{j}a_{j}^{\mathrm{T}}\right)^{-1}a_{i}
\end{aligned}\]</span></p>
<p>从上述表达式并不能立即得到函数 <span class="math inline">\(g\)</span>
的凹性（不过可以从矩阵分式函数的凸性来推导函数 <span class="math inline">\(g\)</span> 的凹性）。</p>
</blockquote>
<blockquote>
<p><strong>举例</strong> <strong>对称矩阵的最大特征值</strong>。
定义函数 <span class="math inline">\(f(X)=\lambda_{\max}(X)\)</span>，其定义域为 <span class="math inline">\(\mathop{\bf
dom}f=\mathbf{S}^m\)</span>，它是凸函数。为了说明这一点，我们将 <span class="math inline">\(f\)</span> 表述为</p>
<p><span class="math display">\[
f(X)=\sup\{y^\mathrm{T}Xy\mid\|y\|_2=1\}
\]</span></p>
<p>即针对不同的 <span class="math inline">\(y\in\mathbf{R}^m\)</span>
关于 <span class="math inline">\(X\)</span> 的一族线性函数（即<span class="math inline">\(y^\mathrm{T}Xy\)</span>）的逐点上确界。</p>
</blockquote>
<blockquote>
<p><strong>举例</strong> <strong>矩阵范数</strong>。考虑函数 <span class="math inline">\(f(X)=\|X\|_2\)</span>，其定义域为 <span class="math inline">\(\mathop{\bf dom}f=\mathbf{R}^{p\times
q}\)</span>，其中 <span class="math inline">\(\|\cdot\|_2\)</span>
表示谱范数或者最大奇异值。函数 <span class="math inline">\(f\)</span>
可以表述为</p>
<p><span class="math display">\[
f(X)=\sup\{u^{\mathrm{T}}Xv\mid\|u\|_{2}=1,\|v\|_{2}=1\}
\]</span></p>
<p>由于它是 <span class="math inline">\(X\)</span>
的一族线性函数的逐点上确界，所以是凸函数。</p>
<p>作为一个推广，假设 <span class="math inline">\(\|\cdot\|_a\)</span>和<span class="math inline">\(\|\cdot\|_b\)</span> 分别是 <span class="math inline">\(\mathbf{R}^p\)</span> 和 <span class="math inline">\(\mathbf{R}^q\)</span> 上的范数，定义矩阵 <span class="math inline">\(X\in\mathbf{R}^{p\times q}\)</span>
的诱导范数为</p>
<p><span class="math display">\[
\|X\|_{a,b}=\sup_{v\neq0}\frac{\|Xv\|_{a}}{\|v\|_{b}}
\]</span></p>
</blockquote>
<h2 id="表示成一族仿射函数的逐点上确界">3.3
表示成一族仿射函数的逐点上确界</h2>
<p>  上述例子描述了一个建立函数凸性的好方法：将函数表示为一族仿射函数的逐点上确界。除了一个技术条件，反过来也是成立的：几乎所有的凸函数都可以表示成一族仿射函数的逐点上确界。例如，若函数
<span class="math inline">\(f:\mathbf{R}^n\to\mathbf{R}\)</span>
是凸函数，其定义域为 <span class="math inline">\(\mathop{\bf
dom}f=\mathbf{R}^n\)</span>，我们有</p>
<p><span class="math display">\[
f(x)=\sup\{g(x)\mid g\:\text{仿射},\:g(z)\leqslant f(z)\:\forall z\}
\]</span></p>
<p>换言之，函数 <span class="math inline">\(f\)</span>
是它所有的仿射全局下估计的逐点上确界。下面我们将证明这个结论。</p>
<p>  设函数 <span class="math inline">\(f\)</span> 是凸函数，定义域为
<span class="math inline">\(\mathop{\bf dom}f=\mathbf{R}^{n}\)</span>
，显然下面的不等式成立</p>
<p><span class="math display">\[
f ( x ) \geqslant \sup \{g ( x ) \mid g\:\text{仿射}, \ g ( z )
\leqslant f ( z ) \ \forall z \},
\]</span></p>
<p>因为函数 <span class="math inline">\(g\)</span> 是函数 <span class="math inline">\(f\)</span> 的任意仿射下估计，我们有 <span class="math inline">\(g ( x ) \leqslant f ( x
)\)</span>。为了建立等式，我们说明，对于任意 <span class="math inline">\(x \in\mathbf{R}^{n}\)</span>，存在仿射函数 <span class="math inline">\(g\)</span> 是函数 <span class="math inline">\(f\)</span> 的全局下估计，并且满足 <span class="math inline">\(g ( x )=f ( x )\)</span>。</p>
<p>  毫无疑问，函数 <span class="math inline">\(f\)</span>
的上境图是凸集，因此我们在点 <span class="math inline">\(( x, f ( x )
)\)</span> 处可以找到此凸集的支撑超平面，即存在 <span class="math inline">\(a \in\mathbf{R}^{n}\)</span>，<span class="math inline">\(\; b \in\mathbf{R}\)</span> 且 <span class="math inline">\(( a, b ) \neq0\)</span>，使得对任意 <span class="math inline">\(( z, t ) \in\mathop{\bf epi}f\)</span>，有</p>
<p><span class="math display">\[
\left[ \begin{array} {c} a \\ b \\ \end{array} \right]^{\mathrm{T}}
\left[ \begin{array} {c} {x-z} \\ {f ( x )-t} \\ \end{array} \right]
\leqslant0.
\]</span></p>
<p>即对任意 <span class="math inline">\(z\in\mathop{\bf
dom}f=\mathbf{R}^n\)</span> 以及所有 <span class="math inline">\(s\geqslant0\)</span>（<span class="math inline">\((z,t)\in\mathop{\bf epi}f\)</span> 等价于存在
<span class="math inline">\(s\geqslant0\)</span> 使得 <span class="math inline">\(t=f(z)+s\)</span>），下式成立</p>
<p><span class="math display">\[\begin{equation}\label{ProofOfAffineFunctionRepresentation}
  a^\mathrm{T}(x-z)+b(f(x)-f(z)-s)\leqslant0
\end{equation}
\]</span></p>
<p>为了保证不等式 <span class="math inline">\(\eqref{ProofOfAffineFunctionRepresentation}\)</span>
对所有的 <span class="math inline">\(s\geqslant0\)</span> 均成立，必须有
<span class="math inline">\(b\geqslant0\)</span>。若 <span class="math inline">\(b=0\)</span>，对所有的<span class="math inline">\(z\in\mathbf{R}^n\)</span>，不等式 <span class="math inline">\(\eqref{ProofOfAffineFunctionRepresentation}\)</span>
可以简化为 <span class="math inline">\(a^\mathrm{T}(x-z)\leqslant0\)</span>，这意味着
<span class="math inline">\(a=0\)</span>，于是和假设 <span class="math inline">\((a,b)\neq0\)</span> 矛盾。因此 <span class="math inline">\(b&gt;0\)</span>，即支撑超平面不是竖直的。</p>
<p>  我们知道 <span class="math inline">\(b&gt;0\)</span>，因此，对任意
<span class="math inline">\(z\)</span>，令 <span class="math inline">\(s=0\)</span>，式 <span class="math inline">\(\eqref{ProofOfAffineFunctionRepresentation}\)</span>
可以重新表述为</p>
<p><span class="math display">\[
g(z)=f(x)+(a/b)^{\mathrm{T}}(x-z)\leqslant f(z)
\]</span></p>
<p>由此说明函数 <span class="math inline">\(g\)</span> 是函数 <span class="math inline">\(f\)</span> 的一个仿射下估计，并且满足 <span class="math inline">\(g(x)=f(x)\)</span>。</p>
<h1 id="复合">4. 复合</h1>
<p>  本节给定函数 <span class="math inline">\(h:\mathbf{R}^k\to\mathbf{R}\)</span> 以及 <span class="math inline">\(g:\mathbf{R}^n\to\mathbf{R}^k\)</span>，定义复合函数
<span class="math inline">\(f=h\circ
g:\mathbf{R}^n\to\mathbf{R}\)</span> 为</p>
<p><span class="math display">\[
f(x)=h(g(x)),\quad\mathop{\bf dom}f=\{x\in\mathop{\bf dom}g\mid
g(x)\in\mathop{\bf dom}h\}
\]</span></p>
<p>我们考虑当函数 <span class="math inline">\(f\)</span>
保凸或者保凹时，函数 <span class="math inline">\(h\)</span> 和 <span class="math inline">\(g\)</span> 必须满足的条件。</p>
<h2 id="标量复合">4.1 标量复合</h2>
<p>  首先考虑 <span class="math inline">\(k=1\)</span> 的情况，即 <span class="math inline">\(h:\mathbf{R}\to\mathbf{R}\)</span>，<span class="math inline">\(g:\mathbf{R}^n\to\mathbf{R}\)</span>。仅考虑 <span class="math inline">\(n=1\)</span>
的情况（事实上，将函数限定在与其定义域相交的任意直线上得到的函数决定了原函数的凸性）。</p>
<p>  为了找出复合规律，首先假设函数 <span class="math inline">\(h\)</span> 和 <span class="math inline">\(g\)</span> 是二次可微的，且 <span class="math inline">\(\mathop{\bf dom}g= \mathop{\bf dom}h=
\mathbf{R}\)</span>。在上述假设下，函数 <span class="math inline">\(f\)</span> 是凸的等价于 <span class="math inline">\(f^{\prime\prime}\geqslant 0\)</span>（即对所有的
<span class="math inline">\(x\in\mathbf{R}\)</span>，<span class="math inline">\(f^{\prime\prime}(x)\geqslant 0\)</span>）。</p>
<p>  复合函数 <span class="math inline">\(f=h\circ g\)</span>
的二阶导数为</p>
<p><span class="math display">\[\begin{equation}\label{SecondDerivativeOfScalarCompositionFunction}
  f''(x)=h''(g(x))g'(x)^2+h'(g(x))g''(x)
\end{equation}\]</span></p>
<p>假设函数 <span class="math inline">\(g\)</span> 是凸函数（<span class="math inline">\(g^{\prime\prime}\geqslant 0\)</span>），函数 <span class="math inline">\(h\)</span> 是凸函数且非减（即<span class="math inline">\(h^{\prime\prime}\geqslant0\)</span> 且 <span class="math inline">\(h^{\prime}\geqslant0\)</span>），从式 <span class="math inline">\(\eqref{SecondDerivativeOfScalarCompositionFunction}\)</span>
可以得出 <span class="math inline">\(f^{\prime\prime}\geqslant
0\)</span>，即函数 <span class="math inline">\(f\)</span>
是凸函数。类似地，由式 <span class="math inline">\(\eqref{SecondDerivativeOfScalarCompositionFunction}\)</span>
可以得出如下结论</p>
<p><span class="math display">\[\begin{equation}\label{Conclusion1}\begin{aligned}
  若\,h\,是凸函数且非减，g\,是凸函数，则\,f\,是凸函数，\\
  若\,h\,是凸函数且非增，g\,是凹函数，则\,f\,是凸函数，\\
  若\,h\,是凹函数且非减，g\,是凹函数，则\,f\,是凹函数，\\
  若\,h\,是凹函数且非增，g\,是凸函数，则\,f\,是凹函数。
\end{aligned}\end{equation}\]</span></p>
<p>上述结论在函数 <span class="math inline">\(g\)</span> 和 <span class="math inline">\(h\)</span> 二次可微且定义域均为 <span class="math inline">\(\mathbf{R}\)</span>
时成立。事实上，对于更一般的情况，如 <span class="math inline">\(n&gt;1\)</span>，不再假设函数 <span class="math inline">\(h\)</span> 和 <span class="math inline">\(g\)</span> 可微或者 <span class="math inline">\(\mathop{\bf dom}g=\mathbf{R}^n\)</span>，<span class="math inline">\(\mathop{\bf
dom}h=\mathbf{R}\)</span>，一些相似的复合规则仍然成立</p>
<p><span class="math display">\[\begin{equation}\label{Conclusion2}\begin{aligned}
  若\,h\,是凸函数且\,\tilde{h}\,非减，\,g\,是凸函数，则\,f\,是凸函数，\\
  若\,h\,是凸函数且\,\tilde{h}\,非增，\,g\,是凹函数，则\,f\,是凸函数，\\
  若\,h\,是凹函数且\,\tilde{h}\,非减，\,g\,是凹函数，则\,f\,是凹函数，\\
  若\,h\,是凹函数且\,\tilde{h}\,非增，\,g\,是凸函数，则\,f\,是凹函数。
\end{aligned}\end{equation}\]</span></p>
<p>其中，<span class="math inline">\(\tilde{h}\)</span> 表示函数 <span class="math inline">\(h\)</span> 的扩展值延伸，若点不在 <span class="math inline">\(\mathop{\bf dom}h\)</span> 内，对其赋值 <span class="math inline">\(\infty\)</span>（若 <span class="math inline">\(h\)</span> 是凸函数）或者<span class="math inline">\(-\infty\)</span>（若 <span class="math inline">\(h\)</span> 是凹函数）。这些结论和式 <span class="math inline">\(\eqref{Conclusion1}\)</span>
中的结论的唯一不同是我们要求<strong>扩展值延伸</strong>（<em>extended-value
extension</em>）<span class="math inline">\(\tilde{h}\)</span> 在整个
<span class="math inline">\(\mathbf{R}\)</span> 上非增或者非减。</p>
<p>  为了更好地理解式 <span class="math inline">\(\eqref{Conclusion2}\)</span> 中的结论，假设 <span class="math inline">\(h\)</span> 是凸函数，所以 <span class="math inline">\(\tilde{h}\)</span> 在定义域 <span class="math inline">\(\mathop{\bf dom}h\)</span> 外取值为 <span class="math inline">\(\infty\)</span>。<span class="math inline">\(\tilde{h}\)</span> 非减意味着对于任意 <span class="math inline">\(x,y\in\mathbf{R}\)</span>，<span class="math inline">\(x&lt;y\)</span>，有 <span class="math inline">\(\tilde{h}(x)\leqslant\tilde{h}(y)\)</span>。特别地，若
<span class="math inline">\(y\in\mathop{\bf dom}h\)</span>，则 <span class="math inline">\(x\in\mathop{\bf
dom}h\)</span>。换言之，我们可以认为 <span class="math inline">\(h\)</span> 的定义域在负方向上无限延伸。它或者是
<span class="math inline">\(\mathbf{R}\)</span> 或者是形如 <span class="math inline">\((-\infty,a)\)</span> 或 <span class="math inline">\(\left(-\infty,a\right]\)</span> 的区间。类似地，若
<span class="math inline">\(h\)</span> 是凸函数且 <span class="math inline">\(\tilde{h}\)</span> 非增，我们可以理解为 <span class="math inline">\(h\)</span> 是非增的且 <span class="math inline">\(\mathop{\bf dom}h\)</span> 在正方向上趋于无穷。<a href="#图7">图 7</a> 描述了不同的扩展值延伸的情况。</p>
<p><a id="图7"></a></p>
<figure>
<img data-src="../images/post/2024-07-03-josh-cvx-2-2/2024-07-03-josh-cvx-2-2-070-ExtendedValueExtension.png" width="700" alt="图 7. 左：函数 x^2，其定义域为 \mathbf{R}_+，在其定义域内是凸且非减的，但是其扩展值延伸不是非减的。右：函数 \max\{x,0\}^2，其定义域为 \mathbf{R}，函数是凸函数，且其扩展值延伸是非减的。">
<figcaption aria-hidden="true">图 7. <strong>左</strong>：函数 <span class="math inline">\(x^2\)</span>，其定义域为 <span class="math inline">\(\mathbf{R}_+\)</span>，在其定义域内是凸且非减的，但是其扩展值延伸不是非减的。<strong>右</strong>：函数
<span class="math inline">\(\max\{x,0\}^2\)</span>，其定义域为 <span class="math inline">\(\mathbf{R}\)</span>，函数是凸函数，且其扩展值延伸是非减的。</figcaption>
</figure>
<blockquote>
<p><strong>举例</strong> 通过一些简单例子，我们可以更好地理解复合定理中函数
<span class="math inline">\(h\)</span> 需要满足的条件。</p>
<ul>
<li>函数 <span class="math inline">\(h(x)=\log x\)</span>：定义域为
<span class="math inline">\(\mathop{\bf
dom}h=\mathbf{R}_{++}\)</span>，为凹函数且 <span class="math inline">\(\tilde{h}\)</span> 非减。</li>
<li>函数 <span class="math inline">\(h(x)=x^1/2\)</span>：定义域为 <span class="math inline">\(\mathop{\bf
dom}h=\mathbf{R}_+\)</span>，为凹函数且 <span class="math inline">\(\tilde{h}\)</span> 非减。</li>
<li>函数 <span class="math inline">\(h(x)=x^{3/2}\)</span>：定义域为
<span class="math inline">\(\mathop{\bf
dom}h=\mathbf{R}_+\)</span>，为凸函数，但是<strong>不</strong>满足 <span class="math inline">\(\tilde{h}\)</span> 非减的条件。例如，<span class="math inline">\(\tilde{h}(-1)=\infty\)</span> 但 <span class="math inline">\(\tilde{h}(1)=1\)</span>。</li>
<li>当 <span class="math inline">\(x\geqslant 0\)</span> 时，<span class="math inline">\(h(x)=x^3/2\)</span>，当 <span class="math inline">\(x&lt;0\)</span> 时，<span class="math inline">\(h(x)=0\)</span>：定义域为 <span class="math inline">\(\mathop{\bf dom}h=\mathbf{R}\)</span>，<span class="math inline">\(h\)</span> 是凸函数且满足 <span class="math inline">\(\tilde{h}\)</span> 非减的条件。</li>
</ul>
</blockquote>
<p>  即使不假设可微并运用表达式 <span class="math inline">\(\eqref{SecondDerivativeOfScalarCompositionFunction}\)</span>，也可以直接证明复合函数结论式
<span class="math inline">\(\eqref{Conclusion2}\)</span>。举例来说，我们证明如下结论：若
<span class="math inline">\(g\)</span> 是凸函数，<span class="math inline">\(h\)</span> 是凸函数且 <span class="math inline">\(\tilde{h}\)</span> 非减，则 <span class="math inline">\(f=h\circ g\)</span> 是凸函数。</p>
<blockquote>
<p><strong>证明</strong> 假设 <span class="math inline">\(x,y\in\mathop{\bf dom}f\)</span>，<span class="math inline">\(0\leqslant\theta\leqslant1\)</span>。由 <span class="math inline">\(x,y\in\mathop{\bf dom}f\)</span>，有 <span class="math inline">\(x,y\in\mathop{\bf dom}g\)</span> 且 <span class="math inline">\(g( x)\)</span>, <span class="math inline">\(g( y)
\in \mathop{\bf dom}h\)</span>。因为 <span class="math inline">\(\mathop{\bf dom}g\)</span> 是凸集，有 <span class="math inline">\(\theta x+(1-\theta)y\in\mathop{\bf
dom}g\)</span>，由函数 <span class="math inline">\(g\)</span>
的凸性可得</p>
<p><span class="math display">\[\begin{equation}\label{ConvexityOfFunctionG}
  g(\theta x+(1-\theta)y)\leqslant\theta g(x)+(1-\theta)g(y)
\end{equation}
\]</span></p>
<p>由 <span class="math inline">\(g(x),g(y)\in\mathop{\bf dom}h\)</span>
可得 <span class="math inline">\(\theta
g(x)+(1-\theta)g(y)\in\mathop{\bf dom}h\)</span>，即式 <span class="math inline">\(\eqref{ConvexityOfFunctionG}\)</span> 的右端在
<span class="math inline">\(\mathop{\bf dom}h\)</span> 内。根据假设
<span class="math inline">\(\tilde{h}\)</span>
是非减的，可以理解为其定义域在负方向上无限延伸。由式 <span class="math inline">\(\eqref{ConvexityOfFunctionG}\)</span> 的右端在
<span class="math inline">\(\mathop{\bf dom}h\)</span>
内，我们知道其左侧仍在定义域内，即 <span class="math inline">\(g(\theta
x+(1-\theta)y)\in\mathop{\bf dom}h\)</span>，因此 <span class="math inline">\(\mathop{\bf dom}f\)</span> 是凸集。</p>
<p>根据前提条件，<span class="math inline">\(\tilde{h}\)</span>
非减，利用不等式 <span class="math inline">\(\eqref{ConvexityOfFunctionG}\)</span>，有</p>
<p><span class="math display">\[\begin{equation}\label{NondecreasingOfFunctionH}
  h(g(\theta x+(1-\theta)y))\leqslant h(\theta g(x)+(1-\theta)g(y))
\end{equation}
\]</span></p>
<p>由函数 <span class="math inline">\(h\)</span> 的凸性可得</p>
<p><span class="math display">\[\begin{equation}\label{ConvexityOfFunctionH}
  h(\theta g(x)+(1-\theta)g(y))\leqslant\theta h(g(x))+(1-\theta)h(g(y))
\end{equation}
\]</span></p>
<p>综合式 <span class="math inline">\(\eqref{NondecreasingOfFunctionH}\)</span> 和式
<span class="math inline">\(\eqref{ConvexityOfFunctionH}\)</span>
可得</p>
<p><span class="math display">\[
h(g(\theta x+(1-\theta)y))\leqslant\theta h(g(x))+(1-\theta)h(g(y))
\]</span></p>
<p>复合定理得证。</p>
</blockquote>
<blockquote>
<p><strong>举例</strong> <strong>简单的复合结论</strong>。</p>
<ul>
<li>若 <span class="math inline">\(g\)</span> 是凸函数，则 <span class="math inline">\(\exp g(x)\)</span> 是凸函数。</li>
<li>若 <span class="math inline">\(g\)</span> 是凹函数且大于零，则 <span class="math inline">\(\log g(x)\)</span> 是凹函数。</li>
<li>若 <span class="math inline">\(g\)</span> 是凹函数且大于零，则 <span class="math inline">\(1/g(x)\)</span>是凸函数。</li>
<li>若 <span class="math inline">\(g\)</span> 是凸函数且不小于零，<span class="math inline">\(p\geqslant1\)</span>，则 <span class="math inline">\(g(x)^p\)</span> 是凸函数。</li>
<li>若 <span class="math inline">\(g\)</span> 是凸函数，则 <span class="math inline">\(-\log(-g(x))\)</span> 在 <span class="math inline">\(\{x\mid g(x)&lt;0\}\)</span> 上是凸函数。</li>
</ul>
</blockquote>
<blockquote>
<p><strong>注释</strong> 扩展值延伸 <span class="math inline">\(\tilde{h}\)</span> 的单调性要求必须满足，注意到是
<span class="math inline">\(\tilde{h}\)</span>，而不仅仅是 <span class="math inline">\(h\)</span>。例如，考虑 <span class="math inline">\(g( x) = x^2\)</span>，<span class="math inline">\(\mathop{\bf dom}g = \mathbf{R}\)</span>，<span class="math inline">\(h( x) = 0\)</span>，<span class="math inline">\(\mathop{\bf dom}h= [ 1, 2]\)</span>
复合的情形。此时 <span class="math inline">\(g\)</span> 是凸函数，<span class="math inline">\(h\)</span> 是凸函数且非减，但是函数 <span class="math inline">\(f=h\circ g\)</span></p>
<p><span class="math display">\[
f(x)=0,\quad\mathop{\bf dom}f=[-\sqrt{2},-1]\:\cup\:[1,\sqrt{2}]
\]</span></p>
<p>不是凸函数，因为其定义域非凸。当然，此时函数 <span class="math inline">\(\tilde{h}\)</span> 不是非减的。</p>
</blockquote>
<h2 id="矢量复合">4.2 矢量复合</h2>
<p>  下面考虑 <span class="math inline">\(k\geqslant1\)</span>
的情况，此时更复杂一些。设</p>
<p><span class="math display">\[
f(x)=h(g(x))=h(g_1(x),\cdots,g_k(x))
\]</span></p>
<p>其中 <span class="math inline">\(h: \mathbf{R} ^k\to
\mathbf{R}\)</span>，<span class="math inline">\(g_i: \mathbf{R} ^n\to
\mathbf{R}\)</span>。和上一节一样，不失一般性，假设 <span class="math inline">\(n=1\)</span>。和 <span class="math inline">\(k=1\)</span>
的情形类似，为了得到复合规则，假设函数二次可微，且 <span class="math inline">\(\mathop{\bf dom}g=\)</span> <span class="math inline">\(\mathbf{R}\)</span>，<span class="math inline">\(\mathop{\bf dom}h= \mathbf{R}
^{k}\)</span>。此时，对函数 <span class="math inline">\(f\)</span>
进行二次微分可得</p>
<p><span class="math display">\[\begin{equation}\label{SecondDerivativeOfVectorCompositionFunction}
  f''(x)=g'(x)^{\mathrm{T}}\nabla^2h(g(x))g'(x)+\nabla
h(g(x))^{\mathrm{T}}g''(x)
\end{equation}
\]</span></p>
<p>上式可以看成式 <span class="math inline">\(\eqref{SecondDerivativeOfScalarCompositionFunction}\)</span>
对应的向量形式。同样我们需要判断在什么条件下对所有 <span class="math inline">\(x\)</span> 有 <span class="math inline">\(f(x)^{\prime\prime}\geqslant0\)</span>（或者对所有
<span class="math inline">\(x\)</span> 有 <span class="math inline">\(f(x)^\prime\prime\leqslant 0\)</span>，此时 <span class="math inline">\(f\)</span> 是凹函数）。利用式 <span class="math inline">\(\eqref{SecondDerivativeOfVectorCompositionFunction}\)</span>，我们可以得到很多规则，例如：</p>
<p><span class="math display">\[\begin{aligned}
  若\:h\:是凸函数且在每维分量上\:h\:非减，g_i\:是凸函数，则\:f\:是凸函数；\\
  若\:h\:是凸函数且在每维分量上\:h\:非增，g_i\:是凹函数，则\:f\:是凸函数；\\
  若\:h\:是凹函数且在每维分量上\:h\:非减，g_i\:是凹函数，则\:f\:是凹函数。
\end{aligned}\]</span></p>
<p>和标量的情形类似，对于更一般的情况：<span class="math inline">\(n&gt;1\)</span>，不假设 <span class="math inline">\(h\)</span> 或 <span class="math inline">\(g\)</span>
可微以及一般的定义域类似的复合结论仍然成立。对于一般的结论，不仅 <span class="math inline">\(h\)</span> 需要满足单调性条件，其扩展值延伸 <span class="math inline">\(\tilde{h}\)</span> 同样必须满足。</p>
<p>  为了更好地理解扩展值延伸 <span class="math inline">\(\tilde{h}\)</span>
必须满足单调性条件的含义，我们考虑凸函数 <span class="math inline">\(h:\mathbf{R}^{k}\to\mathbf{R}\)</span>，且 <span class="math inline">\(\tilde{h}\)</span> 非减，即对任意 <span class="math inline">\(u\preceq v\)</span>，有 <span class="math inline">\(\tilde{h}(u)\leqslant\tilde{h}(v)\)</span>。这说明了若
<span class="math inline">\(v\in\mathop{\bf dom}h\)</span> 则 <span class="math inline">\(u\in\mathop{\bf dom}h\)</span>，也即 <span class="math inline">\(h\)</span> 的定义域在方向 <span class="math inline">\(-\mathbf{R}_+^k\)</span>
上必须无限延伸。这个条件可以紧凑地描述为 <span class="math inline">\(\mathop{\bf dom}h-\mathbf{R}_{+}^{k}=\mathop{\bf
dom}h\)</span>。</p>
<blockquote>
<p><strong>举例</strong> 矢量复合的例子。</p>
<ul>
<li><p>令 <span class="math inline">\(h(z)=z_[1]+\cdots+z_{[r]}\)</span>，即对 <span class="math inline">\(z\in\mathbf{R}^k\)</span> 的前 <span class="math inline">\(r\)</span> 大分量进行求和。则 <span class="math inline">\(h\)</span> 是凸函数且在每一维分量上非减。假设
<span class="math inline">\(g_1,\cdots,g_k\)</span> 是 <span class="math inline">\(\mathbf{R}^n\)</span> 上的凸函数，则复合函数 <span class="math inline">\(f=h\circ g\)</span>，即最大 <span class="math inline">\(r\uparrow g_i\)</span>
函数的逐点和，是凸函数。</p></li>
<li><p>函数 <span class="math inline">\(h(z)=\log\left(\displaystyle\sum_{i=1}^k\mathrm{e}^{z_i}\right)\)</span>
是凸函数且在每一维分量上非减，因此只要 <span class="math inline">\(g_i\)</span> 是凸函数，<span class="math inline">\(\log\left(\displaystyle\sum_{i=1}^{k}\mathrm{e}^{g_{i}}\right)\)</span>
就是凸函数。</p></li>
<li><p>对 <span class="math inline">\(0&lt;p\leqslant 1\)</span>，定义在
<span class="math inline">\(\mathbf{R}_+^k\)</span> 上的函数 <span class="math inline">\(h(z)=\left(\displaystyle\sum_{i=1}^kz_i^p\right)^{1/p}\)</span>
是凹的，且其扩展值延伸（当 <span class="math inline">\(z\not\succeq0\)</span> 时为 <span class="math inline">\(-\infty\)</span>）在每维分量上非减，则若 <span class="math inline">\(g_i\)</span> 是凹函数且非负，<span class="math inline">\(f(x)=\left(\displaystyle\sum_{i=1}^kg_i(x)^p\right)^{1/p}\)</span>
是凸函数。</p></li>
<li><p>设 <span class="math inline">\(p\geqslant 1\)</span>, <span class="math inline">\(g_{1}, \cdots , g_{k}\)</span>
是凸函数且非负。则函数 <span class="math inline">\(\left(\displaystyle\sum_{i=1}^ng_i(x)^p\right)^{1/p}\)</span></p>
<p>为了说明这一点，考虑函数 <span class="math inline">\(h:\mathbf{R}^k\to\mathbf{R}\)</span></p>
<p><span class="math display">\[
h(z)=\left(\sum_{i=1}^{k}\max\{z_{i},0\}^{p}\right)^{1/p}
\]</span></p>
<p>其中 <span class="math inline">\(\mathop{\bf
dom}h=\mathbf{R}^{k}\)</span>，因此 <span class="math inline">\(h=\tilde{h}\)</span>。由函数 <span class="math inline">\(h\)</span> 是凸函数且非减可知 <span class="math inline">\(h(g(x))\)</span> 关于 <span class="math inline">\(x\)</span> 是凸函数。对 <span class="math inline">\(z\succeq0\)</span>，我们有 <span class="math inline">\(h(z)=\left(\displaystyle\sum_{i=1}^kz_i^p\right)^{1/p}\)</span>，所以
<span class="math inline">\(\left(\displaystyle\sum_{i=1}^kg_i(x)^p\right)^{1/p}\)</span>
是凸函数。</p></li>
<li><p>几何平均函数 <span class="math inline">\(h(z)=\left(\displaystyle\prod_{i=1}^kz_i\right)^{1/k}\)</span>，定义域为
<span class="math inline">\(\mathbf{R}_+^k\)</span>，它是凹函数，且其扩展值延伸在每维分量上非减。因此若
<span class="math inline">\(g_1,\cdots,g_k\)</span>
是非负凹函数，它们的几何平均 <span class="math inline">\(\left(\displaystyle\prod_{i=1}^kg_i\right)^{1/k}\)</span>
也是非负凸函数。</p></li>
</ul>
</blockquote>
<h1 id="最小化">5. 最小化</h1>
<p>  我们已经得到，任意个凸函数的逐点最大或者上确界仍然是凸函数。事实上，一些特殊形式的最小化同样可以得到凸函数。若函数
<span class="math inline">\(f\)</span> 关于 <span class="math inline">\((x,y)\)</span> 是凸函数，集合 <span class="math inline">\(C\)</span> 是非空凸集，定义函数</p>
<p><span class="math display">\[\begin{equation}\label{DefinitionOfMinimization}
  g(x)=\inf_{y\in C}f(x,y)
\end{equation}
\]</span></p>
<p>若存在某个 <span class="math inline">\(x\)</span> 使得 <span class="math inline">\(g(x)&gt;-\infty\)</span>（该条件隐含着对所有 <span class="math inline">\(x,g(x)&gt;-\infty\)</span>），则函数 <span class="math inline">\(g\)</span> 关于 <span class="math inline">\(x\)</span> 是凸函数。函数 <span class="math inline">\(g\)</span> 的定义域是 <span class="math inline">\(\mathop{\bf dom}f\)</span> 在 <span class="math inline">\(x\)</span> 方向上的投影，即</p>
<p><span class="math display">\[
\mathop{\bf dom}g=\{x\mid 对某些\:y\in C\:有\: (x,y)\in\mathop{\bf
dom}f\}
\]</span></p>
<p>  任取 <span class="math inline">\(x_1\)</span>, <span class="math inline">\(x_2\in \mathop{\bf dom}g\)</span>，利用 Jensen
不等式来证明上述结论。</p>
<blockquote>
<p><strong>证明</strong> 令 <span class="math inline">\(\epsilon&gt;0\)</span>，则存在 <span class="math inline">\(y_{1}\)</span>, <span class="math inline">\(y_{2}\in C\)</span>，使 <span class="math inline">\(f( x_{i}, y_{i}) \leqslant g( x_{i}) + \epsilon (
i= 1\)</span>, 2)。设 <span class="math inline">\(\theta\in[0,1]\)</span>，有</p>
<p><span class="math display">\[\begin{aligned}
g(\theta x_{1}+(1-\theta)x_{2})&amp;=\inf_{y\in C}f(\theta
x_{1}+(1-\theta)x_{2},y)
\\
&amp;\leqslant f(\theta x_1+(1-\theta)x_2,\theta y_1+(1-\theta)y_2)
\\
&amp;\leqslant\theta f(x_1,y_1)+(1-\theta)f(x_2,y_2)
\\
&amp;\leqslant\theta g(x_1)+(1-\theta)g(x_2)+\epsilon
\end{aligned}\]</span></p>
<p>因为上式对任意<span class="math inline">\(\epsilon&gt;0\)</span>均成立，所以下式成立 <span class="math display">\[
g(\theta x_1+(1-\theta)x_2)\leqslant\theta g(x_1)+(1-\theta)g(x_2)
\]</span></p>
</blockquote>
<p>  此结论亦可通过上境图来说明。对式 <span class="math inline">\(\eqref{DefinitionOfMinimization}\)</span> 中定义的
<span class="math inline">\(f\)</span>，<span class="math inline">\(g\)</span> 和 <span class="math inline">\(C\)</span>，设对每个 <span class="math inline">\(x\)</span>，在集合 <span class="math inline">\(y\in C\)</span> 上求下确界均可达到，则有</p>
<p><span class="math display">\[
\mathop{\bf epi}g=\{(x,t)\mid$对某个$y\in C$成立$(x,y,t)\in\mathop{\bf
epi}f\}
\]</span></p>
<p>由于 <span class="math inline">\(\mathop{\bf
epi}g\)</span>是凸集在其中一些分量上的投影，所以它仍然是凸集。</p>
<blockquote>
<p><strong>举例</strong> <strong>Schur 补</strong>。设二次函数</p>
<p><span class="math display">\[
f(x,y)=x^{\mathrm{T}}Ax+2x^{\mathrm{T}}By+y^{\mathrm{T}}Cy
\]</span></p>
<p>（其中<span class="math inline">\(A\)</span>和<span class="math inline">\(C\)</span>是对称矩阵）关于 <span class="math inline">\((x,y)\)</span> 是凸函数，即</p>
<p><span class="math display">\[
\left[\begin{array}{cc}A&amp;B\\B^{\mathrm{T}}&amp;C\end{array}\right]\succeq0
\]</span></p>
<p>我们可以将<span class="math inline">\(g(x)=\inf_yf(x,y)\)</span>表述为</p>
<p><span class="math display">\[
g(x)=x^{\mathrm{T}}(A-BC^\dagger B^{\mathrm{T}})x
\]</span></p>
<p>其中 <span class="math inline">\(C^\dagger\)</span> 是矩阵 <span class="math inline">\(C\)</span> 的伪逆。根据极小化的性质，<span class="math inline">\(g\)</span> 是凸函数，因此 <span class="math inline">\(A-BC^\dagger B^{\mathrm{T}}\succeq
0\)</span>。</p>
<p>如果矩阵<span class="math inline">\(C\)</span>可逆，即<span class="math inline">\(C\succ0\)</span>,则矩阵<span class="math inline">\(A-BC^{-1}B^{\mathrm{T}}\)</span>称为<span class="math inline">\(C\)</span>在矩阵</p>
<p><span class="math display">\[
\left[\begin{array}{cc}A&amp;B\\B^{\mathrm{T}}&amp;C\end{array}\right]
\]</span></p>
<p>中的 Schur 补。</p>
</blockquote>
<blockquote>
<p><strong>举例</strong> <strong>到某一集合的距离</strong>。采用范数
<span class="math inline">\(\|\cdot\|\)</span>，某点<span class="math inline">\(x\)</span>到集合 <span class="math inline">\(S\subseteq\mathbb{R}^n\)</span> 的距离定义为</p>
<p><span class="math display">\[
\mathop{\bf dist}(x,S)=\inf_{y\in S}\|x-y\|
\]</span></p>
<p>函数 <span class="math inline">\(\|x-y\|\)</span>关于<span class="math inline">\((x,y)\)</span> 是凸的，所以若集合 <span class="math inline">\(S\)</span> 是凸集，距离函数 <span class="math inline">\(\mathop{\bf dist}(x,S)\)</span> 是 <span class="math inline">\(x\)</span> 的凸函数。</p>
</blockquote>
<blockquote>
<p><strong>举例</strong> 设 <span class="math inline">\(h\)</span>
是凸函数。则函数 <span class="math inline">\(g\)</span></p>
<p><span class="math display">\[
g(x)=\inf\{h(y)\mid Ay=x\}
\]</span></p>
<p>是凸函数。为了说明这一点，定义函数 <span class="math inline">\(f\)</span></p>
<p><span class="math display">\[
f(x,y)=\left\{\begin{array}{ll}h(y)&amp;\text{如果}Ay=x\\\infty&amp;\text{其他情况,}\end{array}\right.
\]</span></p>
<p>此函数关于<span class="math inline">\((x,y)\)</span>是凸的。以<span class="math inline">\(y\)</span>为自变量，极小化函数<span class="math inline">\(f\)</span>即可得到函数<span class="math inline">\(g\)</span>,因此函数<span class="math inline">\(g\)</span>是凸函数。(直接证明<span class="math inline">\(g\)</span>是凸函数亦不复杂。)</p>
</blockquote>
<h1 id="透视函数">6. 透视函数</h1>
<p>  给定函数 <span class="math inline">\(f:\mathbf{R}^n\to\mathbf{R}\)</span>，则 <span class="math inline">\(f\)</span> 的透视函数 <span class="math inline">\(g:\mathbf{R}^n+1\to\mathbf{R}\)</span> 定义为</p>
<p><span class="math display">\[
g(x,t)=tf(x/t)
\]</span></p>
<p>其定义域为</p>
<p><span class="math display">\[
\mathbf{dom}g=\{(x,t)\mid x/t\in\mathbf{dom}f,t&gt;0\}
\]</span></p>
<p>透视运算是保凸运算：如果函数 <span class="math inline">\(f\)</span>
是凸函数，则其透视函数 <span class="math inline">\(g\)</span>
也是凸函数。类似地，若 <span class="math inline">\(f\)</span>
是凹函数，则 <span class="math inline">\(g\)</span> 亦是凹函数。</p>
<p>  可以从多个角度来证明此结论，例如，我们可以直接验证定义凸性的不等式。这里应用上境图和<a href="https://josh-gao.top/posts/a4a69a4f.html#%E9%80%8F%E8%A7%86%E5%87%BD%E6%95%B0">透视函数</a>一节所描述的
<span class="math inline">\(\mathbf{R}^{n+1}\)</span>
上的透视映射给出一个简短的证明（同时也可以说明“透视”一词的由来）。当
<span class="math inline">\(t&gt;0\)</span> 时，我们有</p>
<p><span class="math display">\[\begin{array}{lll}
(x,t,s)\in\mathop{\bf epi}g&amp;\iff&amp;tf(x/t)\leqslant s
\\
&amp;\iff&amp;f(x/t)\leqslant s/t
\\
&amp;\iff&amp;(x/t,s/t)\in\mathop{\bf epi}f
\end{array}\]</span></p>
<p>因此，<span class="math inline">\(\mathop{\bf
epi}g\)</span>是透视映射下 <span class="math inline">\(\mathop{\bf
epi}f\)</span> 的原像，此透视映射将 <span class="math inline">\((u,v,w)\)</span> 映射为 <span class="math inline">\((u,w)/v\)</span>。根据<a href="https://josh-gao.top/posts/a4a69a4f.html#%E9%80%8F%E8%A7%86%E5%87%BD%E6%95%B0">透视函数</a>一节中的结论，<span class="math inline">\(\mathop{\bf epi}g\)</span> 是凸集，所以函数 <span class="math inline">\(g\)</span> 是凸函数。</p>
<blockquote>
<p><strong>举例</strong> <strong>Euclid 范数的平方</strong>。<span class="math inline">\(\mathbb{R}^n\)</span> 上的凸函数 <span class="math inline">\(f(x)=x^{\mathrm{T}}x\)</span>
的透视函数由下式给出</p>
<p><span class="math display">\[
g(x,t)=t(x/t)^{\mathrm{T}}(x/t)=\frac{x^{\mathrm{T}}x}{t}
\]</span></p>
<p>当 <span class="math inline">\(t&gt;0\)</span> 时它关于 <span class="math inline">\((x,t)\)</span> 是凸函数。</p>
<p>我们可以利用其他方法导出<span class="math inline">\(g\)</span>的凸性。首先，将 <span class="math inline">\(g\)</span> 表示为一系列二次-线性分式函数 <span class="math inline">\(x_i^2/t\)</span> 的和。在<a href="https://josh-gao.top/posts/320f661c.html#%E4%BE%8B%E5%AD%90">凸函数举例</a>部分，我们已经知道，每一项
<span class="math inline">\(x_i^2/t\)</span>
是凸函数，因此和亦为凸函数。另一方面。我们可以将 <span class="math inline">\(g\)</span> 表述为一种特殊的矩阵分式函数 <span class="math inline">\(x^{\mathrm{T}}(tI)^{-1}x\)</span>，由此导出凸性。</p>
</blockquote>
<blockquote>
<p><strong>举例</strong> <strong>负对数</strong>。考虑 <span class="math inline">\(\mathbf{R}_{++}\)</span> 上的凸函数 <span class="math inline">\(f(x)=-\log x\)</span>，其透视函数为</p>
<p><span class="math display">\[
g(x,t)=-t\log(x/t)=t\log(t/x)=t\log t-t\log x
\]</span></p>
<p>在 <span class="math inline">\(\mathbf{R}_{++}^{2}\)</span>
上它是凸函数。函数 <span class="math inline">\(g\)</span> 称为关于 <span class="math inline">\(t\)</span> 和 <span class="math inline">\(x\)</span> 的<strong>相对熵</strong>（<em>relative
entropy</em>）。当 <span class="math inline">\(x=1\)</span> 时，<span class="math inline">\(g\)</span> 即为负熵函数。</p>
<p>基于函数 <span class="math inline">\(g\)</span>
的凸性，我们可以得出一些有趣的相关函数的凸性或凹性。首先，定义两个向量
<span class="math inline">\(u, v\in \mathbf{R} _{+ + }^{n}\)</span>
的相对熵</p>
<p><span class="math display">\[
\sum_{i=1}^nu_i\log(u_i/v_i)
\]</span></p>
<p>由于它是一系列 <span class="math inline">\(u_i,v_i\)</span>
的相对熵的和，因此关于 <span class="math inline">\((u,v)\)</span>
是凸函数。</p>
<p>另一个密切相关的函数是向量 <span class="math inline">\(u,v\in\mathbf{R}_{++}^{n}\)</span> 之间的
<strong>Kullback-Leibler 散度</strong>（Kullback-Leibler
divergence），其形式为</p>
<p><span class="math display">\[\begin{equation}\label{KLDivergence}
  D_{\mathrm{kl}}(u,v)=\sum_{i=1}^{n}\left(u_{i}\log(u_{i}/v_{i})-u_{i}+v_{i}\right)
\end{equation}
\]</span></p>
<p>因为它是 <span class="math inline">\((u,v)\)</span>
的相对熵和线性函数的和，所以它也是凸函数。Kullback-Leibler 散度总是满足
<span class="math inline">\(D_{\mathrm{kl}}(u,v)\geqslant0\)</span>，当且仅当
<span class="math inline">\(u=v\)</span> 时，<span class="math inline">\(D_\mathrm{kl}(u,v)=0\)</span>，因此
Kullback-Leibler 散度可以用来衡量两个正向量之间的偏差。（注意到当 <span class="math inline">\(u\)</span> 和 <span class="math inline">\(v\)</span> 都是概率向量，即 <span class="math inline">\(\mathbf{1}^{\mathrm{T}}u=\mathbf{1}^{\mathrm{T}}v=1\)</span>
时，相对熵和 Kullback-Leibler 散度是等价的。）</p>
<p>如果在相对熵函数中选择 <span class="math inline">\(v_i=\mathbf{1}^{\mathrm{T}}u\)</span>，我们可以得到定义在
<span class="math inline">\(u\in\mathbb{R}_+^n\)</span>
上的凹函数（也是齐次函数）</p>
<p><span class="math display">\[
\sum_{i=1}^{n}u_{i}\log(\mathbf{1}^{\mathrm{T}}u/u_{i})=(\mathbf{1}^{\mathrm{T}}u)\sum_{i=1}^{n}z_{i}\log(1/z_{i})
\]</span></p>
<p>其中 <span class="math inline">\(z=u/(\mathbf{1}^{\mathrm{T}}u)\)</span>。此函数称为<strong>归一化熵</strong>（<em>normalized
entropy</em>）函数。向量 <span class="math inline">\(z=u/\mathbf{1}^{\mathrm{T}}u\)</span> 的分量和为
1，称为归一化向量或者概率分布；<span class="math inline">\(u\)</span>
的归一化熵是 <span class="math inline">\(\mathbf{1}^{\mathrm{T}}u\)</span>和归一化概率分布
<span class="math inline">\(z\)</span> 的熵的乘积。</p>
</blockquote>
<blockquote>
<p><strong>举例</strong> 设 <span class="math inline">\(f:\mathbf{R}^m\to\mathbf{R}\)</span>
是凸函数，<span class="math inline">\(A\in\mathbf{R}^m\times
n,b\in\mathbf{R}^m,c\in\mathbf{R}^n,d\in\mathbf{R}\)</span>。定义</p>
<p><span class="math display">\[
g(x)=(c^Tx+d)f\left((Ax+b)/(c^Tx+d)\right)
\]</span></p>
<p>其定义域为</p>
<p><span class="math display">\[
\mathbf{dom}g=\{x\mid c^Tx+d&gt;0,(Ax+b)/(c^Tx+d)\in\mathbf{dom}f\}
\]</span></p>
<p>则<span class="math inline">\(g\)</span>是凸函数。</p>
</blockquote>
<h1 id="参考文献">参考文献</h1>
<ol type="1">
<li>Stephen P. Boyd and Lieven Vandenberghe, <em>Convex
optimization</em>. Cambridge, UK: Cambridge University Press, 2004.</li>
<li>Stephen P. Boyd and Lieven Vandenberghe, <em>凸优化</em>. 北京:
清华大学出版社, 2013.</li>
</ol>
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script>
<link rel="stylesheet" href="/css/markmap.css">

<script src="/js/markmap.js"></script>
]]></content>
      <categories>
        <category>Josh 的学习笔记</category>
        <category>凸优化</category>
        <category>数学</category>
        <category>凸优化</category>
        <category>凸函数</category>
      </categories>
      <tags>
        <tag>凸优化</tag>
        <tag>保凸运算</tag>
        <tag>凸函数</tag>
      </tags>
  </entry>
</search>
