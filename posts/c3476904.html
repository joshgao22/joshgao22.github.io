<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222" media="(prefers-color-scheme: light)"><meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.3.0"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="apple-touch-icon" sizes="180x180" href="/images/meta/apple-touch-icon-j.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/meta/favicon-32x32-j.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/meta/favicon-16x16-j.png"><link rel="mask-icon" href="/images/meta/favicon-j.svg" color="#222"><meta name="google-site-verification" content="Iqgmf1lNNM2SYvtW-6MExzBfoISxK8nBEcwfPGM8giU"><meta name="baidu-site-verification" content="codeva-qqFHulQHkE"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&family=Noto+Serif+SC:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&family=Dancing+Script:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.36/dist/fancybox/fancybox.css" integrity="sha256-zM8WXtG4eUn7dKKNMTuoWZub++VnSfaOpA/8PJfvTBo=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-corner-indicator.css"><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous" defer></script><script class="next-config" data-name="main" type="application/json">{"hostname":"josh-gao.top","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.23.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":12,"offset":12,"width":260},"hljswrap":true,"copycode":{"enable":true,"style":"mac"},"fold":{"enable":false,"height":500},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":true,"nav":null,"activeClass":"gitalk"},"stickytabs":false,"motion":{"enable":false,"async":true,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"slideRightBigIn","post_header":"perspectiveLeftIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideLeftIn"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false,"trigger":"auto"}}</script><script src="/js/config.js" defer></script><meta name="description" content="$ $  本文讨论几种保持函数凸性或者凹性的运算，这样可以构造新的凸函数或者凹函数。首先从一些简单的运算开始，如求和、伸缩以及逐点上确界，之后再介绍一些更为复杂的运算（其中一些运算的特例即为简单运算）。 1. 非负加权求和   显然，若函数 \(f\) 是凸函数且 \(\alpha\geqslant0\)，则函数 \(\alpha f\) 也是凸函数。若函数 \(f_1\) 和 \(f_2\) 都"><meta property="og:type" content="article"><meta property="og:title" content="Josh&#39;s Note — 凸优化&lt;br&gt;Part 2.2 凸函数—保凸运算"><meta property="og:url" content="https://josh-gao.top/posts/c3476904.html"><meta property="og:site_name" content="Josh&#39;s Blog"><meta property="og:description" content="$ $  本文讨论几种保持函数凸性或者凹性的运算，这样可以构造新的凸函数或者凹函数。首先从一些简单的运算开始，如求和、伸缩以及逐点上确界，之后再介绍一些更为复杂的运算（其中一些运算的特例即为简单运算）。 1. 非负加权求和   显然，若函数 \(f\) 是凸函数且 \(\alpha\geqslant0\)，则函数 \(\alpha f\) 也是凸函数。若函数 \(f_1\) 和 \(f_2\) 都"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://josh-gao.top/images/post/2024-07-03-josh-cvx-2-2/2024-07-03-josh-cvx-2-2-070-ExtendedValueExtension.png"><meta property="article:published_time" content="2024-07-03T15:04:33.000Z"><meta property="article:modified_time" content="2024-07-07T15:24:07.491Z"><meta property="article:author" content="Josh Gao"><meta property="article:tag" content="凸优化"><meta property="article:tag" content="保凸运算"><meta property="article:tag" content="凸函数"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://josh-gao.top/images/post/2024-07-03-josh-cvx-2-2/2024-07-03-josh-cvx-2-2-070-ExtendedValueExtension.png"><link rel="canonical" href="https://josh-gao.top/posts/c3476904.html"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://josh-gao.top/posts/c3476904.html","path":"posts/c3476904.html","title":"Josh's Note — 凸优化\u003cbr>Part 2.2 凸函数—保凸运算"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Josh's Note — 凸优化<br>Part 2.2 凸函数—保凸运算 | Josh's Blog</title><script async src="https://www.googletagmanager.com/gtag/js?id=G-FS8FDJ89QM"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-FS8FDJ89QM","only_pageview":false,"measure_protocol_api_secret":null}</script><script src="/js/third-party/analytics/google-analytics.js" defer></script><script src="/js/third-party/analytics/baidu-analytics.js" defer></script><script async src="https://hm.baidu.com/hm.js?350182f3e243a2a441aad7e64040d3ce"></script><script data-pjax defer src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon="{&quot;token&quot;: &quot;97f59b7e4ea54bd79d9c911c06f990de&quot;}"></script><script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script><script src="https://cdn.jsdelivr.net/npm/@next-theme/pjax@0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous" defer></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.36/dist/fancybox/fancybox.umd.js" integrity="sha256-hiUEBwFEpLF6DlB8sGXlKo4kPZ46Ui4qGpd0vrVkOm4=" crossorigin="anonymous" defer></script><script src="https://cdn.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous" defer></script><script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous" defer></script><script src="/js/utils.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script><script src="/js/bookmark.js" defer></script><script src="/js/pjax.js" defer></script><script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.1/dist/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous" defer></script><script src="/js/third-party/search/local-search.js" defer></script><script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"forest","dark":"dark"},"js":{"url":"https://cdn.jsdelivr.net/npm/mermaid@11.5.0/dist/mermaid.min.js","integrity":"sha256-2obLuIPcceEhkE3G09G33hBdmE55ivVcZUlcKcGNHjU="}}</script><script src="/js/third-party/tags/mermaid.js" defer></script><script src="/js/third-party/fancybox.js" defer></script><script src="/js/third-party/pace.js" defer></script><script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"ams","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script><script src="/js/third-party/math/mathjax.js" defer></script><script src="https://cdn.jsdelivr.net/npm/quicklink@2.3.0/dist/quicklink.umd.js" integrity="sha256-yvJQOINiH9fWemHn0vCA5lsHWJaHs6/ZmO+1Ft04SvM=" crossorigin="anonymous" defer></script><script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":true,"archive":true,"delay":true,"timeout":3000,"priority":true,"url":"https://josh-gao.top/posts/c3476904.html"}</script><script src="/js/third-party/quicklink.js" defer></script><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><style>.github-emoji{position:relative;display:inline-block;width:1.2em;min-height:1.2em;overflow:hidden;vertical-align:top;color:transparent}.github-emoji>span{position:relative;z-index:10}.github-emoji .fancybox,.github-emoji img{margin:0!important;padding:0!important;border:none!important;outline:0!important;text-decoration:none!important;user-select:none!important;cursor:auto!important}.github-emoji img{height:1.2em!important;width:1.2em!important;position:absolute!important;left:50%!important;top:50%!important;transform:translate(-50%,-50%)!important;user-select:none!important;cursor:auto!important}.github-emoji-fallback{color:inherit}.github-emoji-fallback img{opacity:0!important}</style></head><body itemscope itemtype="http://schema.org/WebPage"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Josh's Blog</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">一个电子工程师的修养</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">190</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">30</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">51</span></a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9D%9E%E8%B4%9F%E5%8A%A0%E6%9D%83%E6%B1%82%E5%92%8C"><span class="nav-text">1. 非负加权求和</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A4%8D%E5%90%88%E4%BB%BF%E5%B0%84%E6%98%A0%E5%B0%84"><span class="nav-text">2. 复合仿射映射</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%80%90%E7%82%B9%E6%9C%80%E5%A4%A7%E5%92%8C%E9%80%90%E7%82%B9%E4%B8%8A%E7%A1%AE%E7%95%8C"><span class="nav-text">3. 逐点最大和逐点上确界</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%90%E7%82%B9%E6%9C%80%E5%A4%A7"><span class="nav-text">3.1 逐点最大</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%90%E7%82%B9%E4%B8%8A%E7%A1%AE%E7%95%8C"><span class="nav-text">3.2 逐点上确界</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A1%A8%E7%A4%BA%E6%88%90%E4%B8%80%E6%97%8F%E4%BB%BF%E5%B0%84%E5%87%BD%E6%95%B0%E7%9A%84%E9%80%90%E7%82%B9%E4%B8%8A%E7%A1%AE%E7%95%8C"><span class="nav-text">3.3 表示成一族仿射函数的逐点上确界</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A4%8D%E5%90%88"><span class="nav-text">4. 复合</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%87%E9%87%8F%E5%A4%8D%E5%90%88"><span class="nav-text">4.1 标量复合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9F%A2%E9%87%8F%E5%A4%8D%E5%90%88"><span class="nav-text">4.2 矢量复合</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E5%8C%96"><span class="nav-text">5. 最小化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%80%8F%E8%A7%86%E5%87%BD%E6%95%B0"><span class="nav-text">6. 透视函数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE"><span class="nav-text">参考文献</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Josh Gao" src="/images/meta/favicon-j.svg"><p class="site-author-name" itemprop="name">Josh Gao</p><div class="site-description" itemprop="description">我，搞通信的</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">51</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">30</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">190</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/joshgao22" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;joshgao22" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:josh_gao@foxmail.com" title="E-Mail → mailto:josh_gao@foxmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a> </span><span class="links-of-author-item"><a href="https://blog.csdn.net/weixin_43870101" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_43870101" rel="noopener me" target="_blank"><i class="fab fa-cuttlefish fa-fw"></i>CSDN</a></span></div></div></div><div class="back-to-top animated" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div><div class="sidebar-inner sidebar-blogroll"><div class="links-of-blogroll animated"><div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i> 链接</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="https://gatsby.icu/zh-cn/" title="https:&#x2F;&#x2F;gatsby.icu&#x2F;zh-cn&#x2F;" rel="noopener" target="_blank">gatsby.icu</a></li></ul></div></div><div class="pjax"><div class="sidebar-inner sidebar-post-related"><div class="animated"><div class="links-of-blogroll-title"><i class="fa fa-signs-post fa-fw"></i> 相关文章</div><ul class="popular-posts"><li class="popular-posts-item"><a class="popular-posts-link" href="/posts/86ade7bc.html" rel="bookmark"><time class="popular-posts-time">2024-02-01</time><br>MVDR 算法仿真</a></li><li class="popular-posts-item"><a class="popular-posts-link" href="/posts/320f661c.html" rel="bookmark"><time class="popular-posts-time">2024-06-14</time><br>Josh's Note — 凸优化<br>Part 2.1 凸函数—基本性质和例子</a></li><li class="popular-posts-item"><a class="popular-posts-link" href="/posts/43146ee9.html" rel="bookmark"><time class="popular-posts-time">2022-03-29</time><br>Josh's Note — 凸优化<br>Part 1.1 凸集—仿射集合和凸集</a></li><li class="popular-posts-item"><a class="popular-posts-link" href="/posts/304dacfb.html" rel="bookmark"><time class="popular-posts-time">2024-01-30</time><br>Source Localization and Sensing: A Nonparametric Iterative Adaptive Approach Based on Weighted Least Squares</a></li><li class="popular-posts-item"><a class="popular-posts-link" href="/posts/9293b739.html" rel="bookmark"><time class="popular-posts-time">2024-06-08</time><br>Josh's Note — 凸优化<br>Part 1.2 凸集—一些重要的凸集</a></li></ul></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://josh-gao.top/posts/c3476904.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/meta/favicon-j.svg"><meta itemprop="name" content="Josh Gao"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Josh's Blog"><meta itemprop="description" content="我，搞通信的"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="Josh's Note — 凸优化<br>Part 2.2 凸函数—保凸运算 | Josh's Blog"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Josh's Note — 凸优化<br>Part 2.2 凸函数—保凸运算</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2024-07-03 23:04:33" itemprop="dateCreated datePublished" datetime="2024-07-03T23:04:33+08:00">2024-07-03</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2024-07-07 23:24:07" itemprop="dateModified" datetime="2024-07-07T23:24:07+08:00">2024-07-07</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Josh-%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">Josh 的学习笔记</span></a> </span>， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Josh-%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%87%B8%E4%BC%98%E5%8C%96/" itemprop="url" rel="index"><span itemprop="name">凸优化</span></a> </span>， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E6%95%B0%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">数学</span></a> </span>， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E6%95%B0%E5%AD%A6/%E5%87%B8%E4%BC%98%E5%8C%96/" itemprop="url" rel="index"><span itemprop="name">凸优化</span></a> </span>， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Josh-%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%87%B8%E4%BC%98%E5%8C%96/%E5%87%B8%E5%87%BD%E6%95%B0/" itemprop="url" rel="index"><span itemprop="name">凸函数</span></a> </span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span> </span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>7.7k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>28 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>$ $  本文讨论几种保持函数凸性或者凹性的运算，这样可以构造新的凸函数或者凹函数。首先从一些简单的运算开始，如求和、伸缩以及逐点上确界，之后再介绍一些更为复杂的运算（其中一些运算的特例即为简单运算）。</p><h1 id="非负加权求和">1. 非负加权求和</h1><p>  显然，若函数 <span class="math inline">\(f\)</span> 是凸函数且 <span class="math inline">\(\alpha\geqslant0\)</span>，则函数 <span class="math inline">\(\alpha f\)</span> 也是凸函数。若函数 <span class="math inline">\(f_1\)</span> 和 <span class="math inline">\(f_2\)</span> 都是凸函数，则它们的和 <span class="math inline">\(f_1+f_2\)</span> 也是凸函数。将非负伸缩以及求和运算结合起来，可以看出，凸函数的集合本身是一个凸锥：凸函数的非负加权求和仍然是凸函数，即函数</p><p><span class="math display">\[ f=w_1f_1+\cdots+w_mf_m \]</span></p><p>是凸函数。类似地，凹函数的非负加权求和仍然是凹函数。严格凸（凹）函数的非负，非零加权求和是严格凸（凹）函数。</p><p>  这个性质可以扩展至无限项的求和以及积分的情形。例如，若对于每一个 <span class="math inline">\(y\in\mathcal{A}\)</span>，函数 <span class="math inline">\(f(x,y)\)</span> 关于 <span class="math inline">\(x\)</span> 都是凸函数，且 <span class="math inline">\(w(y)\geqslant 0\)</span>，则函数</p><p><span class="math display">\[ g(x)=\int_{\mathcal{A}}w(y)f(x,y)\mathrm{d}y \]</span></p><p>关于 <span class="math inline">\(x\)</span>是凸函数（若此积分存在）。</p><span id="more"></span><p>  容易验证非负伸缩以及求和运算是保凸运算，或者可以根据相关的上境图得到此结论。例如，若 <span class="math inline">\(w\geqslant 0\)</span> 且 <span class="math inline">\(f\)</span> 是凸函数，则有</p><p><span class="math display">\[ \mathop{\bf epi}(wf)=\left[\begin{array}{cc} I&amp;0\\ 0&amp;w \end{array}\right]\mathop{\bf epi}f \]</span></p><p>因为凸集通过线性变换得到的像仍然是凸集，所以 <span class="math inline">\(\mathop{\bf epi}(wf)\)</span> 是凸集。</p><details class="note info"><summary><p>注解</p></summary><p>这里对上镜图的相关结论进行解释。函数 <span class="math inline">\(f:\mathbf{R}^{n}\to\mathbf{R}\)</span> 的上镜图定义为</p><p><span class="math display">\[ \epi f=\{(x,t)\mid f(x)\leqslant t\} \]</span></p><p>则有</p><p><span class="math display">\[\begin{aligned} \left[\begin{array}{cc} I&amp;0\\ 0&amp;w \end{array}\right]\epi f&amp;=\left\{\left[\begin{array}{cc} I&amp;0\\ 0&amp;w \end{array}\right](x,t)\:\middle|\: f(x)\leqslant t\right\} \\ &amp;= \{(x,wt)\mid f(x)\leqslant t\} \\ &amp;= \{(x,t)\mid wf(x)\leqslant t\} \\ &amp;= \epi (wf) \end{aligned} \]</span></p></details><h1 id="复合仿射映射">2. 复合仿射映射</h1><p>  假设函数 <span class="math inline">\(f:\mathbf{R}^n\to\mathbf{R}\)</span>，<span class="math inline">\(A\in\mathbf{R}^{n\times m}\)</span>，<span class="math inline">\(b\in\mathbf{R}^n\)</span>，定义<strong>复合仿射映射</strong>（<em>composition with an affine mapping</em>）$ g:^m$ 为</p><p><span class="math display">\[ g(x)=f(Ax+b) \]</span></p><p>其中 <span class="math inline">\(\mathop{\bf dom}g=\{x\mid Ax+b\in\mathop{\bf dom}f\}\)</span>。若函数 <span class="math inline">\(f\)</span> 是凸函数，则函数 <span class="math inline">\(g\)</span> 是凸函数；若函数 <span class="math inline">\(f\)</span> 是凹函数，则函数 <span class="math inline">\(g\)</span> 是凹函数。</p><h1 id="逐点最大和逐点上确界">3. 逐点最大和逐点上确界</h1><h2 id="逐点最大">3.1 逐点最大</h2><p>  若函数 <span class="math inline">\(f_{1}\)</span> 和 <span class="math inline">\(f_{2}\)</span> 均为凸函数，则二者的<strong>逐点最大</strong>（<em>pointwise maximum</em>）函数</p><p><span class="math display">\[ f(x)=\max\{f_1(x),f_2(x)\} \]</span></p><p>其定义域为 <span class="math inline">\(\mathop{\bf dom}f=\mathop{\bf dom}f_1\cap\mathop{\bf dom}f_2\)</span>，仍然是凸函数。这个性质很容易验证：任取 <span class="math inline">\(0\leqslant \theta \leqslant 1\)</span> 以及 <span class="math inline">\(x,y\in\mathop{\bf dom}f\)</span>，有</p><p><span class="math display">\[\begin{aligned} f(\theta x+(1-\theta)y)&amp;=\max\{f_1(\theta x+(1-\theta)y),f_2(\theta x+(1-\theta)y)\} \\ &amp;\leqslant\max\{\theta f_1(x)+(1-\theta)f_1(y),\theta f_2(x)+(1-\theta)f_2(y)\} \\ &amp;\leqslant\theta\max\{f_1(x),f_2(x)\}+(1-\theta)\max\{f_1(y),f_2(y)\} \\ &amp;=\theta f(x)+(1-\theta)f(y) \end{aligned}\]</span></p><p>从而得到了函数 <span class="math inline">\(f\)</span> 的凸性。同样很容易证明，若函数 <span class="math inline">\(f_1,\cdots,f_m\)</span> 为凸函数，则它们的逐点最大函数</p><p><span class="math display">\[ f(x)=\max\{f_1(x),\cdots,f_m(x)\} \]</span></p><p>仍然是凸函数。</p><blockquote><p><strong>举例</strong> <strong>分段线性函数</strong>（<em>Piecewise-linear functions</em>）。函数</p><p><span class="math display">\[ f(x)=\max\left\{a_1^\mathrm{T}x+b_1,\cdots,a_L^\mathrm{T}x+b_L\right\} \]</span></p><p>定义了一个（具有不大于 <span class="math inline">\(L\)</span> 个子区域的）分段线性函数（实际上是仿射函数）。因为它是一系列仿射函数的逐点最大函数，所以它是凸函数。反之亦成立：任意具有不大于 <span class="math inline">\(L\)</span> 个子区域的分段线性凸函数都可以表述成上述形式。</p><details class="note info"><summary><p>注解</p></summary><blockquote><p>参考 Wikipedia，<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Piecewise_linear_function">分段线性函数词条</a>即为我们通常理解的分段函数，但是这里的分段线性函数有所不同，定义为多个分段函数的逐点最大，因此数凸的。</p><p>关于子区域数量，可以这样理解：若 <span class="math inline">\(L\)</span> 个仿射函数相邻两段各不相同，则每一段仿射函数均对应着一个子区域，因此最多共有 <span class="math inline">\(L\)</span> 个子区域。</p></blockquote></details></blockquote><blockquote><p><strong>举例</strong> <strong>最大 <span class="math inline">\(r\)</span> 个分量之和</strong>。对于任意 <span class="math inline">\(x\in\mathbf{R}^n\)</span>，用 <span class="math inline">\(x_{[i]}\)</span> 表示 <span class="math inline">\(x\)</span> 中第 <span class="math inline">\(i\)</span> 大的分量，将 <span class="math inline">\(x\)</span> 的分量按照非升序进行排列</p><p><span class="math display">\[ x_{[1]}\geqslant x_{[2]}\geqslant\cdots\geqslant x_{[n]} \]</span></p><p>则对 <span class="math inline">\(x\)</span> 的最大 <span class="math inline">\(r\)</span> 个分量进行求和所得到的函数</p><p><span class="math display">\[ f(x)=\sum_{i=1}^rx_{[i]} \]</span></p><p>是凸函数。事实上，此函数可以表述为</p><p><span class="math display">\[ f(x)=\sum_{i=1}^rx_{[i]}=\max\{x_{i_1}+\cdots+x_{i_r}\mid1\leqslant i_1&lt;i_2&lt;\cdots&lt;i_r\leqslant n\} \]</span></p><p>即从 <span class="math inline">\(x\)</span> 的分量中选取 <span class="math inline">\(r\)</span> 个不同分量进行求和的所有可能组合的最大值。因为函数 <span class="math inline">\(f\)</span> 是 <span class="math inline">\(\displaystyle\frac{n!}{r!(n-r)!}\)</span> 个线性函数的逐点最大，所以是凸函数。</p><p>进一步可以证明，当 <span class="math inline">\(w_1\geqslant w_2\geqslant\cdots\geqslant w_r\geqslant 0\)</span> 时，函数 <span class="math inline">\(\displaystyle\sum_{i=1}^rw_ix_{[i]}\)</span> 是凸函数。</p></blockquote><h2 id="逐点上确界">3.2 逐点上确界</h2><p>  逐点最大的性质可以扩展至无限个凸函数的<strong>逐点上确界</strong>（<em>pointwise supremum</em>）。</p><details class="note info"><summary><p>上确界和下确界</p></summary><p>  假定 <span class="math inline">\(C\subseteq\mathbf{R}\)</span>。若对每个 <span class="math inline">\(x\in C\)</span> 均有 <span class="math inline">\(x\leqslant a\)</span>，则称 <span class="math inline">\(a\)</span> 是 <span class="math inline">\(C\)</span> 的<strong>上界</strong>（<em>upper bound</em>）。<span class="math inline">\(C\)</span> 的上界组成的集合或是空集（此时称 <span class="math inline">\(C\)</span> 无上界），或等于 <span class="math inline">\(\mathbf{R}\)</span>（仅当 <span class="math inline">\(C=\emptyset\)</span> 时），或是闭的无限区间 <span class="math inline">\([b,\infty)\)</span>。称 <span class="math inline">\(b\)</span> 为 <span class="math inline">\(C\)</span> 的<strong>最小上界</strong>（<em>least upper bound</em>）或<strong>上确界</strong>（<em>supremum</em>），用 <span class="math inline">\(\sup C\)</span> 表示。规定 <span class="math inline">\(\sup\emptyset=-\infty\)</span>，当 <span class="math inline">\(C\)</span> 无上界时取 <span class="math inline">\(\sup C=\infty\)</span>。当 <span class="math inline">\(\sup C\in C\)</span> 时，称 <span class="math inline">\(C\)</span> 的上确界是可达的。</p><p>  当 <span class="math inline">\(C\)</span> 是有限集时，<span class="math inline">\(\sup C\)</span> 是它所有元素的最大值。一些作者用符号 <span class="math inline">\(\max C\)</span> 表示可达的上确界，但我们采用标准的数学习惯，只在 <span class="math inline">\(C\)</span> 是有限集时用 <span class="math inline">\(\max C\)</span>。</p><p>  类似地，可以定义下界和下确界。若对每个 <span class="math inline">\(x\in C\)</span> 均有 <span class="math inline">\(a\leqslant x\)</span>，则称 <span class="math inline">\(a\)</span> 是 <span class="math inline">\(C\subseteq\mathbf{R}\)</span> 的下界。<span class="math inline">\(C\subseteq\mathbf{R}\)</span> 的<strong>下确界</strong>（<em>infimum</em>）或<strong>最大下界</strong>（<em>greatest lower bound</em>）定义为 <span class="math inline">\(\inf C=-\sup(-C)\)</span>。当 <span class="math inline">\(C\)</span> 是有限集时，下确界是它所有元素的最小值。规定 <span class="math inline">\(\inf\emptyset=\infty\)</span>，并在 <span class="math inline">\(C\)</span> 无下界时，取 <span class="math inline">\(\inf C=-\infty\)</span>。</p></details><p>  若对于任意 <span class="math inline">\(y\in\mathcal{A}\)</span>，函数 <span class="math inline">\(f(x,y)\)</span> 关于 <span class="math inline">\(x\)</span> 都是凸的，则函数</p><p><span class="math display">\[\begin{equation}\label{PointwiseMaximum} g(x)=\sup_{y\in\mathcal{A}}f(x,y) \end{equation}\]</span></p><p>关于 <span class="math inline">\(x\)</span> 亦是凸的。此时，函数 <span class="math inline">\(g\)</span> 的定义域为</p><p><span class="math display">\[ \mathop{\bf dom}g=\{x\mid(x,y)\in\mathop{\bf dom}f\:\forall y\in\mathcal{A},\sup_{y\in\mathcal{A}}f(x,y)&lt;\infty\} \]</span></p><p>类似地，一系列凹函数的逐点下确界仍然是凹函数。</p><p>  从上境图的角度理解，一系列函数的逐点上确界函数对应着这些函数上境图的交集：对于函数 <span class="math inline">\(f\)</span>，<span class="math inline">\(g\)</span> 以及式 <span class="math inline">\(\eqref{PointwiseMaximum}\)</span> 定义的 <span class="math inline">\(\mathcal{A}\)</span>，有</p><p><span class="math display">\[ \mathop{\bf epi}g=\bigcap_{y\in\mathcal{A}}\mathop{\bf epi}f(\:\cdot\:,y) \]</span></p><p>因此，函数 <span class="math inline">\(g\)</span> 的凸性可由一系列凸集的交集仍然是凸集得到。</p><blockquote><p><strong>举例</strong> <strong>集合的支撑函数</strong>。令集合 <span class="math inline">\(C\subseteq\mathbf{R}^n\)</span>，且 <span class="math inline">\(C\neq\emptyset\)</span>，定义集合 <span class="math inline">\(C\)</span> 的<strong>支撑函数</strong>（<em>support function</em>）<span class="math inline">\(S_C\)</span> 为</p><p><span class="math display">\[ S_C(x)=\sup\{x^\mathrm{T}y\mid y\in C\} \]</span></p><p>（自然地，函数 <span class="math inline">\(S_C\)</span> 的定义域为 <span class="math inline">\(\mathop{\bf dom}S_{C}=\left\{x\mid\sup_{y\in C}x^\mathrm{T}y&lt;\infty\right\}\)</span>）。</p><p>对于任意 <span class="math inline">\(y\in C\)</span>，<span class="math inline">\(x^\mathrm{T}y\)</span> 是 <span class="math inline">\(x\)</span> 的线性函数，所以 <span class="math inline">\(S_{C}\)</span> 是一系列线性函数的逐点上确界函数，因此是凸函数。</p></blockquote><blockquote><p><strong>举例</strong> <strong>到集合中最远点的距离</strong>。令集合 <span class="math inline">\(C\subseteq\mathbf{R}^n\)</span>，定义点 <span class="math inline">\(x\)</span> 与集合中最远点的距离（范数）为</p><p><span class="math display">\[ f(x)=\sup_{y\in C}\|x-y\| \]</span></p><p>此函数是凸函数。为了说明这一点，我们注意到，对于任意 <span class="math inline">\(y\)</span>，函数 <span class="math inline">\(\|x-y\|\)</span> 关于 <span class="math inline">\(x\)</span> 是凸函数。因为函数 <span class="math inline">\(f\)</span> 是一族凸函数（对应不同的 <span class="math inline">\(y\in C\)</span>）的逐点上确界，所以是凸函数。</p></blockquote><blockquote><p><strong>举例</strong> <strong>以权为变量的最小二乘代价函数</strong>。令 <span class="math inline">\(a_1,\cdots,a_n\in\mathbf{R}^m\)</span>，在加权最小二乘问题中我们对所有的 <span class="math inline">\(x\in\mathbf{R}^m\)</span> 极小化目标函数 <span class="math inline">\(\displaystyle\sum_{i=1}^nw_i(a_i^\mathrm{T}x-b_i)^2\)</span>。我们称 <span class="math inline">\(w_i\)</span> 为<strong>权</strong>（<em>weight</em>），并允许 <span class="math inline">\(w_i\)</span> 为负（则目标函数有可能无下界）。</p><p>定义（最优）<strong>加权最小二乘代价</strong>（<em>weighted least-squares cost</em>）函数为</p><p><span class="math display">\[ g(w)=\inf_{x}\sum_{i=1}^{n}w_{i}(a_{i}^{\mathrm{T}}x-b_{i})^{2} \]</span></p><p>其定义域为</p><p><span class="math display">\[\mathop{\bf dom}g=\left\{w\,\middle|\,\inf_{x}\sum_{i=1}^{n}w_{i}(a_{i}^{\mathrm{T}}x-b_{i})^{2}&gt;-\infty\right\}\]</span></p><p>因为函数 <span class="math inline">\(g\)</span> 是一族关于 <span class="math inline">\(w\)</span> 的线性函数的下确界（对应于不同的 <span class="math inline">\(x\in\mathbf{R}^m\)</span>），它是 <span class="math inline">\(w\)</span> 的凹函数。</p><p>至少在部分定义域上，我们可以得到函数 <span class="math inline">\(g\)</span> 的一个显式表达式。令 <span class="math inline">\(W=\mathop{\bf diag}(w)\)</span> 是一对角阵，其对角线元素为 <span class="math inline">\(w_1,\cdots,w_n\)</span>，令 <span class="math inline">\(A\in\mathbf{R}^{n\times m}\)</span>，其行向量为 <span class="math inline">\(a_i^\mathrm{T}\)</span>，有</p><p><span class="math display">\[ g(w)=\inf_{x}(Ax-b)^{\mathrm{T}}W(Ax-b)=\inf_{x}(x^{\mathrm{T}}A^{\mathrm{T}}WAx-2b^{\mathrm{T}}WAx+b^{\mathrm{T}}Wb) \]</span></p><p>从上式可以看出，若 <span class="math inline">\(A^{\mathrm{T}}WA\not\succeq0\)</span>，括号里的二次函数关于 <span class="math inline">\(x\)</span> 无下界，故 <span class="math inline">\(g(w)=-\infty\)</span>，即 <span class="math inline">\(w\not\in\mathop{\bf dom}g\)</span>。当 <span class="math inline">\(A^\mathrm{T}WA\succ0\)</span> 时（即定义了一个严格的线性矩阵不等式），通过解析求解二次函数的极小值，可以得到函数 <span class="math inline">\(g\)</span> 的一个简单的表达式</p><p><span class="math display">\[\begin{aligned} g(w)&amp;=b^{\mathrm{T}}Wb-b^{\mathrm{T}}WA(A^{\mathrm{T}}WA)^{-1}A^{\mathrm{T}}Wb \\ &amp;=\sum_{i=1}^{n}w_{i}b_{i}^{2}-\sum_{i=1}^{n}w_{i}^{2}b_{i}^{2}a_{i}^{\mathrm{T}}\left(\sum_{j=1}^{n}w_{j}a_{j}a_{j}^{\mathrm{T}}\right)^{-1}a_{i} \end{aligned}\]</span></p><p>从上述表达式并不能立即得到函数 <span class="math inline">\(g\)</span> 的凹性（不过可以从矩阵分式函数的凸性来推导函数 <span class="math inline">\(g\)</span> 的凹性）。</p></blockquote><blockquote><p><strong>举例</strong> <strong>对称矩阵的最大特征值</strong>。 定义函数 <span class="math inline">\(f(X)=\lambda_{\max}(X)\)</span>，其定义域为 <span class="math inline">\(\mathop{\bf dom}f=\mathbf{S}^m\)</span>，它是凸函数。为了说明这一点，我们将 <span class="math inline">\(f\)</span> 表述为</p><p><span class="math display">\[ f(X)=\sup\{y^\mathrm{T}Xy\mid\|y\|_2=1\} \]</span></p><p>即针对不同的 <span class="math inline">\(y\in\mathbf{R}^m\)</span> 关于 <span class="math inline">\(X\)</span> 的一族线性函数（即<span class="math inline">\(y^\mathrm{T}Xy\)</span>）的逐点上确界。</p></blockquote><blockquote><p><strong>举例</strong> <strong>矩阵范数</strong>。考虑函数 <span class="math inline">\(f(X)=\|X\|_2\)</span>，其定义域为 <span class="math inline">\(\mathop{\bf dom}f=\mathbf{R}^{p\times q}\)</span>，其中 <span class="math inline">\(\|\cdot\|_2\)</span> 表示谱范数或者最大奇异值。函数 <span class="math inline">\(f\)</span> 可以表述为</p><p><span class="math display">\[ f(X)=\sup\{u^{\mathrm{T}}Xv\mid\|u\|_{2}=1,\|v\|_{2}=1\} \]</span></p><p>由于它是 <span class="math inline">\(X\)</span> 的一族线性函数的逐点上确界，所以是凸函数。</p><p>作为一个推广，假设 <span class="math inline">\(\|\cdot\|_a\)</span>和<span class="math inline">\(\|\cdot\|_b\)</span> 分别是 <span class="math inline">\(\mathbf{R}^p\)</span> 和 <span class="math inline">\(\mathbf{R}^q\)</span> 上的范数，定义矩阵 <span class="math inline">\(X\in\mathbf{R}^{p\times q}\)</span> 的诱导范数为</p><p><span class="math display">\[ \|X\|_{a,b}=\sup_{v\neq0}\frac{\|Xv\|_{a}}{\|v\|_{b}} \]</span></p></blockquote><h2 id="表示成一族仿射函数的逐点上确界">3.3 表示成一族仿射函数的逐点上确界</h2><p>  上述例子描述了一个建立函数凸性的好方法：将函数表示为一族仿射函数的逐点上确界。除了一个技术条件，反过来也是成立的：几乎所有的凸函数都可以表示成一族仿射函数的逐点上确界。例如，若函数 <span class="math inline">\(f:\mathbf{R}^n\to\mathbf{R}\)</span> 是凸函数，其定义域为 <span class="math inline">\(\mathop{\bf dom}f=\mathbf{R}^n\)</span>，我们有</p><p><span class="math display">\[ f(x)=\sup\{g(x)\mid g\:\text{仿射},\:g(z)\leqslant f(z)\:\forall z\} \]</span></p><p>换言之，函数 <span class="math inline">\(f\)</span> 是它所有的仿射全局下估计的逐点上确界。下面我们将证明这个结论。</p><p>  设函数 <span class="math inline">\(f\)</span> 是凸函数，定义域为 <span class="math inline">\(\mathop{\bf dom}f=\mathbf{R}^{n}\)</span> ，显然下面的不等式成立</p><p><span class="math display">\[ f ( x ) \geqslant \sup \{g ( x ) \mid g\:\text{仿射}, \ g ( z ) \leqslant f ( z ) \ \forall z \}, \]</span></p><p>因为函数 <span class="math inline">\(g\)</span> 是函数 <span class="math inline">\(f\)</span> 的任意仿射下估计，我们有 <span class="math inline">\(g ( x ) \leqslant f ( x )\)</span>。为了建立等式，我们说明，对于任意 <span class="math inline">\(x \in\mathbf{R}^{n}\)</span>，存在仿射函数 <span class="math inline">\(g\)</span> 是函数 <span class="math inline">\(f\)</span> 的全局下估计，并且满足 <span class="math inline">\(g ( x )=f ( x )\)</span>。</p><p>  毫无疑问，函数 <span class="math inline">\(f\)</span> 的上境图是凸集，因此我们在点 <span class="math inline">\(( x, f ( x ) )\)</span> 处可以找到此凸集的支撑超平面，即存在 <span class="math inline">\(a \in\mathbf{R}^{n}\)</span>，<span class="math inline">\(\; b \in\mathbf{R}\)</span> 且 <span class="math inline">\(( a, b ) \neq0\)</span>，使得对任意 <span class="math inline">\(( z, t ) \in\mathop{\bf epi}f\)</span>，有</p><p><span class="math display">\[ \left[ \begin{array} {c} a \\ b \\ \end{array} \right]^{\mathrm{T}} \left[ \begin{array} {c} {x-z} \\ {f ( x )-t} \\ \end{array} \right] \leqslant0. \]</span></p><p>即对任意 <span class="math inline">\(z\in\mathop{\bf dom}f=\mathbf{R}^n\)</span> 以及所有 <span class="math inline">\(s\geqslant0\)</span>（<span class="math inline">\((z,t)\in\mathop{\bf epi}f\)</span> 等价于存在 <span class="math inline">\(s\geqslant0\)</span> 使得 <span class="math inline">\(t=f(z)+s\)</span>），下式成立</p><p><span class="math display">\[\begin{equation}\label{ProofOfAffineFunctionRepresentation} a^\mathrm{T}(x-z)+b(f(x)-f(z)-s)\leqslant0 \end{equation} \]</span></p><p>为了保证不等式 <span class="math inline">\(\eqref{ProofOfAffineFunctionRepresentation}\)</span> 对所有的 <span class="math inline">\(s\geqslant0\)</span> 均成立，必须有 <span class="math inline">\(b\geqslant0\)</span>。若 <span class="math inline">\(b=0\)</span>，对所有的<span class="math inline">\(z\in\mathbf{R}^n\)</span>，不等式 <span class="math inline">\(\eqref{ProofOfAffineFunctionRepresentation}\)</span> 可以简化为 <span class="math inline">\(a^\mathrm{T}(x-z)\leqslant0\)</span>，这意味着 <span class="math inline">\(a=0\)</span>，于是和假设 <span class="math inline">\((a,b)\neq0\)</span> 矛盾。因此 <span class="math inline">\(b&gt;0\)</span>，即支撑超平面不是竖直的。</p><p>  我们知道 <span class="math inline">\(b&gt;0\)</span>，因此，对任意 <span class="math inline">\(z\)</span>，令 <span class="math inline">\(s=0\)</span>，式 <span class="math inline">\(\eqref{ProofOfAffineFunctionRepresentation}\)</span> 可以重新表述为</p><p><span class="math display">\[ g(z)=f(x)+(a/b)^{\mathrm{T}}(x-z)\leqslant f(z) \]</span></p><p>由此说明函数 <span class="math inline">\(g\)</span> 是函数 <span class="math inline">\(f\)</span> 的一个仿射下估计，并且满足 <span class="math inline">\(g(x)=f(x)\)</span>。</p><h1 id="复合">4. 复合</h1><p>  本节给定函数 <span class="math inline">\(h:\mathbf{R}^k\to\mathbf{R}\)</span> 以及 <span class="math inline">\(g:\mathbf{R}^n\to\mathbf{R}^k\)</span>，定义复合函数 <span class="math inline">\(f=h\circ g:\mathbf{R}^n\to\mathbf{R}\)</span> 为</p><p><span class="math display">\[ f(x)=h(g(x)),\quad\mathop{\bf dom}f=\{x\in\mathop{\bf dom}g\mid g(x)\in\mathop{\bf dom}h\} \]</span></p><p>我们考虑当函数 <span class="math inline">\(f\)</span> 保凸或者保凹时，函数 <span class="math inline">\(h\)</span> 和 <span class="math inline">\(g\)</span> 必须满足的条件。</p><h2 id="标量复合">4.1 标量复合</h2><p>  首先考虑 <span class="math inline">\(k=1\)</span> 的情况，即 <span class="math inline">\(h:\mathbf{R}\to\mathbf{R}\)</span>，<span class="math inline">\(g:\mathbf{R}^n\to\mathbf{R}\)</span>。仅考虑 <span class="math inline">\(n=1\)</span> 的情况（事实上，将函数限定在与其定义域相交的任意直线上得到的函数决定了原函数的凸性）。</p><p>  为了找出复合规律，首先假设函数 <span class="math inline">\(h\)</span> 和 <span class="math inline">\(g\)</span> 是二次可微的，且 <span class="math inline">\(\mathop{\bf dom}g= \mathop{\bf dom}h= \mathbf{R}\)</span>。在上述假设下，函数 <span class="math inline">\(f\)</span> 是凸的等价于 <span class="math inline">\(f^{\prime\prime}\geqslant 0\)</span>（即对所有的 <span class="math inline">\(x\in\mathbf{R}\)</span>，<span class="math inline">\(f^{\prime\prime}(x)\geqslant 0\)</span>）。</p><p>  复合函数 <span class="math inline">\(f=h\circ g\)</span> 的二阶导数为</p><p><span class="math display">\[\begin{equation}\label{SecondDerivativeOfScalarCompositionFunction} f''(x)=h''(g(x))g'(x)^2+h'(g(x))g''(x) \end{equation}\]</span></p><p>假设函数 <span class="math inline">\(g\)</span> 是凸函数（<span class="math inline">\(g^{\prime\prime}\geqslant 0\)</span>），函数 <span class="math inline">\(h\)</span> 是凸函数且非减（即<span class="math inline">\(h^{\prime\prime}\geqslant0\)</span> 且 <span class="math inline">\(h^{\prime}\geqslant0\)</span>），从式 <span class="math inline">\(\eqref{SecondDerivativeOfScalarCompositionFunction}\)</span> 可以得出 <span class="math inline">\(f^{\prime\prime}\geqslant 0\)</span>，即函数 <span class="math inline">\(f\)</span> 是凸函数。类似地，由式 <span class="math inline">\(\eqref{SecondDerivativeOfScalarCompositionFunction}\)</span> 可以得出如下结论</p><p><span class="math display">\[\begin{equation}\label{Conclusion1}\begin{aligned} 若\,h\,是凸函数且非减，g\,是凸函数，则\,f\,是凸函数，\\ 若\,h\,是凸函数且非增，g\,是凹函数，则\,f\,是凸函数，\\ 若\,h\,是凹函数且非减，g\,是凹函数，则\,f\,是凹函数，\\ 若\,h\,是凹函数且非增，g\,是凸函数，则\,f\,是凹函数。 \end{aligned}\end{equation}\]</span></p><p>上述结论在函数 <span class="math inline">\(g\)</span> 和 <span class="math inline">\(h\)</span> 二次可微且定义域均为 <span class="math inline">\(\mathbf{R}\)</span> 时成立。事实上，对于更一般的情况，如 <span class="math inline">\(n&gt;1\)</span>，不再假设函数 <span class="math inline">\(h\)</span> 和 <span class="math inline">\(g\)</span> 可微或者 <span class="math inline">\(\mathop{\bf dom}g=\mathbf{R}^n\)</span>，<span class="math inline">\(\mathop{\bf dom}h=\mathbf{R}\)</span>，一些相似的复合规则仍然成立</p><p><span class="math display">\[\begin{equation}\label{Conclusion2}\begin{aligned} 若\,h\,是凸函数且\,\tilde{h}\,非减，\,g\,是凸函数，则\,f\,是凸函数，\\ 若\,h\,是凸函数且\,\tilde{h}\,非增，\,g\,是凹函数，则\,f\,是凸函数，\\ 若\,h\,是凹函数且\,\tilde{h}\,非减，\,g\,是凹函数，则\,f\,是凹函数，\\ 若\,h\,是凹函数且\,\tilde{h}\,非增，\,g\,是凸函数，则\,f\,是凹函数。 \end{aligned}\end{equation}\]</span></p><p>其中，<span class="math inline">\(\tilde{h}\)</span> 表示函数 <span class="math inline">\(h\)</span> 的扩展值延伸，若点不在 <span class="math inline">\(\mathop{\bf dom}h\)</span> 内，对其赋值 <span class="math inline">\(\infty\)</span>（若 <span class="math inline">\(h\)</span> 是凸函数）或者<span class="math inline">\(-\infty\)</span>（若 <span class="math inline">\(h\)</span> 是凹函数）。这些结论和式 <span class="math inline">\(\eqref{Conclusion1}\)</span> 中的结论的唯一不同是我们要求<strong>扩展值延伸</strong>（<em>extended-value extension</em>）<span class="math inline">\(\tilde{h}\)</span> 在整个 <span class="math inline">\(\mathbf{R}\)</span> 上非增或者非减。</p><p>  为了更好地理解式 <span class="math inline">\(\eqref{Conclusion2}\)</span> 中的结论，假设 <span class="math inline">\(h\)</span> 是凸函数，所以 <span class="math inline">\(\tilde{h}\)</span> 在定义域 <span class="math inline">\(\mathop{\bf dom}h\)</span> 外取值为 <span class="math inline">\(\infty\)</span>。<span class="math inline">\(\tilde{h}\)</span> 非减意味着对于任意 <span class="math inline">\(x,y\in\mathbf{R}\)</span>，<span class="math inline">\(x&lt;y\)</span>，有 <span class="math inline">\(\tilde{h}(x)\leqslant\tilde{h}(y)\)</span>。特别地，若 <span class="math inline">\(y\in\mathop{\bf dom}h\)</span>，则 <span class="math inline">\(x\in\mathop{\bf dom}h\)</span>。换言之，我们可以认为 <span class="math inline">\(h\)</span> 的定义域在负方向上无限延伸。它或者是 <span class="math inline">\(\mathbf{R}\)</span> 或者是形如 <span class="math inline">\((-\infty,a)\)</span> 或 <span class="math inline">\(\left(-\infty,a\right]\)</span> 的区间。类似地，若 <span class="math inline">\(h\)</span> 是凸函数且 <span class="math inline">\(\tilde{h}\)</span> 非增，我们可以理解为 <span class="math inline">\(h\)</span> 是非增的且 <span class="math inline">\(\mathop{\bf dom}h\)</span> 在正方向上趋于无穷。<a href="#图7">图 7</a> 描述了不同的扩展值延伸的情况。</p><p><a id="图7"></a></p><figure><img data-src="../images/post/2024-07-03-josh-cvx-2-2/2024-07-03-josh-cvx-2-2-070-ExtendedValueExtension.png" width="700" alt="图 7. 左：函数 x^2，其定义域为 \mathbf{R}_+，在其定义域内是凸且非减的，但是其扩展值延伸不是非减的。右：函数 \max\{x,0\}^2，其定义域为 \mathbf{R}，函数是凸函数，且其扩展值延伸是非减的。"><figcaption aria-hidden="true">图 7. <strong>左</strong>：函数 <span class="math inline">\(x^2\)</span>，其定义域为 <span class="math inline">\(\mathbf{R}_+\)</span>，在其定义域内是凸且非减的，但是其扩展值延伸不是非减的。<strong>右</strong>：函数 <span class="math inline">\(\max\{x,0\}^2\)</span>，其定义域为 <span class="math inline">\(\mathbf{R}\)</span>，函数是凸函数，且其扩展值延伸是非减的。</figcaption></figure><blockquote><p><strong>举例</strong> 通过一些简单例子，我们可以更好地理解复合定理中函数 <span class="math inline">\(h\)</span> 需要满足的条件。</p><ul><li>函数 <span class="math inline">\(h(x)=\log x\)</span>：定义域为 <span class="math inline">\(\mathop{\bf dom}h=\mathbf{R}_{++}\)</span>，为凹函数且 <span class="math inline">\(\tilde{h}\)</span> 非减。</li><li>函数 <span class="math inline">\(h(x)=x^1/2\)</span>：定义域为 <span class="math inline">\(\mathop{\bf dom}h=\mathbf{R}_+\)</span>，为凹函数且 <span class="math inline">\(\tilde{h}\)</span> 非减。</li><li>函数 <span class="math inline">\(h(x)=x^{3/2}\)</span>：定义域为 <span class="math inline">\(\mathop{\bf dom}h=\mathbf{R}_+\)</span>，为凸函数，但是<strong>不</strong>满足 <span class="math inline">\(\tilde{h}\)</span> 非减的条件。例如，<span class="math inline">\(\tilde{h}(-1)=\infty\)</span> 但 <span class="math inline">\(\tilde{h}(1)=1\)</span>。</li><li>当 <span class="math inline">\(x\geqslant 0\)</span> 时，<span class="math inline">\(h(x)=x^3/2\)</span>，当 <span class="math inline">\(x&lt;0\)</span> 时，<span class="math inline">\(h(x)=0\)</span>：定义域为 <span class="math inline">\(\mathop{\bf dom}h=\mathbf{R}\)</span>，<span class="math inline">\(h\)</span> 是凸函数且满足 <span class="math inline">\(\tilde{h}\)</span> 非减的条件。</li></ul></blockquote><p>  即使不假设可微并运用表达式 <span class="math inline">\(\eqref{SecondDerivativeOfScalarCompositionFunction}\)</span>，也可以直接证明复合函数结论式 <span class="math inline">\(\eqref{Conclusion2}\)</span>。举例来说，我们证明如下结论：若 <span class="math inline">\(g\)</span> 是凸函数，<span class="math inline">\(h\)</span> 是凸函数且 <span class="math inline">\(\tilde{h}\)</span> 非减，则 <span class="math inline">\(f=h\circ g\)</span> 是凸函数。</p><blockquote><p><strong>证明</strong> 假设 <span class="math inline">\(x,y\in\mathop{\bf dom}f\)</span>，<span class="math inline">\(0\leqslant\theta\leqslant1\)</span>。由 <span class="math inline">\(x,y\in\mathop{\bf dom}f\)</span>，有 <span class="math inline">\(x,y\in\mathop{\bf dom}g\)</span> 且 <span class="math inline">\(g( x)\)</span>, <span class="math inline">\(g( y) \in \mathop{\bf dom}h\)</span>。因为 <span class="math inline">\(\mathop{\bf dom}g\)</span> 是凸集，有 <span class="math inline">\(\theta x+(1-\theta)y\in\mathop{\bf dom}g\)</span>，由函数 <span class="math inline">\(g\)</span> 的凸性可得</p><p><span class="math display">\[\begin{equation}\label{ConvexityOfFunctionG} g(\theta x+(1-\theta)y)\leqslant\theta g(x)+(1-\theta)g(y) \end{equation} \]</span></p><p>由 <span class="math inline">\(g(x),g(y)\in\mathop{\bf dom}h\)</span> 可得 <span class="math inline">\(\theta g(x)+(1-\theta)g(y)\in\mathop{\bf dom}h\)</span>，即式 <span class="math inline">\(\eqref{ConvexityOfFunctionG}\)</span> 的右端在 <span class="math inline">\(\mathop{\bf dom}h\)</span> 内。根据假设 <span class="math inline">\(\tilde{h}\)</span> 是非减的，可以理解为其定义域在负方向上无限延伸。由式 <span class="math inline">\(\eqref{ConvexityOfFunctionG}\)</span> 的右端在 <span class="math inline">\(\mathop{\bf dom}h\)</span> 内，我们知道其左侧仍在定义域内，即 <span class="math inline">\(g(\theta x+(1-\theta)y)\in\mathop{\bf dom}h\)</span>，因此 <span class="math inline">\(\mathop{\bf dom}f\)</span> 是凸集。</p><p>根据前提条件，<span class="math inline">\(\tilde{h}\)</span> 非减，利用不等式 <span class="math inline">\(\eqref{ConvexityOfFunctionG}\)</span>，有</p><p><span class="math display">\[\begin{equation}\label{NondecreasingOfFunctionH} h(g(\theta x+(1-\theta)y))\leqslant h(\theta g(x)+(1-\theta)g(y)) \end{equation} \]</span></p><p>由函数 <span class="math inline">\(h\)</span> 的凸性可得</p><p><span class="math display">\[\begin{equation}\label{ConvexityOfFunctionH} h(\theta g(x)+(1-\theta)g(y))\leqslant\theta h(g(x))+(1-\theta)h(g(y)) \end{equation} \]</span></p><p>综合式 <span class="math inline">\(\eqref{NondecreasingOfFunctionH}\)</span> 和式 <span class="math inline">\(\eqref{ConvexityOfFunctionH}\)</span> 可得</p><p><span class="math display">\[ h(g(\theta x+(1-\theta)y))\leqslant\theta h(g(x))+(1-\theta)h(g(y)) \]</span></p><p>复合定理得证。</p></blockquote><blockquote><p><strong>举例</strong> <strong>简单的复合结论</strong>。</p><ul><li>若 <span class="math inline">\(g\)</span> 是凸函数，则 <span class="math inline">\(\exp g(x)\)</span> 是凸函数。</li><li>若 <span class="math inline">\(g\)</span> 是凹函数且大于零，则 <span class="math inline">\(\log g(x)\)</span> 是凹函数。</li><li>若 <span class="math inline">\(g\)</span> 是凹函数且大于零，则 <span class="math inline">\(1/g(x)\)</span>是凸函数。</li><li>若 <span class="math inline">\(g\)</span> 是凸函数且不小于零，<span class="math inline">\(p\geqslant1\)</span>，则 <span class="math inline">\(g(x)^p\)</span> 是凸函数。</li><li>若 <span class="math inline">\(g\)</span> 是凸函数，则 <span class="math inline">\(-\log(-g(x))\)</span> 在 <span class="math inline">\(\{x\mid g(x)&lt;0\}\)</span> 上是凸函数。</li></ul></blockquote><blockquote><p><strong>注释</strong> 扩展值延伸 <span class="math inline">\(\tilde{h}\)</span> 的单调性要求必须满足，注意到是 <span class="math inline">\(\tilde{h}\)</span>，而不仅仅是 <span class="math inline">\(h\)</span>。例如，考虑 <span class="math inline">\(g( x) = x^2\)</span>，<span class="math inline">\(\mathop{\bf dom}g = \mathbf{R}\)</span>，<span class="math inline">\(h( x) = 0\)</span>，<span class="math inline">\(\mathop{\bf dom}h= [ 1, 2]\)</span> 复合的情形。此时 <span class="math inline">\(g\)</span> 是凸函数，<span class="math inline">\(h\)</span> 是凸函数且非减，但是函数 <span class="math inline">\(f=h\circ g\)</span></p><p><span class="math display">\[ f(x)=0,\quad\mathop{\bf dom}f=[-\sqrt{2},-1]\:\cup\:[1,\sqrt{2}] \]</span></p><p>不是凸函数，因为其定义域非凸。当然，此时函数 <span class="math inline">\(\tilde{h}\)</span> 不是非减的。</p></blockquote><h2 id="矢量复合">4.2 矢量复合</h2><p>  下面考虑 <span class="math inline">\(k\geqslant1\)</span> 的情况，此时更复杂一些。设</p><p><span class="math display">\[ f(x)=h(g(x))=h(g_1(x),\cdots,g_k(x)) \]</span></p><p>其中 <span class="math inline">\(h: \mathbf{R} ^k\to \mathbf{R}\)</span>，<span class="math inline">\(g_i: \mathbf{R} ^n\to \mathbf{R}\)</span>。和上一节一样，不失一般性，假设 <span class="math inline">\(n=1\)</span>。和 <span class="math inline">\(k=1\)</span> 的情形类似，为了得到复合规则，假设函数二次可微，且 <span class="math inline">\(\mathop{\bf dom}g=\)</span> <span class="math inline">\(\mathbf{R}\)</span>，<span class="math inline">\(\mathop{\bf dom}h= \mathbf{R} ^{k}\)</span>。此时，对函数 <span class="math inline">\(f\)</span> 进行二次微分可得</p><p><span class="math display">\[\begin{equation}\label{SecondDerivativeOfVectorCompositionFunction} f''(x)=g'(x)^{\mathrm{T}}\nabla^2h(g(x))g'(x)+\nabla h(g(x))^{\mathrm{T}}g''(x) \end{equation} \]</span></p><p>上式可以看成式 <span class="math inline">\(\eqref{SecondDerivativeOfScalarCompositionFunction}\)</span> 对应的向量形式。同样我们需要判断在什么条件下对所有 <span class="math inline">\(x\)</span> 有 <span class="math inline">\(f(x)^{\prime\prime}\geqslant0\)</span>（或者对所有 <span class="math inline">\(x\)</span> 有 <span class="math inline">\(f(x)^\prime\prime\leqslant 0\)</span>，此时 <span class="math inline">\(f\)</span> 是凹函数）。利用式 <span class="math inline">\(\eqref{SecondDerivativeOfVectorCompositionFunction}\)</span>，我们可以得到很多规则，例如：</p><p><span class="math display">\[\begin{aligned} 若\:h\:是凸函数且在每维分量上\:h\:非减，g_i\:是凸函数，则\:f\:是凸函数；\\ 若\:h\:是凸函数且在每维分量上\:h\:非增，g_i\:是凹函数，则\:f\:是凸函数；\\ 若\:h\:是凹函数且在每维分量上\:h\:非减，g_i\:是凹函数，则\:f\:是凹函数。 \end{aligned}\]</span></p><p>和标量的情形类似，对于更一般的情况：<span class="math inline">\(n&gt;1\)</span>，不假设 <span class="math inline">\(h\)</span> 或 <span class="math inline">\(g\)</span> 可微以及一般的定义域类似的复合结论仍然成立。对于一般的结论，不仅 <span class="math inline">\(h\)</span> 需要满足单调性条件，其扩展值延伸 <span class="math inline">\(\tilde{h}\)</span> 同样必须满足。</p><p>  为了更好地理解扩展值延伸 <span class="math inline">\(\tilde{h}\)</span> 必须满足单调性条件的含义，我们考虑凸函数 <span class="math inline">\(h:\mathbf{R}^{k}\to\mathbf{R}\)</span>，且 <span class="math inline">\(\tilde{h}\)</span> 非减，即对任意 <span class="math inline">\(u\preceq v\)</span>，有 <span class="math inline">\(\tilde{h}(u)\leqslant\tilde{h}(v)\)</span>。这说明了若 <span class="math inline">\(v\in\mathop{\bf dom}h\)</span> 则 <span class="math inline">\(u\in\mathop{\bf dom}h\)</span>，也即 <span class="math inline">\(h\)</span> 的定义域在方向 <span class="math inline">\(-\mathbf{R}_+^k\)</span> 上必须无限延伸。这个条件可以紧凑地描述为 <span class="math inline">\(\mathop{\bf dom}h-\mathbf{R}_{+}^{k}=\mathop{\bf dom}h\)</span>。</p><blockquote><p><strong>举例</strong> 矢量复合的例子。</p><ul><li><p>令 <span class="math inline">\(h(z)=z_[1]+\cdots+z_{[r]}\)</span>，即对 <span class="math inline">\(z\in\mathbf{R}^k\)</span> 的前 <span class="math inline">\(r\)</span> 大分量进行求和。则 <span class="math inline">\(h\)</span> 是凸函数且在每一维分量上非减。假设 <span class="math inline">\(g_1,\cdots,g_k\)</span> 是 <span class="math inline">\(\mathbf{R}^n\)</span> 上的凸函数，则复合函数 <span class="math inline">\(f=h\circ g\)</span>，即最大 <span class="math inline">\(r\uparrow g_i\)</span> 函数的逐点和，是凸函数。</p></li><li><p>函数 <span class="math inline">\(h(z)=\log\left(\displaystyle\sum_{i=1}^k\mathrm{e}^{z_i}\right)\)</span> 是凸函数且在每一维分量上非减，因此只要 <span class="math inline">\(g_i\)</span> 是凸函数，<span class="math inline">\(\log\left(\displaystyle\sum_{i=1}^{k}\mathrm{e}^{g_{i}}\right)\)</span> 就是凸函数。</p></li><li><p>对 <span class="math inline">\(0&lt;p\leqslant 1\)</span>，定义在 <span class="math inline">\(\mathbf{R}_+^k\)</span> 上的函数 <span class="math inline">\(h(z)=\left(\displaystyle\sum_{i=1}^kz_i^p\right)^{1/p}\)</span> 是凹的，且其扩展值延伸（当 <span class="math inline">\(z\not\succeq0\)</span> 时为 <span class="math inline">\(-\infty\)</span>）在每维分量上非减，则若 <span class="math inline">\(g_i\)</span> 是凹函数且非负，<span class="math inline">\(f(x)=\left(\displaystyle\sum_{i=1}^kg_i(x)^p\right)^{1/p}\)</span> 是凸函数。</p></li><li><p>设 <span class="math inline">\(p\geqslant 1\)</span>, <span class="math inline">\(g_{1}, \cdots , g_{k}\)</span> 是凸函数且非负。则函数 <span class="math inline">\(\left(\displaystyle\sum_{i=1}^ng_i(x)^p\right)^{1/p}\)</span></p><p>为了说明这一点，考虑函数 <span class="math inline">\(h:\mathbf{R}^k\to\mathbf{R}\)</span></p><p><span class="math display">\[ h(z)=\left(\sum_{i=1}^{k}\max\{z_{i},0\}^{p}\right)^{1/p} \]</span></p><p>其中 <span class="math inline">\(\mathop{\bf dom}h=\mathbf{R}^{k}\)</span>，因此 <span class="math inline">\(h=\tilde{h}\)</span>。由函数 <span class="math inline">\(h\)</span> 是凸函数且非减可知 <span class="math inline">\(h(g(x))\)</span> 关于 <span class="math inline">\(x\)</span> 是凸函数。对 <span class="math inline">\(z\succeq0\)</span>，我们有 <span class="math inline">\(h(z)=\left(\displaystyle\sum_{i=1}^kz_i^p\right)^{1/p}\)</span>，所以 <span class="math inline">\(\left(\displaystyle\sum_{i=1}^kg_i(x)^p\right)^{1/p}\)</span> 是凸函数。</p></li><li><p>几何平均函数 <span class="math inline">\(h(z)=\left(\displaystyle\prod_{i=1}^kz_i\right)^{1/k}\)</span>，定义域为 <span class="math inline">\(\mathbf{R}_+^k\)</span>，它是凹函数，且其扩展值延伸在每维分量上非减。因此若 <span class="math inline">\(g_1,\cdots,g_k\)</span> 是非负凹函数，它们的几何平均 <span class="math inline">\(\left(\displaystyle\prod_{i=1}^kg_i\right)^{1/k}\)</span> 也是非负凸函数。</p></li></ul></blockquote><h1 id="最小化">5. 最小化</h1><p>  我们已经得到，任意个凸函数的逐点最大或者上确界仍然是凸函数。事实上，一些特殊形式的最小化同样可以得到凸函数。若函数 <span class="math inline">\(f\)</span> 关于 <span class="math inline">\((x,y)\)</span> 是凸函数，集合 <span class="math inline">\(C\)</span> 是非空凸集，定义函数</p><p><span class="math display">\[\begin{equation}\label{DefinitionOfMinimization} g(x)=\inf_{y\in C}f(x,y) \end{equation} \]</span></p><p>若存在某个 <span class="math inline">\(x\)</span> 使得 <span class="math inline">\(g(x)&gt;-\infty\)</span>（该条件隐含着对所有 <span class="math inline">\(x,g(x)&gt;-\infty\)</span>），则函数 <span class="math inline">\(g\)</span> 关于 <span class="math inline">\(x\)</span> 是凸函数。函数 <span class="math inline">\(g\)</span> 的定义域是 <span class="math inline">\(\mathop{\bf dom}f\)</span> 在 <span class="math inline">\(x\)</span> 方向上的投影，即</p><p><span class="math display">\[ \mathop{\bf dom}g=\{x\mid 对某些\:y\in C\:有\: (x,y)\in\mathop{\bf dom}f\} \]</span></p><p>  任取 <span class="math inline">\(x_1\)</span>, <span class="math inline">\(x_2\in \mathop{\bf dom}g\)</span>，利用 Jensen 不等式来证明上述结论。</p><blockquote><p><strong>证明</strong> 令 <span class="math inline">\(\epsilon&gt;0\)</span>，则存在 <span class="math inline">\(y_{1}\)</span>, <span class="math inline">\(y_{2}\in C\)</span>，使 <span class="math inline">\(f( x_{i}, y_{i}) \leqslant g( x_{i}) + \epsilon ( i= 1\)</span>, 2)。设 <span class="math inline">\(\theta\in[0,1]\)</span>，有</p><p><span class="math display">\[\begin{aligned} g(\theta x_{1}+(1-\theta)x_{2})&amp;=\inf_{y\in C}f(\theta x_{1}+(1-\theta)x_{2},y) \\ &amp;\leqslant f(\theta x_1+(1-\theta)x_2,\theta y_1+(1-\theta)y_2) \\ &amp;\leqslant\theta f(x_1,y_1)+(1-\theta)f(x_2,y_2) \\ &amp;\leqslant\theta g(x_1)+(1-\theta)g(x_2)+\epsilon \end{aligned}\]</span></p><p>因为上式对任意<span class="math inline">\(\epsilon&gt;0\)</span>均成立，所以下式成立 <span class="math display">\[ g(\theta x_1+(1-\theta)x_2)\leqslant\theta g(x_1)+(1-\theta)g(x_2) \]</span></p></blockquote><p>  此结论亦可通过上境图来说明。对式 <span class="math inline">\(\eqref{DefinitionOfMinimization}\)</span> 中定义的 <span class="math inline">\(f\)</span>，<span class="math inline">\(g\)</span> 和 <span class="math inline">\(C\)</span>，设对每个 <span class="math inline">\(x\)</span>，在集合 <span class="math inline">\(y\in C\)</span> 上求下确界均可达到，则有</p><p><span class="math display">\[ \mathop{\bf epi}g=\{(x,t)\mid$对某个$y\in C$成立$(x,y,t)\in\mathop{\bf epi}f\} \]</span></p><p>由于 <span class="math inline">\(\mathop{\bf epi}g\)</span>是凸集在其中一些分量上的投影，所以它仍然是凸集。</p><blockquote><p><strong>举例</strong> <strong>Schur 补</strong>。设二次函数</p><p><span class="math display">\[ f(x,y)=x^{\mathrm{T}}Ax+2x^{\mathrm{T}}By+y^{\mathrm{T}}Cy \]</span></p><p>（其中<span class="math inline">\(A\)</span>和<span class="math inline">\(C\)</span>是对称矩阵）关于 <span class="math inline">\((x,y)\)</span> 是凸函数，即</p><p><span class="math display">\[ \left[\begin{array}{cc}A&amp;B\\B^{\mathrm{T}}&amp;C\end{array}\right]\succeq0 \]</span></p><p>我们可以将<span class="math inline">\(g(x)=\inf_yf(x,y)\)</span>表述为</p><p><span class="math display">\[ g(x)=x^{\mathrm{T}}(A-BC^\dagger B^{\mathrm{T}})x \]</span></p><p>其中 <span class="math inline">\(C^\dagger\)</span> 是矩阵 <span class="math inline">\(C\)</span> 的伪逆。根据极小化的性质，<span class="math inline">\(g\)</span> 是凸函数，因此 <span class="math inline">\(A-BC^\dagger B^{\mathrm{T}}\succeq 0\)</span>。</p><p>如果矩阵<span class="math inline">\(C\)</span>可逆，即<span class="math inline">\(C\succ0\)</span>,则矩阵<span class="math inline">\(A-BC^{-1}B^{\mathrm{T}}\)</span>称为<span class="math inline">\(C\)</span>在矩阵</p><p><span class="math display">\[ \left[\begin{array}{cc}A&amp;B\\B^{\mathrm{T}}&amp;C\end{array}\right] \]</span></p><p>中的 Schur 补。</p></blockquote><blockquote><p><strong>举例</strong> <strong>到某一集合的距离</strong>。采用范数 <span class="math inline">\(\|\cdot\|\)</span>，某点<span class="math inline">\(x\)</span>到集合 <span class="math inline">\(S\subseteq\mathbb{R}^n\)</span> 的距离定义为</p><p><span class="math display">\[ \mathop{\bf dist}(x,S)=\inf_{y\in S}\|x-y\| \]</span></p><p>函数 <span class="math inline">\(\|x-y\|\)</span>关于<span class="math inline">\((x,y)\)</span> 是凸的，所以若集合 <span class="math inline">\(S\)</span> 是凸集，距离函数 <span class="math inline">\(\mathop{\bf dist}(x,S)\)</span> 是 <span class="math inline">\(x\)</span> 的凸函数。</p></blockquote><blockquote><p><strong>举例</strong> 设 <span class="math inline">\(h\)</span> 是凸函数。则函数 <span class="math inline">\(g\)</span></p><p><span class="math display">\[ g(x)=\inf\{h(y)\mid Ay=x\} \]</span></p><p>是凸函数。为了说明这一点，定义函数 <span class="math inline">\(f\)</span></p><p><span class="math display">\[ f(x,y)=\left\{\begin{array}{ll}h(y)&amp;\text{如果}Ay=x\\\infty&amp;\text{其他情况,}\end{array}\right. \]</span></p><p>此函数关于<span class="math inline">\((x,y)\)</span>是凸的。以<span class="math inline">\(y\)</span>为自变量，极小化函数<span class="math inline">\(f\)</span>即可得到函数<span class="math inline">\(g\)</span>,因此函数<span class="math inline">\(g\)</span>是凸函数。(直接证明<span class="math inline">\(g\)</span>是凸函数亦不复杂。)</p></blockquote><h1 id="透视函数">6. 透视函数</h1><p>  给定函数 <span class="math inline">\(f:\mathbf{R}^n\to\mathbf{R}\)</span>，则 <span class="math inline">\(f\)</span> 的透视函数 <span class="math inline">\(g:\mathbf{R}^n+1\to\mathbf{R}\)</span> 定义为</p><p><span class="math display">\[ g(x,t)=tf(x/t) \]</span></p><p>其定义域为</p><p><span class="math display">\[ \mathbf{dom}g=\{(x,t)\mid x/t\in\mathbf{dom}f,t&gt;0\} \]</span></p><p>透视运算是保凸运算：如果函数 <span class="math inline">\(f\)</span> 是凸函数，则其透视函数 <span class="math inline">\(g\)</span> 也是凸函数。类似地，若 <span class="math inline">\(f\)</span> 是凹函数，则 <span class="math inline">\(g\)</span> 亦是凹函数。</p><p>  可以从多个角度来证明此结论，例如，我们可以直接验证定义凸性的不等式。这里应用上境图和<a href="https://josh-gao.top/posts/a4a69a4f.html#%E9%80%8F%E8%A7%86%E5%87%BD%E6%95%B0">透视函数</a>一节所描述的 <span class="math inline">\(\mathbf{R}^{n+1}\)</span> 上的透视映射给出一个简短的证明（同时也可以说明“透视”一词的由来）。当 <span class="math inline">\(t&gt;0\)</span> 时，我们有</p><p><span class="math display">\[\begin{array}{lll} (x,t,s)\in\mathop{\bf epi}g&amp;\iff&amp;tf(x/t)\leqslant s \\ &amp;\iff&amp;f(x/t)\leqslant s/t \\ &amp;\iff&amp;(x/t,s/t)\in\mathop{\bf epi}f \end{array}\]</span></p><p>因此，<span class="math inline">\(\mathop{\bf epi}g\)</span>是透视映射下 <span class="math inline">\(\mathop{\bf epi}f\)</span> 的原像，此透视映射将 <span class="math inline">\((u,v,w)\)</span> 映射为 <span class="math inline">\((u,w)/v\)</span>。根据<a href="https://josh-gao.top/posts/a4a69a4f.html#%E9%80%8F%E8%A7%86%E5%87%BD%E6%95%B0">透视函数</a>一节中的结论，<span class="math inline">\(\mathop{\bf epi}g\)</span> 是凸集，所以函数 <span class="math inline">\(g\)</span> 是凸函数。</p><blockquote><p><strong>举例</strong> <strong>Euclid 范数的平方</strong>。<span class="math inline">\(\mathbb{R}^n\)</span> 上的凸函数 <span class="math inline">\(f(x)=x^{\mathrm{T}}x\)</span> 的透视函数由下式给出</p><p><span class="math display">\[ g(x,t)=t(x/t)^{\mathrm{T}}(x/t)=\frac{x^{\mathrm{T}}x}{t} \]</span></p><p>当 <span class="math inline">\(t&gt;0\)</span> 时它关于 <span class="math inline">\((x,t)\)</span> 是凸函数。</p><p>我们可以利用其他方法导出<span class="math inline">\(g\)</span>的凸性。首先，将 <span class="math inline">\(g\)</span> 表示为一系列二次-线性分式函数 <span class="math inline">\(x_i^2/t\)</span> 的和。在<a href="https://josh-gao.top/posts/320f661c.html#%E4%BE%8B%E5%AD%90">凸函数举例</a>部分，我们已经知道，每一项 <span class="math inline">\(x_i^2/t\)</span> 是凸函数，因此和亦为凸函数。另一方面。我们可以将 <span class="math inline">\(g\)</span> 表述为一种特殊的矩阵分式函数 <span class="math inline">\(x^{\mathrm{T}}(tI)^{-1}x\)</span>，由此导出凸性。</p></blockquote><blockquote><p><strong>举例</strong> <strong>负对数</strong>。考虑 <span class="math inline">\(\mathbf{R}_{++}\)</span> 上的凸函数 <span class="math inline">\(f(x)=-\log x\)</span>，其透视函数为</p><p><span class="math display">\[ g(x,t)=-t\log(x/t)=t\log(t/x)=t\log t-t\log x \]</span></p><p>在 <span class="math inline">\(\mathbf{R}_{++}^{2}\)</span> 上它是凸函数。函数 <span class="math inline">\(g\)</span> 称为关于 <span class="math inline">\(t\)</span> 和 <span class="math inline">\(x\)</span> 的<strong>相对熵</strong>（<em>relative entropy</em>）。当 <span class="math inline">\(x=1\)</span> 时，<span class="math inline">\(g\)</span> 即为负熵函数。</p><p>基于函数 <span class="math inline">\(g\)</span> 的凸性，我们可以得出一些有趣的相关函数的凸性或凹性。首先，定义两个向量 <span class="math inline">\(u, v\in \mathbf{R} _{+ + }^{n}\)</span> 的相对熵</p><p><span class="math display">\[ \sum_{i=1}^nu_i\log(u_i/v_i) \]</span></p><p>由于它是一系列 <span class="math inline">\(u_i,v_i\)</span> 的相对熵的和，因此关于 <span class="math inline">\((u,v)\)</span> 是凸函数。</p><p>另一个密切相关的函数是向量 <span class="math inline">\(u,v\in\mathbf{R}_{++}^{n}\)</span> 之间的 <strong>Kullback-Leibler 散度</strong>（Kullback-Leibler divergence），其形式为</p><p><span class="math display">\[\begin{equation}\label{KLDivergence} D_{\mathrm{kl}}(u,v)=\sum_{i=1}^{n}\left(u_{i}\log(u_{i}/v_{i})-u_{i}+v_{i}\right) \end{equation} \]</span></p><p>因为它是 <span class="math inline">\((u,v)\)</span> 的相对熵和线性函数的和，所以它也是凸函数。Kullback-Leibler 散度总是满足 <span class="math inline">\(D_{\mathrm{kl}}(u,v)\geqslant0\)</span>，当且仅当 <span class="math inline">\(u=v\)</span> 时，<span class="math inline">\(D_\mathrm{kl}(u,v)=0\)</span>，因此 Kullback-Leibler 散度可以用来衡量两个正向量之间的偏差。（注意到当 <span class="math inline">\(u\)</span> 和 <span class="math inline">\(v\)</span> 都是概率向量，即 <span class="math inline">\(\mathbf{1}^{\mathrm{T}}u=\mathbf{1}^{\mathrm{T}}v=1\)</span> 时，相对熵和 Kullback-Leibler 散度是等价的。）</p><p>如果在相对熵函数中选择 <span class="math inline">\(v_i=\mathbf{1}^{\mathrm{T}}u\)</span>，我们可以得到定义在 <span class="math inline">\(u\in\mathbb{R}_+^n\)</span> 上的凹函数（也是齐次函数）</p><p><span class="math display">\[ \sum_{i=1}^{n}u_{i}\log(\mathbf{1}^{\mathrm{T}}u/u_{i})=(\mathbf{1}^{\mathrm{T}}u)\sum_{i=1}^{n}z_{i}\log(1/z_{i}) \]</span></p><p>其中 <span class="math inline">\(z=u/(\mathbf{1}^{\mathrm{T}}u)\)</span>。此函数称为<strong>归一化熵</strong>（<em>normalized entropy</em>）函数。向量 <span class="math inline">\(z=u/\mathbf{1}^{\mathrm{T}}u\)</span> 的分量和为 1，称为归一化向量或者概率分布；<span class="math inline">\(u\)</span> 的归一化熵是 <span class="math inline">\(\mathbf{1}^{\mathrm{T}}u\)</span>和归一化概率分布 <span class="math inline">\(z\)</span> 的熵的乘积。</p></blockquote><blockquote><p><strong>举例</strong> 设 <span class="math inline">\(f:\mathbf{R}^m\to\mathbf{R}\)</span> 是凸函数，<span class="math inline">\(A\in\mathbf{R}^m\times n,b\in\mathbf{R}^m,c\in\mathbf{R}^n,d\in\mathbf{R}\)</span>。定义</p><p><span class="math display">\[ g(x)=(c^Tx+d)f\left((Ax+b)/(c^Tx+d)\right) \]</span></p><p>其定义域为</p><p><span class="math display">\[ \mathbf{dom}g=\{x\mid c^Tx+d&gt;0,(Ax+b)/(c^Tx+d)\in\mathbf{dom}f\} \]</span></p><p>则<span class="math inline">\(g\)</span>是凸函数。</p></blockquote><h1 id="参考文献">参考文献</h1><ol type="1"><li>Stephen P. Boyd and Lieven Vandenberghe, <em>Convex optimization</em>. Cambridge, UK: Cambridge University Press, 2004.</li><li>Stephen P. Boyd and Lieven Vandenberghe, <em>凸优化</em>. 北京: 清华大学出版社, 2013.</li></ol><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script><link rel="stylesheet" href="/css/markmap.css"><script src="/js/markmap.js"></script></div><footer class="post-footer"><div class="post-copyright"><ul><li class="post-copyright-author"><strong>本文作者： </strong>Josh Gao</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://josh-gao.top/posts/c3476904.html" title="Josh&#39;s Note — 凸优化&lt;br&gt;Part 2.2 凸函数—保凸运算">https://josh-gao.top/posts/c3476904.html</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="post-tags"><a href="/tags/%E5%87%B8%E4%BC%98%E5%8C%96/" rel="tag"><i class="fa fa-tag"></i> 凸优化</a> <a href="/tags/%E4%BF%9D%E5%87%B8%E8%BF%90%E7%AE%97/" rel="tag"><i class="fa fa-tag"></i> 保凸运算</a> <a href="/tags/%E5%87%B8%E5%87%BD%E6%95%B0/" rel="tag"><i class="fa fa-tag"></i> 凸函数</a></div><div class="post-nav"><div class="post-nav-item"><a href="/posts/11cd1dc.html" rel="prev" title="Zynq MPSoC / RFSoC 动态配置 DIMM DDR"><i class="fa fa-angle-left"></i> Zynq MPSoC / RFSoC 动态配置 DIMM DDR</a></div><div class="post-nav-item"></div></div></footer></article></div><div class="comments gitalk-container"></div></div></main><footer class="footer"><div class="footer-inner"><div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">京ICP备2022006859号-1 </a><img src="/images/misc/%E5%A4%87%E6%A1%88%E5%9B%BE%E6%A0%87.png" alt=""><a href="https://beian.mps.gov.cn/#/query/webSearch?code=11010802039063" rel="noopener" target="_blank">京公网安备11010802039063号</a></div><div class="copyright">&copy; 2020 – <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Josh Gao</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span>站点总字数：</span> <span title="站点总字数">264k</span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span>站点阅读时长 &asymp;</span> <span title="站点阅读时长">16:01</span></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div><div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动</div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="reading-progress-bar"></div><a role="button" class="book-mark-link book-mark-link-fixed"></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous"><script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"joshgao22","repo":"Josh-Blog-Comment","client_id":"eb4dc2ea750519598663","client_secret":"4fe0fb49aeb8fac49c609796b214a99a6df044cf","admin_user":"joshgao22","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"en | es-ES | fr | ru | zh-CN | zh-TW","js":{"url":"https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"e78a7f18dcceecf12ea5894f960a030a"}</script><script src="/js/third-party/comments/gitalk.js" defer></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,log:!1,model:{jsonPath:"/live2dw/assets/assets/wanko.model.json"},display:{position:"right",width:200,height:250},mobile:{show:!0},react:{opacity:1}})</script></body></html>