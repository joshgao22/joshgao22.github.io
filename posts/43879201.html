<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222" media="(prefers-color-scheme: light)"><meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.3.0"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="apple-touch-icon" sizes="180x180" href="/images/meta/apple-touch-icon-j.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/meta/favicon-32x32-j.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/meta/favicon-16x16-j.png"><link rel="mask-icon" href="/images/meta/favicon-j.svg" color="#222"><meta name="google-site-verification" content="Iqgmf1lNNM2SYvtW-6MExzBfoISxK8nBEcwfPGM8giU"><meta name="baidu-site-verification" content="codeva-qqFHulQHkE"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&family=Noto+Serif+SC:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&family=Dancing+Script:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.36/dist/fancybox/fancybox.css" integrity="sha256-zM8WXtG4eUn7dKKNMTuoWZub++VnSfaOpA/8PJfvTBo=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-corner-indicator.css"><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous" defer></script><script class="next-config" data-name="main" type="application/json">{"hostname":"josh-gao.top","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.23.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":12,"offset":12,"width":260},"hljswrap":true,"codeblock":{"theme":{"light":"vs","dark":"github-dark-dimmed"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":true,"style":"mac"},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":true,"nav":null,"activeClass":"gitalk"},"stickytabs":false,"motion":{"enable":false,"async":true,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"slideRightBigIn","post_header":"perspectiveLeftIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideLeftIn"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false,"trigger":"auto"}}</script><script src="/js/config.js" defer></script><meta name="description" content="在做设计验证时，需要写很多代码，其中大部分在任务和函数里面。SystemVerilog 在这方面增加了许多改进使得它更接近 C 语言，从而使代码的编写变得更加容易，尤其是在处理参数传递上。"><meta property="og:type" content="article"><meta property="og:title" content="Josh&#39;s Note — SystemVerilog 验证&lt;br&gt;Part 3 过程语句和子程序"><meta property="og:url" content="https://josh-gao.top/posts/43879201.html"><meta property="og:site_name" content="Josh&#39;s Blog"><meta property="og:description" content="在做设计验证时，需要写很多代码，其中大部分在任务和函数里面。SystemVerilog 在这方面增加了许多改进使得它更接近 C 语言，从而使代码的编写变得更加容易，尤其是在处理参数传递上。"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2022-06-02T05:24:54.000Z"><meta property="article:modified_time" content="2024-06-06T11:46:15.127Z"><meta property="article:author" content="Josh Gao"><meta property="article:tag" content="硬件，Verilog，阵列"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://josh-gao.top/posts/43879201.html"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://josh-gao.top/posts/43879201.html","path":"posts/43879201.html","title":"Josh's Note — SystemVerilog 验证\u003cbr>Part 3 过程语句和子程序"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Josh's Note — SystemVerilog 验证<br>Part 3 过程语句和子程序 | Josh's Blog</title><script async src="https://www.googletagmanager.com/gtag/js?id=G-FS8FDJ89QM"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-FS8FDJ89QM","only_pageview":false,"measure_protocol_api_secret":null}</script><script src="/js/third-party/analytics/google-analytics.js" defer></script><script src="/js/third-party/analytics/baidu-analytics.js" defer></script><script async src="https://hm.baidu.com/hm.js?350182f3e243a2a441aad7e64040d3ce"></script><script data-pjax defer src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon="{&quot;token&quot;: &quot;97f59b7e4ea54bd79d9c911c06f990de&quot;}"></script><script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script><script src="https://cdn.jsdelivr.net/npm/@next-theme/pjax@0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous" defer></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.36/dist/fancybox/fancybox.umd.js" integrity="sha256-hiUEBwFEpLF6DlB8sGXlKo4kPZ46Ui4qGpd0vrVkOm4=" crossorigin="anonymous" defer></script><script src="https://cdn.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous" defer></script><script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous" defer></script><script src="/js/utils.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script><script src="/js/bookmark.js" defer></script><script src="/js/pjax.js" defer></script><script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.1/dist/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous" defer></script><script src="/js/third-party/search/local-search.js" defer></script><script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"forest","dark":"dark"},"js":{"url":"https://cdn.jsdelivr.net/npm/mermaid@11.5.0/dist/mermaid.min.js","integrity":"sha256-2obLuIPcceEhkE3G09G33hBdmE55ivVcZUlcKcGNHjU="}}</script><script src="/js/third-party/tags/mermaid.js" defer></script><script src="/js/third-party/fancybox.js" defer></script><script src="/js/third-party/pace.js" defer></script><script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"ams","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script><script src="/js/third-party/math/mathjax.js" defer></script><script src="https://cdn.jsdelivr.net/npm/quicklink@2.3.0/dist/quicklink.umd.js" integrity="sha256-yvJQOINiH9fWemHn0vCA5lsHWJaHs6/ZmO+1Ft04SvM=" crossorigin="anonymous" defer></script><script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":true,"archive":true,"delay":true,"timeout":3000,"priority":true,"url":"https://josh-gao.top/posts/43879201.html"}</script><script src="/js/third-party/quicklink.js" defer></script><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><style>.github-emoji{position:relative;display:inline-block;width:1.2em;min-height:1.2em;overflow:hidden;vertical-align:top;color:transparent}.github-emoji>span{position:relative;z-index:10}.github-emoji .fancybox,.github-emoji img{margin:0!important;padding:0!important;border:none!important;outline:0!important;text-decoration:none!important;user-select:none!important;cursor:auto!important}.github-emoji img{height:1.2em!important;width:1.2em!important;position:absolute!important;left:50%!important;top:50%!important;transform:translate(-50%,-50%)!important;user-select:none!important;cursor:auto!important}.github-emoji-fallback{color:inherit}.github-emoji-fallback img{opacity:0!important}</style></head><body itemscope itemtype="http://schema.org/WebPage"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Josh's Blog</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">一个电子工程师的修养</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">192</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">32</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">52</span></a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%87%E7%A8%8B%E8%AF%AD%E5%8F%A5"><span class="nav-text">1. 过程语句</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E5%87%BD%E6%95%B0%E4%BB%A5%E5%8F%8A-void-%E5%87%BD%E6%95%B0"><span class="nav-text">2. 任务、函数以及 void 函数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%87%BD%E6%95%B0%E6%A6%82%E8%BF%B0"><span class="nav-text">3. 任务和函数概述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8%E5%AD%90%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%A7%BB%E9%99%A4-begin...end"><span class="nav-text">3.1. 在子程序中移除 begin...end</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AD%90%E7%A8%8B%E5%BA%8F%E5%8F%82%E6%95%B0"><span class="nav-text">4. 子程序参数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#c-%E8%AF%AD%E8%A8%80%E9%A3%8E%E6%A0%BC%E7%9A%84%E5%AD%90%E7%A8%8B%E5%BA%8F%E5%8F%82%E6%95%B0"><span class="nav-text">4.1. C 语言风格的子程序参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E7%9A%84%E6%96%B9%E5%90%91"><span class="nav-text">4.2. 参数的方向</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7%E7%9A%84%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="nav-text">4.3. 高级的参数类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="nav-text">4.4. 参数的默认值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%87%E7%94%A8%E5%90%8D%E5%AD%97%E8%BF%9B%E8%A1%8C%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="nav-text">4.5. 采用名字进行参数传递</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E4%BB%A3%E7%A0%81%E9%94%99%E8%AF%AF"><span class="nav-text">4.6. 常见的代码错误</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AD%90%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BF%94%E5%9B%9E"><span class="nav-text">5. 子程序的返回</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E-return-%E8%AF%AD%E5%8F%A5"><span class="nav-text">5.1. 返回 (return) 语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8E%E5%87%BD%E6%95%B0%E4%B8%AD%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84"><span class="nav-text">5.2. 从函数中返回一个数组</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8"><span class="nav-text">6. 局部数据存储</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E5%AD%98%E5%82%A8"><span class="nav-text">6.1. 自动存储</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">6.2. 变量的初始化</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E5%80%BC"><span class="nav-text">7. 时间值</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E5%8D%95%E4%BD%8D%E5%92%8C%E7%B2%BE%E5%BA%A6"><span class="nav-text">7.1. 时间单位和精度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E5%8F%82%E6%95%B0"><span class="nav-text">7.2. 时间参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E5%92%8C%E5%8F%98%E9%87%8F"><span class="nav-text">7.3. 时间和变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#time-%E4%B8%8E-realtime-%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="nav-text">7.4. $time 与 $realtime 的对比</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BB%93%E6%9D%9F%E8%AF%AD"><span class="nav-text">8. 结束语</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE"><span class="nav-text">参考文献</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Josh Gao" src="/images/meta/favicon-j.svg"><p class="site-author-name" itemprop="name">Josh Gao</p><div class="site-description" itemprop="description">我，搞通信的</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">52</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">32</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">192</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/joshgao22" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;joshgao22" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:josh_gao@foxmail.com" title="E-Mail → mailto:josh_gao@foxmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a> </span><span class="links-of-author-item"><a href="https://blog.csdn.net/weixin_43870101" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_43870101" rel="noopener me" target="_blank"><i class="fab fa-cuttlefish fa-fw"></i>CSDN</a></span></div></div></div><div class="back-to-top animated" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div><div class="sidebar-inner sidebar-blogroll"><div class="links-of-blogroll animated"><div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i> 链接</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="https://gatsby.icu/zh-cn/" title="https:&#x2F;&#x2F;gatsby.icu&#x2F;zh-cn&#x2F;" rel="noopener" target="_blank">gatsby.icu</a></li></ul></div></div><div class="pjax"></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://josh-gao.top/posts/43879201.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/meta/favicon-j.svg"><meta itemprop="name" content="Josh Gao"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Josh's Blog"><meta itemprop="description" content="我，搞通信的"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="Josh&#39;s Note — SystemVerilog 验证&lt;br&gt;Part 3 过程语句和子程序 | Josh's Blog"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Josh's Note — SystemVerilog 验证<br>Part 3 过程语句和子程序</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-06-02 13:24:54" itemprop="dateCreated datePublished" datetime="2022-06-02T13:24:54+08:00">2022-06-02</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2024-06-06 19:46:15" itemprop="dateModified" datetime="2024-06-06T19:46:15+08:00">2024-06-06</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Josh-%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">Josh 的学习笔记</span></a> </span>， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Josh-%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/SystemVerilog/" itemprop="url" rel="index"><span itemprop="name">SystemVerilog</span></a> </span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span> </span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>5.8k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>21 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>在做设计验证时，需要写很多代码，其中大部分在任务和函数里面。SystemVerilog 在这方面增加了许多改进使得它更接近 C 语言，从而使代码的编写变得更加容易，尤其是在处理参数传递上。</p><span id="more"></span><h1 id="过程语句">1. 过程语句</h1><p>SystemVerilog 从 C 和 C++ 中引入了很多操作符和语句：</p><ul><li>可以在 <code>for</code> 循环中定义循环变量，它的作用范围仅限于循环内部，从而有助于避免一些 bug。</li><li>自动递增符 <code>++</code> 和自动递减符 <code>--</code> 既可以作为前缀，也可以作为后缀。</li><li>如果在 <code>begin</code> 或 <code>fork</code> 语句中使用标识符，那么在相对应的 <code>end</code> 或 <code>join</code> 语句中可以放置相同的标号，这使得程序块的首尾匹配更加容易。</li><li>也可以把标识符放在 SystemVerilog 的其他结束语句里，例如 <code>endmodule</code>、<code>endtask</code>、<code>endfunction</code> 以及本文将介绍的其他语句。</li></ul><p><a href="#例3.1">例 3.1</a> 展示了一些新的语法结构。</p><p><span id="例3.1"></span></p><figure class="highlight verilog"><figcaption><span>例 3.1 新的过程语句和操作符</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span></span><br><span class="line">    <span class="keyword">begin</span> : example</span><br><span class="line">    <span class="keyword">integer</span> array[<span class="number">10</span>], sum, j;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 for 语句中声明 i</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)       <span class="comment">// i 递增</span></span><br><span class="line">        array[i] = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add up values in the array</span></span><br><span class="line">    sum = array[<span class="number">9</span>];</span><br><span class="line">    j=<span class="number">8</span>;</span><br><span class="line">    <span class="keyword">do</span>                            <span class="comment">// do...while 循环</span></span><br><span class="line">        sum += array[j];          <span class="comment">// 累加</span></span><br><span class="line">    <span class="keyword">while</span> (j--);                  <span class="comment">// 判断 j=0 是否成立</span></span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">"Sum=%4d"</span>, sum);     <span class="comment">// %4d，指定宽度</span></span><br><span class="line"><span class="keyword">end</span> : example                     <span class="comment">// 结束标识符</span></span><br></pre></td></tr></tbody></table></figure><p>SystemVerilog 为循环功能增加了两个新语句：</p><ul><li>第一个是 <code>continue</code>，用于在循环中跳过本轮循环剩下的语句而直接进入下一轮循环。</li><li>第二个是 <code>break</code>，用于终止并跳出循环。</li></ul><p><a href="#例3.2">例 3.2</a> 中的循环使用 Verilog-2001 中的文件输入输出系统任务从一个文件中读取命令。如果读到的命令只是一个空行，则执行 <code>continue</code> 语句，跳过对这个命令的任何进一步处理。如果读到的命令是 “done”，代码将会执行 <code>break</code> 终止循环。</p><p><span id="例3.2"></span></p><figure class="highlight verilog"><figcaption><span>例 3.2 在读取文件时使用 <code>break</code> 和 <code>continue</code></span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">127</span>:<span class="number">0</span>] cmd;</span><br><span class="line">    <span class="keyword">int</span> file, c;</span><br><span class="line"></span><br><span class="line">    file = <span class="built_in">$fopen</span>(<span class="string">"commands.txt"</span>, <span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">$feof</span>(file)) <span class="keyword">begin</span></span><br><span class="line">        c = <span class="built_in">$fscanf</span>(file, <span class="string">"%s"</span>, cmd);</span><br><span class="line">        <span class="keyword">case</span> (cmd)</span><br><span class="line">            <span class="string">""</span>:     <span class="keyword">continue</span>;    <span class="comment">// 空行——跳到本轮循环的末尾</span></span><br><span class="line">            <span class="string">"done"</span>: <span class="keyword">break</span>;       <span class="comment">// Done——终止并跳出循环</span></span><br><span class="line">            ...                  <span class="comment">// 处理其他命令</span></span><br><span class="line">        <span class="keyword">endcase</span> <span class="comment">// case(cmd)</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">$fclose</span>(file);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure><h1 id="任务函数以及-void-函数">2. 任务、函数以及 <code>void</code> 函数</h1><p>在 Verilog 中，任务 (task) 和函数 (function) 之间有很明显的区别，其中最重要的一点是，<strong>任务可以消耗时间而函数不能</strong>。函数里面不能带有诸如 <code>#100</code> 的时延语句或诸如 <code>@(posedge clock)</code>、<code>wait(ready)</code> 的阻塞语句，也不能调用任务。另外，Verilog 中的函数必须有返回值，并且返回值必须被使用，例如用到赋值语句中。</p><p>SystemVerilog 对这条限制稍有放宽，允许函数调用任务，但只能在由 <code>fork... join_none</code> 语句生成的线程中调用。</p><blockquote><p>不消耗时间的 SystemVerilog 任务应该被定义成 <code>void</code> 函数，这种函数没有返回值，这样它就能被任何任务或函数所调用了。从最大灵活性的角度考虑，所有用于调试的子程序都应该定义成 <code>void</code> 函数而非任务，以便于被任何其他任务或函数所调用。<a href="#例3.3">例 3.3</a> 可以输出状态机的当前状态值。</p></blockquote><p><span id="例3.3"></span></p><figure class="highlight verilog"><figcaption><span>例 3.3 用于调试的 <code>void</code> 函数</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> print_state(...);</span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">"@%0t: state = %s"</span>, <span class="built_in">$time</span>, cur_state<span class="variable">.name</span>());</span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></tbody></table></figure><p>在 SystemVerilog 中，如果想调用函数并且忽略它的返回值，可以使用 <code>void</code> 进行结果转换，如<a href="#例3.4">例 3.4</a> 所示。有些仿真器，如 VCS，允许在不使用上述 void 语法的情况下忽略返回值。</p><p><span id="例3.4"></span></p><figure class="highlight verilog"><figcaption><span>例 3.4 忽略函数的返回值</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>'(<span class="built_in">$fscanf</span>(file, <span class="string">"%d"</span>, i));</span><br></pre></td></tr></tbody></table></figure><h1 id="任务和函数概述">3. 任务和函数概述</h1><p>SystemVerilog 在任务和函数上做了一些小改进，使得它们看起来更像 C 或 C++ 的程序。一般情况下，不带参数的子程序在定义或调用时并不需要带空括号 <code>()</code>。为清楚起见，本文对此种情形的子程序将全部带括号。</p><h2 id="在子程序中移除-begin...end">3.1. 在子程序中移除 <code>begin...end</code></h2><p>在 SystemVerilog 中，你可能会注意到的第一个改进就是，<code>begin...end</code> 块变成可选了，而在 Verilog-1995 中则对单行以外的子程序都是必须的。如<a href="#例3.5">例 3.5</a> 所示，<code>task/end­task</code> 和 <code>function/endfunction</code> 的关键词已经足以定义这些子程序的边界了。</p><p><span id="例3.5"></span></p><figure class="highlight verilog"><figcaption><span>例 3.5 不带 <code>begin...end</code> 的简单任务</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> multiple_lines;</span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">"First line"</span>);</span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">"Second line"</span>);</span><br><span class="line"><span class="keyword">endtask</span> : multiple_lines</span><br></pre></td></tr></tbody></table></figure><h1 id="子程序参数">4. 子程序参数</h1><p>SystemVerilog 对子程序的很多改进使参数的声明变得更加方便，同时也扩展了参数的传递方式。</p><h2 id="c-语言风格的子程序参数">4.1. C 语言风格的子程序参数</h2><p>System Verilog 和 Verilog-2001 在任务和函数参数的声明上更加简洁，更少重复。<a href="#例3.6">例 3.6</a> 中的 Verilog 任务要求对一些参数进行两次声明，一次是方向声明，另一次是类型声明。</p><p><span id="例3.6"></span></p><figure class="highlight verilog"><figcaption><span>例 3.6 Verilog-1995 的子程序参数</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> mytask2;</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] x;</span><br><span class="line">    <span class="keyword">reg</span>    [<span class="number">31</span>:<span class="number">0</span>] x;</span><br><span class="line">    <span class="keyword">input</span>         y;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">endtask</span></span><br></pre></td></tr></tbody></table></figure><p>而在 System Verilog 中，可以采用简明的 C 语言风格，如<a href="#例3.7">例 3.7</a> 所示。但注意<strong>必须使用通用的输入类型 <code>logic</code></strong>。</p><p><span id="例3.7"></span></p><figure class="highlight verilog"><figcaption><span>例 3.7 C 语言风格的子程序参数</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> mytask1 (<span class="keyword">output</span> <span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] x,</span><br><span class="line">              <span class="keyword">input</span>  <span class="keyword">logic</span> y);</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">endtask</span></span><br></pre></td></tr></tbody></table></figure><h2 id="参数的方向">4.2. 参数的方向</h2><p>在声明子程序参数方面还可以有更多的便捷。因为默认的类型和方向是 “logic 输入”，所以在声明类似参数时可不必重复。<a href="#例3.8">例 3.8</a> 所示为采用 SystemVerilog 的数据类型，但以 Verilog-1995 的风格编写的一个子程序头。</p><p><span id="例3.8"></span></p><figure class="highlight verilog"><figcaption><span>例 3.8 带 Verilog 风格的繁冗的子程序参数</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> T3;</span><br><span class="line">    <span class="keyword">input</span> a, b;</span><br><span class="line">    <span class="keyword">logic</span> a, b;</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">15</span>:<span class="number">0</span>] u, v;</span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">15</span>:<span class="number">0</span>] u, v;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">endtask</span></span><br></pre></td></tr></tbody></table></figure><p>可以把它重写成<a href="#例3.9">例 3.9</a> 的形式。</p><p><span id="例3.9"></span></p><figure class="highlight verilog"><figcaption><span>例 3.9 使用默认类型的子程序参数</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> T3(a, b, <span class="keyword">output</span> <span class="keyword">bit</span> [<span class="number">15</span>:<span class="number">0</span>] u, v);</span><br></pre></td></tr></tbody></table></figure><p>参数 <code>a</code> 和 <code>b</code> 是 1 比特宽度的 logic 输入。参数 <code>u</code> 和 <code>v</code> 是 16 比特宽度的 bit 类型输出。尽管有这种简洁的编程方式，但不建议使用这种方式，因为这种方式将容易引入一些细小而难以发现的 bug。所以<strong>建议对所有子程序参数的声明都带上类型和方向</strong>。</p><h2 id="高级的参数类型">4.3. 高级的参数类型</h2><p>Verilog 对参数的处理方式很简单：在子程序的开头把 <code>input</code> 和 <code>inout</code> 的值复制给本地变量，在子程序退出时则复制 <code>output</code> 和 <code>inout</code> 的值。除了标量以外，没有任何把存储器传递给 Verilog 子程序的办法。</p><p>在 SystemVerilog 中，参数的传递方式可以指定为引用而不是复制。这种 <code>ref</code> 参数类型比 <code>input</code>、<code>output</code> 或 <code>inout</code> 更好用。首先，把数组传递给子程序。</p><p><span id="例3.10"></span></p><figure class="highlight verilog"><figcaption><span>例 3.10 使用 <code>ref</code> 和 <code>const</code> 传递数组</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> print_checksum (<span class="keyword">const</span> <span class="keyword">ref</span> <span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] a[]);</span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] checksum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;a<span class="variable">.size</span>(); i++)</span><br><span class="line">        checksum ^= a[i];</span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">"The array checksum is %0d"</span>, checksum);</span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></tbody></table></figure><p>SystemVerilog 允许不带 <code>ref</code> 进行数组参数的传递，这时数组会被复制到堆栈区里。这种操作的代价很高，除非是对特别小的数组。</p><p>SystemVerilog 的语言参考手册 (LRM) 规定了 <code>ref</code> 参数只能被用于带自动存储的子程序中。如果对程序或模块指明了 <code>automatic</code> 属性，则整个子程序内部都是自动存储的。</p><p><a href="#例3.10">例 3.10</a> 也用到了 <code>const</code> 修饰符，其结果是，<strong>虽然数组变量 <code>a</code> 指向了调用程序中的数组，但子程序不能修改数组的值</strong>。如果试图改变数组的值，编译器将报错。</p><blockquote><p>向子程序传递数组时应尽量使用 <code>ref</code> 以获取最佳性能。如果不希望子程序改变数组的值，可以使用 <code>const ref</code> 类型。这种情况下，编译器会进行检查以确保数组不被子程序修改。</p></blockquote><p><code>ref</code> 参数的第二个好处是<strong>可以在任务里修改变量，并且修改结果对调用它的函数随时可见</strong>。当有若干并发执行的线程时，这样操作可以提供一种简单的信息传递方式。</p><p>在<a href="#例3.11">例 3.11</a> 中，一旦 <code>bus.enable</code> 有效，初始化块中的 <code>thread2</code> 块马上就可以获取来自存储器的数据，而不用等到 <code>bus_read</code> 任务完成总线上的数据处理后返回，这可能需要若干个时钟周期。由于参数 <code>data</code> 是以 <code>ref</code> 方式传递的，所以只要任务里的 <code>data</code> 一有变化，<code>@data</code> 语句就会触发。如果你把 <code>data</code> 声明为 <code>output</code>，则 <code>@data</code> 语句就要等到总线处理完成后才能触发。</p><p><span id="例3.11"></span></p><figure class="highlight verilog"><figcaption><span>例 3.11 在多线程间使用 <code>ref</code></span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> bus_read(<span class="keyword">input</span> <span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] addr,</span><br><span class="line">              <span class="keyword">ref</span>   <span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求总线并驱动地址</span></span><br><span class="line">    bus<span class="variable">.request</span> = <span class="number">1'b1</span>;</span><br><span class="line">    @(<span class="keyword">posedge</span> bus<span class="variable">.grant</span>) bus<span class="variable">.addr</span> = addr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待来自存储器的数据</span></span><br><span class="line">    @(<span class="keyword">posedge</span> bus<span class="variable">.enable</span>) data = bus<span class="variable">.data</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放总线并等待许可</span></span><br><span class="line">    bus<span class="variable">.request</span> = <span class="number">1'b0</span>;</span><br><span class="line">    @(<span class="keyword">negedge</span> bus<span class="variable">.grant</span>);</span><br><span class="line"><span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] addr, data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span></span><br><span class="line">    <span class="keyword">fork</span></span><br><span class="line">        bus_read(addr, data);</span><br><span class="line">        thread2: <span class="keyword">begin</span></span><br><span class="line">            @data;  <span class="comment">// 在数据变化时触发</span></span><br><span class="line">            <span class="built_in">$display</span>(<span class="string">"Read %h from bus"</span>, data);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">join</span></span><br></pre></td></tr></tbody></table></figure><h2 id="参数的默认值">4.4. 参数的默认值</h2><p>当测试程序越来越复杂时，会希望在不破坏已有代码的情况下增加额外的控制。在<a href="#例3.10">例 3.10</a> 的函数里，可能想把数组中间部分元素的校验和打印出来，但是又不希望改写代码，为每次函数调用增加额外的参数。在 SystemVerilog 中，可以为参数指定一个默认值，如果在调用时不指明参数，则使用默认值。<a href="#例3.12">例 3.12</a> 为 <code>print_checksum</code> 函数增加了 <code>low</code> 和 <code>high</code> 两个参数，这样就能够打印出指定范围内的数组内容的校验和。</p><p><span id="例3.12"></span></p><figure class="highlight verilog"><figcaption><span>例 3.12 带默认参数值的函数</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> print_checksum(<span class="keyword">ref</span> <span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] a[],</span><br><span class="line">                             <span class="keyword">input</span> <span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] low = <span class="number">0</span>,</span><br><span class="line">                             <span class="keyword">input</span> <span class="keyword">int</span> high = -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] checksum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (high == -<span class="number">1</span> || high &gt;= a<span class="variable">.size</span>())</span><br><span class="line">        high = a<span class="variable">.size</span>()-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=low; i&lt;=high; i++)</span><br><span class="line">        checksum += a[i];</span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">"The array checksum is %0d"</span>, sum);</span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></tbody></table></figure><p>可以使用如<a href="#例3.13">例 3.13</a> 所示的方式调用这个函数。注意，第一个调用对两种形式的 <code>print_checksum</code> 子程序都是可行的。</p><p><span id="例3.13"></span></p><figure class="highlight verilog"><figcaption><span>例 3.13 使用参数的默认值</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">print_checksum(a);       <span class="comment">// a[0:size()-1]中所有元素的校验和——默认情况</span></span><br><span class="line">print_checksum(a, <span class="number">2</span>, <span class="number">4</span>); <span class="comment">// a[2:4]中所有元素的校验和</span></span><br><span class="line">print_checksum(a, <span class="number">1</span>);    <span class="comment">// 从 1 开始</span></span><br><span class="line">print_checksum(a,, <span class="number">2</span>);   <span class="comment">// a[0:2]中所有元素的校验和</span></span><br><span class="line">print_checksum();        <span class="comment">// 编译错误：a 没有默认值</span></span><br></pre></td></tr></tbody></table></figure><p>使用 -1 (或其他任何越界值) 作为默认值，对于获知调用时是否有指定值，不失为一个好方法。</p><p>Verilog 中的 <code>for</code> 循环总是在执行初始化 (<code>int i=low</code>) 和条件测试 (<code>i&lt;=high</code>) 之后再开始循环。所以，如果不小心把一个大于 <code>high</code> 或数组宽度的数值传递给 <code>low</code>，那么 <code>for</code> 循环的循环体将不会被执行。</p><h2 id="采用名字进行参数传递">4.5. 采用名字进行参数传递</h2><p>在 SystemVerilog 的语言参考手册 (LRM) 中，任务或函数的参数有时被称为端口 (port)，就跟模块的接口一样。如果有一个带着许多参数的任务或函数，其中一些参数有缺省值，而又只想对它们中的部分参数进行设置，那么可以通过采用类似 <code>port</code> 的语法指定子程序参数名字的方式来指定一个子集，如<a href="#例3.14">例 3.14</a> 所示。</p><p><span id="例3.14"></span></p><figure class="highlight verilog"><figcaption><span>例 3.14 采用名字进行参数传递</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> many (<span class="keyword">input</span> <span class="keyword">int</span> a=<span class="number">1</span>, b=<span class="number">2</span>, c=<span class="number">3</span>, d=<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">"%0d %0d %0d %0d"</span>, a, b, c, d);</span><br><span class="line"><span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span>           <span class="comment">// a  b  c  d</span></span><br><span class="line">    many(<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>);   <span class="comment">// 6  7  8  9  指定所有值</span></span><br><span class="line">    many();             <span class="comment">// 1  2  3  4  使用默认值</span></span><br><span class="line">    many(<span class="variable">.c</span>(<span class="number">5</span>));        <span class="comment">// 1  2  5  4  只指定 c</span></span><br><span class="line">    many(, <span class="number">6</span>, <span class="variable">.d</span>(<span class="number">8</span>));   <span class="comment">// 1  6  3  8  混合方式</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure><h2 id="常见的代码错误">4.6. 常见的代码错误</h2><blockquote><p>在编写子程序代码时最容易犯的错误就是，往往会忘记，在默认情况下，参数的类型是与其前一个参数相同的，而第一个参数的默认类型是单比特输入。先看看<a href="#例3.15">例 3.15</a> 所示的简单的任务头。</p></blockquote><p><span id="例3.15"></span></p><figure class="highlight verilog"><figcaption><span>例 3.15 原始的任务头</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> sticky(<span class="keyword">int</span> a, b);</span><br></pre></td></tr></tbody></table></figure><p>这两个参数都是整型输入。在编写这个任务时，由于需要访问一个数组，因此又加入了一个新的数组参数，并且使用 <code>ref</code> 类型以便让数组值不被复制。修改后的子程序头如<a href="#例3.16">例 3.16</a> 所示。</p><p><span id="例3.16"></span></p><figure class="highlight verilog"><figcaption><span>例 3.16 加入额外数组参数的任务头</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> sticky(<span class="keyword">ref</span> <span class="keyword">int</span> array[<span class="number">50</span>],</span><br><span class="line">            <span class="keyword">int</span> a, b);      <span class="comment">// 这些变量的方向是什么？</span></span><br></pre></td></tr></tbody></table></figure><p><code>a</code> 和 <code>b</code> 的参数类型是什么呢？它们在方向上实际采用的是与前一个参数一致的 <code>ref</code> 类型。对简单的 <code>int</code> 变量使用 <code>ref</code> 通常并无必要，但编译器不会对此做出任何反应，连警告都没有，所以你不会意识到正在使用一个错误的方向类型。</p><p>如果在子程序中使用了非默认输入类型的参数，应该明确指明所有参数的方向，如<a href="#例3.17">例 3.17</a> 所示。</p><p><span id="例3.17"></span></p><figure class="highlight verilog"><figcaption><span>例 3.17 加入额外数组参数的任务头</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> sticky(<span class="keyword">ref</span>   <span class="keyword">int</span> array[<span class="number">50</span>],</span><br><span class="line">            <span class="keyword">input</span> <span class="keyword">int</span> a, b);  <span class="comment">// 明确指定方向</span></span><br></pre></td></tr></tbody></table></figure><h1 id="子程序的返回">5. 子程序的返回</h1><p>Verilog 中子程序的结束方式比较简单；当执行完子程序的最后一条语句，程序就会返回到调用子程序的代码上。此外，函数还会返回一个值，该值被赋给与函数同名的变量。</p><h2 id="返回-return-语句">5.1. 返回 (<code>return</code>) 语句</h2><p>SystemVerilog 增加了 <code>return</code> 语句，使子程序中的流程控制变得更方便。<a href="#例3.18">例 3.18</a> 中的任务由于发现错误而需要提前返回。如果不这样做，那么任务中剩下的部分就必须被放到一个 <code>else</code> 条件语句中，从而使得代码变得不规整，可读性也降低了。</p><p><span id="例3.18"></span></p><figure class="highlight verilog"><figcaption><span>例 3.18 在任务中用 <code>return</code> 返回</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> load_array(<span class="keyword">int</span> len, <span class="keyword">ref</span> <span class="keyword">int</span> array[]);</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">0</span>) <span class="keyword">begin</span></span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">"Bad len"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 任务中其余的代码</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">endtask</span></span><br></pre></td></tr></tbody></table></figure><p><code>return</code> 语句也可以简化函数，如<a href="#例3.19">例 3.19</a> 所示。</p><p><span id="例3.19"></span></p><figure class="highlight verilog"><figcaption><span>例 3.19 在函数中用 <code>return</code> 返回</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">bit</span> transmit(...);</span><br><span class="line">    <span class="comment">// Send transaction</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> ~ifc<span class="variable">.cb</span><span class="variable">.error</span>; <span class="comment">// 返回状态：0=error</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></tbody></table></figure><h2 id="从函数中返回一个数组">5.2. 从函数中返回一个数组</h2><p>Verilog 的子程序只能返回一个简单值，如比特、整数或是向量。如果想计算并返回一个数组，那就不是一件容易的事情了。在 SystemVerilog 中，函数可以采用多种方式返回一个数组。</p><p><strong>第一种方式是定义一个数组类型，然后在函数的声明中使用该类型</strong>。<a href="#例3.20">例 3.20</a> 使用了<a href="https://josh-gao.top/posts/2a5db13d.html#%E4%BE%8B2.35">例 2.35</a> 的数组类型，并创建了一个函数来初始化数组。</p><p><span id="例3.20"></span></p><figure class="highlight verilog"><figcaption><span>例 3.20 使用 <code>typedef</code> 从函数中返回一个数组</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> fixed_array5[<span class="number">5</span>];</span><br><span class="line">fixed_array5 f5;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> fixed_array5 init(<span class="keyword">int</span> start);</span><br><span class="line">    <span class="keyword">foreach</span> (init[i])</span><br><span class="line">        init[i] = i + start;</span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    f5 = init(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">foreach</span> (f5[i])</span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">"f5[%0d] = %0d"</span>, i, f5[i]);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure><p>使用上述代码的一个问题是，函数 <code>init</code> 创建了一个数组，该数组的值被拷贝到数组 <code>f5</code> 中。如果数组很大，那么可能会引起性能上的问题。</p><p><strong>另一种方式是通过引用来进行数组参数的传递</strong>。最简单的办法是以 ref 参数的形式将数组传递到函数里，如<a href="#例3.21">例 3.21</a> 所示。</p><p><span id="例3.21"></span></p><figure class="highlight verilog"><figcaption><span>例 3.21 把数组作为 <code>ref</code> 参数传递给函数</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> init(<span class="keyword">ref</span> <span class="keyword">int</span> f[<span class="number">5</span>], <span class="keyword">input</span> <span class="keyword">int</span> start);</span><br><span class="line">    <span class="keyword">foreach</span> (f[i])</span><br><span class="line">        f[i] = i + start;</span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    init(fa, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">foreach</span> (fa[i])</span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">"fa[%0d] = %0d"</span>, i, fa[i]);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure><p>从函数中返回数组的最后一种方式是将数组包装到一个类中，然后返回对象的句柄。</p><h1 id="局部数据存储">6. 局部数据存储</h1><p>Verilog 在 20 世纪 80 年代被创建时，最初的目的是用来描述硬件。因此，语言中的所有对象都是静态分配的。特别是，子程序参数和局部变量是被存放在固定位置的，而不像其他编程语言那样存放在堆栈区里。诸如递归子程序一类的动态代码没有对应的芯片实现方式，那还有什么必要为它们建模呢？对于那些做验证的软件工程师来说，使用 Verilog 可能会有些困难，他们已经习惯了像 C 一类的基于堆栈区 (stack-based) 的语言，因而在使用子程序库创建复杂 testbench 方面可能会显得力不从心。</p><h2 id="自动存储">6.1. 自动存储</h2><p>在 Verilog-1995 里，如果试图在测试程序里的多个地方调用同一个任务，由于任务里的局部变量会使用共享的静态存储区，所以不同的线程之间会窜用这些局部变量。在Verilog-2001 里，可以指定任务、函数和模块使用自动存储，从而迫使仿真器使用堆栈区存储局部变量。</p><blockquote><p>在 SystemVerilog 中，模块 (<code>module</code>) 和 <code>program</code> 块中的子程序默认情况下仍然使用静态存储。如果要使用自动存储，则必须在程序语句中加入 <code>automatic</code> 关键词。后续会详细讲解用于编写 testbench 代码的 <code>program</code> 块，以及如何在创建多线程时使用动态存储。</p></blockquote><p><a href="#例3.22">例 3.22</a> 所示的是一个用于监测数据何时被写人存储器的任务。</p><p><span id="例3.22"></span></p><figure class="highlight verilog"><figcaption><span>例 3.22 在 <code>program</code> 块中指定自动存储方式</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">program</span> <span class="keyword">automatic</span> test;</span><br><span class="line">    <span class="keyword">task</span> wait_for_mem(<span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] addr, expect_data,</span><br><span class="line">                      <span class="keyword">output</span> success);</span><br><span class="line">        <span class="keyword">while</span> (bus<span class="variable">.addr</span> !== addr)</span><br><span class="line">            @(bus<span class="variable">.addr</span>);</span><br><span class="line">        success = (bus<span class="variable">.data</span> == expect_data);</span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">endprogram</span></span><br></pre></td></tr></tbody></table></figure><p>因为参数 <code>addr</code> 和 <code>expect_data</code> 在每次调用时都使用不同的存储空间，所以对这个任务同时进行多次调用是没有问题的。但如果没有修饰符 <code>automatic</code>，由于第一次调用的任务处于等待状态，所以对 <code>wait_for_mem</code> 的第二次调用会覆盖它的两个参数。</p><h2 id="变量的初始化">6.2. 变量的初始化</h2><blockquote><p>当试图在声明中初始化局部变量时，类似的问题也会出现，因为局部变量实际上在仿真开始前就被赋了初值。常规的解决方法是<strong>避免在变量声明中赋予除常数以外的任何值</strong>。对局部变量使用单独的赋值语句也会使控制变得更方便。</p></blockquote><p><a href="#例3.23">例 3.23</a> 中的任务在检测总线五个周期以后，创建了一个局部变量并试图把当前地址总线的值作为初值赋给它。</p><p><span id="例3.23"></span></p><figure class="highlight verilog"><figcaption><span>例 3.23 静态初始化的 bug</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">program</span> initialization; <span class="comment">// 有 bug 的版本</span></span><br><span class="line">    <span class="keyword">task</span> check_bus;</span><br><span class="line">        <span class="keyword">repeat</span> (<span class="number">5</span>) @(<span class="keyword">posedge</span> clock);</span><br><span class="line">        <span class="keyword">if</span> (bus_cmd == 'READ) <span class="keyword">begin</span></span><br><span class="line">            <span class="comment">// 何时对 local_addr 赋初值？</span></span><br><span class="line">            <span class="keyword">logic</span> [<span class="number">7</span>:<span class="number">0</span>] local_addr = addr&lt;&lt;<span class="number">2</span>;  <span class="comment">// Bug</span></span><br><span class="line">            <span class="built_in">$display</span>(<span class="string">"Local Addr = %h"</span>, local_addr);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endprogram</span></span><br></pre></td></tr></tbody></table></figure><p>存在的 bug 是，变量 <code>local_addr</code> 是静态分配的，所以实际上在仿真的一开始它就有了初值，而不是等到进入 <code>begin ... end</code> 块中才进行初始化。同样，解决的办法是把程序块声明为 <code>automatic</code>，如同<a href="#例3.24">例 3.24</a> 所示。</p><p><span id="例3.24"></span></p><figure class="highlight verilog"><figcaption><span>例 3.24 修复静态初始化的 bug：使用 <code>automatic</code></span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">program</span> <span class="keyword">automatic</span> initialization; <span class="comment">// Bug 被修复</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">endprogram</span></span><br></pre></td></tr></tbody></table></figure><p>此外，如果不在声明中初始化变量，那这个 bug 也可以避免，只是这种方式不太好记住，尤其是对习惯了 C 语言的程序员。<a href="#例3.25">例 3.25</a> 给出了一种较为可取的编码风格，用于分离声明和初始化。</p><p><span id="例3.25"></span></p><figure class="highlight verilog"><figcaption><span>例 3.25 修复静态初始化的 bug：把声明和初始化拆开</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">logic</span> [<span class="number">7</span>:<span class="number">0</span>] local_addr</span><br><span class="line">local_addr = addr &lt;&lt; <span class="number">2</span>;  <span class="comment">// Bug</span></span><br></pre></td></tr></tbody></table></figure><h1 id="时间值">7. 时间值</h1><p>SystemVerilog 有几种新结构使你可以非常明确地在系统中指明时间值。</p><h2 id="时间单位和精度">7.1. 时间单位和精度</h2><p>当使用编译指示语句 <code>'timescale</code> 时，在编译文件时就必须按照适当的顺序以确保所有的时延都采用适宜的量程和精度。<code>timeunit</code> 和 <code>timeprecision</code> 声明语句可以明确地为每个模块指明时间值，从而避免歧义。<a href="#例3.26">例 3.26</a> 展示了这些声明语句。注意，如果使用这些语句替代 <code>`timescale</code>，则必须把它们放到每个带有时延的模块里。</p><h2 id="时间参数">7.2. 时间参数</h2><p>SystemVerilog 允许使用数值和单位来明确指定一个时间值。代码里可以使用类似 <code>0.1ns</code> 和 <code>20ps</code> 的时延。只要记得使用 <code>timeunit</code> 和 <code>timeprecision</code>、或者 <code>`timescale</code> 即可。还可以通过使用经典的 Verilog 时间函数 <code>$timeformat</code>，<code>$time</code> 和 <code>$realtime</code> 来使代码在时间标度上更清楚。<code>$timeformat</code> 的四个参数分别是时间标度 (-9 代表纳秒，-12 代表皮秒)，小数点后的数据精度，时间值之后的后缀字符串，以及显示数值的最小宽度。</p><p>例 3.26 所示的是使用 <code>$tmeformat()</code> 和 <code>%t</code> 指定符进行格式化后的多种时延以及打印结果。</p><p><span id="例3.26"></span></p><figure class="highlight verilog"><figcaption><span>例 3.26 时间参数和 <code>$timeformat</code></span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> timing;</span><br><span class="line">    <span class="keyword">timeunit</span> <span class="number">1</span>ns;</span><br><span class="line">    <span class="keyword">timeprecision</span> <span class="number">1</span>ps;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="built_in">$timeformat</span>(-<span class="number">9</span>, <span class="number">3</span>, <span class="string">"ns"</span>, <span class="number">8</span>);</span><br><span class="line">        #<span class="number">1</span>     <span class="built_in">$display</span>(<span class="string">"%t"</span>, <span class="built_in">$realtime</span>); <span class="comment">// 1.000ns</span></span><br><span class="line">        #<span class="number">2</span>ns   <span class="built_in">$display</span>(<span class="string">"%t"</span>, <span class="built_in">$realtime</span>); <span class="comment">// 3.000ns</span></span><br><span class="line">        #<span class="number">0</span><span class="variable">.1ns</span> <span class="built_in">$display</span>(<span class="string">"%t"</span>, <span class="built_in">$realtime</span>); <span class="comment">// 3.100ns</span></span><br><span class="line">        #<span class="number">41</span>ps  <span class="built_in">$display</span>(<span class="string">"%t"</span>, <span class="built_in">$realtime</span>); <span class="comment">// 3.141ns</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></tbody></table></figure><h2 id="时间和变量">7.3. 时间和变量</h2><p>可以把时间值存放到变量里，并在计算和延时中使用它们。根据当前的时间量程和精度，时间值会被缩放或舍入。<code>time</code> 类型的变量不能保存小数时延，因为它们是 64 比特的整数，所以时延的小数部分会被舍入。如果不希望这样，那应该采用 <code>real</code> 变量。</p><p><a href="#例3.27">例 3.27</a> 使用实 (real) 变量保存精确的数值，它们只在用作时延量的时候才被舍入。</p><p><span id="例3.27"></span></p><figure class="highlight verilog"><figcaption><span>例 3.27 时间变量及舍入</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ps/1ps</span></span><br><span class="line"><span class="keyword">module</span> ps;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">real</span> rdelay = <span class="number">800</span>fs;    <span class="comment">// 以 0.800 存储</span></span><br><span class="line">        <span class="keyword">time</span> tdelay = <span class="number">800</span>fs;    <span class="comment">// 舍入后得到 1</span></span><br><span class="line">        <span class="built_in">$timeformat</span>(-<span class="number">15</span>, <span class="number">0</span>, <span class="string">"fs"</span>, <span class="number">5</span>);</span><br><span class="line">        #rdelay;                <span class="comment">// 时延舍入后得到 1ps</span></span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">"%t"</span>, rdelay); <span class="comment">// "800fs"</span></span><br><span class="line">        #tdelay;                <span class="comment">// 再次延时 1ps</span></span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">"%t"</span>, tdelay); <span class="comment">// "1000fs"</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></tbody></table></figure><h2 id="time-与-realtime-的对比">7.4. <code>$time</code> 与 <code>$realtime</code> 的对比</h2><p>系统任务 <code>$time</code> 的返回值是一个根据所在模块的时间精度要求进行舍入的整数，不带小数部分，而 <code>$realtime</code> 的返回值则是一个带小数部分的完整实数。本文为简洁起见，所举例子中全部使用 <code>$time</code>，但请不要忘记，testbench 可能需要使用 <code>$realtime</code>。</p><h1 id="结束语">8. 结束语</h1><p>SystemVerilog 的程序化结构和任务、函数中的新特点使得它与诸如 C/C++ 一类的编程语言更加接近，从而也更便于编写 testbench。和 C/C++ 相比，SystemVerilog 还拥有额外的 HDL 结构，例如，时序控制、简单的线程控制和四态逻辑等。</p><h1 id="参考文献">参考文献</h1><ol type="1"><li>克里斯·斯皮尔, 斯皮尔, 张春,等. SystemVerilog验证:测试平台编写指南[M]. 科学出版社, 2009.</li><li>Spear C. SystemVerilog for verification: a guide to learning the testbench language features[M]. Springer Science &amp; Business Media, 2008.</li></ol><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script><link rel="stylesheet" href="/css/markmap.css"><script src="/js/markmap.js"></script></div><footer class="post-footer"><div class="post-copyright"><ul><li class="post-copyright-author"><strong>本文作者： </strong>Josh Gao</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://josh-gao.top/posts/43879201.html" title="Josh&#39;s Note — SystemVerilog 验证&lt;br&gt;Part 3 过程语句和子程序">https://josh-gao.top/posts/43879201.html</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="post-nav"><div class="post-nav-item"><a href="/posts/2a5db13d.html" rel="prev" title="Josh&#39;s Note — SystemVerilog 验证&lt;br&gt;Part 2 数据类型"><i class="fa fa-angle-left"></i> Josh's Note — SystemVerilog 验证<br>Part 2 数据类型</a></div><div class="post-nav-item"><a href="/posts/e28b5ccc.html" rel="next" title="牛津 3000 词汇表（The Oxford 3000）">牛津 3000 词汇表（The Oxford 3000） <i class="fa fa-angle-right"></i></a></div></div></footer></article></div><div class="comments gitalk-container"></div></div></main><footer class="footer"><div class="footer-inner"><div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">京ICP备2022006859号-1 </a><img src="/images/misc/%E5%A4%87%E6%A1%88%E5%9B%BE%E6%A0%87.png" alt=""><a href="https://beian.mps.gov.cn/#/query/webSearch?code=11010802039063" rel="noopener" target="_blank">京公网安备11010802039063号</a></div><div class="copyright">&copy; 2020 – <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Josh Gao</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span>站点总字数：</span> <span title="站点总字数">266k</span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span>站点阅读时长 &asymp;</span> <span title="站点阅读时长">16:07</span></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div><div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动</div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="reading-progress-bar"></div><a role="button" class="book-mark-link book-mark-link-fixed"></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous"><script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"joshgao22","repo":"Josh-Blog-Comment","client_id":"eb4dc2ea750519598663","client_secret":"4fe0fb49aeb8fac49c609796b214a99a6df044cf","admin_user":"joshgao22","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"en | es-ES | fr | ru | zh-CN | zh-TW","js":{"url":"https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"ff34f9c4d60e578278a0d5c5dd570c92"}</script><script src="/js/third-party/comments/gitalk.js" defer></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,log:!1,model:{jsonPath:"/live2dw/assets/assets/wanko.model.json"},display:{position:"right",width:200,height:250},mobile:{show:!0},react:{opacity:1}})</script></body></html>