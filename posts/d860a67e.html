<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222" media="(prefers-color-scheme: light)"><meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.3.0"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="apple-touch-icon" sizes="180x180" href="/images/meta/apple-touch-icon-j.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/meta/favicon-32x32-j.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/meta/favicon-16x16-j.png"><link rel="mask-icon" href="/images/meta/favicon-j.svg" color="#222"><meta name="google-site-verification" content="Iqgmf1lNNM2SYvtW-6MExzBfoISxK8nBEcwfPGM8giU"><meta name="baidu-site-verification" content="codeva-qqFHulQHkE"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&family=Noto+Serif+SC:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&family=Dancing+Script:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.36/dist/fancybox/fancybox.css" integrity="sha256-zM8WXtG4eUn7dKKNMTuoWZub++VnSfaOpA/8PJfvTBo=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-corner-indicator.css"><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous" defer></script><script class="next-config" data-name="main" type="application/json">{"hostname":"josh-gao.top","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.23.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":12,"offset":12,"width":260},"hljswrap":true,"codeblock":{"theme":{"light":"vs","dark":"github-dark-dimmed"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":true,"style":"mac"},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":true,"nav":null,"activeClass":"gitalk"},"stickytabs":false,"motion":{"enable":false,"async":true,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"slideRightBigIn","post_header":"perspectiveLeftIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideLeftIn"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false,"trigger":"auto"}}</script><script src="/js/config.js" defer></script><meta name="description" content="状态机是逻辑设计的重要内容，其设计水平直接反映工程师的逻辑功底，所以许多公司的硬件和逻辑工程师面试中，状态机设计几乎是必选题目。本文在引入状态机设计思想的基础上，重点讨论如何写好状态机。"><meta property="og:type" content="article"><meta property="og:title" content="Josh&#39;s Note — Verilog&lt;br&gt;Part 6 如何写好状态机"><meta property="og:url" content="https://josh-gao.top/posts/d860a67e.html"><meta property="og:site_name" content="Josh&#39;s Blog"><meta property="og:description" content="状态机是逻辑设计的重要内容，其设计水平直接反映工程师的逻辑功底，所以许多公司的硬件和逻辑工程师面试中，状态机设计几乎是必选题目。本文在引入状态机设计思想的基础上，重点讨论如何写好状态机。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://josh-gao.top/images/post/2023-04-16-josh-verilog-part-6/2023-04-16-josh-verilog-part-6-010-SchoolLifeStateTransitionDiagramOfStudentA.png"><meta property="og:image" content="https://josh-gao.top/images/post/2023-04-16-josh-verilog-part-6/2023-04-16-josh-verilog-part-6-020-SchoolLifeStateTransitionDiagramOfStudentB.png"><meta property="og:image" content="https://josh-gao.top/images/post/2023-04-16-josh-verilog-part-6/2023-04-16-josh-verilog-part-6-030-StateTransitionDiagramOfExample.png"><meta property="og:image" content="https://josh-gao.top/images/post/2023-04-16-josh-verilog-part-6/2023-04-16-josh-verilog-part-6-040-OneStageFSM.png"><meta property="og:image" content="https://josh-gao.top/images/post/2023-04-16-josh-verilog-part-6/2023-04-16-josh-verilog-part-6-050-TwoStageFSM.png"><meta property="og:image" content="https://josh-gao.top/images/post/2023-04-16-josh-verilog-part-6/2023-04-16-josh-verilog-part-6-060-ThreeStageFSM.png"><meta property="og:image" content="https://josh-gao.top/images/post/2023-04-16-josh-verilog-part-6/2023-04-16-josh-verilog-part-6-070-ComparisonOfOneAndThreeStageFSM.png"><meta property="article:published_time" content="2023-04-16T03:36:44.000Z"><meta property="article:modified_time" content="2024-06-06T11:43:16.616Z"><meta property="article:author" content="Josh Gao"><meta property="article:tag" content="Verilog"><meta property="article:tag" content="HDL"><meta property="article:tag" content="RTL"><meta property="article:tag" content="状态机"><meta property="article:tag" content="摩尔型"><meta property="article:tag" content="米里型"><meta property="article:tag" content="两段式"><meta property="article:tag" content="三段式"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://josh-gao.top/images/post/2023-04-16-josh-verilog-part-6/2023-04-16-josh-verilog-part-6-010-SchoolLifeStateTransitionDiagramOfStudentA.png"><link rel="canonical" href="https://josh-gao.top/posts/d860a67e.html"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://josh-gao.top/posts/d860a67e.html","path":"posts/d860a67e.html","title":"Josh's Note — Verilog\u003cbr>Part 6 如何写好状态机"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>Josh's Note — Verilog<br>Part 6 如何写好状态机 | Josh's Blog</title><script async src="https://www.googletagmanager.com/gtag/js?id=G-FS8FDJ89QM"></script><script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-FS8FDJ89QM","only_pageview":false,"measure_protocol_api_secret":null}</script><script src="/js/third-party/analytics/google-analytics.js" defer></script><script src="/js/third-party/analytics/baidu-analytics.js" defer></script><script async src="https://hm.baidu.com/hm.js?350182f3e243a2a441aad7e64040d3ce"></script><script data-pjax defer src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon="{&quot;token&quot;: &quot;97f59b7e4ea54bd79d9c911c06f990de&quot;}"></script><script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script><script src="https://cdn.jsdelivr.net/npm/@next-theme/pjax@0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous" defer></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.36/dist/fancybox/fancybox.umd.js" integrity="sha256-hiUEBwFEpLF6DlB8sGXlKo4kPZ46Ui4qGpd0vrVkOm4=" crossorigin="anonymous" defer></script><script src="https://cdn.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous" defer></script><script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous" defer></script><script src="/js/utils.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script><script src="/js/bookmark.js" defer></script><script src="/js/pjax.js" defer></script><script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.1/dist/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous" defer></script><script src="/js/third-party/search/local-search.js" defer></script><script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"forest","dark":"dark"},"js":{"url":"https://cdn.jsdelivr.net/npm/mermaid@11.5.0/dist/mermaid.min.js","integrity":"sha256-2obLuIPcceEhkE3G09G33hBdmE55ivVcZUlcKcGNHjU="}}</script><script src="/js/third-party/tags/mermaid.js" defer></script><script src="/js/third-party/fancybox.js" defer></script><script src="/js/third-party/pace.js" defer></script><script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"ams","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script><script src="/js/third-party/math/mathjax.js" defer></script><script src="https://cdn.jsdelivr.net/npm/quicklink@2.3.0/dist/quicklink.umd.js" integrity="sha256-yvJQOINiH9fWemHn0vCA5lsHWJaHs6/ZmO+1Ft04SvM=" crossorigin="anonymous" defer></script><script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":true,"archive":true,"delay":true,"timeout":3000,"priority":true,"url":"https://josh-gao.top/posts/d860a67e.html"}</script><script src="/js/third-party/quicklink.js" defer></script><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><style>.github-emoji{position:relative;display:inline-block;width:1.2em;min-height:1.2em;overflow:hidden;vertical-align:top;color:transparent}.github-emoji>span{position:relative;z-index:10}.github-emoji .fancybox,.github-emoji img{margin:0!important;padding:0!important;border:none!important;outline:0!important;text-decoration:none!important;user-select:none!important;cursor:auto!important}.github-emoji img{height:1.2em!important;width:1.2em!important;position:absolute!important;left:50%!important;top:50%!important;transform:translate(-50%,-50%)!important;user-select:none!important;cursor:auto!important}.github-emoji-fallback{color:inherit}.github-emoji-fallback img{opacity:0!important}</style></head><body itemscope itemtype="http://schema.org/WebPage"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Josh's Blog</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">一个电子工程师的修养</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">190</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">31</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">51</span></a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E6%9C%BA%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">1. 状态机的基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E6%9C%BA%E6%98%AF%E4%B8%80%E7%A7%8D%E6%80%9D%E6%83%B3%E6%96%B9%E6%B3%95"><span class="nav-text">1.1. 状态机是一种思想方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E6%9C%BA%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A6%81%E7%B4%A0%E4%B8%8E%E5%88%86%E7%B1%BB"><span class="nav-text">1.2. 状态机的基本要素与分类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E6%9C%BA%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%8F%8F%E8%BF%B0%E6%96%B9%E5%BC%8F"><span class="nav-text">1.3. 状态机的基本描述方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E5%9B%BE"><span class="nav-text">1.3.1. 状态转移图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E5%88%97%E8%A1%A8"><span class="nav-text">1.3.2. 状态转移列表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hdl-%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="nav-text">1.3.3. HDL 语言描述状态机</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BC%BA%E5%86%99%E5%A5%BD%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="nav-text">2. 如伺写好状态机</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A5%BD%E7%9A%84-rtl-%E7%BA%A7-fsm-%E6%8F%8F%E8%BF%B0"><span class="nav-text">2.1. 什么是好的 RTL 级 FSM 描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#rtl-%E7%BA%A7%E7%8A%B6%E6%80%81%E6%9C%BA%E6%8F%8F%E8%BF%B0%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95"><span class="nav-text">2.2. RTL 级状态机描述常用语法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A8%E8%8D%90%E7%9A%84%E7%8A%B6%E6%80%81%E6%9C%BA%E6%8F%8F%E8%BF%B0%E6%96%B9%E6%B3%95"><span class="nav-text">2.3. 推荐的状态机描述方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E6%AE%B5%E5%BC%8F%E7%8A%B6%E6%80%81%E6%9C%BA%E6%8F%8F%E8%BF%B0%E6%96%B9%E6%B3%95%E5%BA%94%E8%AF%A5%E9%81%BF%E5%85%8D%E7%9A%84%E5%86%99%E6%B3%95"><span class="nav-text">2.3.1. 一段式状态机描述方法（应该避免的写法）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A4%E6%AE%B5%E5%BC%8F%E7%8A%B6%E6%80%81%E6%9C%BA%E6%8F%8F%E8%BF%B0%E6%96%B9%E6%B3%95%E6%8E%A8%E8%8D%90%E5%86%99%E6%B3%95"><span class="nav-text">2.3.2. 两段式状态机描述方法（推荐写法）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E6%AE%B5%E5%BC%8F%E7%8A%B6%E6%80%81%E6%9C%BA%E6%8F%8F%E8%BF%B0%E6%96%B9%E6%B3%95%E6%8E%A8%E8%8D%90%E5%86%99%E6%B3%95"><span class="nav-text">2.3.3. 三段式状态机描述方法（推荐写法）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A7%8D%E6%8F%8F%E8%BF%B0%E6%96%B9%E6%B3%95%E4%B8%8E%E7%8A%B6%E6%80%81%E6%9C%BA%E5%BB%BA%E6%A8%A1%E9%97%AE%E9%A2%98%E7%9A%84%E5%BC%95%E7%94%B3"><span class="nav-text">2.3.4. 3 种描述方法与状态机建模问题的引申</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#n-%E6%AE%B5%E5%BC%8F%E6%8F%8F%E8%BF%B0%E6%96%B9%E6%B3%95%E5%92%8C-always-%E8%AF%AD%E6%B3%95%E5%9D%97%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="nav-text">2.3.4.1. n 段式描述方法和 always 语法块的个数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fsm-%E7%9A%84%E5%BB%BA%E6%A8%A1%E6%96%B9%E5%BC%8F"><span class="nav-text">2.3.4.2. FSM 的建模方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E6%AE%B5%E5%BC%8F%E5%BB%BA%E6%A8%A1%E5%92%8C%E4%B8%89%E6%AE%B5%E5%BC%8F%E5%BB%BA%E6%A8%A1%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-text">2.3.4.3. 一段式建模和三段式建模的关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%A4%E6%AE%B5%E5%BC%8F%E5%BB%BA%E6%A8%A1%E5%92%8C%E4%B8%89%E6%AE%B5%E5%BC%8F%E5%BB%BA%E6%A8%A1%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-text">2.3.4.4. 两段式建模和三段式建模的关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A7%8D%E6%8F%8F%E8%BF%B0-fsm-%E6%96%B9%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83"><span class="nav-text">2.3.4.5. 3 种描述 FSM 方法的比较</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E6%9C%BA%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7"><span class="nav-text">2.4. 状态机设计的其他技巧</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#fsm-%E7%9A%84%E7%BC%96%E7%A0%81"><span class="nav-text">2.4.1. FSM 的编码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fsm-%E5%88%9D%E5%A7%8B%E5%8C%96%E7%8A%B6%E6%80%81"><span class="nav-text">2.4.2. FSM 初始化状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fsm-%E7%8A%B6%E6%80%81%E7%BC%96%E7%A0%81%E5%AE%9A%E4%B9%89"><span class="nav-text">2.4.3. FSM 状态编码定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fsm-%E8%BE%93%E5%87%BA"><span class="nav-text">2.4.4. FSM 输出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E%E8%B5%8B%E5%80%BC"><span class="nav-text">2.4.5. 阻塞和非阻塞赋值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fsm-%E7%9A%84%E9%BB%98%E8%AE%A4%E7%8A%B6%E6%80%81"><span class="nav-text">2.4.6. FSM 的默认状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#full-case-%E4%B8%8E-parallel-case-%E7%BB%BC%E5%90%88%E5%B1%9E%E6%80%A7"><span class="nav-text">2.4.7. Full Case 与 Parallel Case 综合属性</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-text">3. 小结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE"><span class="nav-text">参考文献</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Josh Gao" src="/images/meta/favicon-j.svg"><p class="site-author-name" itemprop="name">Josh Gao</p><div class="site-description" itemprop="description">我，搞通信的</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">51</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">31</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">190</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/joshgao22" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;joshgao22" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:josh_gao@foxmail.com" title="E-Mail → mailto:josh_gao@foxmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a> </span><span class="links-of-author-item"><a href="https://blog.csdn.net/weixin_43870101" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_43870101" rel="noopener me" target="_blank"><i class="fab fa-cuttlefish fa-fw"></i>CSDN</a></span></div></div></div><div class="back-to-top animated" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div><div class="sidebar-inner sidebar-blogroll"><div class="links-of-blogroll animated"><div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i> 链接</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="https://gatsby.icu/zh-cn/" title="https:&#x2F;&#x2F;gatsby.icu&#x2F;zh-cn&#x2F;" rel="noopener" target="_blank">gatsby.icu</a></li></ul></div></div><div class="pjax"></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://josh-gao.top/posts/d860a67e.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/meta/favicon-j.svg"><meta itemprop="name" content="Josh Gao"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Josh's Blog"><meta itemprop="description" content="我，搞通信的"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="Josh&#39;s Note — Verilog&lt;br&gt;Part 6 如何写好状态机 | Josh's Blog"><meta itemprop="description" content="状态机是逻辑设计的重要内容，其设计水平直接反映工程师的逻辑功底，所以许多公司的硬件和逻辑工程师面试中，状态机设计几乎是必选题目。本文在引入状态机设计思想的基础上，重点讨论如何写好状态机。"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Josh's Note — Verilog<br>Part 6 如何写好状态机</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-04-16 11:36:44" itemprop="dateCreated datePublished" datetime="2023-04-16T11:36:44+08:00">2023-04-16</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2024-06-06 19:43:16" itemprop="dateModified" datetime="2024-06-06T19:43:16+08:00">2024-06-06</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Josh-%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">Josh 的学习笔记</span></a> </span>， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Josh-%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Verilog/" itemprop="url" rel="index"><span itemprop="name">Verilog</span></a> </span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span> </span><span class="post-meta-break"></span> <span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>12k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>45 分钟</span></span></div><div class="post-description">状态机是逻辑设计的重要内容，其设计水平直接反映工程师的逻辑功底，所以许多公司的硬件和逻辑工程师面试中，状态机设计几乎是必选题目。本文在引入状态机设计思想的基础上，重点讨论如何写好状态机。</div></div></header><div class="post-body" itemprop="articleBody"><h1 id="状态机的基本概念">1. 状态机的基本概念</h1><p>本节的重点在于理解状态机的基本概念和应用场合。</p><h2 id="状态机是一种思想方法">1.1. 状态机是一种思想方法<a id="toc.1.1"></a></h2><p>大多数工科生在学习数字电路时都学习过状态机的基本概念，了解一些使用状态机描述时序电路的基本方法。但是<strong>状态机不仅仅是一种时序电路设计工具，它更是一种思想方法</strong>。</p><span id="more"></span><p>先看一个简单的例子。在大学生活中，某同学的在校生活可以简单地概括为宿舍、教室、食堂之间的周而复始，可以用<a href="#fig.6-1">图 6-1</a> 形象地表现出来。这张图并不是要讨论这个学生是否是一个“乖乖”类型学生。</p><div class="note info"><p>请注意，如果将图中的“地点”认为是“状态”，将“功能“认为是状态的“输出”，这张图就是一张标准的状态转移图，也就是说，用状态机的方式清晰地描述了这个学生的在校生活方式。</p></div><p><a id="fig.6-1"></a></p><figure><img data-src="../images/post/2023-04-16-josh-verilog-part-6/2023-04-16-josh-verilog-part-6-010-SchoolLifeStateTransitionDiagramOfStudentA.png" width="600" alt="图 6-1 某学生在校生活状态转移图"><figcaption aria-hidden="true">图 6-1 某学生在校生活状态转移图</figcaption></figure><p>如果你认为这张图描述的学生生活过于单调而怀疑状态机描述方法的能力，就再看另一位生活丰富多彩的同学的在校生活，他/她的在校生活方式可以用<a href="#fig.6-2">图 6-2</a> 表示。</p><p><a id="fig.6-2"></a></p><figure><img data-src="../images/post/2023-04-16-josh-verilog-part-6/2023-04-16-josh-verilog-part-6-020-SchoolLifeStateTransitionDiagramOfStudentB.png" width="600" alt="图 6-2 另一位学生在校生活状态转移图"><figcaption aria-hidden="true">图 6-2 另一位学生在校生活状态转移图</figcaption></figure><div class="note info"><p>同样如果将图中的“地点”认为是“状态”，将“功能”认为是状态的“输出”，将“条件”认为是状态转移的“输入条件”，<a href="#fig.6-2">图 6-2</a> 也是一张标准的状态转移图，通过状态机的方式再次清晰地描述了另一个学生的在校生活方式。</p></div><p>事实上使用状态机可以细致入微地描述任何一位同学的在校生活方式。通过前面两个简单举例可以发现，<strong>状态机特别适合描述有发生有先后顺序，或者有逻辑规律的事情</strong>——这就是状态机的本质——对具有逻辑顺序或时序规律事件的一种描述方法。这个论断最重要的两个词就是“<strong>逻辑顺序</strong>”和“<strong>时序规律</strong>”，这两点就是状态机所要描述的核心和强项，换言之，<strong>所有具有逻辑顺序和时序规律的事情都适合用状态机描述</strong>。</p><p>很多初学者不知道何时应用状态机。这里介绍两种应用思路：第一种思路，<strong>从状态变量入手</strong>。如果一个电路具有时序规律或者逻辑顺序，就可以自然而然地规划出状态，从这些状态入手，分析每个状态的输入，状态转移和输出，从而完成电路功能。第二种思路，首先明确电路的输出关系，这些输出相当于状态的输出，<strong>回溯规划</strong>每个状态和状态转移条件与状态输入。无论哪种思路，使用状态机的目的都是要控制某部分电路，完成某种具有逻辑顺序或时序规律的电路设计。</p><p>其实对于逻辑电路而言，小到一个简单的时序逻辑，大到复杂的微处理器，都适合用状态机方法进行描述。请打开思路，不要仅仅局限于时序逻辑，发现电路的内在规律，确认电路的“状态变量”，大胆使用状态机描述电路模型。由于<strong>状态机不仅是一种电路描述工具，它更是一种思想方法</strong>，而且状态机的 HDL 语言表达方式比较规范，有章可循，所以很多有经验的设计者习惯用状态机思想进行逻辑设计，对各种复杂设计都套用状态机的设计理念，从而提高设计的效率和稳定性。</p><h2 id="状态机的基本要素与分类">1.2. 状态机的基本要素与分类</h2><p>状态机的基本要素有 3 个，其实在<a href="#toc.1.1">第一小节</a>的举例中都有涉及，只是没有点明，它们是：<strong>状态</strong>、<strong>输出</strong>和<strong>输入</strong>。</p><ul><li><p><strong>状态</strong>：也叫状态变量。在逻辑设计中，使用状态划分逻辑顺序和时序规律。比如，设计伪随机码发生器时，可以用移位寄存器序列作为状态；在设计电机控制电路时，可以以电机的不同转速作为状态；在设计通信系统时，可以用信号的状态作为状态变量等。</p></li><li><p><strong>输出</strong>：输出指<strong>在某一个状态时特定发生的事件</strong>。如设计电机控制电路中，如果电机转速过高，则输出为转速过高报警，也可以伴随减速指令或降温措施等。</p></li><li><p><strong>输入</strong>：指状态机中<strong>进入每个状态的条件</strong>，有的状态机没有输入条件，其中的状态转移较为简单，有的状态机有输入条件，当某个输入条件存在时才能转移到相应的状态。</p></li></ul><p>根据状态机的输出是否与输入条件相关，可将状态机分为两大类：摩尔（Moore）型状态机和米里 (Mealy) 型状态机。</p><ul><li><p><strong>摩尔型状态机</strong>：摩尔型状态机的<strong>输出仅仅依赖于当前状态，而与输入条件无关</strong>。例如<a href="#fig.6-1">图 6-1</a> 所示的例子，将图中的“地点”认为是“状态”，将“功能”认为是状态的“输出”，则每个输出仅仅与状态相关，所以它是一个摩尔型状态机。</p></li><li><p><strong>米里型状态机</strong>：米里型状态机的<strong>输出不仅依赖于当前状态，而且取决于该状态的输入条件</strong>。例如<a href="#fig.6-2">图 6-2</a> 所示的例子，将图中的“地点”认为是“状态”，将“功能”认为是状态的“输出”，将“条件”认为是状态转移的“输入条件”，可以发现，该学生到达什么地方，做什么事情都是由当前状态和输入条件共同决定，所以它是一个米里型状态机。</p></li></ul><p>根据状态机的数掀是否为有限个，可将状态机分为有限状态机 (Finite State Machine, FSM) 和无限状态机 （Infinite State Machine, ISM）。<strong>逻辑设计中一般所涉及的状态都是有限的，所以以后所说的状态机都指有限状态机</strong>，用 FSM 表示。</p><h2 id="状态机的基本描述方式">1.3. 状态机的基本描述方式</h2><p>逻辑设计中，状态机的基本描述方式有 3 种，分别是状态转移图、状态转移列表及 HDL 语言描述。</p><h3 id="状态转移图">1.3.1. 状态转移图</h3><p>状态转移图是状态机描述的最自然的方式。如<a href="#fig.6-1">图 6-1</a>、<a href="#fig.6-2">图 6-2</a> 都使用了状态转移图这一描述方式。状态转移图经常在设计规划阶段定义逻辑功能时使用，也可以在分析代码中状态机时使用，通过图形化的方式非常有助于理解设计意图。</p><p>另外值得一提的是目前有一些 EDA 工具支持状态转移图作为逻辑设计的输入，如 StateCAD。在该工具中设计者只要画出状态转移图就可以了， StateCAD 能自动将状态转移图翻译成 HDL 语言代码，而且翻译出来的代码规范、可读性较好、可综合、易维护。 StateCAD 还能自动检测状态机的完备性和正确性，对状态转移图中的冗余状态、自锁状态、歧义转移条件和不完备状态机等隐含错误都会报警，并协助设计者更正错误。最后 StateCAD 会自动生成设计的测试激励，并调用仿真程序，验证状态机的正确性，这个测试激励甚至可在后仿真中使用。总之， StateCAD 提供了状态机的输入、翻译、检测、优化和测试等一条龙的服务，使状态机的设计变得安全、可靠、快速、便捷。这类自动转换状态转移图为 HDL 源代码的工具对设计、分析一些规模较小的状态机非常有效，但是由于自动反应的代码过于程式化，效率不是很高，所以对于较大规模的逻辑设计，一般还是推荐使用 HDL 语言描述。</p><div class="note info"><p>使用 Synplify Pro 的 RTL 视图配合 FSM Viewer 可以将源代码中描述的 FSM 用状态转移图显示出来，使用图形化的界面帮助用户分析、理解状态机。</p></div><h3 id="状态转移列表">1.3.2. 状态转移列表</h3><p>状态转移列表是用列表的方式描述状态机，是数字逻辑电路常用的设计方法之一，经常被用于对状态化简，对可编程逻辑设计，由于可用逻辑资源比较丰富，而且状态编码要考虑设计的稳定性、安全性等因素，所以并不经常使用状态转移列表优化状态。</p><h3 id="hdl-语言描述状态机">1.3.3. HDL 语言描述状态机</h3><p>使用 HDL 语言描述状态机是本文讨论的重点，使用 HDL 语言描述状态机有一定的灵活性，但不是天马行空，而是有章可循的。通过一些规范的描述方法，可以使 HDL 语言描述的状态机更安全、稳定、高效、易于维护。</p><h1 id="如伺写好状态机">2. 如伺写好状态机</h1><p>本节重点讨论可综合的状态机描述的一些基本规范，即如何在 RTL 级描述安全、高效的 FSM。</p><h2 id="什么是好的-rtl-级-fsm-描述">2.1. 什么是好的 RTL 级 FSM 描述</h2><p>首先介绍好的 RTL 级 FSM 的评判标准。其实评判 FSM 的标准很多，这里挑选最重要的几个方面讨论一 下。好的 RTL 级 FSM 的评判标准如下：</p><ol type="1"><li><p><strong>FSM 要安全，稳定性高</strong></p><p>FSM 安全是指 FSM <strong>不会进入死循环，特别是不会进入非预知的状态，而且由于某些扰动进入非设计状态，也能很快地恢复到正常的状态循环中来</strong>。这里面有两层含义，第一 ，要求该 FSM 的综合实现结果<strong>无毛刺</strong>等异常扰动；第二，要求状态机要<strong>完备</strong>，即使收到异常扰动进入非设计状态，也能很快恢复到正常状态。</p></li><li><p>FSM 速度快，满足设计的频率要求</p><p>任何 RTL 设计都应该满足设计的频率要求。</p></li><li><p>FSM 面积小，满足设计的面积要求</p><p>同理任何 RTL 设计都应该满足设计的面积要求。</p></li><li><p>FSM 设计要清晰易懂、易维护</p><p>不规范的 FSM 写法很难让其他人解读，甚至过一段时间后设计者也发现很难维护。</p></li></ol><p>需要说明的是以上所列的各项标准，特别是前 3 项标准绝不是割裂的，它们直接有紧密的内在联系。前面花了相当长的篇幅论述 FPGA/CPLD 设计评判的两个基本标准：面积和速度。这里“面积”是指一个设计所消耗 FPGA/CPLD 的逻辑资源数量；“速度”指设计在芯片上稳定运行所能够达到的最高频率。两者是对立统一的矛盾体，要求一个设计同时具备设计面积最小，运行频率最高，这是不现实的。科学的设计目标应该是：<strong>在满足设计时序要求（包含对设计最高频率的要求）的前提下，占用最小的芯片面积，或者在所规定的面积下，使设计的时序余量更大，频率更高</strong>。</p><p>另外，如果要求 FSM 安全，则很多时候需要使用“full case”的编码方式，即将状态转移变量的所有向量组合情况都在 FSM 中有相应的处理，这势必意味若要多花更多的设计资源，有时也会影响 FSM 的频率。</p><p>所以，各条标准要综合考虑，根据设计的要求进行权衡。但是如果各条评判标准发生冲突时，请按照标准的罗列顺序考虑，前文标准的罗列顺序是根据这些标准在设计中的重要性排列的，也就是说第 1 条“FSM 要安全，稳定性高”的优先级最高，最重要；第 4 条“FSM 设计要清晰易懂易维护”的优先级最低，是相对次要的标准。</p><h2 id="rtl-级状态机描述常用语法">2.2. RTL 级状态机描述常用语法<a id="2.2"></a></h2><p>在 <a href="https://josh-gao.top/posts/fd2ca242.html">Part 2——Verilog 语言基础</a>和 <a href="https://josh-gao.top/posts/fd117896.html">Part 3——描述方式和设计层次</a>中论述了 Verilog 的基本语法和常用关键字，其中 RTL 级设计可综合的FSM 相关的常用关键字如下：</p><ol type="1"><li><p><code>wire</code>、<code>reg</code> 等</p><p>对 <code>wire</code>、<code>reg</code> 等变量、向量定义不加累述，需要补充的是<strong>状态编码时（也就是用某种编码描述各个状态）一般都要使用 <code>reg</code> 寄存器型向量</strong>。</p></li><li><p><code>parameter</code></p><p>用于描述状态名称，增强源代码可读性，简化描述。</p><p>例：某状态机使用初始值为 <code>0</code> 的<strong>独热码</strong>（one-hot）编码方式定义的 4 bit 宽度的状态变量 <code>NS</code>（代表 Next State，下一状态）和 <code>CS</code>（代表 Current State，当前状态），且状态机包含 5 个具体状态 <code>IDLE</code>（空闲状态）、<code>S1</code>（工作状态 1）、 <code>S2</code>（工作状态 2）、 <code>S3</code>（工作状态 3）、<code>ERROR</code>（告警状态），则代码如下：</p><p></p><figure class="highlight verilog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span>         [<span class="number">3</span>:<span class="number">0</span>] NS,CS;</span><br><span class="line"><span class="keyword">parameter</span>   [<span class="number">3</span>:<span class="number">0</span>]             <span class="comment">// one hot with zero initial</span></span><br><span class="line">    IDLE    = <span class="number">4'b0000</span>,</span><br><span class="line">    S1      = <span class="number">4'b0001</span>,</span><br><span class="line">    S2      = <span class="number">4'b0010</span>,</span><br><span class="line">    S3      = <span class="number">4'b0100</span>,</span><br><span class="line">    ERROR   = <span class="number">4'b1000</span>;</span><br></pre></td></tr></tbody></table></figure><p></p></li><li><p><code>always</code></p><p>在 FSM 设计中有 3 种 <code>always</code> 的使用方法，第 1 种用法是根据<strong>主时钟沿</strong>，完成同步时序的状态迁移。</p><p>例：某状态机从当前状态 <code>CS</code> 迁移到下一个状态 <code>NS</code> 可以如下表述：</p><p></p><figure class="highlight verilog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sequential state transition</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> elk <span class="keyword">or</span> <span class="keyword">negedge</span> nrst)</span><br><span class="line">    <span class="keyword">if</span> (!nrst)</span><br><span class="line">        CS &lt;= IDLE;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        CS &lt;= NS;</span><br></pre></td></tr></tbody></table></figure><p></p><p><code>always</code> 的第 2 种用法是根据<strong>信号敏感表</strong>，完成组合逻辑的输出。</p><p><code>always</code> 的第 3 种用法是根据<strong>时钟沿</strong>，完成同步时序逻辑的输出。</p></li><li><p><code>case/endcase</code></p><p><code>case/endcase</code> 是 FSM 描述中最重要的语法关键字 ，要详细讨论一下。 <code>case/endcase</code> 的基本语法结构如下：</p><p></p><figure class="highlight verilog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> (case_expression)</span><br><span class="line">    case_item1 : case_item_statement1;</span><br><span class="line">    case_item2 : case_item_statement2;</span><br><span class="line">    case_item3 : case_item_statement3;</span><br><span class="line">    case_item4 : case_item_statement4;</span><br><span class="line">    <span class="keyword">default</span>    : case_item_statement5;</span><br><span class="line"><span class="keyword">endcase</span></span><br></pre></td></tr></tbody></table></figure><p></p><p>其中：</p><ul><li><code>case_expression</code> 就是 <code>case</code> 的判断条件表达式，在 FSM 描述中，它一般为当前状态寄存器；每个 <code>case_item</code> 是 <code>case</code> 语句的分支列表，在 FSM 描述中，它一般为 FSM 中的所有状态的罗列，从中还可以分析出状态的编码方式；</li><li><code>case_item_statement</code> 为进入每个 <code>case_item</code> 的对应操作，在 FSM 中，即为每个状态对应的状态转移或者输出，如果 <code>case_item_statement</code> 包含的操作不只一条，可以用 <code>begin/end</code> 嵌套多条操作；</li><li><code>default</code> 是可选的关键字，用以指明当所列的所有 <code>case_item</code> 与 <code>case_ex­pression</code> 都不匹配时的操作，在 FSM 设计中，为了提高设计的安全性，排除所设计的FSM 进入死循环，一般要求加上 <code>default</code> 关键字来描述 FSM 所需状态的补集状态下的操作。</li></ul><p>另外 Verilog 还支持 <code>casex</code> 和 <code>casez</code> 等不同关键字，但是由于综合器对这两个关键字的支持情况略有差异，所以建议初学者使用完整的 <code>case</code> 结构而不使用 <code>casex</code> 或 <code>casez</code>。</p><p>例：某 FSM 的状态转移用 <code>case/endcase</code> 结构描述如下：</p><p></p><figure class="highlight verilog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> (CS)</span><br><span class="line">    IDLE:       <span class="keyword">begin</span></span><br><span class="line">                    IDLE_out;</span><br><span class="line">                    <span class="keyword">if</span> (~i1)             NS = IDLE;</span><br><span class="line">                    <span class="keyword">if</span> (i1 &amp;&amp; i2)         NS = S1;</span><br><span class="line">                    <span class="keyword">if</span> (i1 &amp;&amp; (~i2))     NS = ERROR;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">    S1:         <span class="keyword">begin</span></span><br><span class="line">                    S1_out;</span><br><span class="line">                    <span class="keyword">if</span> (~i2)            NS = S1;</span><br><span class="line">                    <span class="keyword">if</span> (i2 &amp;&amp; i1)        NS = S2;</span><br><span class="line">                    <span class="keyword">if</span> (i2 &amp;&amp; (~i))        NS = ERROR;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">    S2:         <span class="keyword">begin</span></span><br><span class="line">                    S2_out;</span><br><span class="line">                    <span class="keyword">if</span> (i2)                NS = S2;</span><br><span class="line">                    <span class="keyword">if</span> ((~i2) &amp;&amp; i1)    NS = IDLE;</span><br><span class="line">                    <span class="keyword">if</span> ((~i2) &amp;&amp; (~i1))    NS = ERROR;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">    ERROR:      <span class="keyword">begin</span></span><br><span class="line">                    ERROR_out;</span><br><span class="line">                    <span class="keyword">if</span> (i1)                NS = ERROR;</span><br><span class="line">                    <span class="keyword">if</span> (~i1)            NS = IDLE;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">default</span>:    <span class="keyword">begin</span></span><br><span class="line">                    Default_out;</span><br><span class="line">                    NS = ERROE;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endcase</span></span><br></pre></td></tr></tbody></table></figure><p></p><p></p><div class="note warning"><p>Verilog 的 <code>case</code> 结构虽然与 C 等高级语言的 <code>case</code> 结构形式相似，但是本质不同。Verilog 的 <code>case</code> 结构对应并行判断的硬件结构，而且当 <code>case_expression</code> 与任意一个 <code>case_item</code> 匹配后，将忽略对其他 <code>case_item</code> 的判断，执行完匹配的 <code>case_item_statement</code> 后直接跳出 <code>case</code> 结构。</p></div><p></p></li><li><p><code>task/endtask</code></p><p><code>task/endtask</code> 在描述状态机时主要用途是将不同状态对应的输出用 <code>task/endtask</code> 封装，增强了代码的可维护性和可读性。</p><p>例：某状态机 IDLE 状态的输出可以用 <code>task/endtask</code> 封装为 <code>IDLE_out</code> 任务：</p><p></p><figure class="highlight verilog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> IDLE_out;</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        {w_ol, w_o2, w_err} = <span class="number">3'b000</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endtask</span></span><br></pre></td></tr></tbody></table></figure><p></p><p><code>endtask</code> 描述状态机时也会使用到其他一些常用的 RTL 级语法，如 <code>if/else</code>、<code>as­sign</code> 等，它们的功能和一般 RTL 描述方法一致，这里不在叙述。</p></li></ol><h2 id="推荐的状态机描述方法">2.3. 推荐的状态机描述方法<a id="2.3"></a></h2><p>状态机描述时关键是要描述清楚前面提到的几个状态机的要素，即如何进行状态转移；每个状态的输出是什么；状态转移是否和输入条件相关等。具体描述时方法各不相同。</p><ul><li><p>有的设计者习惯将整个状态机写到 1 个 always 模块里面，在该模块中既描述状态转移，又描述状态的输入和输出，这种写法一般被称为<strong>一段式 FSM 描述方法</strong>；</p></li><li><p>还有一种写法是将 2 个 <code>always</code> 模块中的一个 <code>always</code> 模块采用同步时序描述状态转移，另一个模块采用组合逻辑判断状态转移条件，描述状态转移规律，这种写法被称为<strong>两段式 FSM 描述方法</strong>；</p></li><li><p>还有一种写法是在两段式描述方法基础上发展出来的，这种写法使用 3 个 <code>always</code> 模块，第 1 个 <code>always</code> 模块采用同步时序描述状态转移；第 2 个采用组合逻辑判断状态转移条件，描述状态转移规律；第 3 个 <code>always</code> 模块使用同步时序电路描述每个状态的输出，这种写法在这里称为<strong>三段式写法</strong>。</p></li></ul><p>一般而言，推荐的 FSM 描述方法是后两种，即两段式和三段式 FSM 描述方法。其原因为：FSM 和其他设计一样，最好使用同步时序方式设计，以提高设计的稳定性，消除毛刺。状态机实现后，一般来说，<strong>状态转移部分是同步时序电路</strong>，而<strong>状态的转移条件的判断是组合逻辑</strong>。两段式之所以比一段式编码合理，就在于<strong>两段式编码将同步时序和组合逻辑分别放到不同的 <code>always</code> 程序块中实现</strong>。这样做的好处不仅是便于阅读、理解、维护，更重要的是利于综合器优化代码、利于用户添加合适的时序约束条件、利于布局布线器实现设计。而一段式 FSM 描述不利于时序约束、功能更改、调试等，而且不能很好的表示米里 FSM 的输出，容易写出 Latches，导致逻辑功能错误。</p><p>在一般两段式描述中，为了便于描述当前状态的输出，很多设计者习惯将当前状态的输出用组合逻辑实现。但是这种组合逻辑<strong>仍然有产生毛刺的可能性</strong>，而且不利于约束、不利于综合器和布局布线器实现高性能的设计。因此如果设计运行额外的一个时钟节拍的插入（latency），则要求尽量对状态机的输出用寄存器寄存一拍。但是很多<strong>实际情况不允许插入一个寄存节拍，此时则可以通过三段式描述方法进行解决</strong>。三段式与两段式相比，关键在于根据状态转移规律，在上一状态根据输入条件判断出当前状态的输出，从而在不插入额外时钟节拍的前提下，实现了寄存器输出。</p><p>为了便于理解，将通过一个使用不同的 FSM 描述风格描述状态机的实例讨论这 3 种不同的写法。</p><p>在这个范例中将用一段式、两段式、三段式分别描述例子的状态转移，如<a href="#fig.6-3">图 6-3</a> 所示。这里选用了一个非常典型的米里型状态机，共有 4 个状态： <code>IDEL</code>、<code>S1</code>、<code>S2</code>、<code>ERROR</code>；输入信号为时钟 <code>clk</code>，低电平异步复位信号 <code>nrst</code>， 输入信号 <code>i1</code>、<code>i2</code>，输出信号为 <code>o1</code>、<code>o2</code> 和 <code>err</code>，状态关系如<a href="#fig.6-3">图 6-3</a> 所示。状态的输出如下：</p><figure class="highlight verilog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IDLE        状态的输出为：    {o1, o2, err} = <span class="number">3'b000</span>；</span><br><span class="line">S1          状态的输出为：    {o1, o2, err} = <span class="number">3'b100</span>；</span><br><span class="line">S2          状态的输出为：    {o1, o2, err} = <span class="number">3'b010</span>；</span><br><span class="line">ERROR       状态的输出为：    {o1, o2, err} = <span class="number">3'b111</span>。</span><br></pre></td></tr></tbody></table></figure><p><a id="fig.6-3"></a></p><figure><img data-src="../images/post/2023-04-16-josh-verilog-part-6/2023-04-16-josh-verilog-part-6-030-StateTransitionDiagramOfExample.png" width="600" alt="图 6-3 例子的状态转移图"><figcaption aria-hidden="true">图 6-3 例子的状态转移图</figcaption></figure><h3 id="一段式状态机描述方法应该避免的写法">2.3.1. 一段式状态机描述方法（应该避免的写法）</h3><p>该例的一段式描述代码如下：</p><figure class="highlight verilog"><figcaption><span>state1.v</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// state1.v</span></span><br><span class="line"><span class="comment">// 1-paragraph method to describe FSM</span></span><br><span class="line"><span class="comment">// Describe state transition, state output, state input condition in only 1</span></span><br><span class="line"><span class="comment">// always block</span></span><br><span class="line"><span class="comment">// Westor, Dec. 2006</span></span><br><span class="line"><span class="comment">// Verilog Usage Book</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> state1 (</span><br><span class="line">    nrst,clk,</span><br><span class="line">    i1,i2,</span><br><span class="line">    o1,o2,</span><br><span class="line">    err</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>          nrst,clk;</span><br><span class="line"><span class="keyword">input</span>          i1,i2;</span><br><span class="line"><span class="keyword">output</span>         o1,o2,err;</span><br><span class="line"><span class="keyword">reg</span>            o1,o2,err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span>    [<span class="number">2</span>:<span class="number">0</span>]   NS;      <span class="comment">// NextState</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">parameter</span> [<span class="number">2</span>:<span class="number">0</span>]         <span class="comment">// one hot with zero idle</span></span><br><span class="line">    IDLE   = <span class="number">3'b000</span>,</span><br><span class="line">    S1     = <span class="number">3'b001</span>,</span><br><span class="line">    S2     = <span class="number">3'b010</span>,</span><br><span class="line">    ERROR  = <span class="number">3'b100</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1 always block to describe state transition, state output, state input</span></span><br><span class="line"><span class="comment">// condition</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> nrst)</span><br><span class="line">    <span class="keyword">if</span> (!nrst) <span class="keyword">begin</span></span><br><span class="line">       NS         &lt;= IDLE;</span><br><span class="line">      {o1,o2,err} &lt;= <span class="number">3'b000</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        NS          &lt;=  <span class="number">3'bx</span>;</span><br><span class="line">        {o1,o2,err} &lt;=  <span class="number">3'b000</span>;</span><br><span class="line">        <span class="keyword">case</span> (NS)</span><br><span class="line">            IDLE:  <span class="keyword">begin</span></span><br><span class="line">                    <span class="keyword">if</span> (~i1)         <span class="keyword">begin</span>{o1,o2,err}&lt;=<span class="number">3'b000</span>;NS &lt;= IDLE; <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">if</span> (i1 &amp;&amp; i2)    <span class="keyword">begin</span>{o1,o2,err}&lt;=<span class="number">3'b100</span>;NS &lt;= S1;   <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">if</span> (i1 &amp;&amp; ~i2)   <span class="keyword">begin</span>{o1,o2,err}&lt;=<span class="number">3'b111</span>;NS &lt;= ERROR;<span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">            S1:     <span class="keyword">begin</span></span><br><span class="line">                    <span class="keyword">if</span> (~i2)         <span class="keyword">begin</span>{o1,o2,err}&lt;=<span class="number">3'b100</span>;NS &lt;= S1;   <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">if</span> (i2 &amp;&amp; i1)    <span class="keyword">begin</span>{o1,o2,err}&lt;=<span class="number">3'b010</span>;NS &lt;= S2;   <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">if</span> (i2 &amp;&amp; (~i1)) <span class="keyword">begin</span>{o1,o2,err}&lt;=<span class="number">3'b111</span>;NS &lt;= ERROR;<span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">            S2:     <span class="keyword">begin</span></span><br><span class="line">                    <span class="keyword">if</span> (i2)          <span class="keyword">begin</span>{o1,o2,err}&lt;=<span class="number">3'b010</span>;NS &lt;= S2;   <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">if</span> (~i2 &amp;&amp; i1)   <span class="keyword">begin</span>{o1,o2,err}&lt;=<span class="number">3'b000</span>;NS &lt;= IDLE; <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">if</span> (~i2 &amp;&amp; (~i1))<span class="keyword">begin</span>{o1,o2,err}&lt;=<span class="number">3'b111</span>;NS &lt;= ERROR;<span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">            ERROR:  <span class="keyword">begin</span></span><br><span class="line">                    <span class="keyword">if</span> (i1)          <span class="keyword">begin</span>{o1,o2,err}&lt;=<span class="number">3'b111</span>;NS &lt;= ERROR;<span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">if</span> (~i1)         <span class="keyword">begin</span>{o1,o2,err}&lt;=<span class="number">3'b000</span>;NS &lt;= IDLE; <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></tbody></table></figure><p>如前面介绍，一段式写法就是将状态的同步转移、状态输出和状态的输入条件都写在一个 <code>always</code> 模块中，一段式写法可以概括为<a href="#fig.6-4">图 6-4</a> 描述的结构。</p><p><a id="fig.6-4"></a></p><figure><img data-src="../images/post/2023-04-16-josh-verilog-part-6/2023-04-16-josh-verilog-part-6-040-OneStageFSM.png" width="900" alt="图 6-4 一段式 FSM 描述结构"><figcaption aria-hidden="true">图 6-4 一段式 FSM 描述结构</figcaption></figure><p>一段式描述方法将状态转移判断的组合逻辑和状态寄存器转移的时序逻辑混写在同一个 always 模块中，<strong>不符合将时序和组合逻辑分开描述的 Coding Style（代码风格）</strong>，而且在描述当前状态时要考虑下个状态的输出，整个代码不清晰，不利于维护修改，并且不利于附加约束，不利于综合器和布局布线器对设计的优化。</p><p>另外，这种描述相对于两段式描述比较<strong>冗长</strong>。本例为了便于初学者掌握，选择了一个非常简单的米里型状态机，不能很好的反应一段式比较冗长的缺点，但是如果状态机相对复杂些，一般来说，一段式代码长度会比两段式冗长大约 80%~150%。</p><p>所以一段式 FSM 描述是不推荐的 FSM 描述方式，请一定要避免。</p><h3 id="两段式状态机描述方法推荐写法">2.3.2. 两段式状态机描述方法（推荐写法）</h3><p>为了使 FSM 描述清晰简洁，易于维护，易于附加时序约束，使综合器和布局布线器更好的优化设计，推荐使用两段式 FSM 描述方法。</p><p>本例的两段式描述代码如下：</p><figure class="highlight verilog"><figcaption><span>state2.v</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// state2.v</span></span><br><span class="line"><span class="comment">// 2-paragraph method to describe FSM</span></span><br><span class="line"><span class="comment">// Describe sequential state transition in 1 sequential always block</span></span><br><span class="line"><span class="comment">// State transition conditions in the other combinational always block</span></span><br><span class="line"><span class="comment">// Package state output by task. Then register the output</span></span><br><span class="line"><span class="comment">// Westor, Dec. 2006</span></span><br><span class="line"><span class="comment">// Verilog Usage Book</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> state2 (</span><br><span class="line">    nrst,clk,</span><br><span class="line">    i1,i2,</span><br><span class="line">    o1,o2,</span><br><span class="line">    err</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>          nrst,clk;</span><br><span class="line"><span class="keyword">input</span>          i1,i2;</span><br><span class="line"><span class="keyword">output</span>         o1,o2,err;</span><br><span class="line"><span class="keyword">reg</span>            o1,o2,err;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span>    [<span class="number">2</span>:<span class="number">0</span>]   NS,CS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">parameter</span> [<span class="number">2</span>:<span class="number">0</span>]         <span class="comment">// one hot with zero idle</span></span><br><span class="line">    IDLE   = <span class="number">3'b000</span>,</span><br><span class="line">    S1     = <span class="number">3'b001</span>,</span><br><span class="line">    S2     = <span class="number">3'b010</span>,</span><br><span class="line">    ERROR  = <span class="number">3'b100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sequential state transition</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> nrst)</span><br><span class="line">    <span class="keyword">if</span> (!nrst)</span><br><span class="line">        CS &lt;= IDLE;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        CS &lt;= NS;</span><br><span class="line"></span><br><span class="line"><span class="comment">// combinational condition judgment</span></span><br><span class="line"><span class="keyword">always</span> @(nrst <span class="keyword">or</span> CS <span class="keyword">or</span> i1 <span class="keyword">or</span> i2) <span class="keyword">begin</span></span><br><span class="line">    NS = <span class="number">3'bx</span>;</span><br><span class="line">    ERROR_out;</span><br><span class="line">    <span class="keyword">case</span> (CS)</span><br><span class="line">        IDLE:   <span class="keyword">begin</span></span><br><span class="line">                    IDLE_out;</span><br><span class="line">                    <span class="keyword">if</span> (~i1)           NS = IDLE;</span><br><span class="line">                    <span class="keyword">if</span> (i1 &amp;&amp; i2)      NS = S1;</span><br><span class="line">                    <span class="keyword">if</span> (i1 &amp;&amp; ~i2)     NS = ERROR;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">        S1:     <span class="keyword">begin</span></span><br><span class="line">                    S1_out;</span><br><span class="line">                    <span class="keyword">if</span> (~i2)           NS = S1;</span><br><span class="line">                    <span class="keyword">if</span> (i2 &amp;&amp; i1)      NS = S2;</span><br><span class="line">                    <span class="keyword">if</span> (i2 &amp;&amp; (~i1))   NS = ERROR;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">        S2:     <span class="keyword">begin</span></span><br><span class="line">                    S2_out;</span><br><span class="line">                    <span class="keyword">if</span> (i2)            NS = S2;</span><br><span class="line">                    <span class="keyword">if</span> (~i2 &amp;&amp; i1)     NS = IDLE;</span><br><span class="line">                    <span class="keyword">if</span> (~i2 &amp;&amp; (~i1))  NS = ERROR;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">        ERROR:  <span class="keyword">begin</span></span><br><span class="line">                    ERROR_out;</span><br><span class="line">                    <span class="keyword">if</span> (i1)            NS = ERROR;</span><br><span class="line">                    <span class="keyword">if</span> (~i1)           NS = IDLE;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// output task</span></span><br><span class="line"><span class="keyword">task</span> IDLE_out;</span><br><span class="line">     {o1,o2,err} = <span class="number">3'b000</span>;</span><br><span class="line"><span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">task</span> S1_out;</span><br><span class="line">     {o1,o2,err} = <span class="number">3'b100</span>;</span><br><span class="line"><span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">task</span> S2_out;</span><br><span class="line">     {o1,o2,err} = <span class="number">3'b010</span>;</span><br><span class="line"><span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">task</span> ERROR_out;</span><br><span class="line">     {o1,o2,err} = <span class="number">3'b111</span>;</span><br><span class="line"><span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></tbody></table></figure><p>两段式写法是推荐的 FSM 描述方法之一，在此仔细讨论一下代码结构。两段式 FSM 的核心就是：<strong>一个 always 模块采用同步时序描述状态转移；另一个模块采用组合逻辑判断状态转移条件，描述状态转移规律</strong>。两段式写法可以概括为<a href="图6-5">图 6-5</a> 所示的结构。</p><p><a id="fig.6-5"></a></p><figure><img data-src="../images/post/2023-04-16-josh-verilog-part-6/2023-04-16-josh-verilog-part-6-050-TwoStageFSM.png" width="900" alt="图 6-5 两段式FSM描述结构图"><figcaption aria-hidden="true">图 6-5 两段式FSM描述结构图</figcaption></figure><p>本例中，同步时序描述状态转移的 <code>always</code> 模块代码如下：</p><figure class="highlight verilog"><figcaption><span>state2.v</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> nrst)</span><br><span class="line">    <span class="keyword">if</span> (!nrst)</span><br><span class="line">        CS &lt;= IDLE;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        CS &lt;= NS;</span><br></pre></td></tr></tbody></table></figure><p>其实这是一种<strong>程式化的描述结构</strong>，无论具体到何种 FSM 设计，都可以定义两个状态寄存器 <code>CS</code> 和 <code>NS</code>, 分别代表当前状态和下一状态 ， 然后根据所需的复位方式（同步复位或异步复位），在时钟沿到达时将 <code>NS</code> 赋给 <code>CS</code> 。需要注意的是这个同步时序模块的赋值要<strong>采用非阻塞赋值</strong> <code>&lt;=</code>。</p><p>本例中，另一个采用组合逻辑判断状态转移条件的 <code>always</code> 模块代码如下：</p><figure class="highlight verilog"><figcaption><span>state2.v</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// combinational condition judgment</span></span><br><span class="line"><span class="keyword">always</span> @(nrst <span class="keyword">or</span> CS <span class="keyword">or</span> i1 <span class="keyword">or</span> i2) <span class="keyword">begin</span></span><br><span class="line">    NS = <span class="number">3'bx</span>;</span><br><span class="line">    ERROR_out;</span><br><span class="line">    <span class="keyword">case</span> (CS)</span><br><span class="line">        IDLE:   <span class="keyword">begin</span></span><br><span class="line">                    IDLE_out;</span><br><span class="line">                    <span class="keyword">if</span> (~i1)           NS = IDLE;</span><br><span class="line">                    <span class="keyword">if</span> (i1 &amp;&amp; i2)      NS = S1;</span><br><span class="line">                    <span class="keyword">if</span> (i1 &amp;&amp; ~i2)     NS = ERROR;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">        S1:     <span class="keyword">begin</span></span><br><span class="line">                    S1_out;</span><br><span class="line">                    <span class="keyword">if</span> (~i2)           NS = S1;</span><br><span class="line">                    <span class="keyword">if</span> (i2 &amp;&amp; i1)      NS = S2;</span><br><span class="line">                    <span class="keyword">if</span> (i2 &amp;&amp; (~i1))   NS = ERROR;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">        S2:     <span class="keyword">begin</span></span><br><span class="line">                    S2_out;</span><br><span class="line">                    <span class="keyword">if</span> (i2)            NS = S2;</span><br><span class="line">                    <span class="keyword">if</span> (~i2 &amp;&amp; i1)     NS = IDLE;</span><br><span class="line">                    <span class="keyword">if</span> (~i2 &amp;&amp; (~i1))  NS = ERROR;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">        ERROR:  <span class="keyword">begin</span></span><br><span class="line">                    ERROR_out;</span><br><span class="line">                    <span class="keyword">if</span> (i1)            NS = ERROR;</span><br><span class="line">                    <span class="keyword">if</span> (~i1)           NS = IDLE;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure><p>这个使用组合逻辑判断状态转移条件的 <code>always</code> 模块也<strong>可以看成格式化的书写结构</strong>。其中 <code>always</code> 的敏感列表为当前状态 <code>CS</code>, 复位信号和输入条件（<strong>如果是米里状态机，则必须有输入条件；如果是摩尔状态机，一般敏感表和后续逻辑判定没有输入</strong>），请大家注意<strong>电平敏感表必须列完整</strong>。本例中这段电平敏感列表为：</p><figure class="highlight verilog"><figcaption><span>state2.v</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(nrst <span class="keyword">or</span> CS <span class="keyword">or</span> i1 <span class="keyword">or</span> i2)</span><br></pre></td></tr></tbody></table></figure><p>一般来说，在这个组合 <code>always</code> 敏感表下先写一个默认的下一状态 <code>NS</code> 的描述，然后根据实际的状态转移条件由内部的 <code>case</code> 或者 <code>if ... else</code> 条件判断确定正确的转移。如本例中下面这段代码，</p><figure class="highlight verilog"><figcaption><span>state2.v</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    NS = <span class="number">3'bx</span>;</span><br><span class="line">    ERROR_out;</span><br><span class="line">    <span class="keyword">case</span> (CS)</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></tbody></table></figure><p>推荐<strong>在敏感表下的默认状态为不定状态 <code>X</code></strong>， 这样描述的好处有两个：第一在仿真时可以很好地考察所设计的 FSM 的完备性，如果所设计的 FSM 不完备，则会进入任意状态，仿真很容易发现；第二个好处是综合器对不定态 <code>X</code> 的处理是 “Don’t Care”，即<strong>任何没有定义的状态寄存器向最都会被忽略</strong>。这里赋值不定态的效果和使用 <code>casez</code> 或 <code>casex</code> 替代 case 的效果非常相似。</p><p>在每个 <code>case</code> 模块内部的结构也非常相似，都是先描述当前状态的组合逻辑输出，然后根据输入条件（米里 FSM) 判定下一个状态。</p><p>该组合逻辑模块中所有的赋值推荐采用阻塞赋值 <code>=</code>。</p><div class="note warning"><p>请注意，虽然下一状态寄存器 <code>NS</code> 为寄存器类型，但是在两段式 FSM 的判断状态转移条件的 <code>always</code> 模块中，<strong>实际上对应的真实硬件电路是纯组合逻辑电路</strong>。</p></div><p>对于每个输出，一般用组合逻辑描述，比较简便的方法是用 <code>task/endtask</code> 将输出封装起来，这样不仅是写法简单，而且利于复用共同的输出。如本例中 <code>S1</code> 状态的输出被封装为 <code>S1_out</code>，在组合逻辑 <code>always</code> 模块中直接调用即可。</p><figure class="highlight verilog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> IDLE_out;</span><br><span class="line">     {o1,o2,err} = <span class="number">3'b000</span>;</span><br><span class="line"><span class="keyword">endtask</span></span><br></pre></td></tr></tbody></table></figure><p>组合逻辑容易产生毛刺，因此如果时序允许，请尽量<strong>对组合逻辑的输出插入一个寄存器节拍</strong>，这样可以很好地保证输出信号的稳定性。</p><h3 id="三段式状态机描述方法推荐写法">2.3.3. 三段式状态机描述方法（推荐写法）</h3><p>两段式 FSM 描述方法虽然有很多好处，但是它有一个明显的弱点就是其输出一般使用组合逻辑描述，而组合逻辑易产生毛刺等不稳定因素，并且在 FPGA/CPLD 等逻辑器件中过多的组合逻辑会影响实现的速率（这点与 ASIC 设计不同）。所以在上节特别提到了在两段式 FSM 描述方法中，如果时序允许插入一个额外的时钟节拍，则尽量在后级电路对 FSM 的组合逻辑输出用寄存器寄存一个节拍，则可以有效地消除毛刺。但是很多情况下，设计并不允许额外的节拍插入（Latency），此时，解决之道就是采用三段式 FSM 描述方法。三段式描述方法与两段式描述方法相比，关键在于使用同步时序逻辑寄存 FSM 的输出。</p><p>本例的三段式描述代码如下：</p><figure class="highlight verilog"><figcaption><span>state3.v</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// state3.v</span></span><br><span class="line"><span class="comment">// 3-paragraph method to describe FSM</span></span><br><span class="line"><span class="comment">// Describe sequential state transition in the 1st sequential always block</span></span><br><span class="line"><span class="comment">// State transition conditions in the 2nd combinational always block</span></span><br><span class="line"><span class="comment">// Describe the FSM out in the 3rd sequential always block</span></span><br><span class="line"><span class="comment">// Westor, Dec. 2006</span></span><br><span class="line"><span class="comment">// Verilog Usage Book</span></span><br><span class="line"><span class="keyword">module</span> state3 (</span><br><span class="line">    nrst,clk,</span><br><span class="line">    i1,i2,</span><br><span class="line">    o1,o2,</span><br><span class="line">    err</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>          nrst,clk;</span><br><span class="line"><span class="keyword">input</span>          i1,i2;</span><br><span class="line"><span class="keyword">output</span>         o1,o2,err;</span><br><span class="line"><span class="keyword">reg</span>            o1,o2,err;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span>    [<span class="number">2</span>:<span class="number">0</span>]   NS,CS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">parameter</span> [<span class="number">2</span>:<span class="number">0</span>]         <span class="comment">// one hot with zero idle</span></span><br><span class="line">    IDLE   = <span class="number">3'b000</span>,</span><br><span class="line">    S1     = <span class="number">3'b001</span>,</span><br><span class="line">    S2     = <span class="number">3'b010</span>,</span><br><span class="line">    ERROR  = <span class="number">3'b100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1st always block, sequential state transition</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> nrst)</span><br><span class="line">    <span class="keyword">if</span> (!nrst)</span><br><span class="line">        CS &lt;= IDLE;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        CS &lt;= NS;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2nd always block, combinational condition judgment</span></span><br><span class="line"><span class="keyword">always</span> @ (nrst <span class="keyword">or</span> CS <span class="keyword">or</span> i1 <span class="keyword">or</span> i2) <span class="keyword">begin</span></span><br><span class="line">    NS = <span class="number">3'bx</span>;</span><br><span class="line">    <span class="keyword">case</span> (CS)</span><br><span class="line">        IDLE:   <span class="keyword">begin</span></span><br><span class="line">                    <span class="keyword">if</span> (~i1)           NS = IDLE;</span><br><span class="line">                    <span class="keyword">if</span> (i1 &amp;&amp; i2)      NS = S1;</span><br><span class="line">                    <span class="keyword">if</span> (i1 &amp;&amp; ~i2)     NS = ERROR;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">        S1:     <span class="keyword">begin</span></span><br><span class="line">                    <span class="keyword">if</span> (~i2)           NS = S1;</span><br><span class="line">                    <span class="keyword">if</span> (i2 &amp;&amp; i1)      NS = S2;</span><br><span class="line">                    <span class="keyword">if</span> (i2 &amp;&amp; (~i1))   NS = ERROR;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">        S2:     <span class="keyword">begin</span></span><br><span class="line">                    <span class="keyword">if</span> (i2)            NS = S2;</span><br><span class="line">                    <span class="keyword">if</span> (~i2 &amp;&amp; i1)     NS = IDLE;</span><br><span class="line">                    <span class="keyword">if</span> (~i2 &amp;&amp; (~i1))  NS = ERROR;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">        ERROR:  <span class="keyword">begin</span></span><br><span class="line">                    <span class="keyword">if</span> (i1)            NS = ERROR;</span><br><span class="line">                    <span class="keyword">if</span> (~i1)           NS = IDLE;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3rd always block, the sequential FSM output</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> nrst)</span><br><span class="line">    <span class="keyword">if</span> (!nrst)</span><br><span class="line">        {o1,o2,err} &lt;= <span class="number">3'b000</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        {o1,o2,err} &lt;=  <span class="number">3'b000</span>;</span><br><span class="line">    <span class="keyword">case</span> (NS)</span><br><span class="line">        IDLE:   {o1,o2,err} &lt;= <span class="number">3'b000</span>;</span><br><span class="line"></span><br><span class="line">        S1:     {o1,o2,err} &lt;= <span class="number">3'b100</span>;</span><br><span class="line">        S2:     {o1,o2,err} &lt;= <span class="number">3'b010</span>;</span><br><span class="line">        ERROR:  {o1,o2,err} &lt;= <span class="number">3'b111</span>;</span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></tbody></table></figure><p>三段式写法可以概括为<a href="#fig.6-6">图 6-6</a> 描述的结构。</p><p><a id="fig.6-6"></a></p><figure><img data-src="../images/post/2023-04-16-josh-verilog-part-6/2023-04-16-josh-verilog-part-6-060-ThreeStageFSM.png" width="1000" alt="图 6-6 三段式FSM描述结构图"><figcaption aria-hidden="true">图 6-6 三段式FSM描述结构图</figcaption></figure><p>对比上节两段式 FSM 的描述，可以清晰发现三段式与两段式 FSM 描述的最大区别在于<strong>两段式采用了组合逻辑输出</strong>，而<strong>三段式巧妙地根据下一状态的判断，用同步时序逻辑寄存 FSM 的输出</strong>。本例中就是下面一段代码，</p><figure class="highlight verilog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> nrst)</span><br><span class="line">    <span class="keyword">if</span> (!nrst)</span><br><span class="line">        {o1,o2,err} &lt;= <span class="number">3'b000</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        {o1,o2,err} &lt;=  <span class="number">3'b000</span>;</span><br><span class="line">    <span class="keyword">case</span> (NS)</span><br><span class="line">        IDLE:   {o1,o2,err} &lt;= <span class="number">3'b000</span>;</span><br><span class="line"></span><br><span class="line">        S1:     {o1,o2,err} &lt;= <span class="number">3'b100</span>;</span><br><span class="line">        S2:     {o1,o2,err} &lt;= <span class="number">3'b010</span>;</span><br><span class="line">        ERROR:  {o1,o2,err} &lt;= <span class="number">3'b111</span>;</span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure><p>大家可能会问，一段式写法也是用寄存器同步了 FSM 的输出，为什么前面介绍一段式的输出代码容易混淆，不利于维护呢？请大家对比一下这段一段式输出的代码，</p><figure class="highlight verilog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span>(NS)</span><br><span class="line">    IDLE:   <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span> (~i1)         <span class="keyword">begin</span>{o1,o2,err}&lt;=<span class="number">3'b000</span>;NS &lt;= IDLE; <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">if</span> (i1 &amp;&amp; i2)    <span class="keyword">begin</span>{o1,o2,err}&lt;=<span class="number">3'b100</span>;NS &lt;= S1;   <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">if</span> (i1 &amp;&amp; ~i2)   <span class="keyword">begin</span>{o1,o2,err}&lt;=<span class="number">3'b111</span>;NS &lt;= ERROR;<span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure><p>通过对比，可以清晰地看到：使用一段式建模 FSM 的寄存器输出的时候，<strong>必须要综合考虑现态在何种状态转移条件下会进入哪些次态</strong>，然后在每个现态的 <code>case</code> 分支下分别描述每个次态的输出，这显然不符合思维习惯；而三段式建模描述 FSM 的状态机输出时，<strong>只需指定 <code>case</code> 敏感表为次态寄存器，然后直接在每个次态的 <code>case</code> 分支中描述该状态的输出即可</strong>，根本不用考虑状态转移条件。本例的 FSM 很简单，如果设计的 FSM 相对复杂，三段式的描述优势就会凸显出来。</p><p>另一方面，三段式描述方法与两段式描述相比，虽然代码结构复杂了一些，但是换来的优势是使 FSM 做到了同步寄存器输出，消除了组合逻辑输出的不稳定与毛刺的隐患，而且更利于时序路径分组，一般来说在 FPGA/CPLD 等可编程逻辑器件上的综合与布局布线效果更佳。</p><div class="note warning"><p>请注意，在三段式 FSM 描述方法中，<strong>判断状态转移的 <code>always</code> 模块的 <code>case</code> 语句判断的条件是当前状态 <code>CS</code></strong>，而<strong>在同步时序 FSM 输出的 <code>always</code> 模块的 <code>case</code> 语句判断的条件是下一状态 <code>NS</code></strong>。</p></div><h3 id="种描述方法与状态机建模问题的引申">2.3.4. 3 种描述方法与状态机建模问题的引申</h3><p>可以说合理的状态机描述与状态机的建模技巧是本章的重中之重。这里需要引申讨论几个问题。</p><h4 id="n-段式描述方法和-always-语法块的个数">2.3.4.1. n 段式描述方法和 <code>always</code> 语法块的个数</h4><p>通过学习，大家知道标准的一段式、两段式、三段式 FSM 描述方法分别使用了 1、2、3 个 <code>always</code> 语法块。但是请注意，这个命题的反命题不成立，不能说一段 FSM 的描述中使用了 n 个 <code>always</code> 语法块，就是 n 段式描述方法。这是因为<strong>特指的一段式、两段式、三段式 FSM 描述方法中每个 <code>always</code> 语法块都有固定的描述内容和格式化的结构</strong>，其实也就是通过这些特定的描述内容和格式化的结构，确立了 3 种 FSM 建模方式。</p><p>例如两段式写法中，第一个 <code>always</code> 模块格式化地使用同步时序电路描述次态寄存器到现态寄存器的转移；而第二个 <code>always</code> 模块格式化地使用纯组合逻辑描述状态转移条件。 也就是说两段式描述对应的建模方式的硬件电路就是<a href="#fig.6-5">图 6-5</a> 所示的电路结构。其实从语法角度说，可以将一个 <code>always</code> 模块拆分成多个 <code>always</code> 模块，或者反之将多个 <code>always</code> 模块合并为一个 <code>always</code> 模块。所以请注意，<strong>n 段式 FSM 描述方法强调的是一种建模思路，绝不是简单的 <code>always</code> 语法块个数</strong>。</p><h4 id="fsm-的建模方式">2.3.4.2. FSM 的建模方式</h4><p>反复强调的 n 段式描述方法其实是 FSM 的 3 种建模方式。大家回顾一下状态<a href="#fig.6-3">转移图 6-3</a> 描述的 FSM，在学习本节之前，大家可能会产生各种不同的描述思路，通过本节的学习，希望大家能够自然而然地想到用<a href="#fig.6-5">图 6-5</a>（对应两段式思路）和<a href="#fig.6-6">图 6-6</a>（对应三段式思路）的结构建模。其实对于绝大多数 FSM，都可以采用<a href="#fig.6-4">图 6-4</a>、<a href="#fig.6-5">图 6-5</a> 或<a href="#fig.6-6">图 6-6</a> 的结构建模。一般来说，推<strong>荐使用后两种结构建模</strong>。这是因为：两段式思路建模结构清晰，描述简洁，便于约束，而且如果允许输出逻辑、允许插入一个节拍，就可以通过插入输出寄存器改善输出逻辑的时序并避免组合逻辑的毛刺；三段式思路建模结构清晰，结构格式化，解决了不改变时序要求的前提下用寄存器做状态输出的问题。请大家仔细研究<a href="#fig.6-4">图 6-4</a>、<a href="#fig.6-5">图 6-5</a> 和<a href="#fig.6-6">图 6-6</a> 体会 3 种建模方式。</p><h4 id="一段式建模和三段式建模的关系">2.3.4.3. 一段式建模和三段式建模的关系</h4><p>引申比较一下 3 种 FSM 建模的关系。请比较<a href="#fig.6-4">图 6-4</a> 与<a href="#fig.6-6">图 6-6</a>，如果将<a href="#fig.6-4">图 6-4</a> 的两部分组合逻辑合并起来，则三段式建模电路与一段式建模电路的结构完全一致了，如<a href="#fig.6-7">图 6-7</a> 所示。反过来，可以看到三段式与一段式的最大区别在于：<strong>使用一段式建模 FSM 的寄存器输出的时候，必须要综合考虑现态在何种状态转移条件下会进入哪些次态，然后在每个现态的 <code>case</code> 分支下分别描述每个次态的输出</strong>，这显然不符合思维习惯；而<strong>三段式建模校描述 FSM 的状态机输出时，只需指定 <code>case</code> 敏感表为次态寄存器，然后直接在每个次态的 <code>case</code> 分支中描述该状态的输出即可，根本不用考虑状态转移条件</strong>。对于简单的 FSM，三段式建模的寄存器输出的优势还不是十分明显，但是对于复杂一些的 FSM，三段式建模的优势就会十分显著。</p><p><a id="fig.6-7"></a></p><figure><img data-src="../images/post/2023-04-16-josh-verilog-part-6/2023-04-16-josh-verilog-part-6-070-ComparisonOfOneAndThreeStageFSM.png" width="1000" alt="图 6-7 三段式建模结构与一段式建模结构的关系图"><figcaption aria-hidden="true">图 6-7 三段式建模结构与一段式建模结构的关系图</figcaption></figure><h4 id="两段式建模和三段式建模的关系">2.3.4.4. 两段式建模和三段式建模的关系</h4><p>从代码上看，三段式建模的前两段与两段式建模完全相同，仅仅多了一段寄存器 FSM 输出。一般来说，使用寄存器输出可以改善输出的时序条件，还能避免组合电路的毛刺，所以是更为推荐的描述方式。但是电路设计不是一成不变的，存某些情况下，两段式结构比三段式结构更有优势。请大家再分析一下<a href="#fig.6-5">图 6-5</a> 和<a href="#fig.6-6">图 6-6</a> 的结构，细心的读者会发现，<strong>两段式用状态寄存器分割了两部分组合逻辑（状态转移条件组合逻辑和输出组合逻辑）</strong>；而<strong>三段式结构中，从输入到寄存器状态输出的路径上，要经过两部分组合逻辑（状态转移条件组合逻辑和输出组合逻辑）</strong>，从时序上，这两部分组合逻辑完全可以看为一体。这样<strong>这条路径的组合逻辑就比较繁杂，该路径的时序相对紧张</strong>。也就是说，两段式建模中用状态寄存器分割了组合逻辑，而三段式将寄存器移到组合逻辑的最后端。<strong>如果寄存器前的组合逻辑过于复杂，势必会成为整个设计的关键路径，此时就不宜再使用三段式建模，而要使用两段式建模</strong>。解决两段式建模组合逻辑输出产生毛刺的方法是，额外的在 FSM 后级电路插入寄存器，调整时序，完成功能。</p><h4 id="种描述-fsm-方法的比较">2.3.4.5. 3 种描述 FSM 方法的比较</h4><p>一般来说，3 种 FSM 描述方法可以用下表进行比较。但是请注意，任何一种描述的优劣只是一般规律，而不是绝对性规律。例如，一般来说不推荐一段式描述，但是如果 FSM 的结构十分简单，状态很少，状态转移条件和状态输出都十分简化，则使用一段式建模的效率很高。这些经验需要逐步积累，但是在这里推荐的是一般性规律，请结合电路，体会这几种 FSM 建模方法。</p><table><colgroup><col style="width:35%"><col style="width:21%"><col style="width:21%"><col style="width:21%"></colgroup><tbody><tr><td style="text-align:left">推荐等级</td><td style="text-align:left">不推荐</td><td style="text-align:left">推荐</td><td style="text-align:left">推荐</td></tr><tr><td style="text-align:left">代码简洁程度<br>（对于相对复杂的 FSM 而言）</td><td style="text-align:left">冗长</td><td style="text-align:left">最简洁</td><td style="text-align:left">简洁</td></tr><tr><td style="text-align:left"><code>always</code> 模块个数</td><td style="text-align:left">1</td><td style="text-align:left">2</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">是否利于时序约束</td><td style="text-align:left">不利于</td><td style="text-align:left">利于</td><td style="text-align:left">利于</td></tr><tr><td style="text-align:left">是否有组合逻辑输出</td><td style="text-align:left">可以无组合逻辑输出</td><td style="text-align:left">多数情况有组合逻辑输出</td><td style="text-align:left">无组合逻辑输出</td></tr><tr><td style="text-align:left">是否利于综合与布局布线</td><td style="text-align:left">不利于</td><td style="text-align:left">利于</td><td style="text-align:left">利于</td></tr><tr><td style="text-align:left">代码的可靠性与可维护度</td><td style="text-align:left">低</td><td style="text-align:left">高</td><td style="text-align:left">最好</td></tr><tr><td style="text-align:left">代码风格的规范性</td><td style="text-align:left">低，任意度大</td><td style="text-align:left">格式化，规范</td><td style="text-align:left">格式化，规范</td></tr></tbody></table><h2 id="状态机设计的其他技巧">2.4. 状态机设计的其他技巧</h2><p>本小节讨论 FSM 设计的其他技巧。</p><h3 id="fsm-的编码">2.4.1. FSM 的编码</h3><p>Binary（二进制编码）、gray-code（格雷码）编码使用最少的触发器，较多的组合逻辑，而 one-hot（独热码）编码反之。one-hot 编码的最大优势在于状态比较时仅仅需要比较一个位，一定程度上简化了比较逻辑，减少了毛刺产生的概率。由于 CPLD 更多地提供组合逻辑资源，而 FPGA 更多地提供触发器资源，所以 <strong>CPLD 多使用 gray-code</strong>，而 <strong>FPGA 多使用 one-hot 编码</strong>。另一方面，<strong>对于小型设计使用 gray-code 和 binary 编码更有效</strong>，而<strong>大型状态机使用 one-hot 更高效</strong>。</p><p>在代码中添加综合器的综合约束属性或者在图形界面下设置综合约束属性可以比较方便地改变状态的编码。需要注意的是： Synplicity、Synopsys、Exemplar 等综合工具关于 FSM 的综合约束属性的语法格式各不相同。</p><h3 id="fsm-初始化状态">2.4.2. FSM 初始化状态</h3><p>一个完备的状态机（健壮性强）应该具备初始化状态和默认状态。当芯片加电或者复位后，状态机应该能够自动将所有判断条件复位，并进入初始化状态。需要注明的一点是，大多数 FPGA 有 GSR（Global Set/Reset）信号，当 FPGA 加电后， GSR 信号拉高，对所有的寄存器、RAM 等单元复位/置位，这时配置于 FPGA 的逻辑并未生效，所以不能保证正确地进入初始化状态。所以使用 GSR 企图进入 FPGA 的初始化状态，常常会产生种种不必要的麻烦。<strong>一般的方法是采用异步复位信号</strong>，当然也可以使用同步复位，但是要注意同步复位逻辑的设计。解决这个问题的<strong>另一种方法是将默认的初始状态的编码设为全零</strong>，这样 GSR 复位后，状态机自动进入初始状态。如 <a href="#2.3">2.3 小节</a>所示的编码方法就是初始状态全零的 one-hot 编码方式。</p><h3 id="fsm-状态编码定义">2.4.3. FSM 状态编码定义</h3><p><strong>状态机的定义可以用 <code>parameter</code> 定义，但是不推荐使用 <code>`define</code> 宏定义的方式</strong>，因为 <code>`define</code> 宏定义在编译时自动替换整个设计中所定义的宏，而 <code>parameter</code> 仅定义模 块内部的参数，定义的参数不会与模块外的其他状态机混淆。例如，一个工程里面有两个 <code>module</code>，各包含一个 FSM，如果设计时都有 <code>IDLE</code> 这一名称的状态，使用 <code>`define</code> 宏定义就会混淆起来，而使用 <code>parameter</code> 则不会造成任何不良影响。</p><h3 id="fsm-输出">2.4.4. FSM 输出</h3><p>如果使用二段式 FSM 描述 Mealy 状态机，输出逻辑可以用 <code>?</code> 语句描述，或者使用 <code>case</code> 语句判断转移条件与输入信号即可。如果输出条件比较复杂，而且多个状态共用某些输出，则建议使用 <code>task/endtask</code> 将输出封装起来，达到<strong>模块复用</strong>的目的。</p><h3 id="阻塞和非阻塞赋值">2.4.5. 阻塞和非阻塞赋值</h3><p>为了避免不必要的竞争冒险，不论是做两段式还是三段式 FSM 描述时，必须遵<strong>循时序逻辑 <code>always</code> 模块使用非阻塞赋值 <code>&lt;=</code></strong>，即当前状态向下一状态时序转移， 和寄存 FSM 输出等时序 <code>always</code> 模块中都要使用非阻塞赋值；而<strong>组合逻辑 <code>always</code> 模块使用阻塞赋值 <code>=</code></strong>，即状态转移条件判断，组合逻辑输出等 <code>always</code> 模块中都要使用阻塞赋值。</p><h3 id="fsm-的默认状态">2.4.6. FSM 的默认状态</h3><p><strong>完整的状态机应该包含一个默认（default）状态</strong>，当转移条件不满足，或者状态发生了突变时，要能保证逻辑不会陷入“死循环”。这是对状态机<strong>健壮性</strong>的一个重要要求，也就是常说的要具备“自恢复”功能。对编码 <code>case</code> 和 <code>if ... else</code> 语句要特别注意， <strong>尽量使用完备的条件判断语句</strong>。 Verilog 中，使用 <code>case</code> 语句的时候要用 <code>default</code> 建立默认状态。</p><p>大家可能注意到，在上节举例的 <code>case</code> 语句中，没有写 <code>default</code> 默认状态， 其实<strong>可以将其中一个状态不编码，指定其为 <code>default</code> 默认状态</strong>，则任何与所列状态机不匹配的状态都会转到 <code>default</code> 状态，从而增强了 FSM 的健壮性，另外<strong>也可以添加一个额外的 <code>default</code> 状态</strong>，一旦进入这个状态就会自动转到 <code>IDLE</code> 状态，从新启动状态机，这样做也增强了状态机的健壮性。</p><figure class="highlight verilog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> (CS)</span><br><span class="line">    IDLE:   <span class="keyword">begin</span></span><br><span class="line">                IDLE_out;</span><br><span class="line">                <span class="keyword">if</span> (~i1)           NS = IDLE;</span><br><span class="line">                <span class="keyword">if</span> (i1 &amp;&amp; i2)      NS = S1;</span><br><span class="line">                <span class="keyword">if</span> (i1 &amp;&amp; ~i2)     NS = ERROR;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">    S1:     <span class="keyword">begin</span></span><br><span class="line">                S1_out;</span><br><span class="line">                <span class="keyword">if</span> (~i2)           NS = S1;</span><br><span class="line">                <span class="keyword">if</span> (i2 &amp;&amp; i1)      NS = S2;</span><br><span class="line">                <span class="keyword">if</span> (i2 &amp;&amp; (~i1))   NS = ERROR;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">    S2:     <span class="keyword">begin</span></span><br><span class="line">                S2_out;</span><br><span class="line">                <span class="keyword">if</span> (i2)            NS = S2;</span><br><span class="line">                <span class="keyword">if</span> (~i2 &amp;&amp; i1)     NS = IDLE;</span><br><span class="line">                <span class="keyword">if</span> (~i2 &amp;&amp; (~i1))  NS = ERROR;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">    ERROR:  <span class="keyword">begin</span></span><br><span class="line">                ERROR_out;</span><br><span class="line">                <span class="keyword">if</span> (i1)            NS = ERROR;</span><br><span class="line">                <span class="keyword">if</span> (~i1)           NS = IDLE;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">default</span>:<span class="keyword">begin</span></span><br><span class="line">                IDLE_out;</span><br><span class="line">                NS = IDLE;</span><br><span class="line">               <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endcase</span></span><br></pre></td></tr></tbody></table></figure><div class="note info"><p>在 <code>case</code> 语句结构中增加 <code>default</code> 默认状态是推荐的代码风格。</p></div><h3 id="full-case-与-parallel-case-综合属性">2.4.7. Full Case 与 Parallel Case 综合属性</h3><p>所谓 Full Case 是指：FSM 的所有编码向量都可以与 <code>case</code> 结构的某个分支或 <code>default</code> 默认情况匹配起来。如果一个 FSM 的状态编码是 8 bit，则对应的 256 个状态编码（全状态编码是 2<sup>n</sup> 个）都可以与 <code>case</code> 的某个分支或者 <code>default</code> 映射起来。</p><p>所谓 Parallel Case 是指：在 <code>case</code> 结构中，每个 <code>case</code> 的判断条件表达式（即 <a href="#2.2">2.2 小节</a> 描述的 <code>case_ expression</code>），有且仅有唯一的 <code>case</code> 语句的分支（即 <a href="#2.2">2.2 小节</a> 描述的每个 <code>case_item</code>）与之对应，即两者关系是一一对应关系。</p><p>目前知名综合器如 Synplify Pro、 Precision RTL 和 Synopys 综合工具等都支持 “synthesis full_case”和“synthesis parallel_case”这些综合约束属性，<strong>合理使用 Full Case 约束属性，可以增强设计的安全性</strong>；<strong>合理使用 Parallel Case 约束属性，可以改善状态机译码逻辑</strong>。但是设计者必须具体情况具体分析，对于有的设计，这两条语句使用不当，会占用大量逻辑资源，并恶化 FSM 的时序表现。</p><h1 id="小结">3. 小结</h1><p>状态机不仅是一种时序电路设计工具，它更是一种思想方法。状态机的本质就是对具有逻辑顺序或时序规律事件的一种描述方法。这个论断最重要的两个词就是“逻辑顺序”和“时序规律”，这两点就是状态机所要描述的核心和强项，换言之，所有具有逻辑顺序和时序规律的事情都适合用状态机描述。</p><p>根据 FSM 描述使用的 <code>always</code> 模块数和功能可以将 FSM 的描述分为 3 种写法：</p><ul><li><p>不推荐使用一段式描述方法。因为一段式描述方法将状态转移判断的组合逻辑和状态寄存器转移的时序逻辑混写在同一个 <code>always</code> 模块中，不符合将时序和组合逻辑分开描述的 Coding Style（代码风格），而且在描述当前状态时要考虑下个状态的输出，整个代码不清晰，不利于维护、修改，不利于附加约束，并且不利于综合器和布局布线器对设计的优化。</p></li><li><p>推荐使用两段式状态机描述方法。两段式描述方法用 2 个 <code>always</code> 模块，其中一个 <code>always</code> 模块采用同步时序描述状态转移；另一个 <code>always</code> 模块采用组合逻辑判断状态转移条件，描述状态转移规律。这种方法使 FSM 描述清晰、简洁，易于维护，易于附加时序约束，使综合器和布局布线器更好的优化设计。</p></li><li><p>强烈推荐使用三段式描述方法。与一段式描述方法相比较，三段式 FSM 描述方法对 FSM 寄存器输出的描述只需判断下一状态，然后直接将下一状态的输出用寄存器输出即可，根本不用考虑状态转移条件（米里状态机）。与两段式描述相比，三段式虽然代码结构复杂了一些，但是换来的优势是使 FSM 做到了同步寄存器输出，消除了组合逻辑输出的不稳定与毛刺的隐患，而且更利于时序路径分组，一般来说在 FPGA/CPLD 等可编程逻辑器件上的综合与布局布线效果更佳。</p></li></ul><h1 id="参考文献">参考文献</h1><p>EDA 先锋工作室. <em>轻松成为设计高手——Verilog HDL 实用精解.</em> 北京航空航天大学出版社, 2012.</p><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10/dist/style.css"><script src="https://fastly.jsdelivr.net/npm/d3@7"></script><script src="https://fastly.jsdelivr.net/npm/markmap-view@0.18.10"></script><script src="https://fastly.jsdelivr.net/npm/markmap-toolbar@0.18.10"></script><link rel="stylesheet" href="/css/markmap.css"><script src="/js/markmap.js"></script></div><footer class="post-footer"><div class="post-copyright"><ul><li class="post-copyright-author"><strong>本文作者： </strong>Josh Gao</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://josh-gao.top/posts/d860a67e.html" title="Josh&#39;s Note — Verilog&lt;br&gt;Part 6 如何写好状态机">https://josh-gao.top/posts/d860a67e.html</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="post-tags"><a href="/tags/Verilog/" rel="tag"><i class="fa fa-tag"></i> Verilog</a> <a href="/tags/HDL/" rel="tag"><i class="fa fa-tag"></i> HDL</a> <a href="/tags/RTL/" rel="tag"><i class="fa fa-tag"></i> RTL</a> <a href="/tags/%E7%8A%B6%E6%80%81%E6%9C%BA/" rel="tag"><i class="fa fa-tag"></i> 状态机</a> <a href="/tags/%E6%91%A9%E5%B0%94%E5%9E%8B/" rel="tag"><i class="fa fa-tag"></i> 摩尔型</a> <a href="/tags/%E7%B1%B3%E9%87%8C%E5%9E%8B/" rel="tag"><i class="fa fa-tag"></i> 米里型</a> <a href="/tags/%E4%B8%A4%E6%AE%B5%E5%BC%8F/" rel="tag"><i class="fa fa-tag"></i> 两段式</a> <a href="/tags/%E4%B8%89%E6%AE%B5%E5%BC%8F/" rel="tag"><i class="fa fa-tag"></i> 三段式</a></div><div class="post-nav"><div class="post-nav-item"><a href="/posts/60664a7e.html" rel="prev" title="Josh&#39;s Review — 数字信号处理&lt;br&gt;Part 7 数字滤波器设计"><i class="fa fa-angle-left"></i> Josh's Review — 数字信号处理<br>Part 7 数字滤波器设计</a></div><div class="post-nav-item"><a href="/posts/e060f513.html" rel="next" title="Josh&#39;s Note — Verilog&lt;br&gt;Part 7 逻辑验证与 testbench 编写">Josh's Note — Verilog<br>Part 7 逻辑验证与 testbench 编写 <i class="fa fa-angle-right"></i></a></div></div></footer></article></div><div class="comments gitalk-container"></div></div></main><footer class="footer"><div class="footer-inner"><div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">京ICP备2022006859号-1 </a><img src="/images/misc/%E5%A4%87%E6%A1%88%E5%9B%BE%E6%A0%87.png" alt=""><a href="https://beian.mps.gov.cn/#/query/webSearch?code=11010802039063" rel="noopener" target="_blank">京公网安备11010802039063号</a></div><div class="copyright">&copy; 2020 – <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Josh Gao</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span>站点总字数：</span> <span title="站点总字数">265k</span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span>站点阅读时长 &asymp;</span> <span title="站点阅读时长">16:03</span></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div><div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动</div></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="reading-progress-bar"></div><a role="button" class="book-mark-link book-mark-link-fixed"></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous"><script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"joshgao22","repo":"Josh-Blog-Comment","client_id":"eb4dc2ea750519598663","client_secret":"4fe0fb49aeb8fac49c609796b214a99a6df044cf","admin_user":"joshgao22","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"en | es-ES | fr | ru | zh-CN | zh-TW","js":{"url":"https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"82aa44bad10f3b38f951d915bbb619d9"}</script><script src="/js/third-party/comments/gitalk.js" defer></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,log:!1,model:{jsonPath:"/live2dw/assets/assets/wanko.model.json"},display:{position:"right",width:200,height:250},mobile:{show:!0},react:{opacity:1}})</script></body></html>